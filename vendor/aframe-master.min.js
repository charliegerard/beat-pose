(function (f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.AFRAME = f();
  }
})(function () {
  var define, module, exports;
  return (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw ((a.code = "MODULE_NOT_FOUND"), a);
          }
          var p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t
          );
        }
        return n[i].exports;
      }
      for (
        var u = "function" == typeof require && require, i = 0;
        i < t.length;
        i++
      )
        o(t[i]);
      return o;
    }
    return r;
  })()(
    {
      1: [
        function (_dereq_, module, exports) {
          function anArray(r) {
            return (
              (r.BYTES_PER_ELEMENT &&
                "[object ArrayBuffer]" === str.call(r.buffer)) ||
              Array.isArray(r)
            );
          }
          var str = Object.prototype.toString;
          module.exports = anArray;
        },
        {},
      ],
      2: [
        function (_dereq_, module, exports) {
          (function (global) {
            var $jscomp = { scope: {} };
            ($jscomp.defineProperty =
              "function" == typeof Object.defineProperties
                ? Object.defineProperty
                : function (t, e, r) {
                    if (r.get || r.set)
                      throw new TypeError(
                        "ES3 does not support getters and setters."
                      );
                    t != Array.prototype &&
                      t != Object.prototype &&
                      (t[e] = r.value);
                  }),
              ($jscomp.getGlobal = function (t) {
                return "undefined" != typeof window && window === t
                  ? t
                  : "undefined" != typeof global && null != global
                  ? global
                  : t;
              }),
              ($jscomp.global = $jscomp.getGlobal(this)),
              ($jscomp.SYMBOL_PREFIX = "jscomp_symbol_"),
              ($jscomp.initSymbol = function () {
                ($jscomp.initSymbol = function () {}),
                  $jscomp.global.Symbol ||
                    ($jscomp.global.Symbol = $jscomp.Symbol);
              }),
              ($jscomp.symbolCounter_ = 0),
              ($jscomp.Symbol = function (t) {
                return (
                  $jscomp.SYMBOL_PREFIX + (t || "") + $jscomp.symbolCounter_++
                );
              }),
              ($jscomp.initSymbolIterator = function () {
                $jscomp.initSymbol();
                var t = $jscomp.global.Symbol.iterator;
                t ||
                  (t = $jscomp.global.Symbol.iterator =
                    $jscomp.global.Symbol("iterator")),
                  "function" != typeof Array.prototype[t] &&
                    $jscomp.defineProperty(Array.prototype, t, {
                      configurable: !0,
                      writable: !0,
                      value: function () {
                        return $jscomp.arrayIterator(this);
                      },
                    }),
                  ($jscomp.initSymbolIterator = function () {});
              }),
              ($jscomp.arrayIterator = function (t) {
                var e = 0;
                return $jscomp.iteratorPrototype(function () {
                  return e < t.length
                    ? { done: !1, value: t[e++] }
                    : { done: !0 };
                });
              }),
              ($jscomp.iteratorPrototype = function (t) {
                return (
                  $jscomp.initSymbolIterator(),
                  (t = { next: t }),
                  (t[$jscomp.global.Symbol.iterator] = function () {
                    return this;
                  }),
                  t
                );
              }),
              ($jscomp.array = $jscomp.array || {}),
              ($jscomp.iteratorFromArray = function (t, e) {
                $jscomp.initSymbolIterator(), t instanceof String && (t += "");
                var r = 0,
                  n = {
                    next: function () {
                      if (r < t.length) {
                        var o = r++;
                        return { value: e(o, t[o]), done: !1 };
                      }
                      return (
                        (n.next = function () {
                          return { done: !0, value: void 0 };
                        }),
                        n.next()
                      );
                    },
                  };
                return (
                  (n[Symbol.iterator] = function () {
                    return n;
                  }),
                  n
                );
              }),
              ($jscomp.polyfill = function (t, e, r, n) {
                if (e) {
                  for (
                    r = $jscomp.global, t = t.split("."), n = 0;
                    n < t.length - 1;
                    n++
                  ) {
                    var o = t[n];
                    o in r || (r[o] = {}), (r = r[o]);
                  }
                  (t = t[t.length - 1]),
                    (n = r[t]),
                    (e = e(n)),
                    e != n &&
                      null != e &&
                      $jscomp.defineProperty(r, t, {
                        configurable: !0,
                        writable: !0,
                        value: e,
                      });
                }
              }),
              $jscomp.polyfill(
                "Array.prototype.keys",
                function (t) {
                  return (
                    t ||
                    function () {
                      return $jscomp.iteratorFromArray(this, function (t) {
                        return t;
                      });
                    }
                  );
                },
                "es6-impl",
                "es3"
              );
            var $jscomp$this = this;
            !(function (t, e) {
              "function" == typeof define && define.amd
                ? define([], e)
                : "object" == typeof module && module.exports
                ? (module.exports = e())
                : (t.anime = e());
            })(this, function () {
              function t(t) {
                if (!X.col(t))
                  try {
                    return document.querySelectorAll(t);
                  } catch (t) {}
              }
              function e(t, e) {
                for (
                  var r = t.length,
                    n = 2 <= arguments.length ? arguments[1] : void 0,
                    o = [],
                    a = 0;
                  a < r;
                  a++
                )
                  if (a in t) {
                    var i = t[a];
                    e.call(n, i, a, t) && o.push(i);
                  }
                return o;
              }
              function r(t) {
                return t.reduce(function (t, e) {
                  return t.concat(X.arr(e) ? r(e) : e);
                }, []);
              }
              function n(e) {
                return X.arr(e)
                  ? e
                  : (X.str(e) && (e = t(e) || e),
                    e instanceof NodeList || e instanceof HTMLCollection
                      ? [].slice.call(e)
                      : [e]);
              }
              function o(t, e) {
                return t.some(function (t) {
                  return t === e;
                });
              }
              function a(t) {
                var e,
                  r = {};
                for (e in t) r[e] = t[e];
                return r;
              }
              function i(t, e) {
                var r,
                  n = a(t);
                for (r in t) n[r] = e.hasOwnProperty(r) ? e[r] : t[r];
                return n;
              }
              function u(t, e) {
                var r,
                  n = a(t);
                for (r in e) n[r] = X.und(t[r]) ? e[r] : t[r];
                return n;
              }
              function s(t) {
                t = t.replace(
                  /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                  function (t, e, r, n) {
                    return e + e + r + r + n + n;
                  }
                );
                var e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                t = parseInt(e[1], 16);
                var r = parseInt(e[2], 16),
                  e = parseInt(e[3], 16);
                return "rgba(" + t + "," + r + "," + e + ",1)";
              }
              function c(t) {
                function e(t, e, r) {
                  return (
                    0 > r && (r += 1),
                    1 < r && --r,
                    r < 1 / 6
                      ? t + 6 * (e - t) * r
                      : 0.5 > r
                      ? e
                      : r < 2 / 3
                      ? t + (e - t) * (2 / 3 - r) * 6
                      : t
                  );
                }
                var r =
                  /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t) ||
                  /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(
                    t
                  );
                t = parseInt(r[1]) / 360;
                var n = parseInt(r[2]) / 100,
                  o = parseInt(r[3]) / 100,
                  r = r[4] || 1;
                if (0 == n) o = n = t = o;
                else {
                  var a = 0.5 > o ? o * (1 + n) : o + n - o * n,
                    i = 2 * o - a,
                    o = e(i, a, t + 1 / 3),
                    n = e(i, a, t);
                  t = e(i, a, t - 1 / 3);
                }
                return (
                  "rgba(" +
                  255 * o +
                  "," +
                  255 * n +
                  "," +
                  255 * t +
                  "," +
                  r +
                  ")"
                );
              }
              function f(t) {
                if (
                  (t =
                    /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
                      t
                    ))
                )
                  return t[2];
              }
              function l(t) {
                return -1 < t.indexOf("translate") || "perspective" === t
                  ? "px"
                  : -1 < t.indexOf("rotate") || -1 < t.indexOf("skew")
                  ? "deg"
                  : void 0;
              }
              function p(t, e) {
                return X.fnc(t) ? t(e.target, e.id, e.total) : t;
              }
              function d(t, e) {
                if (e in t.style)
                  return (
                    getComputedStyle(t).getPropertyValue(
                      e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
                    ) || "0"
                  );
              }
              function m(t, e) {
                return X.dom(t) && o(N, e)
                  ? "transform"
                  : X.dom(t) && (t.getAttribute(e) || (X.svg(t) && t[e]))
                  ? "attribute"
                  : X.dom(t) && "transform" !== e && d(t, e)
                  ? "css"
                  : null != t[e]
                  ? "object"
                  : void 0;
              }
              function g(t, r) {
                var n = l(r),
                  n = -1 < r.indexOf("scale") ? 1 : 0 + n;
                if (!(t = t.style.transform)) return n;
                for (
                  var o = [], a = [], i = [], u = /(\w+)\((.+?)\)/g;
                  (o = u.exec(t));

                )
                  a.push(o[1]), i.push(o[2]);
                return (
                  (t = e(i, function (t, e) {
                    return a[e] === r;
                  })),
                  t.length ? t[0] : n
                );
              }
              function y(t, e) {
                switch (m(t, e)) {
                  case "transform":
                    return g(t, e);
                  case "css":
                    return d(t, e);
                  case "attribute":
                    return t.getAttribute(e);
                }
                return t[e] || 0;
              }
              function h(t, e) {
                var r = /^(\*=|\+=|-=)/.exec(t);
                if (!r) return t;
                var n = f(t) || 0;
                switch (
                  ((e = parseFloat(e)),
                  (t = parseFloat(t.replace(r[0], ""))),
                  r[0][0])
                ) {
                  case "+":
                    return e + t + n;
                  case "-":
                    return e - t + n;
                  case "*":
                    return e * t + n;
                }
              }
              function v(t, e) {
                return Math.sqrt(
                  Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)
                );
              }
              function b(t) {
                t = t.points;
                for (var e, r = 0, n = 0; n < t.numberOfItems; n++) {
                  var o = t.getItem(n);
                  0 < n && (r += v(e, o)), (e = o);
                }
                return r;
              }
              function j(t) {
                if (t.getTotalLength) return t.getTotalLength();
                switch (t.tagName.toLowerCase()) {
                  case "circle":
                    return 2 * Math.PI * t.getAttribute("r");
                  case "rect":
                    return (
                      2 * t.getAttribute("width") + 2 * t.getAttribute("height")
                    );
                  case "line":
                    return v(
                      { x: t.getAttribute("x1"), y: t.getAttribute("y1") },
                      { x: t.getAttribute("x2"), y: t.getAttribute("y2") }
                    );
                  case "polyline":
                    return b(t);
                  case "polygon":
                    var e = t.points;
                    return (
                      b(t) + v(e.getItem(e.numberOfItems - 1), e.getItem(0))
                    );
                }
              }
              function $(t, e) {
                function r(r) {
                  return (
                    (r = void 0 === r ? 0 : r),
                    t.el.getPointAtLength(1 <= e + r ? e + r : 0)
                  );
                }
                var n = r(),
                  o = r(-1),
                  a = r(1);
                switch (t.property) {
                  case "x":
                    return n.x;
                  case "y":
                    return n.y;
                  case "angle":
                    return (180 * Math.atan2(a.y - o.y, a.x - o.x)) / Math.PI;
                }
              }
              function x(t, e) {
                var r,
                  n = /-?\d*\.?\d+/g;
                if (((r = X.pth(t) ? t.totalLength : t), X.col(r)))
                  if (X.rgb(r)) {
                    var o = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(r);
                    r = o ? "rgba(" + o[1] + ",1)" : r;
                  } else r = X.hex(r) ? s(r) : X.hsl(r) ? c(r) : void 0;
                else
                  (o = (o = f(r)) ? r.substr(0, r.length - o.length) : r),
                    (r = e && !/\s/g.test(r) ? o + e : o);
                return (
                  (r += ""),
                  {
                    original: r,
                    numbers: r.match(n) ? r.match(n).map(Number) : [0],
                    strings: X.str(t) || e ? r.split(n) : [],
                  }
                );
              }
              function w(t) {
                return (
                  (t = t ? r(X.arr(t) ? t.map(n) : n(t)) : []),
                  e(t, function (t, e, r) {
                    return r.indexOf(t) === e;
                  })
                );
              }
              function A(t) {
                var e = w(t);
                return e.map(function (t, r) {
                  return { target: t, id: r, total: e.length };
                });
              }
              function I(t, e) {
                var r = a(e);
                if (X.arr(t)) {
                  var o = t.length;
                  2 !== o || X.obj(t[0])
                    ? X.fnc(e.duration) || (r.duration = e.duration / o)
                    : (t = { value: t });
                }
                return n(t)
                  .map(function (t, r) {
                    return (
                      (r = r ? 0 : e.delay),
                      (t = X.obj(t) && !X.pth(t) ? t : { value: t }),
                      X.und(t.delay) && (t.delay = r),
                      t
                    );
                  })
                  .map(function (t) {
                    return u(t, r);
                  });
              }
              function M(t, e) {
                var r,
                  n = {};
                for (r in t) {
                  var o = p(t[r], e);
                  X.arr(o) &&
                    ((o = o.map(function (t) {
                      return p(t, e);
                    })),
                    1 === o.length && (o = o[0])),
                    (n[r] = o);
                }
                return (
                  (n.duration = parseFloat(n.duration)),
                  (n.delay = parseFloat(n.delay)),
                  n
                );
              }
              function S(t) {
                return X.arr(t) ? Y.apply(this, t) : _[t];
              }
              function O(t, e) {
                var r;
                return t.tweens.map(function (n) {
                  n = M(n, e);
                  var o = n.value,
                    a = y(e.target, t.name),
                    i = r ? r.to.original : a,
                    i = X.arr(o) ? o[0] : i,
                    u = h(X.arr(o) ? o[1] : o, i),
                    a = f(u) || f(i) || f(a);
                  return (
                    (n.from = x(i, a)),
                    (n.to = x(u, a)),
                    (n.start = r ? r.end : t.offset),
                    (n.end = n.start + n.delay + n.duration),
                    (n.easing = S(n.easing)),
                    (n.elasticity =
                      (1e3 - Math.min(Math.max(n.elasticity, 1), 999)) / 1e3),
                    (n.isPath = X.pth(o)),
                    (n.isColor = X.col(n.from.original)),
                    n.isColor && (n.round = 1),
                    (r = n)
                  );
                });
              }
              function P(t, n) {
                return e(
                  r(
                    t.map(function (t) {
                      return n.map(function (e) {
                        var r = m(t.target, e.name);
                        if (r) {
                          var n = O(e, t);
                          e = {
                            type: r,
                            property: e.name,
                            animatable: t,
                            tweens: n,
                            duration: n[n.length - 1].end,
                            delay: n[0].delay,
                          };
                        } else e = void 0;
                        return e;
                      });
                    })
                  ),
                  function (t) {
                    return !X.und(t);
                  }
                );
              }
              function k(t, e, r, n) {
                var o = "delay" === t;
                return e.length
                  ? (o ? Math.min : Math.max).apply(
                      Math,
                      e.map(function (e) {
                        return e[t];
                      })
                    )
                  : o
                  ? n.delay
                  : r.offset + n.delay + n.duration;
              }
              function F(t) {
                var e,
                  r = i(E, t),
                  n = i(T, t),
                  o = A(t.targets),
                  a = [],
                  s = u(r, n);
                for (e in t)
                  s.hasOwnProperty(e) ||
                    "targets" === e ||
                    a.push({ name: e, offset: s.offset, tweens: I(t[e], n) });
                return (
                  (t = P(o, a)),
                  u(r, {
                    children: [],
                    animatables: o,
                    animations: t,
                    duration: k("duration", t, r, n),
                    delay: k("delay", t, r, n),
                  })
                );
              }
              function L(t) {
                function r() {
                  return (
                    window.Promise &&
                    new Promise(function (t) {
                      return (l = t);
                    })
                  );
                }
                function n(t) {
                  return m.reversed ? m.duration - t : t;
                }
                function o(t) {
                  for (
                    var r = 0, n = {}, o = m.animations, a = o.length;
                    r < a;

                  ) {
                    var i = o[r],
                      u = i.animatable,
                      s = i.tweens,
                      c = s.length - 1,
                      f = s[c];
                    c &&
                      (f =
                        e(s, function (e) {
                          return t < e.end;
                        })[0] || f);
                    for (
                      var s =
                          Math.min(
                            Math.max(t - f.start - f.delay, 0),
                            f.duration
                          ) / f.duration,
                        l = isNaN(s) ? 1 : f.easing(s, f.elasticity),
                        s = f.to.strings,
                        p = f.round,
                        c = [],
                        g = void 0,
                        g = f.to.numbers.length,
                        y = 0;
                      y < g;
                      y++
                    ) {
                      var h = void 0,
                        h = f.to.numbers[y],
                        v = f.from.numbers[y],
                        h = f.isPath ? $(f.value, l * h) : v + l * (h - v);
                      p &&
                        ((f.isColor && 2 < y) || (h = Math.round(h * p) / p)),
                        c.push(h);
                    }
                    if ((f = s.length))
                      for (g = s[0], l = 0; l < f; l++)
                        (p = s[l + 1]),
                          (y = c[l]),
                          isNaN(y) || (g = p ? g + (y + p) : g + (y + " "));
                    else g = c[0];
                    V[i.type](u.target, i.property, g, n, u.id),
                      (i.currentValue = g),
                      r++;
                  }
                  if ((r = Object.keys(n).length))
                    for (o = 0; o < r; o++)
                      C ||
                        (C = d(document.body, "transform")
                          ? "transform"
                          : "-webkit-transform"),
                        (m.animatables[o].target.style[C] = n[o].join(" "));
                  (m.currentTime = t), (m.progress = (t / m.duration) * 100);
                }
                function a(t) {
                  m[t] && m[t](m);
                }
                function i() {
                  m.remaining && !0 !== m.remaining && m.remaining--;
                }
                function u(t) {
                  var e = m.duration,
                    u = m.offset,
                    d = u + m.delay,
                    g = m.currentTime,
                    y = m.reversed,
                    h = n(t);
                  if (m.children.length) {
                    var v = m.children,
                      b = v.length;
                    if (h >= m.currentTime)
                      for (var j = 0; j < b; j++) v[j].seek(h);
                    else for (; b--; ) v[b].seek(h);
                  }
                  (h >= d || !e) &&
                    (m.began || ((m.began = !0), a("begin")), a("run")),
                    h > u && h < e
                      ? o(h)
                      : (h <= u && 0 !== g && (o(0), y && i()),
                        ((h >= e && g !== e) || !e) && (o(e), y || i())),
                    a("update"),
                    t >= e &&
                      (m.remaining
                        ? ((c = s),
                          "alternate" === m.direction &&
                            (m.reversed = !m.reversed))
                        : (m.pause(),
                          m.completed ||
                            ((m.completed = !0),
                            a("complete"),
                            "Promise" in window && (l(), (p = r())))),
                      (f = 0));
                }
                t = void 0 === t ? {} : t;
                var s,
                  c,
                  f = 0,
                  l = null,
                  p = r(),
                  m = F(t);
                return (
                  (m.reset = function () {
                    var t = m.direction,
                      e = m.loop;
                    for (
                      m.currentTime = 0,
                        m.progress = 0,
                        m.paused = !0,
                        m.began = !1,
                        m.completed = !1,
                        m.reversed = "reverse" === t,
                        m.remaining = "alternate" === t && 1 === e ? 2 : e,
                        o(0),
                        t = m.children.length;
                      t--;

                    )
                      m.children[t].reset();
                  }),
                  (m.tick = function (t) {
                    (s = t), c || (c = s), u((f + s - c) * L.speed);
                  }),
                  (m.seek = function (t) {
                    u(n(t));
                  }),
                  (m.pause = function () {
                    var t = Z.indexOf(m);
                    -1 < t && Z.splice(t, 1), (m.paused = !0);
                  }),
                  (m.play = function () {
                    m.paused &&
                      ((m.paused = !1),
                      (c = 0),
                      (f = n(m.currentTime)),
                      Z.push(m),
                      q || B());
                  }),
                  (m.reverse = function () {
                    (m.reversed = !m.reversed), (c = 0), (f = n(m.currentTime));
                  }),
                  (m.restart = function () {
                    m.pause(), m.reset(), m.play();
                  }),
                  (m.finished = p),
                  m.reset(),
                  m.autoplay && m.play(),
                  m
                );
              }
              var C,
                E = {
                  update: void 0,
                  begin: void 0,
                  run: void 0,
                  complete: void 0,
                  loop: 1,
                  direction: "normal",
                  autoplay: !0,
                  offset: 0,
                },
                T = {
                  duration: 1e3,
                  delay: 0,
                  easing: "easeOutElastic",
                  elasticity: 500,
                  round: 0,
                },
                N =
                  "translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(
                    " "
                  ),
                X = {
                  arr: function (t) {
                    return Array.isArray(t);
                  },
                  obj: function (t) {
                    return (
                      -1 < Object.prototype.toString.call(t).indexOf("Object")
                    );
                  },
                  pth: function (t) {
                    return X.obj(t) && t.hasOwnProperty("totalLength");
                  },
                  svg: function (t) {
                    return t instanceof SVGElement;
                  },
                  dom: function (t) {
                    return t.nodeType || X.svg(t);
                  },
                  str: function (t) {
                    return "string" == typeof t;
                  },
                  fnc: function (t) {
                    return "function" == typeof t;
                  },
                  und: function (t) {
                    return void 0 === t;
                  },
                  hex: function (t) {
                    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t);
                  },
                  rgb: function (t) {
                    return /^rgb/.test(t);
                  },
                  hsl: function (t) {
                    return /^hsl/.test(t);
                  },
                  col: function (t) {
                    return X.hex(t) || X.rgb(t) || X.hsl(t);
                  },
                },
                Y = (function () {
                  function t(t, e, r) {
                    return (
                      (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t +
                        3 * e) *
                      t
                    );
                  }
                  return function (e, r, n, o) {
                    if (0 <= e && 1 >= e && 0 <= n && 1 >= n) {
                      var a = new Float32Array(11);
                      if (e !== r || n !== o)
                        for (var i = 0; 11 > i; ++i) a[i] = t(0.1 * i, e, n);
                      return function (i) {
                        if (e === r && n === o) return i;
                        if (0 === i) return 0;
                        if (1 === i) return 1;
                        for (var u = 0, s = 1; 10 !== s && a[s] <= i; ++s)
                          u += 0.1;
                        --s;
                        var s = u + ((i - a[s]) / (a[s + 1] - a[s])) * 0.1,
                          c =
                            3 * (1 - 3 * n + 3 * e) * s * s +
                            2 * (3 * n - 6 * e) * s +
                            3 * e;
                        if (0.001 <= c) {
                          for (
                            u = 0;
                            4 > u &&
                            0 !==
                              (c =
                                3 * (1 - 3 * n + 3 * e) * s * s +
                                2 * (3 * n - 6 * e) * s +
                                3 * e);
                            ++u
                          )
                            var f = t(s, e, n) - i, s = s - f / c;
                          i = s;
                        } else if (0 === c) i = s;
                        else {
                          var s = u,
                            u = u + 0.1,
                            l = 0;
                          do {
                            (f = s + (u - s) / 2),
                              (c = t(f, e, n) - i),
                              0 < c ? (u = f) : (s = f);
                          } while (1e-7 < Math.abs(c) && 10 > ++l);
                          i = f;
                        }
                        return t(i, r, o);
                      };
                    }
                  };
                })(),
                _ = (function () {
                  function t(t, e) {
                    return 0 === t || 1 === t
                      ? t
                      : -Math.pow(2, 10 * (t - 1)) *
                          Math.sin(
                            (2 *
                              (t - 1 - (e / (2 * Math.PI)) * Math.asin(1)) *
                              Math.PI) /
                              e
                          );
                  }
                  var e,
                    r =
                      "Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(
                        " "
                      ),
                    n = {
                      In: [
                        [0.55, 0.085, 0.68, 0.53],
                        [0.55, 0.055, 0.675, 0.19],
                        [0.895, 0.03, 0.685, 0.22],
                        [0.755, 0.05, 0.855, 0.06],
                        [0.47, 0, 0.745, 0.715],
                        [0.95, 0.05, 0.795, 0.035],
                        [0.6, 0.04, 0.98, 0.335],
                        [0.6, -0.28, 0.735, 0.045],
                        t,
                      ],
                      Out: [
                        [0.25, 0.46, 0.45, 0.94],
                        [0.215, 0.61, 0.355, 1],
                        [0.165, 0.84, 0.44, 1],
                        [0.23, 1, 0.32, 1],
                        [0.39, 0.575, 0.565, 1],
                        [0.19, 1, 0.22, 1],
                        [0.075, 0.82, 0.165, 1],
                        [0.175, 0.885, 0.32, 1.275],
                        function (e, r) {
                          return 1 - t(1 - e, r);
                        },
                      ],
                      InOut: [
                        [0.455, 0.03, 0.515, 0.955],
                        [0.645, 0.045, 0.355, 1],
                        [0.77, 0, 0.175, 1],
                        [0.86, 0, 0.07, 1],
                        [0.445, 0.05, 0.55, 0.95],
                        [1, 0, 0, 1],
                        [0.785, 0.135, 0.15, 0.86],
                        [0.68, -0.55, 0.265, 1.55],
                        function (e, r) {
                          return 0.5 > e
                            ? t(2 * e, r) / 2
                            : 1 - t(-2 * e + 2, r) / 2;
                        },
                      ],
                    },
                    o = { linear: Y(0.25, 0.25, 0.75, 0.75) },
                    a = {};
                  for (e in n)
                    (a.type = e),
                      n[a.type].forEach(
                        (function (t) {
                          return function (e, n) {
                            o["ease" + t.type + r[n]] = X.fnc(e)
                              ? e
                              : Y.apply($jscomp$this, e);
                          };
                        })(a)
                      ),
                      (a = { type: a.type });
                  return o;
                })(),
                V = {
                  css: function (t, e, r) {
                    return (t.style[e] = r);
                  },
                  attribute: function (t, e, r) {
                    return t.setAttribute(e, r);
                  },
                  object: function (t, e, r) {
                    return (t[e] = r);
                  },
                  transform: function (t, e, r, n, o) {
                    n[o] || (n[o] = []), n[o].push(e + "(" + r + ")");
                  },
                },
                Z = [],
                q = 0,
                B = (function () {
                  function t() {
                    q = requestAnimationFrame(e);
                  }
                  function e(e) {
                    var r = Z.length;
                    if (r) {
                      for (var n = 0; n < r; ) Z[n] && Z[n].tick(e), n++;
                      t();
                    } else cancelAnimationFrame(q), (q = 0);
                  }
                  return t;
                })();
              return (
                (L.version = "2.2.0"),
                (L.speed = 1),
                (L.running = Z),
                (L.remove = function (t) {
                  t = w(t);
                  for (var e = Z.length; e--; )
                    for (var r = Z[e], n = r.animations, a = n.length; a--; )
                      o(t, n[a].animatable.target) &&
                        (n.splice(a, 1), n.length || r.pause());
                }),
                (L.getValue = y),
                (L.path = function (e, r) {
                  var n = X.str(e) ? t(e)[0] : e,
                    o = r || 100;
                  return function (t) {
                    return {
                      el: n,
                      property: t,
                      totalLength: j(n) * (o / 100),
                    };
                  };
                }),
                (L.setDashoffset = function (t) {
                  var e = j(t);
                  return t.setAttribute("stroke-dasharray", e), e;
                }),
                (L.bezier = Y),
                (L.easings = _),
                (L.timeline = function (t) {
                  var e = L(t);
                  return (
                    e.pause(),
                    (e.duration = 0),
                    (e.add = function (r) {
                      return (
                        e.children.forEach(function (t) {
                          (t.began = !0), (t.completed = !0);
                        }),
                        n(r).forEach(function (r) {
                          var n = u(r, i(T, t || {}));
                          (n.targets = n.targets || t.targets),
                            (r = e.duration);
                          var o = n.offset;
                          (n.autoplay = !1),
                            (n.direction = e.direction),
                            (n.offset = X.und(o) ? r : h(o, r)),
                            (e.began = !0),
                            (e.completed = !0),
                            e.seek(n.offset),
                            (n = L(n)),
                            (n.began = !0),
                            (n.completed = !0),
                            n.duration > r && (e.duration = n.duration),
                            e.children.push(n);
                        }),
                        e.seek(0),
                        e.reset(),
                        e.autoplay && e.restart(),
                        e
                      );
                    }),
                    e
                  );
                }),
                (L.random = function (t, e) {
                  return Math.floor(Math.random() * (e - t + 1)) + t;
                }),
                L
              );
            });
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {},
      ],
      3: [
        function (_dereq_, module, exports) {
          module.exports = function (e, n) {
            return "number" == typeof e ? e : "number" == typeof n ? n : 0;
          };
        },
        {},
      ],
      4: [
        function (_dereq_, module, exports) {
          "use strict";
          function getLens(o) {
            var r = o.length;
            if (r % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var e = o.indexOf("=");
            return -1 === e && (e = r), [e, e === r ? 0 : 4 - (e % 4)];
          }
          function byteLength(o) {
            var r = getLens(o),
              e = r[0],
              t = r[1];
            return (3 * (e + t)) / 4 - t;
          }
          function _byteLength(o, r, e) {
            return (3 * (r + e)) / 4 - e;
          }
          function toByteArray(o) {
            var r,
              e,
              t = getLens(o),
              n = t[0],
              u = t[1],
              p = new Arr(_byteLength(o, n, u)),
              a = 0,
              h = u > 0 ? n - 4 : n;
            for (e = 0; e < h; e += 4)
              (r =
                (revLookup[o.charCodeAt(e)] << 18) |
                (revLookup[o.charCodeAt(e + 1)] << 12) |
                (revLookup[o.charCodeAt(e + 2)] << 6) |
                revLookup[o.charCodeAt(e + 3)]),
                (p[a++] = (r >> 16) & 255),
                (p[a++] = (r >> 8) & 255),
                (p[a++] = 255 & r);
            return (
              2 === u &&
                ((r =
                  (revLookup[o.charCodeAt(e)] << 2) |
                  (revLookup[o.charCodeAt(e + 1)] >> 4)),
                (p[a++] = 255 & r)),
              1 === u &&
                ((r =
                  (revLookup[o.charCodeAt(e)] << 10) |
                  (revLookup[o.charCodeAt(e + 1)] << 4) |
                  (revLookup[o.charCodeAt(e + 2)] >> 2)),
                (p[a++] = (r >> 8) & 255),
                (p[a++] = 255 & r)),
              p
            );
          }
          function tripletToBase64(o) {
            return (
              lookup[(o >> 18) & 63] +
              lookup[(o >> 12) & 63] +
              lookup[(o >> 6) & 63] +
              lookup[63 & o]
            );
          }
          function encodeChunk(o, r, e) {
            for (var t, n = [], u = r; u < e; u += 3)
              (t =
                ((o[u] << 16) & 16711680) +
                ((o[u + 1] << 8) & 65280) +
                (255 & o[u + 2])),
                n.push(tripletToBase64(t));
            return n.join("");
          }
          function fromByteArray(o) {
            for (
              var r, e = o.length, t = e % 3, n = [], u = 0, p = e - t;
              u < p;
              u += 16383
            )
              n.push(encodeChunk(o, u, u + 16383 > p ? p : u + 16383));
            return (
              1 === t
                ? ((r = o[e - 1]),
                  n.push(lookup[r >> 2] + lookup[(r << 4) & 63] + "=="))
                : 2 === t &&
                  ((r = (o[e - 2] << 8) + o[e - 1]),
                  n.push(
                    lookup[r >> 10] +
                      lookup[(r >> 4) & 63] +
                      lookup[(r << 2) & 63] +
                      "="
                  )),
              n.join("")
            );
          }
          (exports.byteLength = byteLength),
            (exports.toByteArray = toByteArray),
            (exports.fromByteArray = fromByteArray);
          for (
            var lookup = [],
              revLookup = [],
              Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              code =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              i = 0,
              len = code.length;
            i < len;
            ++i
          )
            (lookup[i] = code[i]), (revLookup[code.charCodeAt(i)] = i);
          (revLookup["-".charCodeAt(0)] = 62),
            (revLookup["_".charCodeAt(0)] = 63);
        },
        {},
      ],
      5: [
        function (_dereq_, module, exports) {
          "use strict";
          module.exports = {
            createLink: function (e, t) {
              var a = document.head || document.getElementsByTagName("head")[0],
                n = document.createElement("link");
              (n.href = e), (n.rel = "stylesheet");
              for (var d in t)
                if (t.hasOwnProperty(d)) {
                  var r = t[d];
                  n.setAttribute("data-" + d, r);
                }
              a.appendChild(n);
            },
            createStyle: function (e, t) {
              var a = document.head || document.getElementsByTagName("head")[0],
                n = document.createElement("style");
              n.type = "text/css";
              for (var d in t)
                if (t.hasOwnProperty(d)) {
                  var r = t[d];
                  n.setAttribute("data-" + d, r);
                }
              n.sheet
                ? ((n.innerHTML = e), (n.sheet.cssText = e), a.appendChild(n))
                : n.styleSheet
                ? (a.appendChild(n), (n.styleSheet.cssText = e))
                : (n.appendChild(document.createTextNode(e)), a.appendChild(n));
            },
          };
        },
        {},
      ],
      6: [
        function (_dereq_, module, exports) {
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          function runTimeout(e) {
            if (cachedSetTimeout === setTimeout) return setTimeout(e, 0);
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            )
              return (cachedSetTimeout = setTimeout), setTimeout(e, 0);
            try {
              return cachedSetTimeout(e, 0);
            } catch (t) {
              try {
                return cachedSetTimeout.call(null, e, 0);
              } catch (t) {
                return cachedSetTimeout.call(this, e, 0);
              }
            }
          }
          function runClearTimeout(e) {
            if (cachedClearTimeout === clearTimeout) return clearTimeout(e);
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            )
              return (cachedClearTimeout = clearTimeout), clearTimeout(e);
            try {
              return cachedClearTimeout(e);
            } catch (t) {
              try {
                return cachedClearTimeout.call(null, e);
              } catch (t) {
                return cachedClearTimeout.call(this, e);
              }
            }
          }
          function cleanUpNextTick() {
            draining &&
              currentQueue &&
              ((draining = !1),
              currentQueue.length
                ? (queue = currentQueue.concat(queue))
                : (queueIndex = -1),
              queue.length && drainQueue());
          }
          function drainQueue() {
            if (!draining) {
              var e = runTimeout(cleanUpNextTick);
              draining = !0;
              for (var t = queue.length; t; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < t; )
                  currentQueue && currentQueue[queueIndex].run();
                (queueIndex = -1), (t = queue.length);
              }
              (currentQueue = null), (draining = !1), runClearTimeout(e);
            }
          }
          function Item(e, t) {
            (this.fun = e), (this.array = t);
          }
          function noop() {}
          var process = (module.exports = {}),
            cachedSetTimeout,
            cachedClearTimeout;
          !(function () {
            try {
              cachedSetTimeout =
                "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              cachedClearTimeout =
                "function" == typeof clearTimeout
                  ? clearTimeout
                  : defaultClearTimeout;
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          var queue = [],
            draining = !1,
            currentQueue,
            queueIndex = -1;
          (process.nextTick = function (e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var r = 1; r < arguments.length; r++)
                t[r - 1] = arguments[r];
            queue.push(new Item(e, t)),
              1 !== queue.length || draining || runTimeout(drainQueue);
          }),
            (Item.prototype.run = function () {
              this.fun.apply(null, this.array);
            }),
            (process.title = "browser"),
            (process.browser = !0),
            (process.env = {}),
            (process.argv = []),
            (process.version = ""),
            (process.versions = {}),
            (process.on = noop),
            (process.addListener = noop),
            (process.once = noop),
            (process.off = noop),
            (process.removeListener = noop),
            (process.removeAllListeners = noop),
            (process.emit = noop),
            (process.prependListener = noop),
            (process.prependOnceListener = noop),
            (process.listeners = function (e) {
              return [];
            }),
            (process.binding = function (e) {
              throw new Error("process.binding is not supported");
            }),
            (process.cwd = function () {
              return "/";
            }),
            (process.chdir = function (e) {
              throw new Error("process.chdir is not supported");
            }),
            (process.umask = function () {
              return 0;
            });
        },
        {},
      ],
      7: [
        function (_dereq_, module, exports) {
          var Buffer = _dereq_("buffer").Buffer;
          module.exports = function (f, e) {
            if (Buffer.isBuffer(f) && Buffer.isBuffer(e)) {
              if ("function" == typeof f.equals) return f.equals(e);
              if (f.length !== e.length) return !1;
              for (var r = 0; r < f.length; r++) if (f[r] !== e[r]) return !1;
              return !0;
            }
          };
        },
        { buffer: 8 },
      ],
      8: [
        function (_dereq_, module, exports) {
          (function (global, Buffer) {
            "use strict";
            function typedArraySupport() {
              try {
                var t = new Uint8Array(1);
                return (
                  (t.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function () {
                      return 42;
                    },
                  }),
                  42 === t.foo() &&
                    "function" == typeof t.subarray &&
                    0 === t.subarray(1, 1).byteLength
                );
              } catch (t) {
                return !1;
              }
            }
            function kMaxLength() {
              return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
            }
            function createBuffer(t, e) {
              if (kMaxLength() < e)
                throw new RangeError("Invalid typed array length");
              return (
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((t = new Uint8Array(e)), (t.__proto__ = Buffer.prototype))
                  : (null === t && (t = new Buffer(e)), (t.length = e)),
                t
              );
            }
            function Buffer(t, e, r) {
              if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer))
                return new Buffer(t, e, r);
              if ("number" == typeof t) {
                if ("string" == typeof e)
                  throw new Error(
                    "If encoding is specified then the first argument must be a string"
                  );
                return allocUnsafe(this, t);
              }
              return from(this, t, e, r);
            }
            function from(t, e, r, n) {
              if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number');
              return "undefined" != typeof ArrayBuffer &&
                e instanceof ArrayBuffer
                ? fromArrayBuffer(t, e, r, n)
                : "string" == typeof e
                ? fromString(t, e, r)
                : fromObject(t, e);
            }
            function assertSize(t) {
              if ("number" != typeof t)
                throw new TypeError('"size" argument must be a number');
              if (t < 0)
                throw new RangeError('"size" argument must not be negative');
            }
            function alloc(t, e, r, n) {
              return (
                assertSize(e),
                e <= 0
                  ? createBuffer(t, e)
                  : void 0 !== r
                  ? "string" == typeof n
                    ? createBuffer(t, e).fill(r, n)
                    : createBuffer(t, e).fill(r)
                  : createBuffer(t, e)
              );
            }
            function allocUnsafe(t, e) {
              if (
                (assertSize(e),
                (t = createBuffer(t, e < 0 ? 0 : 0 | checked(e))),
                !Buffer.TYPED_ARRAY_SUPPORT)
              )
                for (var r = 0; r < e; ++r) t[r] = 0;
              return t;
            }
            function fromString(t, e, r) {
              if (
                (("string" == typeof r && "" !== r) || (r = "utf8"),
                !Buffer.isEncoding(r))
              )
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                );
              var n = 0 | byteLength(e, r);
              t = createBuffer(t, n);
              var f = t.write(e, r);
              return f !== n && (t = t.slice(0, f)), t;
            }
            function fromArrayLike(t, e) {
              var r = e.length < 0 ? 0 : 0 | checked(e.length);
              t = createBuffer(t, r);
              for (var n = 0; n < r; n += 1) t[n] = 255 & e[n];
              return t;
            }
            function fromArrayBuffer(t, e, r, n) {
              if ((e.byteLength, r < 0 || e.byteLength < r))
                throw new RangeError("'offset' is out of bounds");
              if (e.byteLength < r + (n || 0))
                throw new RangeError("'length' is out of bounds");
              return (
                (e =
                  void 0 === r && void 0 === n
                    ? new Uint8Array(e)
                    : void 0 === n
                    ? new Uint8Array(e, r)
                    : new Uint8Array(e, r, n)),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((t = e), (t.__proto__ = Buffer.prototype))
                  : (t = fromArrayLike(t, e)),
                t
              );
            }
            function fromObject(t, e) {
              if (Buffer.isBuffer(e)) {
                var r = 0 | checked(e.length);
                return (
                  (t = createBuffer(t, r)),
                  0 === t.length ? t : (e.copy(t, 0, 0, r), t)
                );
              }
              if (e) {
                if (
                  ("undefined" != typeof ArrayBuffer &&
                    e.buffer instanceof ArrayBuffer) ||
                  "length" in e
                )
                  return "number" != typeof e.length || isnan(e.length)
                    ? createBuffer(t, 0)
                    : fromArrayLike(t, e);
                if ("Buffer" === e.type && isArray(e.data))
                  return fromArrayLike(t, e.data);
              }
              throw new TypeError(
                "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
              );
            }
            function checked(t) {
              if (t >= kMaxLength())
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    kMaxLength().toString(16) +
                    " bytes"
                );
              return 0 | t;
            }
            function SlowBuffer(t) {
              return +t != t && (t = 0), Buffer.alloc(+t);
            }
            function byteLength(t, e) {
              if (Buffer.isBuffer(t)) return t.length;
              if (
                "undefined" != typeof ArrayBuffer &&
                "function" == typeof ArrayBuffer.isView &&
                (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
              )
                return t.byteLength;
              "string" != typeof t && (t = "" + t);
              var r = t.length;
              if (0 === r) return 0;
              for (var n = !1; ; )
                switch (e) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return r;
                  case "utf8":
                  case "utf-8":
                  case void 0:
                    return utf8ToBytes(t).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * r;
                  case "hex":
                    return r >>> 1;
                  case "base64":
                    return base64ToBytes(t).length;
                  default:
                    if (n) return utf8ToBytes(t).length;
                    (e = ("" + e).toLowerCase()), (n = !0);
                }
            }
            function slowToString(t, e, r) {
              var n = !1;
              if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                return "";
              if (
                ((void 0 === r || r > this.length) && (r = this.length), r <= 0)
              )
                return "";
              if (((r >>>= 0), (e >>>= 0), r <= e)) return "";
              for (t || (t = "utf8"); ; )
                switch (t) {
                  case "hex":
                    return hexSlice(this, e, r);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, e, r);
                  case "ascii":
                    return asciiSlice(this, e, r);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, e, r);
                  case "base64":
                    return base64Slice(this, e, r);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, e, r);
                  default:
                    if (n) throw new TypeError("Unknown encoding: " + t);
                    (t = (t + "").toLowerCase()), (n = !0);
                }
            }
            function swap(t, e, r) {
              var n = t[e];
              (t[e] = t[r]), (t[r] = n);
            }
            function bidirectionalIndexOf(t, e, r, n, f) {
              if (0 === t.length) return -1;
              if (
                ("string" == typeof r
                  ? ((n = r), (r = 0))
                  : r > 2147483647
                  ? (r = 2147483647)
                  : r < -2147483648 && (r = -2147483648),
                (r = +r),
                isNaN(r) && (r = f ? 0 : t.length - 1),
                r < 0 && (r = t.length + r),
                r >= t.length)
              ) {
                if (f) return -1;
                r = t.length - 1;
              } else if (r < 0) {
                if (!f) return -1;
                r = 0;
              }
              if (
                ("string" == typeof e && (e = Buffer.from(e, n)),
                Buffer.isBuffer(e))
              )
                return 0 === e.length ? -1 : arrayIndexOf(t, e, r, n, f);
              if ("number" == typeof e)
                return (
                  (e &= 255),
                  Buffer.TYPED_ARRAY_SUPPORT &&
                  "function" == typeof Uint8Array.prototype.indexOf
                    ? f
                      ? Uint8Array.prototype.indexOf.call(t, e, r)
                      : Uint8Array.prototype.lastIndexOf.call(t, e, r)
                    : arrayIndexOf(t, [e], r, n, f)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(t, e, r, n, f) {
              function i(t, e) {
                return 1 === o ? t[e] : t.readUInt16BE(e * o);
              }
              var o = 1,
                u = t.length,
                s = e.length;
              if (
                void 0 !== n &&
                ("ucs2" === (n = String(n).toLowerCase()) ||
                  "ucs-2" === n ||
                  "utf16le" === n ||
                  "utf-16le" === n)
              ) {
                if (t.length < 2 || e.length < 2) return -1;
                (o = 2), (u /= 2), (s /= 2), (r /= 2);
              }
              var a;
              if (f) {
                var h = -1;
                for (a = r; a < u; a++)
                  if (i(t, a) === i(e, -1 === h ? 0 : a - h)) {
                    if ((-1 === h && (h = a), a - h + 1 === s)) return h * o;
                  } else -1 !== h && (a -= a - h), (h = -1);
              } else
                for (r + s > u && (r = u - s), a = r; a >= 0; a--) {
                  for (var c = !0, l = 0; l < s; l++)
                    if (i(t, a + l) !== i(e, l)) {
                      c = !1;
                      break;
                    }
                  if (c) return a;
                }
              return -1;
            }
            function hexWrite(t, e, r, n) {
              r = Number(r) || 0;
              var f = t.length - r;
              n ? (n = Number(n)) > f && (n = f) : (n = f);
              var i = e.length;
              if (i % 2 != 0) throw new TypeError("Invalid hex string");
              n > i / 2 && (n = i / 2);
              for (var o = 0; o < n; ++o) {
                var u = parseInt(e.substr(2 * o, 2), 16);
                if (isNaN(u)) return o;
                t[r + o] = u;
              }
              return o;
            }
            function utf8Write(t, e, r, n) {
              return blitBuffer(utf8ToBytes(e, t.length - r), t, r, n);
            }
            function asciiWrite(t, e, r, n) {
              return blitBuffer(asciiToBytes(e), t, r, n);
            }
            function latin1Write(t, e, r, n) {
              return asciiWrite(t, e, r, n);
            }
            function base64Write(t, e, r, n) {
              return blitBuffer(base64ToBytes(e), t, r, n);
            }
            function ucs2Write(t, e, r, n) {
              return blitBuffer(utf16leToBytes(e, t.length - r), t, r, n);
            }
            function base64Slice(t, e, r) {
              return 0 === e && r === t.length
                ? base64.fromByteArray(t)
                : base64.fromByteArray(t.slice(e, r));
            }
            function utf8Slice(t, e, r) {
              r = Math.min(t.length, r);
              for (var n = [], f = e; f < r; ) {
                var i = t[f],
                  o = null,
                  u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                if (f + u <= r) {
                  var s, a, h, c;
                  switch (u) {
                    case 1:
                      i < 128 && (o = i);
                      break;
                    case 2:
                      (s = t[f + 1]),
                        128 == (192 & s) &&
                          (c = ((31 & i) << 6) | (63 & s)) > 127 &&
                          (o = c);
                      break;
                    case 3:
                      (s = t[f + 1]),
                        (a = t[f + 2]),
                        128 == (192 & s) &&
                          128 == (192 & a) &&
                          (c = ((15 & i) << 12) | ((63 & s) << 6) | (63 & a)) >
                            2047 &&
                          (c < 55296 || c > 57343) &&
                          (o = c);
                      break;
                    case 4:
                      (s = t[f + 1]),
                        (a = t[f + 2]),
                        (h = t[f + 3]),
                        128 == (192 & s) &&
                          128 == (192 & a) &&
                          128 == (192 & h) &&
                          (c =
                            ((15 & i) << 18) |
                            ((63 & s) << 12) |
                            ((63 & a) << 6) |
                            (63 & h)) > 65535 &&
                          c < 1114112 &&
                          (o = c);
                  }
                }
                null === o
                  ? ((o = 65533), (u = 1))
                  : o > 65535 &&
                    ((o -= 65536),
                    n.push(((o >>> 10) & 1023) | 55296),
                    (o = 56320 | (1023 & o))),
                  n.push(o),
                  (f += u);
              }
              return decodeCodePointsArray(n);
            }
            function decodeCodePointsArray(t) {
              var e = t.length;
              if (e <= MAX_ARGUMENTS_LENGTH)
                return String.fromCharCode.apply(String, t);
              for (var r = "", n = 0; n < e; )
                r += String.fromCharCode.apply(
                  String,
                  t.slice(n, (n += MAX_ARGUMENTS_LENGTH))
                );
              return r;
            }
            function asciiSlice(t, e, r) {
              var n = "";
              r = Math.min(t.length, r);
              for (var f = e; f < r; ++f) n += String.fromCharCode(127 & t[f]);
              return n;
            }
            function latin1Slice(t, e, r) {
              var n = "";
              r = Math.min(t.length, r);
              for (var f = e; f < r; ++f) n += String.fromCharCode(t[f]);
              return n;
            }
            function hexSlice(t, e, r) {
              var n = t.length;
              (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
              for (var f = "", i = e; i < r; ++i) f += toHex(t[i]);
              return f;
            }
            function utf16leSlice(t, e, r) {
              for (var n = t.slice(e, r), f = "", i = 0; i < n.length; i += 2)
                f += String.fromCharCode(n[i] + 256 * n[i + 1]);
              return f;
            }
            function checkOffset(t, e, r) {
              if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
              if (t + e > r)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function checkInt(t, e, r, n, f, i) {
              if (!Buffer.isBuffer(t))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (e > f || e < i)
                throw new RangeError('"value" argument is out of bounds');
              if (r + n > t.length) throw new RangeError("Index out of range");
            }
            function objectWriteUInt16(t, e, r, n) {
              e < 0 && (e = 65535 + e + 1);
              for (var f = 0, i = Math.min(t.length - r, 2); f < i; ++f)
                t[r + f] =
                  (e & (255 << (8 * (n ? f : 1 - f)))) >>>
                  (8 * (n ? f : 1 - f));
            }
            function objectWriteUInt32(t, e, r, n) {
              e < 0 && (e = 4294967295 + e + 1);
              for (var f = 0, i = Math.min(t.length - r, 4); f < i; ++f)
                t[r + f] = (e >>> (8 * (n ? f : 3 - f))) & 255;
            }
            function checkIEEE754(t, e, r, n, f, i) {
              if (r + n > t.length) throw new RangeError("Index out of range");
              if (r < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(t, e, r, n, f) {
              return (
                f ||
                  checkIEEE754(
                    t,
                    e,
                    r,
                    4,
                    3.4028234663852886e38,
                    -3.4028234663852886e38
                  ),
                ieee754.write(t, e, r, n, 23, 4),
                r + 4
              );
            }
            function writeDouble(t, e, r, n, f) {
              return (
                f ||
                  checkIEEE754(
                    t,
                    e,
                    r,
                    8,
                    1.7976931348623157e308,
                    -1.7976931348623157e308
                  ),
                ieee754.write(t, e, r, n, 52, 8),
                r + 8
              );
            }
            function base64clean(t) {
              if (
                ((t = stringtrim(t).replace(INVALID_BASE64_RE, "")),
                t.length < 2)
              )
                return "";
              for (; t.length % 4 != 0; ) t += "=";
              return t;
            }
            function stringtrim(t) {
              return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
            }
            function toHex(t) {
              return t < 16 ? "0" + t.toString(16) : t.toString(16);
            }
            function utf8ToBytes(t, e) {
              e = e || 1 / 0;
              for (var r, n = t.length, f = null, i = [], o = 0; o < n; ++o) {
                if ((r = t.charCodeAt(o)) > 55295 && r < 57344) {
                  if (!f) {
                    if (r > 56319) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    if (o + 1 === n) {
                      (e -= 3) > -1 && i.push(239, 191, 189);
                      continue;
                    }
                    f = r;
                    continue;
                  }
                  if (r < 56320) {
                    (e -= 3) > -1 && i.push(239, 191, 189), (f = r);
                    continue;
                  }
                  r = 65536 + (((f - 55296) << 10) | (r - 56320));
                } else f && (e -= 3) > -1 && i.push(239, 191, 189);
                if (((f = null), r < 128)) {
                  if ((e -= 1) < 0) break;
                  i.push(r);
                } else if (r < 2048) {
                  if ((e -= 2) < 0) break;
                  i.push((r >> 6) | 192, (63 & r) | 128);
                } else if (r < 65536) {
                  if ((e -= 3) < 0) break;
                  i.push(
                    (r >> 12) | 224,
                    ((r >> 6) & 63) | 128,
                    (63 & r) | 128
                  );
                } else {
                  if (!(r < 1114112)) throw new Error("Invalid code point");
                  if ((e -= 4) < 0) break;
                  i.push(
                    (r >> 18) | 240,
                    ((r >> 12) & 63) | 128,
                    ((r >> 6) & 63) | 128,
                    (63 & r) | 128
                  );
                }
              }
              return i;
            }
            function asciiToBytes(t) {
              for (var e = [], r = 0; r < t.length; ++r)
                e.push(255 & t.charCodeAt(r));
              return e;
            }
            function utf16leToBytes(t, e) {
              for (
                var r, n, f, i = [], o = 0;
                o < t.length && !((e -= 2) < 0);
                ++o
              )
                (r = t.charCodeAt(o)),
                  (n = r >> 8),
                  (f = r % 256),
                  i.push(f),
                  i.push(n);
              return i;
            }
            function base64ToBytes(t) {
              return base64.toByteArray(base64clean(t));
            }
            function blitBuffer(t, e, r, n) {
              for (
                var f = 0;
                f < n && !(f + r >= e.length || f >= t.length);
                ++f
              )
                e[f + r] = t[f];
              return f;
            }
            function isnan(t) {
              return t !== t;
            }
            var base64 = _dereq_("base64-js"),
              ieee754 = _dereq_("ieee754"),
              isArray = _dereq_("isarray");
            (exports.Buffer = Buffer),
              (exports.SlowBuffer = SlowBuffer),
              (exports.INSPECT_MAX_BYTES = 50),
              (Buffer.TYPED_ARRAY_SUPPORT =
                void 0 !== global.TYPED_ARRAY_SUPPORT
                  ? global.TYPED_ARRAY_SUPPORT
                  : typedArraySupport()),
              (exports.kMaxLength = kMaxLength()),
              (Buffer.poolSize = 8192),
              (Buffer._augment = function (t) {
                return (t.__proto__ = Buffer.prototype), t;
              }),
              (Buffer.from = function (t, e, r) {
                return from(null, t, e, r);
              }),
              Buffer.TYPED_ARRAY_SUPPORT &&
                ((Buffer.prototype.__proto__ = Uint8Array.prototype),
                (Buffer.__proto__ = Uint8Array),
                "undefined" != typeof Symbol &&
                  Symbol.species &&
                  Buffer[Symbol.species] === Buffer &&
                  Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: !0,
                  })),
              (Buffer.alloc = function (t, e, r) {
                return alloc(null, t, e, r);
              }),
              (Buffer.allocUnsafe = function (t) {
                return allocUnsafe(null, t);
              }),
              (Buffer.allocUnsafeSlow = function (t) {
                return allocUnsafe(null, t);
              }),
              (Buffer.isBuffer = function (t) {
                return !(null == t || !t._isBuffer);
              }),
              (Buffer.compare = function (t, e) {
                if (!Buffer.isBuffer(t) || !Buffer.isBuffer(e))
                  throw new TypeError("Arguments must be Buffers");
                if (t === e) return 0;
                for (
                  var r = t.length, n = e.length, f = 0, i = Math.min(r, n);
                  f < i;
                  ++f
                )
                  if (t[f] !== e[f]) {
                    (r = t[f]), (n = e[f]);
                    break;
                  }
                return r < n ? -1 : n < r ? 1 : 0;
              }),
              (Buffer.isEncoding = function (t) {
                switch (String(t).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (Buffer.concat = function (t, e) {
                if (!isArray(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (0 === t.length) return Buffer.alloc(0);
                var r;
                if (void 0 === e)
                  for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
                var n = Buffer.allocUnsafe(e),
                  f = 0;
                for (r = 0; r < t.length; ++r) {
                  var i = t[r];
                  if (!Buffer.isBuffer(i))
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  i.copy(n, f), (f += i.length);
                }
                return n;
              }),
              (Buffer.byteLength = byteLength),
              (Buffer.prototype._isBuffer = !0),
              (Buffer.prototype.swap16 = function () {
                var t = this.length;
                if (t % 2 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 16-bits"
                  );
                for (var e = 0; e < t; e += 2) swap(this, e, e + 1);
                return this;
              }),
              (Buffer.prototype.swap32 = function () {
                var t = this.length;
                if (t % 4 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (var e = 0; e < t; e += 4)
                  swap(this, e, e + 3), swap(this, e + 1, e + 2);
                return this;
              }),
              (Buffer.prototype.swap64 = function () {
                var t = this.length;
                if (t % 8 != 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (var e = 0; e < t; e += 8)
                  swap(this, e, e + 7),
                    swap(this, e + 1, e + 6),
                    swap(this, e + 2, e + 5),
                    swap(this, e + 3, e + 4);
                return this;
              }),
              (Buffer.prototype.toString = function () {
                var t = 0 | this.length;
                return 0 === t
                  ? ""
                  : 0 === arguments.length
                  ? utf8Slice(this, 0, t)
                  : slowToString.apply(this, arguments);
              }),
              (Buffer.prototype.equals = function (t) {
                if (!Buffer.isBuffer(t))
                  throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === Buffer.compare(this, t);
              }),
              (Buffer.prototype.inspect = function () {
                var t = "",
                  e = exports.INSPECT_MAX_BYTES;
                return (
                  this.length > 0 &&
                    ((t = this.toString("hex", 0, e).match(/.{2}/g).join(" ")),
                    this.length > e && (t += " ... ")),
                  "<Buffer " + t + ">"
                );
              }),
              (Buffer.prototype.compare = function (t, e, r, n, f) {
                if (!Buffer.isBuffer(t))
                  throw new TypeError("Argument must be a Buffer");
                if (
                  (void 0 === e && (e = 0),
                  void 0 === r && (r = t ? t.length : 0),
                  void 0 === n && (n = 0),
                  void 0 === f && (f = this.length),
                  e < 0 || r > t.length || n < 0 || f > this.length)
                )
                  throw new RangeError("out of range index");
                if (n >= f && e >= r) return 0;
                if (n >= f) return -1;
                if (e >= r) return 1;
                if (
                  ((e >>>= 0), (r >>>= 0), (n >>>= 0), (f >>>= 0), this === t)
                )
                  return 0;
                for (
                  var i = f - n,
                    o = r - e,
                    u = Math.min(i, o),
                    s = this.slice(n, f),
                    a = t.slice(e, r),
                    h = 0;
                  h < u;
                  ++h
                )
                  if (s[h] !== a[h]) {
                    (i = s[h]), (o = a[h]);
                    break;
                  }
                return i < o ? -1 : o < i ? 1 : 0;
              }),
              (Buffer.prototype.includes = function (t, e, r) {
                return -1 !== this.indexOf(t, e, r);
              }),
              (Buffer.prototype.indexOf = function (t, e, r) {
                return bidirectionalIndexOf(this, t, e, r, !0);
              }),
              (Buffer.prototype.lastIndexOf = function (t, e, r) {
                return bidirectionalIndexOf(this, t, e, r, !1);
              }),
              (Buffer.prototype.write = function (t, e, r, n) {
                if (void 0 === e) (n = "utf8"), (r = this.length), (e = 0);
                else if (void 0 === r && "string" == typeof e)
                  (n = e), (r = this.length), (e = 0);
                else {
                  if (!isFinite(e))
                    throw new Error(
                      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                    );
                  (e |= 0),
                    isFinite(r)
                      ? ((r |= 0), void 0 === n && (n = "utf8"))
                      : ((n = r), (r = void 0));
                }
                var f = this.length - e;
                if (
                  ((void 0 === r || r > f) && (r = f),
                  (t.length > 0 && (r < 0 || e < 0)) || e > this.length)
                )
                  throw new RangeError(
                    "Attempt to write outside buffer bounds"
                  );
                n || (n = "utf8");
                for (var i = !1; ; )
                  switch (n) {
                    case "hex":
                      return hexWrite(this, t, e, r);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, t, e, r);
                    case "ascii":
                      return asciiWrite(this, t, e, r);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, t, e, r);
                    case "base64":
                      return base64Write(this, t, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, t, e, r);
                    default:
                      if (i) throw new TypeError("Unknown encoding: " + n);
                      (n = ("" + n).toLowerCase()), (i = !0);
                  }
              }),
              (Buffer.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            var MAX_ARGUMENTS_LENGTH = 4096;
            (Buffer.prototype.slice = function (t, e) {
              var r = this.length;
              (t = ~~t),
                (e = void 0 === e ? r : ~~e),
                t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
                e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
                e < t && (e = t);
              var n;
              if (Buffer.TYPED_ARRAY_SUPPORT)
                (n = this.subarray(t, e)), (n.__proto__ = Buffer.prototype);
              else {
                var f = e - t;
                n = new Buffer(f, void 0);
                for (var i = 0; i < f; ++i) n[i] = this[i + t];
              }
              return n;
            }),
              (Buffer.prototype.readUIntLE = function (t, e, r) {
                (t |= 0), (e |= 0), r || checkOffset(t, e, this.length);
                for (var n = this[t], f = 1, i = 0; ++i < e && (f *= 256); )
                  n += this[t + i] * f;
                return n;
              }),
              (Buffer.prototype.readUIntBE = function (t, e, r) {
                (t |= 0), (e |= 0), r || checkOffset(t, e, this.length);
                for (var n = this[t + --e], f = 1; e > 0 && (f *= 256); )
                  n += this[t + --e] * f;
                return n;
              }),
              (Buffer.prototype.readUInt8 = function (t, e) {
                return e || checkOffset(t, 1, this.length), this[t];
              }),
              (Buffer.prototype.readUInt16LE = function (t, e) {
                return (
                  e || checkOffset(t, 2, this.length),
                  this[t] | (this[t + 1] << 8)
                );
              }),
              (Buffer.prototype.readUInt16BE = function (t, e) {
                return (
                  e || checkOffset(t, 2, this.length),
                  (this[t] << 8) | this[t + 1]
                );
              }),
              (Buffer.prototype.readUInt32LE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                    16777216 * this[t + 3]
                );
              }),
              (Buffer.prototype.readUInt32BE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  16777216 * this[t] +
                    ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                );
              }),
              (Buffer.prototype.readIntLE = function (t, e, r) {
                (t |= 0), (e |= 0), r || checkOffset(t, e, this.length);
                for (var n = this[t], f = 1, i = 0; ++i < e && (f *= 256); )
                  n += this[t + i] * f;
                return (f *= 128), n >= f && (n -= Math.pow(2, 8 * e)), n;
              }),
              (Buffer.prototype.readIntBE = function (t, e, r) {
                (t |= 0), (e |= 0), r || checkOffset(t, e, this.length);
                for (var n = e, f = 1, i = this[t + --n]; n > 0 && (f *= 256); )
                  i += this[t + --n] * f;
                return (f *= 128), i >= f && (i -= Math.pow(2, 8 * e)), i;
              }),
              (Buffer.prototype.readInt8 = function (t, e) {
                return (
                  e || checkOffset(t, 1, this.length),
                  128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                );
              }),
              (Buffer.prototype.readInt16LE = function (t, e) {
                e || checkOffset(t, 2, this.length);
                var r = this[t] | (this[t + 1] << 8);
                return 32768 & r ? 4294901760 | r : r;
              }),
              (Buffer.prototype.readInt16BE = function (t, e) {
                e || checkOffset(t, 2, this.length);
                var r = this[t + 1] | (this[t] << 8);
                return 32768 & r ? 4294901760 | r : r;
              }),
              (Buffer.prototype.readInt32LE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  this[t] |
                    (this[t + 1] << 8) |
                    (this[t + 2] << 16) |
                    (this[t + 3] << 24)
                );
              }),
              (Buffer.prototype.readInt32BE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  (this[t] << 24) |
                    (this[t + 1] << 16) |
                    (this[t + 2] << 8) |
                    this[t + 3]
                );
              }),
              (Buffer.prototype.readFloatLE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  ieee754.read(this, t, !0, 23, 4)
                );
              }),
              (Buffer.prototype.readFloatBE = function (t, e) {
                return (
                  e || checkOffset(t, 4, this.length),
                  ieee754.read(this, t, !1, 23, 4)
                );
              }),
              (Buffer.prototype.readDoubleLE = function (t, e) {
                return (
                  e || checkOffset(t, 8, this.length),
                  ieee754.read(this, t, !0, 52, 8)
                );
              }),
              (Buffer.prototype.readDoubleBE = function (t, e) {
                return (
                  e || checkOffset(t, 8, this.length),
                  ieee754.read(this, t, !1, 52, 8)
                );
              }),
              (Buffer.prototype.writeUIntLE = function (t, e, r, n) {
                if (((t = +t), (e |= 0), (r |= 0), !n)) {
                  checkInt(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                }
                var f = 1,
                  i = 0;
                for (this[e] = 255 & t; ++i < r && (f *= 256); )
                  this[e + i] = (t / f) & 255;
                return e + r;
              }),
              (Buffer.prototype.writeUIntBE = function (t, e, r, n) {
                if (((t = +t), (e |= 0), (r |= 0), !n)) {
                  checkInt(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                }
                var f = r - 1,
                  i = 1;
                for (this[e + f] = 255 & t; --f >= 0 && (i *= 256); )
                  this[e + f] = (t / i) & 255;
                return e + r;
              }),
              (Buffer.prototype.writeUInt8 = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 1, 255, 0),
                  Buffer.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                  (this[e] = 255 & t),
                  e + 1
                );
              }),
              (Buffer.prototype.writeUInt16LE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 2, 65535, 0),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                    : objectWriteUInt16(this, t, e, !0),
                  e + 2
                );
              }),
              (Buffer.prototype.writeUInt16BE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 2, 65535, 0),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                    : objectWriteUInt16(this, t, e, !1),
                  e + 2
                );
              }),
              (Buffer.prototype.writeUInt32LE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 4, 4294967295, 0),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e + 3] = t >>> 24),
                      (this[e + 2] = t >>> 16),
                      (this[e + 1] = t >>> 8),
                      (this[e] = 255 & t))
                    : objectWriteUInt32(this, t, e, !0),
                  e + 4
                );
              }),
              (Buffer.prototype.writeUInt32BE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 4, 4294967295, 0),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = t >>> 24),
                      (this[e + 1] = t >>> 16),
                      (this[e + 2] = t >>> 8),
                      (this[e + 3] = 255 & t))
                    : objectWriteUInt32(this, t, e, !1),
                  e + 4
                );
              }),
              (Buffer.prototype.writeIntLE = function (t, e, r, n) {
                if (((t = +t), (e |= 0), !n)) {
                  var f = Math.pow(2, 8 * r - 1);
                  checkInt(this, t, e, r, f - 1, -f);
                }
                var i = 0,
                  o = 1,
                  u = 0;
                for (this[e] = 255 & t; ++i < r && (o *= 256); )
                  t < 0 && 0 === u && 0 !== this[e + i - 1] && (u = 1),
                    (this[e + i] = (((t / o) >> 0) - u) & 255);
                return e + r;
              }),
              (Buffer.prototype.writeIntBE = function (t, e, r, n) {
                if (((t = +t), (e |= 0), !n)) {
                  var f = Math.pow(2, 8 * r - 1);
                  checkInt(this, t, e, r, f - 1, -f);
                }
                var i = r - 1,
                  o = 1,
                  u = 0;
                for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); )
                  t < 0 && 0 === u && 0 !== this[e + i + 1] && (u = 1),
                    (this[e + i] = (((t / o) >> 0) - u) & 255);
                return e + r;
              }),
              (Buffer.prototype.writeInt8 = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 1, 127, -128),
                  Buffer.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                  t < 0 && (t = 255 + t + 1),
                  (this[e] = 255 & t),
                  e + 1
                );
              }),
              (Buffer.prototype.writeInt16LE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 2, 32767, -32768),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                    : objectWriteUInt16(this, t, e, !0),
                  e + 2
                );
              }),
              (Buffer.prototype.writeInt16BE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 2, 32767, -32768),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                    : objectWriteUInt16(this, t, e, !1),
                  e + 2
                );
              }),
              (Buffer.prototype.writeInt32LE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 4, 2147483647, -2147483648),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = 255 & t),
                      (this[e + 1] = t >>> 8),
                      (this[e + 2] = t >>> 16),
                      (this[e + 3] = t >>> 24))
                    : objectWriteUInt32(this, t, e, !0),
                  e + 4
                );
              }),
              (Buffer.prototype.writeInt32BE = function (t, e, r) {
                return (
                  (t = +t),
                  (e |= 0),
                  r || checkInt(this, t, e, 4, 2147483647, -2147483648),
                  t < 0 && (t = 4294967295 + t + 1),
                  Buffer.TYPED_ARRAY_SUPPORT
                    ? ((this[e] = t >>> 24),
                      (this[e + 1] = t >>> 16),
                      (this[e + 2] = t >>> 8),
                      (this[e + 3] = 255 & t))
                    : objectWriteUInt32(this, t, e, !1),
                  e + 4
                );
              }),
              (Buffer.prototype.writeFloatLE = function (t, e, r) {
                return writeFloat(this, t, e, !0, r);
              }),
              (Buffer.prototype.writeFloatBE = function (t, e, r) {
                return writeFloat(this, t, e, !1, r);
              }),
              (Buffer.prototype.writeDoubleLE = function (t, e, r) {
                return writeDouble(this, t, e, !0, r);
              }),
              (Buffer.prototype.writeDoubleBE = function (t, e, r) {
                return writeDouble(this, t, e, !1, r);
              }),
              (Buffer.prototype.copy = function (t, e, r, n) {
                if (
                  (r || (r = 0),
                  n || 0 === n || (n = this.length),
                  e >= t.length && (e = t.length),
                  e || (e = 0),
                  n > 0 && n < r && (n = r),
                  n === r)
                )
                  return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length)
                  throw new RangeError("sourceStart out of bounds");
                if (n < 0) throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length),
                  t.length - e < n - r && (n = t.length - e + r);
                var f,
                  i = n - r;
                if (this === t && r < e && e < n)
                  for (f = i - 1; f >= 0; --f) t[f + e] = this[f + r];
                else if (i < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
                  for (f = 0; f < i; ++f) t[f + e] = this[f + r];
                else
                  Uint8Array.prototype.set.call(t, this.subarray(r, r + i), e);
                return i;
              }),
              (Buffer.prototype.fill = function (t, e, r, n) {
                if ("string" == typeof t) {
                  if (
                    ("string" == typeof e
                      ? ((n = e), (e = 0), (r = this.length))
                      : "string" == typeof r && ((n = r), (r = this.length)),
                    1 === t.length)
                  ) {
                    var f = t.charCodeAt(0);
                    f < 256 && (t = f);
                  }
                  if (void 0 !== n && "string" != typeof n)
                    throw new TypeError("encoding must be a string");
                  if ("string" == typeof n && !Buffer.isEncoding(n))
                    throw new TypeError("Unknown encoding: " + n);
                } else "number" == typeof t && (t &= 255);
                if (e < 0 || this.length < e || this.length < r)
                  throw new RangeError("Out of range index");
                if (r <= e) return this;
                (e >>>= 0),
                  (r = void 0 === r ? this.length : r >>> 0),
                  t || (t = 0);
                var i;
                if ("number" == typeof t) for (i = e; i < r; ++i) this[i] = t;
                else {
                  var o = Buffer.isBuffer(t)
                      ? t
                      : utf8ToBytes(new Buffer(t, n).toString()),
                    u = o.length;
                  for (i = 0; i < r - e; ++i) this[i + e] = o[i % u];
                }
                return this;
              });
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {},
            _dereq_("buffer").Buffer
          ));
        },
        { "base64-js": 4, buffer: 8, ieee754: 17, isarray: 9 },
      ],
      9: [
        function (_dereq_, module, exports) {
          var toString = {}.toString;
          module.exports =
            Array.isArray ||
            function (r) {
              return "[object Array]" == toString.call(r);
            };
        },
        {},
      ],
      10: [
        function (_dereq_, module, exports) {
          function useColors() {
            return (
              "WebkitAppearance" in document.documentElement.style ||
              (window.console &&
                (console.firebug || (console.exception && console.table))) ||
              (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                parseInt(RegExp.$1, 10) >= 31)
            );
          }
          function formatArgs() {
            var o = arguments,
              e = this.useColors;
            if (
              ((o[0] =
                (e ? "%c" : "") +
                this.namespace +
                (e ? " %c" : " ") +
                o[0] +
                (e ? "%c " : " ")),
              !e)
            )
              return o;
            var r = "color: " + this.color;
            o = [o[0], r, "color: inherit"].concat(
              Array.prototype.slice.call(o, 1)
            );
            var t = 0,
              s = 0;
            return (
              o[0].replace(/%[a-z%]/g, function (o) {
                "%%" !== o && (t++, "%c" === o && (s = t));
              }),
              o.splice(s, 0, r),
              o
            );
          }
          function log() {
            return (
              "object" == typeof console &&
              console.log &&
              Function.prototype.apply.call(console.log, console, arguments)
            );
          }
          function save(o) {
            try {
              null == o
                ? exports.storage.removeItem("debug")
                : (exports.storage.debug = o);
            } catch (o) {}
          }
          function load() {
            var o;
            try {
              o = exports.storage.debug;
            } catch (o) {}
            return o;
          }
          function localstorage() {
            try {
              return window.localStorage;
            } catch (o) {}
          }
          (exports = module.exports = _dereq_("./debug")),
            (exports.log = log),
            (exports.formatArgs = formatArgs),
            (exports.save = save),
            (exports.load = load),
            (exports.useColors = useColors),
            (exports.storage =
              "undefined" != typeof chrome && void 0 !== chrome.storage
                ? chrome.storage.local
                : localstorage()),
            (exports.colors = [
              "lightseagreen",
              "forestgreen",
              "goldenrod",
              "dodgerblue",
              "darkorchid",
              "crimson",
            ]),
            (exports.formatters.j = function (o) {
              return JSON.stringify(o);
            }),
            exports.enable(load());
        },
        { "./debug": 11 },
      ],
      11: [
        function (_dereq_, module, exports) {
          function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
          }
          function debug(e) {
            function r() {}
            function o() {
              var e = o;
              null == e.useColors && (e.useColors = exports.useColors()),
                null == e.color && e.useColors && (e.color = selectColor());
              var r = Array.prototype.slice.call(arguments);
              (r[0] = exports.coerce(r[0])),
                "string" != typeof r[0] && (r = ["%o"].concat(r));
              var s = 0;
              (r[0] = r[0].replace(/%([a-z%])/g, function (o, t) {
                if ("%%" === o) return o;
                s++;
                var n = exports.formatters[t];
                if ("function" == typeof n) {
                  var l = r[s];
                  (o = n.call(e, l)), r.splice(s, 1), s--;
                }
                return o;
              })),
                "function" == typeof exports.formatArgs &&
                  (r = exports.formatArgs.apply(e, r)),
                (o.log || exports.log || console.log.bind(console)).apply(e, r);
            }
            (r.enabled = !1), (o.enabled = !0);
            var s = exports.enabled(e) ? o : r;
            return (s.namespace = e), s;
          }
          function enable(e) {
            exports.save(e);
            for (
              var r = (e || "").split(/[\s,]+/), o = r.length, s = 0;
              s < o;
              s++
            )
              r[s] &&
                ((e = r[s].replace(/\*/g, ".*?")),
                "-" === e[0]
                  ? exports.skips.push(new RegExp("^" + e.substr(1) + "$"))
                  : exports.names.push(new RegExp("^" + e + "$")));
          }
          function disable() {
            exports.enable("");
          }
          function enabled(e) {
            var r, o;
            for (r = 0, o = exports.skips.length; r < o; r++)
              if (exports.skips[r].test(e)) return !1;
            for (r = 0, o = exports.names.length; r < o; r++)
              if (exports.names[r].test(e)) return !0;
            return !1;
          }
          function coerce(e) {
            return e instanceof Error ? e.stack || e.message : e;
          }
          (exports = module.exports = debug),
            (exports.coerce = coerce),
            (exports.disable = disable),
            (exports.enable = enable),
            (exports.enabled = enabled),
            (exports.names = []),
            (exports.skips = []),
            (exports.formatters = {});
          var prevColor = 0;
        },
        {},
      ],
      12: [
        function (_dereq_, module, exports) {
          "use strict";
          function toObject(r) {
            if (null === r || void 0 === r)
              throw new TypeError("Sources cannot be null or undefined");
            return Object(r);
          }
          function assignKey(r, e, n) {
            var t = e[n];
            if (void 0 !== t && null !== t) {
              if (
                hasOwnProperty.call(r, n) &&
                (void 0 === r[n] || null === r[n])
              )
                throw new TypeError(
                  "Cannot convert undefined or null to object (" + n + ")"
                );
              hasOwnProperty.call(r, n) && isObj(t)
                ? (r[n] = assign(Object(r[n]), e[n]))
                : (r[n] = t);
            }
          }
          function assign(r, e) {
            if (r === e) return r;
            e = Object(e);
            for (var n in e) hasOwnProperty.call(e, n) && assignKey(r, e, n);
            if (Object.getOwnPropertySymbols)
              for (
                var t = Object.getOwnPropertySymbols(e), o = 0;
                o < t.length;
                o++
              )
                propIsEnumerable.call(e, t[o]) && assignKey(r, e, t[o]);
            return r;
          }
          var isObj = _dereq_("is-obj"),
            hasOwnProperty = Object.prototype.hasOwnProperty,
            propIsEnumerable = Object.prototype.propertyIsEnumerable;
          module.exports = function (r) {
            r = toObject(r);
            for (var e = 1; e < arguments.length; e++) assign(r, arguments[e]);
            return r;
          };
        },
        { "is-obj": 21 },
      ],
      13: [
        function (_dereq_, module, exports) {
          !(function (t, r, n, a) {
            "use strict";
            function l(e, t) {
              for (var r = 0, n = e.length; r < n; r++) m(e[r], t);
            }
            function i(e) {
              for (var t, r = 0, n = e.length; r < n; r++)
                (t = e[r]), y(t, H[u(t)]);
            }
            function o(e) {
              return function (t) {
                ae(t) && (m(t, e), l(t.querySelectorAll(x), e));
              };
            }
            function u(e) {
              var t = oe.call(e, "is"),
                r = e.nodeName.toUpperCase(),
                n = G.call(U, t ? k + t.toUpperCase() : _ + r);
              return t && -1 < n && !c(r, t) ? -1 : n;
            }
            function c(e, t) {
              return -1 < x.indexOf(e + '[is="' + t + '"]');
            }
            function s(e) {
              var t = e.currentTarget,
                r = e.attrChange,
                n = e.attrName,
                a = e.target;
              me &&
                (!a || a === t) &&
                t.attributeChangedCallback &&
                "style" !== n &&
                e.prevValue !== e.newValue &&
                t.attributeChangedCallback(
                  n,
                  r === e[F] ? null : e.prevValue,
                  r === e[I] ? null : e.newValue
                );
            }
            function d(e) {
              var t = o(e);
              return function (e) {
                g.push(t, e.target);
              };
            }
            function f(e) {
              be && ((be = !1), e.currentTarget.removeEventListener(P, f)),
                l((e.target || r).querySelectorAll(x), e.detail === T ? T : L),
                ne && p();
            }
            function h(e, t) {
              var r = this;
              ue.call(r, e, t), C.call(r, { target: r });
            }
            function v(e, t) {
              ee(e, t),
                O
                  ? O.observe(e, de)
                  : (pe &&
                      ((e.setAttribute = h),
                      (e[w] = E(e)),
                      e.addEventListener(R, C)),
                    e.addEventListener(D, s)),
                e.createdCallback &&
                  me &&
                  ((e.created = !0), e.createdCallback(), (e.created = !1));
            }
            function p() {
              for (var e, t = 0, r = le.length; t < r; t++)
                (e = le[t]), Z.contains(e) || (r--, le.splice(t--, 1), m(e, T));
            }
            function b(e) {
              throw new Error("A " + e + " type is already registered");
            }
            function m(e, t) {
              var r,
                n = u(e);
              -1 < n &&
                (N(e, H[n]),
                (n = 0),
                t !== L || e[L]
                  ? t === T && !e[T] && ((e[L] = !1), (e[T] = !0), (n = 1))
                  : ((e[T] = !1),
                    (e[L] = !0),
                    (n = 1),
                    ne && G.call(le, e) < 0 && le.push(e)),
                n && (r = e[t + "Callback"]) && r.call(e));
            }
            if (!(a in r)) {
              var g,
                C,
                A,
                E,
                O,
                N,
                y,
                w = "__" + a + ((1e5 * Math.random()) >> 0),
                L = "attached",
                T = "detached",
                M = "extends",
                F = "ADDITION",
                V = "MODIFICATION",
                I = "REMOVAL",
                D = "DOMAttrModified",
                P = "DOMContentLoaded",
                R = "DOMSubtreeModified",
                _ = "<",
                k = "=",
                q = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
                S = [
                  "ANNOTATION-XML",
                  "COLOR-PROFILE",
                  "FONT-FACE",
                  "FONT-FACE-SRC",
                  "FONT-FACE-URI",
                  "FONT-FACE-FORMAT",
                  "FONT-FACE-NAME",
                  "MISSING-GLYPH",
                ],
                U = [],
                H = [],
                x = "",
                Z = r.documentElement,
                G =
                  U.indexOf ||
                  function (e) {
                    for (var t = this.length; t-- && this[t] !== e; );
                    return t;
                  },
                j = n.prototype,
                z = j.hasOwnProperty,
                K = j.isPrototypeOf,
                W = n.defineProperty,
                X = n.getOwnPropertyDescriptor,
                Y = n.getOwnPropertyNames,
                $ = n.getPrototypeOf,
                B = n.setPrototypeOf,
                J = !!n.__proto__,
                Q =
                  n.create ||
                  function e(t) {
                    return t ? ((e.prototype = t), new e()) : this;
                  },
                ee =
                  B ||
                  (J
                    ? function (e, t) {
                        return (e.__proto__ = t), e;
                      }
                    : Y && X
                    ? (function () {
                        function e(e, t) {
                          for (var r, n = Y(t), a = 0, l = n.length; a < l; a++)
                            (r = n[a]), z.call(e, r) || W(e, r, X(t, r));
                        }
                        return function (t, r) {
                          do {
                            e(t, r);
                          } while ((r = $(r)) && !K.call(r, t));
                          return t;
                        };
                      })()
                    : function (e, t) {
                        for (var r in t) e[r] = t[r];
                        return e;
                      }),
                te = t.MutationObserver || t.WebKitMutationObserver,
                re = (t.HTMLElement || t.Element || t.Node).prototype,
                ne = !K.call(re, Z),
                ae = ne
                  ? function (e) {
                      return 1 === e.nodeType;
                    }
                  : function (e) {
                      return K.call(re, e);
                    },
                le = ne && [],
                ie = re.cloneNode,
                oe = re.getAttribute,
                ue = re.setAttribute,
                ce = re.removeAttribute,
                se = r.createElement,
                de = te && {
                  attributes: !0,
                  characterData: !0,
                  attributeOldValue: !0,
                },
                fe =
                  te ||
                  function (e) {
                    (pe = !1), Z.removeEventListener(D, fe);
                  },
                he =
                  t.requestAnimationFrame ||
                  t.webkitRequestAnimationFrame ||
                  t.mozRequestAnimationFrame ||
                  t.msRequestAnimationFrame ||
                  function (e) {
                    setTimeout(e, 10);
                  },
                ve = !1,
                pe = !0,
                be = !0,
                me = !0;
              B || J
                ? ((N = function (e, t) {
                    K.call(t, e) || v(e, t);
                  }),
                  (y = v))
                : ((N = function (e, t) {
                    e[w] || ((e[w] = n(!0)), v(e, t));
                  }),
                  (y = N)),
                ne
                  ? ((pe = !1),
                    (function () {
                      var t = X(re, "addEventListener"),
                        r = t.value,
                        n = function (e) {
                          var t = new CustomEvent(D, { bubbles: !0 });
                          (t.attrName = e),
                            (t.prevValue = oe.call(this, e)),
                            (t.newValue = null),
                            (t[I] = t.attrChange = 2),
                            ce.call(this, e),
                            this.dispatchEvent(t);
                        },
                        a = function (t, r) {
                          var n = this.hasAttribute(t),
                            a = n && oe.call(this, t);
                          (e = new CustomEvent(D, { bubbles: !0 })),
                            ue.call(this, t, r),
                            (e.attrName = t),
                            (e.prevValue = n ? a : null),
                            (e.newValue = r),
                            n
                              ? (e[V] = e.attrChange = 1)
                              : (e[F] = e.attrChange = 0),
                            this.dispatchEvent(e);
                        },
                        l = function (e) {
                          var t,
                            r = e.currentTarget,
                            n = r[w],
                            a = e.propertyName;
                          n.hasOwnProperty(a) &&
                            ((n = n[a]),
                            (t = new CustomEvent(D, { bubbles: !0 })),
                            (t.attrName = n.name),
                            (t.prevValue = n.value || null),
                            (t.newValue = n.value = r[a] || null),
                            null == t.prevValue
                              ? (t[F] = t.attrChange = 0)
                              : (t[V] = t.attrChange = 1),
                            r.dispatchEvent(t));
                        };
                      (t.value = function (e, t, i) {
                        e === D &&
                          this.attributeChangedCallback &&
                          this.setAttribute !== a &&
                          ((this[w] = {
                            className: { name: "class", value: this.className },
                          }),
                          (this.setAttribute = a),
                          (this.removeAttribute = n),
                          r.call(this, "propertychange", l)),
                          r.call(this, e, t, i);
                      }),
                        W(re, "addEventListener", t);
                    })())
                  : te ||
                    (Z.addEventListener(D, fe),
                    Z.setAttribute(w, 1),
                    Z.removeAttribute(w),
                    pe &&
                      ((C = function (e) {
                        var t,
                          r,
                          n,
                          a = this;
                        if (a === e.target) {
                          (t = a[w]), (a[w] = r = E(a));
                          for (n in r) {
                            if (!(n in t)) return A(0, a, n, t[n], r[n], F);
                            if (r[n] !== t[n]) return A(1, a, n, t[n], r[n], V);
                          }
                          for (n in t)
                            if (!(n in r)) return A(2, a, n, t[n], r[n], I);
                        }
                      }),
                      (A = function (e, t, r, n, a, l) {
                        var i = {
                          attrChange: e,
                          currentTarget: t,
                          attrName: r,
                          prevValue: n,
                          newValue: a,
                        };
                        (i[l] = e), s(i);
                      }),
                      (E = function (e) {
                        for (
                          var t,
                            r,
                            n = {},
                            a = e.attributes,
                            l = 0,
                            i = a.length;
                          l < i;
                          l++
                        )
                          (t = a[l]),
                            "setAttribute" !== (r = t.name) && (n[r] = t.value);
                        return n;
                      }))),
                (r[a] = function (e, t) {
                  if (
                    ((n = e.toUpperCase()),
                    ve ||
                      ((ve = !0),
                      te
                        ? ((O = (function (e, t) {
                            function r(e, t) {
                              for (var r = 0, n = e.length; r < n; t(e[r++]));
                            }
                            return new te(function (n) {
                              for (var a, l, i, o = 0, u = n.length; o < u; o++)
                                (a = n[o]),
                                  "childList" === a.type
                                    ? (r(a.addedNodes, e), r(a.removedNodes, t))
                                    : ((l = a.target),
                                      me &&
                                        l.attributeChangedCallback &&
                                        "style" !== a.attributeName &&
                                        (i = oe.call(l, a.attributeName)) !==
                                          a.oldValue &&
                                        l.attributeChangedCallback(
                                          a.attributeName,
                                          a.oldValue,
                                          i
                                        ));
                            });
                          })(o(L), o(T))),
                          O.observe(r, { childList: !0, subtree: !0 }))
                        : ((g = []),
                          he(function e() {
                            for (; g.length; ) g.shift().call(null, g.shift());
                            he(e);
                          }),
                          r.addEventListener("DOMNodeInserted", d(L)),
                          r.addEventListener("DOMNodeRemoved", d(T))),
                      r.addEventListener(P, f),
                      r.addEventListener("readystatechange", f),
                      (r.createElement = function (e, t) {
                        var n = se.apply(r, arguments),
                          a = "" + e,
                          l = G.call(U, (t ? k : _) + (t || a).toUpperCase()),
                          i = -1 < l;
                        return (
                          t &&
                            (n.setAttribute("is", (t = t.toLowerCase())),
                            i && (i = c(a.toUpperCase(), t))),
                          (me = !r.createElement.innerHTMLHelper),
                          i && y(n, H[l]),
                          n
                        );
                      }),
                      (re.cloneNode = function (e) {
                        var t = ie.call(this, !!e),
                          r = u(t);
                        return (
                          -1 < r && y(t, H[r]), e && i(t.querySelectorAll(x)), t
                        );
                      })),
                    -2 < G.call(U, k + n) + G.call(U, _ + n) && b(e),
                    !q.test(n) || -1 < G.call(S, n))
                  )
                    throw new Error("The type " + e + " is invalid");
                  var n,
                    a,
                    s = function () {
                      return v ? r.createElement(p, n) : r.createElement(p);
                    },
                    h = t || j,
                    v = z.call(h, M),
                    p = v ? t[M].toUpperCase() : n;
                  return (
                    v && -1 < G.call(U, _ + p) && b(p),
                    (a = U.push((v ? k : _) + n) - 1),
                    (x = x.concat(
                      x.length ? "," : "",
                      v ? p + '[is="' + e.toLowerCase() + '"]' : p
                    )),
                    (s.prototype = H[a] =
                      z.call(h, "prototype") ? h.prototype : Q(re)),
                    l(r.querySelectorAll(x), L),
                    s
                  );
                });
            }
          })(window, document, Object, "registerElement");
        },
        {},
      ],
      14: [
        function (_dereq_, module, exports) {
          module.exports = function (r) {
            switch (r) {
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "int32":
                return Int32Array;
              case "uint8":
                return Uint8Array;
              case "uint16":
                return Uint16Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              case "array":
                return Array;
              case "uint8_clamped":
                return Uint8ClampedArray;
            }
          };
        },
        {},
      ],
      15: [
        function (_dereq_, module, exports) {
          function flattenVertexData(e, t, r) {
            if (!e) throw new TypeError("must specify data as first parameter");
            if (
              ((r = 0 | +(r || 0)),
              Array.isArray(e) && e[0] && "number" == typeof e[0][0])
            ) {
              var n,
                a,
                l,
                o,
                f = e[0].length,
                s = e.length * f;
              (t && "string" != typeof t) ||
                (t = new (dtype(t || "float32"))(s + r));
              var i = t.length - r;
              if (s !== i)
                throw new Error(
                  "source length " +
                    s +
                    " (" +
                    f +
                    "x" +
                    e.length +
                    ") does not match destination length " +
                    i
                );
              for (n = 0, l = r; n < e.length; n++)
                for (a = 0; a < f; a++)
                  t[l++] = null === e[n][a] ? NaN : e[n][a];
            } else if (t && "string" != typeof t) t.set(e, r);
            else {
              var y = dtype(t || "float32");
              if (Array.isArray(e) || "array" === t)
                for (
                  t = new y(e.length + r), n = 0, l = r, o = t.length;
                  l < o;
                  l++, n++
                )
                  t[l] = null === e[n] ? NaN : e[n];
              else
                0 === r
                  ? (t = new y(e))
                  : ((t = new y(e.length + r)), t.set(e, r));
            }
            return t;
          }
          var dtype = _dereq_("dtype");
          module.exports = flattenVertexData;
        },
        { dtype: 14 },
      ],
      16: [
        function (_dereq_, module, exports) {
          (function (global) {
            var win;
            (win =
              "undefined" != typeof window
                ? window
                : "undefined" != typeof global
                ? global
                : "undefined" != typeof self
                ? self
                : {}),
              (module.exports = win);
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {},
      ],
      17: [
        function (_dereq_, module, exports) {
          (exports.read = function (a, o, t, r, h) {
            var M,
              p,
              w = 8 * h - r - 1,
              f = (1 << w) - 1,
              e = f >> 1,
              i = -7,
              N = t ? h - 1 : 0,
              n = t ? -1 : 1,
              s = a[o + N];
            for (
              N += n, M = s & ((1 << -i) - 1), s >>= -i, i += w;
              i > 0;
              M = 256 * M + a[o + N], N += n, i -= 8
            );
            for (
              p = M & ((1 << -i) - 1), M >>= -i, i += r;
              i > 0;
              p = 256 * p + a[o + N], N += n, i -= 8
            );
            if (0 === M) M = 1 - e;
            else {
              if (M === f) return p ? NaN : (1 / 0) * (s ? -1 : 1);
              (p += Math.pow(2, r)), (M -= e);
            }
            return (s ? -1 : 1) * p * Math.pow(2, M - r);
          }),
            (exports.write = function (a, o, t, r, h, M) {
              var p,
                w,
                f,
                e = 8 * M - h - 1,
                i = (1 << e) - 1,
                N = i >> 1,
                n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                s = r ? 0 : M - 1,
                u = r ? 1 : -1,
                l = o < 0 || (0 === o && 1 / o < 0) ? 1 : 0;
              for (
                o = Math.abs(o),
                  isNaN(o) || o === 1 / 0
                    ? ((w = isNaN(o) ? 1 : 0), (p = i))
                    : ((p = Math.floor(Math.log(o) / Math.LN2)),
                      o * (f = Math.pow(2, -p)) < 1 && (p--, (f *= 2)),
                      (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)),
                      o * f >= 2 && (p++, (f /= 2)),
                      p + N >= i
                        ? ((w = 0), (p = i))
                        : p + N >= 1
                        ? ((w = (o * f - 1) * Math.pow(2, h)), (p += N))
                        : ((w = o * Math.pow(2, N - 1) * Math.pow(2, h)),
                          (p = 0)));
                h >= 8;
                a[t + s] = 255 & w, s += u, w /= 256, h -= 8
              );
              for (
                p = (p << h) | w, e += h;
                e > 0;
                a[t + s] = 255 & p, s += u, p /= 256, e -= 8
              );
              a[t + s - u] |= 128 * l;
            });
        },
        {},
      ],
      18: [
        function (_dereq_, module, exports) {
          "function" == typeof Object.create
            ? (module.exports = function (t, e) {
                e &&
                  ((t.super_ = e),
                  (t.prototype = Object.create(e.prototype, {
                    constructor: {
                      value: t,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0,
                    },
                  })));
              })
            : (module.exports = function (t, e) {
                if (e) {
                  t.super_ = e;
                  var o = function () {};
                  (o.prototype = e.prototype),
                    (t.prototype = new o()),
                    (t.prototype.constructor = t);
                }
              });
        },
        {},
      ],
      19: [
        function (_dereq_, module, exports) {
          function isBuffer(f) {
            return (
              !!f.constructor &&
              "function" == typeof f.constructor.isBuffer &&
              f.constructor.isBuffer(f)
            );
          }
          function isSlowBuffer(f) {
            return (
              "function" == typeof f.readFloatLE &&
              "function" == typeof f.slice &&
              isBuffer(f.slice(0, 0))
            );
          }
          module.exports = function (f) {
            return (
              null != f && (isBuffer(f) || isSlowBuffer(f) || !!f._isBuffer)
            );
          };
        },
        {},
      ],
      20: [
        function (_dereq_, module, exports) {
          function isFunction(o) {
            var t = toString.call(o);
            return (
              "[object Function]" === t ||
              ("function" == typeof o && "[object RegExp]" !== t) ||
              ("undefined" != typeof window &&
                (o === window.setTimeout ||
                  o === window.alert ||
                  o === window.confirm ||
                  o === window.prompt))
            );
          }
          module.exports = isFunction;
          var toString = Object.prototype.toString;
        },
        {},
      ],
      21: [
        function (_dereq_, module, exports) {
          "use strict";
          module.exports = function (t) {
            var e = typeof t;
            return null !== t && ("object" === e || "function" === e);
          };
        },
        {},
      ],
      22: [
        function (_dereq_, module, exports) {
          function TextLayout(t) {
            (this.glyphs = []),
              (this._measure = this.computeMetrics.bind(this)),
              this.update(t);
          }
          function addGetter(t) {
            Object.defineProperty(TextLayout.prototype, t, {
              get: wrapper(t),
              configurable: !0,
            });
          }
          function wrapper(t) {
            return new Function(
              [
                "return function " + t + "() {",
                "  return this._" + t,
                "}",
              ].join("\n")
            )();
          }
          function getGlyphById(t, e) {
            if (!t.chars || 0 === t.chars.length) return null;
            var r = findChar(t.chars, e);
            return r >= 0 ? t.chars[r] : null;
          }
          function getXHeight(t) {
            for (var e = 0; e < X_HEIGHTS.length; e++) {
              var r = X_HEIGHTS[e].charCodeAt(0),
                n = findChar(t.chars, r);
              if (n >= 0) return t.chars[n].height;
            }
            return 0;
          }
          function getMGlyph(t) {
            for (var e = 0; e < M_WIDTHS.length; e++) {
              var r = M_WIDTHS[e].charCodeAt(0),
                n = findChar(t.chars, r);
              if (n >= 0) return t.chars[n];
            }
            return 0;
          }
          function getCapHeight(t) {
            for (var e = 0; e < CAP_HEIGHTS.length; e++) {
              var r = CAP_HEIGHTS[e].charCodeAt(0),
                n = findChar(t.chars, r);
              if (n >= 0) return t.chars[n].height;
            }
            return 0;
          }
          function getKerning(t, e, r) {
            if (!t.kernings || 0 === t.kernings.length) return 0;
            for (var n = t.kernings, i = 0; i < n.length; i++) {
              var a = n[i];
              if (a.first === e && a.second === r) return a.amount;
            }
            return 0;
          }
          function getAlignType(t) {
            return "center" === t
              ? ALIGN_CENTER
              : "right" === t
              ? ALIGN_RIGHT
              : ALIGN_LEFT;
          }
          function findChar(t, e, r) {
            r = r || 0;
            for (var n = r; n < t.length; n++) if (t[n].id === e) return n;
            return -1;
          }
          var wordWrap = _dereq_("word-wrapper"),
            xtend = _dereq_("xtend"),
            number = _dereq_("as-number"),
            X_HEIGHTS = [
              "x",
              "e",
              "a",
              "o",
              "n",
              "s",
              "r",
              "c",
              "u",
              "m",
              "v",
              "w",
              "z",
            ],
            M_WIDTHS = ["m", "w"],
            CAP_HEIGHTS = [
              "H",
              "I",
              "N",
              "E",
              "F",
              "K",
              "L",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z",
            ],
            TAB_ID = "\t".charCodeAt(0),
            SPACE_ID = " ".charCodeAt(0),
            ALIGN_LEFT = 0,
            ALIGN_CENTER = 1,
            ALIGN_RIGHT = 2;
          (module.exports = function (t) {
            return new TextLayout(t);
          }),
            (TextLayout.prototype.update = function (t) {
              if (
                ((t = xtend({ measure: this._measure }, t)),
                (this._opt = t),
                (this._opt.tabSize = number(this._opt.tabSize, 4)),
                !t.font)
              )
                throw new Error("must provide a valid bitmap font");
              var e = this.glyphs,
                r = t.text || "",
                n = t.font;
              this._setupSpaceGlyphs(n);
              var i = wordWrap.lines(r, t),
                a = t.width || 0;
              e.length = 0;
              var h = i.reduce(function (t, e) {
                  return Math.max(t, e.width, a);
                }, 0),
                o = 0,
                s = 0,
                c = number(t.lineHeight, n.common.lineHeight),
                u = n.common.base,
                l = c - u,
                p = t.letterSpacing || 0,
                f = c * i.length - l,
                d = getAlignType(this._opt.align);
              (s -= f),
                (this._width = h),
                (this._height = f),
                (this._descender = c - u),
                (this._baseline = u),
                (this._xHeight = getXHeight(n)),
                (this._capHeight = getCapHeight(n)),
                (this._lineHeight = c),
                (this._ascender = c - l - this._xHeight);
              var g = this;
              i.forEach(function (t, i) {
                for (
                  var a, u = t.start, l = t.end, f = t.width, _ = u;
                  _ < l;
                  _++
                ) {
                  var y = r.charCodeAt(_),
                    G = g.getGlyph(n, y);
                  if (G) {
                    a && (o += getKerning(n, a.id, G.id));
                    var T = o;
                    d === ALIGN_CENTER
                      ? (T += (h - f) / 2)
                      : d === ALIGN_RIGHT && (T += h - f),
                      e.push({ position: [T, s], data: G, index: _, line: i }),
                      (o += G.xadvance + p),
                      (a = G);
                  }
                }
                (s += c), (o = 0);
              }),
                (this._linesTotal = i.length);
            }),
            (TextLayout.prototype._setupSpaceGlyphs = function (t) {
              if (
                ((this._fallbackSpaceGlyph = null),
                (this._fallbackTabGlyph = null),
                t.chars && 0 !== t.chars.length)
              ) {
                var e = getGlyphById(t, SPACE_ID) || getMGlyph(t) || t.chars[0],
                  r = this._opt.tabSize * e.xadvance;
                (this._fallbackSpaceGlyph = e),
                  (this._fallbackTabGlyph = xtend(e, {
                    x: 0,
                    y: 0,
                    xadvance: r,
                    id: TAB_ID,
                    xoffset: 0,
                    yoffset: 0,
                    width: 0,
                    height: 0,
                  }));
              }
            }),
            (TextLayout.prototype.getGlyph = function (t, e) {
              var r = getGlyphById(t, e);
              return (
                r ||
                (e === TAB_ID
                  ? this._fallbackTabGlyph
                  : e === SPACE_ID
                  ? this._fallbackSpaceGlyph
                  : null)
              );
            }),
            (TextLayout.prototype.computeMetrics = function (t, e, r, n) {
              var i,
                a,
                h = this._opt.letterSpacing || 0,
                o = this._opt.font,
                s = 0,
                c = 0,
                u = 0;
              if (!o.chars || 0 === o.chars.length)
                return { start: e, end: e, width: 0 };
              r = Math.min(t.length, r);
              for (var l = e; l < r; l++) {
                var p = t.charCodeAt(l),
                  i = this.getGlyph(o, p);
                if (i) {
                  i.xoffset;
                  s += a ? getKerning(o, a.id, i.id) : 0;
                  var f = s + i.xadvance + h,
                    d = s + i.width;
                  if (d >= n || f >= n) break;
                  (s = f), (c = d), (a = i);
                }
                u++;
              }
              return a && (c += a.xoffset), { start: e, end: e + u, width: c };
            }),
            [
              "width",
              "height",
              "descender",
              "ascender",
              "xHeight",
              "baseline",
              "capHeight",
              "lineHeight",
            ].forEach(addGetter);
        },
        { "as-number": 3, "word-wrapper": 46, xtend: 49 },
      ],
      23: [
        function (_dereq_, module, exports) {
          (function (Buffer) {
            function isArrayBuffer(r) {
              return (
                "[object ArrayBuffer]" === Object.prototype.toString.call(r)
              );
            }
            function getBinaryOpts(r) {
              if (xml2) return xtend(r, { responseType: "arraybuffer" });
              if (void 0 === self.XMLHttpRequest)
                throw new Error("your browser does not support XHR loading");
              var e = new self.XMLHttpRequest();
              return (
                e.overrideMimeType("text/plain; charset=x-user-defined"),
                xtend({ xhr: e }, r)
              );
            }
            var xhr = _dereq_("xhr"),
              noop = function () {},
              parseASCII = _dereq_("parse-bmfont-ascii"),
              parseXML = _dereq_("parse-bmfont-xml"),
              readBinary = _dereq_("parse-bmfont-binary"),
              isBinaryFormat = _dereq_("./lib/is-binary"),
              xtend = _dereq_("xtend"),
              xml2 = (function () {
                return (
                  self.XMLHttpRequest &&
                  "withCredentials" in new XMLHttpRequest()
                );
              })();
            module.exports = function (r, e) {
              (e = "function" == typeof e ? e : noop),
                "string" == typeof r ? (r = { uri: r }) : r || (r = {}),
                r.binary && (r = getBinaryOpts(r)),
                xhr(r, function (t, n, i) {
                  if (t) return e(t);
                  if (!/^2/.test(n.statusCode))
                    return e(new Error("http status code: " + n.statusCode));
                  if (!i) return e(new Error("no body result"));
                  var o = !1;
                  if (isArrayBuffer(i)) {
                    var a = new Uint8Array(i);
                    i = new Buffer(a, "binary");
                  }
                  isBinaryFormat(i) &&
                    ((o = !0),
                    "string" == typeof i && (i = new Buffer(i, "binary"))),
                    o ||
                      (Buffer.isBuffer(i) && (i = i.toString(r.encoding)),
                      (i = i.trim()));
                  var s;
                  try {
                    var u = n.headers["content-type"];
                    s = o
                      ? readBinary(i)
                      : /json/.test(u) || "{" === i.charAt(0)
                      ? JSON.parse(i)
                      : /xml/.test(u) || "<" === i.charAt(0)
                      ? parseXML(i)
                      : parseASCII(i);
                  } catch (r) {
                    e(new Error("error parsing font " + r.message)), (e = noop);
                  }
                  e(null, s);
                });
            };
          }.call(this, _dereq_("buffer").Buffer));
        },
        {
          "./lib/is-binary": 24,
          buffer: 8,
          "parse-bmfont-ascii": 26,
          "parse-bmfont-binary": 27,
          "parse-bmfont-xml": 28,
          xhr: 47,
          xtend: 49,
        },
      ],
      24: [
        function (_dereq_, module, exports) {
          (function (Buffer) {
            var equal = _dereq_("buffer-equal"),
              HEADER = new Buffer([66, 77, 70, 3]);
            module.exports = function (e) {
              return "string" == typeof e
                ? "BMF" === e.substring(0, 3)
                : e.length > 4 && equal(e.slice(0, 4), HEADER);
            };
          }.call(this, _dereq_("buffer").Buffer));
        },
        { buffer: 8, "buffer-equal": 7 },
      ],
      25: [
        function (_dereq_, module, exports) {
          "use strict";
          function toObject(e) {
            if (null === e || void 0 === e)
              throw new TypeError(
                "Object.assign cannot be called with null or undefined"
              );
            return Object(e);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) return !1;
              var e = new String("abc");
              if (((e[5] = "de"), "5" === Object.getOwnPropertyNames(e)[0]))
                return !1;
              for (var r = {}, t = 0; t < 10; t++)
                r["_" + String.fromCharCode(t)] = t;
              if (
                "0123456789" !==
                Object.getOwnPropertyNames(r)
                  .map(function (e) {
                    return r[e];
                  })
                  .join("")
              )
                return !1;
              var n = {};
              return (
                "abcdefghijklmnopqrst".split("").forEach(function (e) {
                  n[e] = e;
                }),
                "abcdefghijklmnopqrst" ===
                  Object.keys(Object.assign({}, n)).join("")
              );
            } catch (e) {
              return !1;
            }
          }
          var getOwnPropertySymbols = Object.getOwnPropertySymbols,
            hasOwnProperty = Object.prototype.hasOwnProperty,
            propIsEnumerable = Object.prototype.propertyIsEnumerable;
          module.exports = shouldUseNative()
            ? Object.assign
            : function (e, r) {
                for (
                  var t, n, o = toObject(e), a = 1;
                  a < arguments.length;
                  a++
                ) {
                  t = Object(arguments[a]);
                  for (var s in t) hasOwnProperty.call(t, s) && (o[s] = t[s]);
                  if (getOwnPropertySymbols) {
                    n = getOwnPropertySymbols(t);
                    for (var c = 0; c < n.length; c++)
                      propIsEnumerable.call(t, n[c]) && (o[n[c]] = t[n[c]]);
                  }
                }
                return o;
              };
        },
        {},
      ],
      26: [
        function (_dereq_, module, exports) {
          function splitLine(e, r) {
            if (!(e = e.replace(/\t+/g, " ").trim())) return null;
            var t = e.indexOf(" ");
            if (-1 === t) throw new Error("no named row at line " + r);
            var a = e.substring(0, t);
            (e = e.substring(t + 1)),
              (e = e.replace(/letter=[\'\"]\S+[\'\"]/gi, "")),
              (e = e.split("=")),
              (e = e.map(function (e) {
                return e.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
              }));
            for (var n = [], i = 0; i < e.length; i++) {
              var s = e[i];
              0 === i
                ? n.push({ key: s[0], data: "" })
                : i === e.length - 1
                ? (n[n.length - 1].data = parseData(s[0]))
                : ((n[n.length - 1].data = parseData(s[0])),
                  n.push({ key: s[1], data: "" }));
            }
            var o = { key: a, data: {} };
            return (
              n.forEach(function (e) {
                o.data[e.key] = e.data;
              }),
              o
            );
          }
          function parseData(e) {
            return e && 0 !== e.length
              ? 0 === e.indexOf('"') || 0 === e.indexOf("'")
                ? e.substring(1, e.length - 1)
                : -1 !== e.indexOf(",")
                ? parseIntList(e)
                : parseInt(e, 10)
              : "";
          }
          function parseIntList(e) {
            return e.split(",").map(function (e) {
              return parseInt(e, 10);
            });
          }
          module.exports = function (e) {
            if (!e) throw new Error("no data provided");
            e = e.toString().trim();
            var r = { pages: [], chars: [], kernings: [] },
              t = e.split(/\r\n?|\n/g);
            if (0 === t.length) throw new Error("no data in BMFont file");
            for (var a = 0; a < t.length; a++) {
              var n = splitLine(t[a], a);
              if (n)
                if ("page" === n.key) {
                  if ("number" != typeof n.data.id)
                    throw new Error(
                      "malformed file at line " + a + " -- needs page id=N"
                    );
                  if ("string" != typeof n.data.file)
                    throw new Error(
                      "malformed file at line " +
                        a +
                        ' -- needs page file="path"'
                    );
                  r.pages[n.data.id] = n.data.file;
                } else
                  "chars" === n.key ||
                    "kernings" === n.key ||
                    ("char" === n.key
                      ? r.chars.push(n.data)
                      : "kerning" === n.key
                      ? r.kernings.push(n.data)
                      : (r[n.key] = n.data));
            }
            return r;
          };
        },
        {},
      ],
      27: [
        function (_dereq_, module, exports) {
          function readBlock(r, e, n) {
            if (n > e.length - 1) return 0;
            var a = e.readUInt8(n++),
              t = e.readInt32LE(n);
            switch (((n += 4), a)) {
              case 1:
                r.info = readInfo(e, n);
                break;
              case 2:
                r.common = readCommon(e, n);
                break;
              case 3:
                r.pages = readPages(e, n, t);
                break;
              case 4:
                r.chars = readChars(e, n, t);
                break;
              case 5:
                r.kernings = readKernings(e, n, t);
            }
            return 5 + t;
          }
          function readInfo(r, e) {
            var n = {};
            n.size = r.readInt16LE(e);
            var a = r.readUInt8(e + 2);
            return (
              (n.smooth = (a >> 7) & 1),
              (n.unicode = (a >> 6) & 1),
              (n.italic = (a >> 5) & 1),
              (n.bold = (a >> 4) & 1),
              (a >> 3) & 1 && (n.fixedHeight = 1),
              (n.charset = r.readUInt8(e + 3) || ""),
              (n.stretchH = r.readUInt16LE(e + 4)),
              (n.aa = r.readUInt8(e + 6)),
              (n.padding = [
                r.readInt8(e + 7),
                r.readInt8(e + 8),
                r.readInt8(e + 9),
                r.readInt8(e + 10),
              ]),
              (n.spacing = [r.readInt8(e + 11), r.readInt8(e + 12)]),
              (n.outline = r.readUInt8(e + 13)),
              (n.face = readStringNT(r, e + 14)),
              n
            );
          }
          function readCommon(r, e) {
            var n = {};
            (n.lineHeight = r.readUInt16LE(e)),
              (n.base = r.readUInt16LE(e + 2)),
              (n.scaleW = r.readUInt16LE(e + 4)),
              (n.scaleH = r.readUInt16LE(e + 6)),
              (n.pages = r.readUInt16LE(e + 8));
            r.readUInt8(e + 10);
            return (
              (n.packed = 0),
              (n.alphaChnl = r.readUInt8(e + 11)),
              (n.redChnl = r.readUInt8(e + 12)),
              (n.greenChnl = r.readUInt8(e + 13)),
              (n.blueChnl = r.readUInt8(e + 14)),
              n
            );
          }
          function readPages(r, e, n) {
            for (
              var a = [],
                t = readNameNT(r, e),
                d = t.length + 1,
                o = n / d,
                i = 0;
              i < o;
              i++
            )
              (a[i] = r.slice(e, e + t.length).toString("utf8")), (e += d);
            return a;
          }
          function readChars(r, e, n) {
            for (var a = [], t = n / 20, d = 0; d < t; d++) {
              var o = {},
                i = 20 * d;
              (o.id = r.readUInt32LE(e + 0 + i)),
                (o.x = r.readUInt16LE(e + 4 + i)),
                (o.y = r.readUInt16LE(e + 6 + i)),
                (o.width = r.readUInt16LE(e + 8 + i)),
                (o.height = r.readUInt16LE(e + 10 + i)),
                (o.xoffset = r.readInt16LE(e + 12 + i)),
                (o.yoffset = r.readInt16LE(e + 14 + i)),
                (o.xadvance = r.readInt16LE(e + 16 + i)),
                (o.page = r.readUInt8(e + 18 + i)),
                (o.chnl = r.readUInt8(e + 19 + i)),
                (a[d] = o);
            }
            return a;
          }
          function readKernings(r, e, n) {
            for (var a = [], t = n / 10, d = 0; d < t; d++) {
              var o = {},
                i = 10 * d;
              (o.first = r.readUInt32LE(e + 0 + i)),
                (o.second = r.readUInt32LE(e + 4 + i)),
                (o.amount = r.readInt16LE(e + 8 + i)),
                (a[d] = o);
            }
            return a;
          }
          function readNameNT(r, e) {
            for (var n = e; n < r.length && 0 !== r[n]; n++);
            return r.slice(e, n);
          }
          function readStringNT(r, e) {
            return readNameNT(r, e).toString("utf8");
          }
          var HEADER = [66, 77, 70];
          module.exports = function (r) {
            if (r.length < 6)
              throw new Error("invalid buffer length for BMFont");
            if (
              !HEADER.every(function (e, n) {
                return r.readUInt8(n) === e;
              })
            )
              throw new Error("BMFont missing BMF byte header");
            var e = 3;
            if (r.readUInt8(e++) > 3)
              throw new Error(
                "Only supports BMFont Binary v3 (BMFont App v1.10)"
              );
            for (var n = { kernings: [], chars: [] }, a = 0; a < 5; a++)
              e += readBlock(n, r, e);
            return n;
          };
        },
        {},
      ],
      28: [
        function (_dereq_, module, exports) {
          function getAttribs(e) {
            return getAttribList(e).reduce(function (e, t) {
              return (e[mapName(t.nodeName)] = t.nodeValue), e;
            }, {});
          }
          function getAttribList(e) {
            for (var t = [], r = 0; r < e.attributes.length; r++)
              t.push(e.attributes[r]);
            return t;
          }
          function mapName(e) {
            return NAME_MAP[e.toLowerCase()] || e;
          }
          var parseAttributes = _dereq_("./parse-attribs"),
            parseFromString = _dereq_("xml-parse-from-string"),
            NAME_MAP = {
              scaleh: "scaleH",
              scalew: "scaleW",
              stretchh: "stretchH",
              lineheight: "lineHeight",
              alphachnl: "alphaChnl",
              redchnl: "redChnl",
              greenchnl: "greenChnl",
              bluechnl: "blueChnl",
            };
          module.exports = function (e) {
            e = e.toString();
            var t = parseFromString(e),
              r = { pages: [], chars: [], kernings: [] };
            ["info", "common"].forEach(function (e) {
              var a = t.getElementsByTagName(e)[0];
              a && (r[e] = parseAttributes(getAttribs(a)));
            });
            var a = t.getElementsByTagName("pages")[0];
            if (!a) throw new Error("malformed file -- no <pages> element");
            for (
              var n = a.getElementsByTagName("page"), i = 0;
              i < n.length;
              i++
            ) {
              var s = n[i],
                g = parseInt(s.getAttribute("id"), 10),
                l = s.getAttribute("file");
              if (isNaN(g))
                throw new Error('malformed file -- page "id" attribute is NaN');
              if (!l)
                throw new Error(
                  'malformed file -- needs page "file" attribute'
                );
              r.pages[parseInt(g, 10)] = l;
            }
            return (
              ["chars", "kernings"].forEach(function (e) {
                var a = t.getElementsByTagName(e)[0];
                if (a)
                  for (
                    var n = e.substring(0, e.length - 1),
                      i = a.getElementsByTagName(n),
                      s = 0;
                    s < i.length;
                    s++
                  ) {
                    var g = i[s];
                    r[e].push(parseAttributes(getAttribs(g)));
                  }
              }),
              r
            );
          };
        },
        { "./parse-attribs": 29, "xml-parse-from-string": 48 },
      ],
      29: [
        function (_dereq_, module, exports) {
          function parseIntList(t) {
            return t.split(",").map(function (t) {
              return parseInt(t, 10);
            });
          }
          var GLYPH_DESIGNER_ERROR = "chasrset";
          module.exports = function (t) {
            GLYPH_DESIGNER_ERROR in t &&
              ((t.charset = t[GLYPH_DESIGNER_ERROR]),
              delete t[GLYPH_DESIGNER_ERROR]);
            for (var n in t)
              "face" !== n &&
                "charset" !== n &&
                (t[n] =
                  "padding" === n || "spacing" === n
                    ? parseIntList(t[n])
                    : parseInt(t[n], 10));
            return t;
          };
        },
        {},
      ],
      30: [
        function (_dereq_, module, exports) {
          var trim = function (r) {
              return r.replace(/^\s+|\s+$/g, "");
            },
            isArray = function (r) {
              return "[object Array]" === Object.prototype.toString.call(r);
            };
          module.exports = function (r) {
            if (!r) return {};
            for (
              var t = {}, e = trim(r).split("\n"), i = 0;
              i < e.length;
              i++
            ) {
              var n = e[i],
                o = n.indexOf(":"),
                s = trim(n.slice(0, o)).toLowerCase(),
                a = trim(n.slice(o + 1));
              void 0 === t[s]
                ? (t[s] = a)
                : isArray(t[s])
                ? t[s].push(a)
                : (t[s] = [t[s], a]);
            }
            return t;
          };
        },
        {},
      ],
      31: [
        function (_dereq_, module, exports) {
          (function (global) {
            var performance = global.performance || {},
              present = (function () {
                for (
                  var e = ["now", "webkitNow", "msNow", "mozNow", "oNow"];
                  e.length;

                ) {
                  var n = e.shift();
                  if (n in performance) return performance[n].bind(performance);
                }
                var r =
                    Date.now ||
                    function () {
                      return new Date().getTime();
                    },
                  o = (performance.timing || {}).navigationStart || r();
                return function () {
                  return r() - o;
                };
              })();
            (present.performanceNow = performance.now),
              (present.noConflict = function () {
                performance.now = present.performanceNow;
              }),
              (present.conflict = function () {
                performance.now = present;
              }),
              present.conflict(),
              (module.exports = present);
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {},
      ],
      32: [
        function (_dereq_, module, exports) {
          (function (setImmediate) {
            !(function (t) {
              function e(t, e) {
                return function () {
                  t.apply(e, arguments);
                };
              }
              function n(t) {
                if ("object" != typeof this)
                  throw new TypeError("Promises must be constructed via new");
                if ("function" != typeof t)
                  throw new TypeError("not a function");
                (this._state = null),
                  (this._value = null),
                  (this._deferreds = []),
                  f(t, e(r, this), e(i, this));
              }
              function o(t) {
                var e = this;
                if (null === this._state) return void this._deferreds.push(t);
                l(function () {
                  var n = e._state ? t.onFulfilled : t.onRejected;
                  if (null === n)
                    return void (e._state ? t.resolve : t.reject)(e._value);
                  var o;
                  try {
                    o = n(e._value);
                  } catch (e) {
                    return void t.reject(e);
                  }
                  t.resolve(o);
                });
              }
              function r(t) {
                try {
                  if (t === this)
                    throw new TypeError(
                      "A promise cannot be resolved with itself."
                    );
                  if (t && ("object" == typeof t || "function" == typeof t)) {
                    var n = t.then;
                    if ("function" == typeof n)
                      return void f(e(n, t), e(r, this), e(i, this));
                  }
                  (this._state = !0), (this._value = t), u.call(this);
                } catch (t) {
                  i.call(this, t);
                }
              }
              function i(t) {
                (this._state = !1), (this._value = t), u.call(this);
              }
              function u() {
                for (var t = 0, e = this._deferreds.length; t < e; t++)
                  o.call(this, this._deferreds[t]);
                this._deferreds = null;
              }
              function c(t, e, n, o) {
                (this.onFulfilled = "function" == typeof t ? t : null),
                  (this.onRejected = "function" == typeof e ? e : null),
                  (this.resolve = n),
                  (this.reject = o);
              }
              function f(t, e, n) {
                var o = !1;
                try {
                  t(
                    function (t) {
                      o || ((o = !0), e(t));
                    },
                    function (t) {
                      o || ((o = !0), n(t));
                    }
                  );
                } catch (t) {
                  if (o) return;
                  (o = !0), n(t);
                }
              }
              var s = setTimeout,
                l =
                  ("function" == typeof setImmediate && setImmediate) ||
                  function (t) {
                    s(t, 1);
                  },
                h =
                  Array.isArray ||
                  function (t) {
                    return (
                      "[object Array]" === Object.prototype.toString.call(t)
                    );
                  };
              (n.prototype.catch = function (t) {
                return this.then(null, t);
              }),
                (n.prototype.then = function (t, e) {
                  var r = this;
                  return new n(function (n, i) {
                    o.call(r, new c(t, e, n, i));
                  });
                }),
                (n.all = function () {
                  var t = Array.prototype.slice.call(
                    1 === arguments.length && h(arguments[0])
                      ? arguments[0]
                      : arguments
                  );
                  return new n(function (e, n) {
                    function o(i, u) {
                      try {
                        if (
                          u &&
                          ("object" == typeof u || "function" == typeof u)
                        ) {
                          var c = u.then;
                          if ("function" == typeof c)
                            return void c.call(
                              u,
                              function (t) {
                                o(i, t);
                              },
                              n
                            );
                        }
                        (t[i] = u), 0 == --r && e(t);
                      } catch (t) {
                        n(t);
                      }
                    }
                    if (0 === t.length) return e([]);
                    for (var r = t.length, i = 0; i < t.length; i++) o(i, t[i]);
                  });
                }),
                (n.resolve = function (t) {
                  return t && "object" == typeof t && t.constructor === n
                    ? t
                    : new n(function (e) {
                        e(t);
                      });
                }),
                (n.reject = function (t) {
                  return new n(function (e, n) {
                    n(t);
                  });
                }),
                (n.race = function (t) {
                  return new n(function (e, n) {
                    for (var o = 0, r = t.length; o < r; o++) t[o].then(e, n);
                  });
                }),
                (n._setImmediateFn = function (t) {
                  l = t;
                }),
                "undefined" != typeof module && module.exports
                  ? (module.exports = n)
                  : t.Promise || (t.Promise = n);
            })(this);
          }.call(this, _dereq_("timers").setImmediate));
        },
        { timers: 44 },
      ],
      33: [
        function (_dereq_, module, exports) {
          var dtype = _dereq_("dtype"),
            anArray = _dereq_("an-array"),
            isBuffer = _dereq_("is-buffer"),
            CW = [0, 2, 3],
            CCW = [2, 1, 3];
          module.exports = function (r, e) {
            (r && (anArray(r) || isBuffer(r))) || ((e = r || {}), (r = null)),
              (e = "number" == typeof e ? { count: e } : e || {});
            for (
              var t = "string" == typeof e.type ? e.type : "uint16",
                u = "number" == typeof e.count ? e.count : 1,
                n = e.start || 0,
                a = !1 !== e.clockwise ? CW : CCW,
                f = a[0],
                o = a[1],
                y = a[2],
                i = 6 * u,
                p = r || new (dtype(t))(i),
                s = 0,
                c = 0;
              s < i;
              s += 6, c += 4
            ) {
              var C = s + n;
              (p[C + 0] = c + 0),
                (p[C + 1] = c + 1),
                (p[C + 2] = c + 2),
                (p[C + 3] = c + f),
                (p[C + 4] = c + o),
                (p[C + 5] = c + y);
            }
            return p;
          };
        },
        { "an-array": 1, dtype: 14, "is-buffer": 19 },
      ],
      34: [
        function (_dereq_, module, exports) {
          function TextGeometry(e) {
            Base.call(this),
              "string" == typeof e && (e = { text: e }),
              (this._opt = assign({}, e)),
              e && this.update(e);
          }
          var createLayout = _dereq_("layout-bmfont-text"),
            inherits = _dereq_("inherits"),
            createIndices = _dereq_("quad-indices"),
            buffer = _dereq_("three-buffer-vertex-data"),
            assign = _dereq_("object-assign"),
            vertices = _dereq_("./lib/vertices"),
            utils = _dereq_("./lib/utils"),
            Base = THREE.BufferGeometry;
          (module.exports = function (e) {
            return new TextGeometry(e);
          }),
            inherits(TextGeometry, Base),
            (TextGeometry.prototype.update = function (e) {
              if (
                ("string" == typeof e && (e = { text: e }),
                (e = assign({}, this._opt, e)),
                !e.font)
              )
                throw new TypeError("must specify a { font } in options");
              this.layout = createLayout(e);
              var t = !1 !== e.flipY,
                i = e.font,
                r = i.common.scaleW,
                o = i.common.scaleH,
                s = this.layout.glyphs.filter(function (e) {
                  var t = e.data;
                  return t.width * t.height > 0;
                });
              this.visibleGlyphs = s;
              var n = vertices.positions(s),
                u = vertices.uvs(s, r, o, t),
                a = createIndices({
                  clockwise: !0,
                  type: "uint16",
                  count: s.length,
                });
              if (
                (buffer.index(this, a, 1, "uint16"),
                buffer.attr(this, "position", n, 2),
                buffer.attr(this, "uv", u, 2),
                !e.multipage && "page" in this.attributes)
              )
                this.removeAttribute("page");
              else if (e.multipage) {
                var h = vertices.pages(s);
                buffer.attr(this, "page", h, 1);
              }
            }),
            (TextGeometry.prototype.computeBoundingSphere = function () {
              null === this.boundingSphere &&
                (this.boundingSphere = new THREE.Sphere());
              var e = this.attributes.position.array,
                t = this.attributes.position.itemSize;
              if (!e || !t || e.length < 2)
                return (
                  (this.boundingSphere.radius = 0),
                  void this.boundingSphere.center.set(0, 0, 0)
                );
              utils.computeSphere(e, this.boundingSphere),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.'
                  );
            }),
            (TextGeometry.prototype.computeBoundingBox = function () {
              null === this.boundingBox &&
                (this.boundingBox = new THREE.Box3());
              var e = this.boundingBox,
                t = this.attributes.position.array,
                i = this.attributes.position.itemSize;
              if (!t || !i || t.length < 2) return void e.makeEmpty();
              utils.computeBox(t, e);
            });
        },
        {
          "./lib/utils": 35,
          "./lib/vertices": 36,
          inherits: 18,
          "layout-bmfont-text": 22,
          "object-assign": 25,
          "quad-indices": 33,
          "three-buffer-vertex-data": 37,
        },
      ],
      35: [
        function (_dereq_, module, exports) {
          function bounds(x) {
            var m = x.length / itemSize;
            (box.min[0] = x[0]),
              (box.min[1] = x[1]),
              (box.max[0] = x[0]),
              (box.max[1] = x[1]);
            for (var o = 0; o < m; o++) {
              var i = x[o * itemSize + 0],
                a = x[o * itemSize + 1];
              (box.min[0] = Math.min(i, box.min[0])),
                (box.min[1] = Math.min(a, box.min[1])),
                (box.max[0] = Math.max(i, box.max[0])),
                (box.max[1] = Math.max(a, box.max[1]));
            }
          }
          var itemSize = 2,
            box = { min: [0, 0], max: [0, 0] };
          (module.exports.computeBox = function (x, m) {
            bounds(x),
              m.min.set(box.min[0], box.min[1], 0),
              m.max.set(box.max[0], box.max[1], 0);
          }),
            (module.exports.computeSphere = function (x, m) {
              bounds(x);
              var o = box.min[0],
                i = box.min[1],
                a = box.max[0],
                n = box.max[1],
                b = a - o,
                e = n - i,
                t = Math.sqrt(b * b + e * e);
              m.center.set(o + b / 2, i + e / 2, 0), (m.radius = t / 2);
            });
        },
        {},
      ],
      36: [
        function (_dereq_, module, exports) {
          (module.exports.pages = function (t) {
            var o = new Float32Array(4 * t.length * 1),
              n = 0;
            return (
              t.forEach(function (t) {
                var r = t.data.page || 0;
                (o[n++] = r), (o[n++] = r), (o[n++] = r), (o[n++] = r);
              }),
              o
            );
          }),
            (module.exports.uvs = function (t, o, n, r) {
              var a = new Float32Array(4 * t.length * 2),
                e = 0;
              return (
                t.forEach(function (t) {
                  var i = t.data,
                    f = i.x + i.width,
                    u = i.y + i.height,
                    h = i.x / o,
                    s = i.y / n,
                    c = f / o,
                    l = u / n;
                  r && ((s = (n - i.y) / n), (l = (n - u) / n)),
                    (a[e++] = h),
                    (a[e++] = s),
                    (a[e++] = h),
                    (a[e++] = l),
                    (a[e++] = c),
                    (a[e++] = l),
                    (a[e++] = c),
                    (a[e++] = s);
                }),
                a
              );
            }),
            (module.exports.positions = function (t) {
              var o = new Float32Array(4 * t.length * 2),
                n = 0;
              return (
                t.forEach(function (t) {
                  var r = t.data,
                    a = t.position[0] + r.xoffset,
                    e = t.position[1] + r.yoffset,
                    i = r.width,
                    f = r.height;
                  (o[n++] = a),
                    (o[n++] = e),
                    (o[n++] = a),
                    (o[n++] = e + f),
                    (o[n++] = a + i),
                    (o[n++] = e + f),
                    (o[n++] = a + i),
                    (o[n++] = e);
                }),
                o
              );
            });
        },
        {},
      ],
      37: [
        function (_dereq_, module, exports) {
          function setIndex(e, t, r, n) {
            "number" != typeof r && (r = 1),
              "string" != typeof n && (n = "uint16");
            var i = !e.index && "function" != typeof e.setIndex,
              a = i ? e.getAttribute("index") : e.index,
              u = updateAttribute(a, t, r, n);
            u && (i ? e.addAttribute("index", u) : (e.index = u));
          }
          function setAttribute(e, t, r, n, i) {
            if (
              ("number" != typeof n && (n = 3),
              "string" != typeof i && (i = "float32"),
              Array.isArray(r) && Array.isArray(r[0]) && r[0].length !== n)
            )
              throw new Error(
                "Nested vertex array has unexpected size; expected " +
                  n +
                  " but found " +
                  r[0].length
              );
            var a = e.getAttribute(t),
              u = updateAttribute(a, r, n, i);
            u && e.addAttribute(t, u);
          }
          function updateAttribute(e, t, r, n) {
            if (((t = t || []), !e || rebuildAttribute(e, t, r))) {
              t = flatten(t, n);
              var i = e && "function" != typeof e.setArray;
              return (
                (e && !i) ||
                  (i &&
                    !warned &&
                    ((warned = !0),
                    console.warn(
                      [
                        "A WebGL buffer is being updated with a new size or itemSize, ",
                        "however this version of ThreeJS only supports fixed-size buffers.",
                        "\nThe old buffer may still be kept in memory.\n",
                        "To avoid memory leaks, it is recommended that you dispose ",
                        "your geometries and create new ones, or update to ThreeJS r82 or newer.\n",
                        "See here for discussion:\n",
                        "https://github.com/mrdoob/three.js/pull/9631",
                      ].join("")
                    )),
                  (e = new THREE.BufferAttribute(t, r))),
                (e.itemSize = r),
                (e.needsUpdate = !0),
                "function" == typeof e.setArray && e.setArray(t),
                e
              );
            }
            return flatten(t, e.array), (e.needsUpdate = !0), null;
          }
          function rebuildAttribute(e, t, r) {
            if (e.itemSize !== r) return !0;
            if (!e.array) return !0;
            var n = e.array.length;
            return Array.isArray(t) && Array.isArray(t[0])
              ? n !== t.length * r
              : n !== t.length;
          }
          var flatten = _dereq_("flatten-vertex-data"),
            warned = !1;
          (module.exports.attr = setAttribute),
            (module.exports.index = setIndex);
        },
        { "flatten-vertex-data": 15 },
      ],
      38: [
        function (_dereq_, module, exports) {
          !(function (t, e) {
            "object" == typeof exports && "undefined" != typeof module
              ? e(exports)
              : "function" == typeof define && define.amd
              ? define(["exports"], e)
              : e((t.THREE = {}));
          })(this, function (t) {
            "use strict";
            function e() {}
            function n(t, e) {
              (this.x = t || 0), (this.y = e || 0);
            }
            function r() {
              (this.elements = [
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]),
                arguments.length > 0 &&
                  console.error(
                    "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                  );
            }
            function i(t, e, n, r) {
              (this._x = t || 0),
                (this._y = e || 0),
                (this._z = n || 0),
                (this._w = void 0 !== r ? r : 1);
            }
            function a(t, e, n) {
              (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
            }
            function o() {
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                arguments.length > 0 &&
                  console.error(
                    "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                  );
            }
            function s(t, e, r, i, a, c, h, l, u, p) {
              Object.defineProperty(this, "id", { value: _c++ }),
                (this.uuid = xc.generateUUID()),
                (this.name = ""),
                (this.image = void 0 !== t ? t : s.DEFAULT_IMAGE),
                (this.mipmaps = []),
                (this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING),
                (this.wrapS = void 0 !== r ? r : os),
                (this.wrapT = void 0 !== i ? i : os),
                (this.magFilter = void 0 !== a ? a : us),
                (this.minFilter = void 0 !== c ? c : ds),
                (this.anisotropy = void 0 !== u ? u : 1),
                (this.format = void 0 !== h ? h : Ls),
                (this.type = void 0 !== l ? l : fs),
                (this.offset = new n(0, 0)),
                (this.repeat = new n(1, 1)),
                (this.center = new n(0, 0)),
                (this.rotation = 0),
                (this.matrixAutoUpdate = !0),
                (this.matrix = new o()),
                (this.generateMipmaps = !0),
                (this.premultiplyAlpha = !1),
                (this.flipY = !0),
                (this.unpackAlignment = 4),
                (this.encoding = void 0 !== p ? p : cc),
                (this.version = 0),
                (this.onUpdate = null);
            }
            function c(t, e, n, r) {
              (this.x = t || 0),
                (this.y = e || 0),
                (this.z = n || 0),
                (this.w = void 0 !== r ? r : 1);
            }
            function h(t, e, n) {
              (this.width = t),
                (this.height = e),
                (this.scissor = new c(0, 0, t, e)),
                (this.scissorTest = !1),
                (this.viewport = new c(0, 0, t, e)),
                (n = n || {}),
                void 0 === n.minFilter && (n.minFilter = us),
                (this.texture = new s(
                  void 0,
                  void 0,
                  n.wrapS,
                  n.wrapT,
                  n.magFilter,
                  n.minFilter,
                  n.format,
                  n.type,
                  n.anisotropy,
                  n.encoding
                )),
                (this.texture.generateMipmaps =
                  void 0 === n.generateMipmaps || n.generateMipmaps),
                (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
                (this.stencilBuffer =
                  void 0 === n.stencilBuffer || n.stencilBuffer),
                (this.depthTexture =
                  void 0 !== n.depthTexture ? n.depthTexture : null);
            }
            function l(t, e, n) {
              h.call(this, t, e, n),
                (this.activeCubeFace = 0),
                (this.activeMipMapLevel = 0);
            }
            function u(t, e, n, r, i, a, o, c, h, l, u, p) {
              s.call(this, null, a, o, c, h, l, r, i, u, p),
                (this.image = { data: t, width: e, height: n }),
                (this.magFilter = void 0 !== h ? h : cs),
                (this.minFilter = void 0 !== l ? l : cs),
                (this.generateMipmaps = !1),
                (this.flipY = !1),
                (this.unpackAlignment = 1);
            }
            function p(t, e) {
              (this.min = void 0 !== t ? t : new a(1 / 0, 1 / 0, 1 / 0)),
                (this.max = void 0 !== e ? e : new a(-1 / 0, -1 / 0, -1 / 0));
            }
            function d(t, e) {
              (this.center = void 0 !== t ? t : new a()),
                (this.radius = void 0 !== e ? e : 0);
            }
            function f(t, e) {
              (this.normal = void 0 !== t ? t : new a(1, 0, 0)),
                (this.constant = void 0 !== e ? e : 0);
            }
            function m(t, e, n, r, i, a) {
              this.planes = [
                void 0 !== t ? t : new f(),
                void 0 !== e ? e : new f(),
                void 0 !== n ? n : new f(),
                void 0 !== r ? r : new f(),
                void 0 !== i ? i : new f(),
                void 0 !== a ? a : new f(),
              ];
            }
            function g(t, e, n) {
              return void 0 === e && void 0 === n
                ? this.set(t)
                : this.setRGB(t, e, n);
            }
            function v() {
              function t(i, a) {
                !1 !== n && (r(i, a), e.requestAnimationFrame(t));
              }
              var e = null,
                n = !1,
                r = null;
              return {
                start: function () {
                  !0 !== n &&
                    null !== r &&
                    (e.requestAnimationFrame(t), (n = !0));
                },
                stop: function () {
                  n = !1;
                },
                setAnimationLoop: function (t) {
                  r = t;
                },
                setContext: function (t) {
                  e = t;
                },
              };
            }
            function y(t) {
              function e(e, n) {
                var r = e.array,
                  i = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                  a = t.createBuffer();
                t.bindBuffer(n, a), t.bufferData(n, r, i), e.onUploadCallback();
                var o = t.FLOAT;
                return (
                  r instanceof Float32Array
                    ? (o = t.FLOAT)
                    : r instanceof Float64Array
                    ? console.warn(
                        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                      )
                    : r instanceof Uint16Array
                    ? (o = t.UNSIGNED_SHORT)
                    : r instanceof Int16Array
                    ? (o = t.SHORT)
                    : r instanceof Uint32Array
                    ? (o = t.UNSIGNED_INT)
                    : r instanceof Int32Array
                    ? (o = t.INT)
                    : r instanceof Int8Array
                    ? (o = t.BYTE)
                    : r instanceof Uint8Array && (o = t.UNSIGNED_BYTE),
                  {
                    buffer: a,
                    type: o,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: e.version,
                  }
                );
              }
              function n(e, n, r) {
                var i = n.array,
                  a = n.updateRange;
                t.bindBuffer(r, e),
                  !1 === n.dynamic
                    ? t.bufferData(r, i, t.STATIC_DRAW)
                    : -1 === a.count
                    ? t.bufferSubData(r, 0, i)
                    : 0 === a.count
                    ? console.error(
                        "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                      )
                    : (t.bufferSubData(
                        r,
                        a.offset * i.BYTES_PER_ELEMENT,
                        i.subarray(a.offset, a.offset + a.count)
                      ),
                      (a.count = -1));
              }
              function r(t) {
                return t.isInterleavedBufferAttribute && (t = t.data), o.get(t);
              }
              function i(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n = o.get(e);
                n && (t.deleteBuffer(n.buffer), o.delete(e));
              }
              function a(t, r) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var i = o.get(t);
                void 0 === i
                  ? o.set(t, e(t, r))
                  : i.version < t.version &&
                    (n(i.buffer, t, r), (i.version = t.version));
              }
              var o = new WeakMap();
              return { get: r, remove: i, update: a };
            }
            function x(t, e, n, r) {
              (this._x = t || 0),
                (this._y = e || 0),
                (this._z = n || 0),
                (this._order = r || x.DefaultOrder);
            }
            function b() {
              this.mask = 1;
            }
            function _() {
              function t() {
                c.setFromEuler(s, !1);
              }
              function e() {
                s.setFromQuaternion(c, void 0, !1);
              }
              Object.defineProperty(this, "id", { value: Ac++ }),
                (this.uuid = xc.generateUUID()),
                (this.name = ""),
                (this.type = "Object3D"),
                (this.parent = null),
                (this.children = []),
                (this.up = _.DefaultUp.clone());
              var n = new a(),
                s = new x(),
                c = new i(),
                h = new a(1, 1, 1);
              s.onChange(t),
                c.onChange(e),
                Object.defineProperties(this, {
                  position: { enumerable: !0, value: n },
                  rotation: { enumerable: !0, value: s },
                  quaternion: { enumerable: !0, value: c },
                  scale: { enumerable: !0, value: h },
                  modelViewMatrix: { value: new r() },
                  normalMatrix: { value: new o() },
                }),
                (this.matrix = new r()),
                (this.matrixWorld = new r()),
                (this.matrixAutoUpdate = _.DefaultMatrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = !1),
                (this.layers = new b()),
                (this.visible = !0),
                (this.castShadow = !1),
                (this.receiveShadow = !1),
                (this.frustumCulled = !0),
                (this.renderOrder = 0),
                (this.userData = {});
            }
            function w() {
              _.call(this),
                (this.type = "Camera"),
                (this.matrixWorldInverse = new r()),
                (this.projectionMatrix = new r());
            }
            function M(t, e, n, r, i, a) {
              w.call(this),
                (this.type = "OrthographicCamera"),
                (this.zoom = 1),
                (this.view = null),
                (this.left = t),
                (this.right = e),
                (this.top = n),
                (this.bottom = r),
                (this.near = void 0 !== i ? i : 0.1),
                (this.far = void 0 !== a ? a : 2e3),
                this.updateProjectionMatrix();
            }
            function E(t, e, n, r, i, o) {
              (this.a = t),
                (this.b = e),
                (this.c = n),
                (this.normal = r && r.isVector3 ? r : new a()),
                (this.vertexNormals = Array.isArray(r) ? r : []),
                (this.color = i && i.isColor ? i : new g()),
                (this.vertexColors = Array.isArray(i) ? i : []),
                (this.materialIndex = void 0 !== o ? o : 0);
            }
            function T() {
              Object.defineProperty(this, "id", { value: (Lc += 2) }),
                (this.uuid = xc.generateUUID()),
                (this.name = ""),
                (this.type = "Geometry"),
                (this.vertices = []),
                (this.colors = []),
                (this.faces = []),
                (this.faceVertexUvs = [[]]),
                (this.morphTargets = []),
                (this.morphNormals = []),
                (this.skinWeights = []),
                (this.skinIndices = []),
                (this.lineDistances = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.elementsNeedUpdate = !1),
                (this.verticesNeedUpdate = !1),
                (this.uvsNeedUpdate = !1),
                (this.normalsNeedUpdate = !1),
                (this.colorsNeedUpdate = !1),
                (this.lineDistancesNeedUpdate = !1),
                (this.groupsNeedUpdate = !1);
            }
            function S(t, e, n) {
              if (Array.isArray(t))
                throw new TypeError(
                  "THREE.BufferAttribute: array should be a Typed Array."
                );
              (this.name = ""),
                (this.array = t),
                (this.itemSize = e),
                (this.count = void 0 !== t ? t.length / e : 0),
                (this.normalized = !0 === n),
                (this.dynamic = !1),
                (this.updateRange = { offset: 0, count: -1 }),
                (this.version = 0);
            }
            function A(t, e, n) {
              S.call(this, new Int8Array(t), e, n);
            }
            function L(t, e, n) {
              S.call(this, new Uint8Array(t), e, n);
            }
            function R(t, e, n) {
              S.call(this, new Uint8ClampedArray(t), e, n);
            }
            function C(t, e, n) {
              S.call(this, new Int16Array(t), e, n);
            }
            function P(t, e, n) {
              S.call(this, new Uint16Array(t), e, n);
            }
            function O(t, e, n) {
              S.call(this, new Int32Array(t), e, n);
            }
            function I(t, e, n) {
              S.call(this, new Uint32Array(t), e, n);
            }
            function N(t, e, n) {
              S.call(this, new Float32Array(t), e, n);
            }
            function D(t, e, n) {
              S.call(this, new Float64Array(t), e, n);
            }
            function U() {
              (this.vertices = []),
                (this.normals = []),
                (this.colors = []),
                (this.uvs = []),
                (this.uvs2 = []),
                (this.groups = []),
                (this.morphTargets = {}),
                (this.skinWeights = []),
                (this.skinIndices = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.verticesNeedUpdate = !1),
                (this.normalsNeedUpdate = !1),
                (this.colorsNeedUpdate = !1),
                (this.uvsNeedUpdate = !1),
                (this.groupsNeedUpdate = !1);
            }
            function B(t) {
              if (0 === t.length) return -1 / 0;
              for (var e = t[0], n = 1, r = t.length; n < r; ++n)
                t[n] > e && (e = t[n]);
              return e;
            }
            function F() {
              Object.defineProperty(this, "id", { value: (Rc += 2) }),
                (this.uuid = xc.generateUUID()),
                (this.name = ""),
                (this.type = "BufferGeometry"),
                (this.index = null),
                (this.attributes = {}),
                (this.morphAttributes = {}),
                (this.groups = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.drawRange = { start: 0, count: 1 / 0 }),
                (this.userData = {});
            }
            function z(t, e, n, r, i, a) {
              T.call(this),
                (this.type = "BoxGeometry"),
                (this.parameters = {
                  width: t,
                  height: e,
                  depth: n,
                  widthSegments: r,
                  heightSegments: i,
                  depthSegments: a,
                }),
                this.fromBufferGeometry(new G(t, e, n, r, i, a)),
                this.mergeVertices();
            }
            function G(t, e, n, r, i, o) {
              function s(t, e, n, r, i, o, s, m, g, v, y) {
                var x,
                  b,
                  _ = o / g,
                  w = s / v,
                  M = o / 2,
                  E = s / 2,
                  T = m / 2,
                  S = g + 1,
                  A = v + 1,
                  L = 0,
                  R = 0,
                  C = new a();
                for (b = 0; b < A; b++) {
                  var P = b * w - E;
                  for (x = 0; x < S; x++) {
                    var O = x * _ - M;
                    (C[t] = O * r),
                      (C[e] = P * i),
                      (C[n] = T),
                      l.push(C.x, C.y, C.z),
                      (C[t] = 0),
                      (C[e] = 0),
                      (C[n] = m > 0 ? 1 : -1),
                      u.push(C.x, C.y, C.z),
                      p.push(x / g),
                      p.push(1 - b / v),
                      (L += 1);
                  }
                }
                for (b = 0; b < v; b++)
                  for (x = 0; x < g; x++) {
                    var I = d + x + S * b,
                      N = d + x + S * (b + 1),
                      D = d + (x + 1) + S * (b + 1),
                      U = d + (x + 1) + S * b;
                    h.push(I, N, U), h.push(N, D, U), (R += 6);
                  }
                c.addGroup(f, R, y), (f += R), (d += L);
              }
              F.call(this),
                (this.type = "BoxBufferGeometry"),
                (this.parameters = {
                  width: t,
                  height: e,
                  depth: n,
                  widthSegments: r,
                  heightSegments: i,
                  depthSegments: o,
                });
              var c = this;
              (t = t || 1),
                (e = e || 1),
                (n = n || 1),
                (r = Math.floor(r) || 1),
                (i = Math.floor(i) || 1),
                (o = Math.floor(o) || 1);
              var h = [],
                l = [],
                u = [],
                p = [],
                d = 0,
                f = 0;
              s("z", "y", "x", -1, -1, n, e, t, o, i, 0),
                s("z", "y", "x", 1, -1, n, e, -t, o, i, 1),
                s("x", "z", "y", 1, 1, t, n, e, r, o, 2),
                s("x", "z", "y", 1, -1, t, n, -e, r, o, 3),
                s("x", "y", "z", 1, -1, t, e, n, r, i, 4),
                s("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
                this.setIndex(h),
                this.addAttribute("position", new N(l, 3)),
                this.addAttribute("normal", new N(u, 3)),
                this.addAttribute("uv", new N(p, 2));
            }
            function H(t, e, n, r) {
              T.call(this),
                (this.type = "PlaneGeometry"),
                (this.parameters = {
                  width: t,
                  height: e,
                  widthSegments: n,
                  heightSegments: r,
                }),
                this.fromBufferGeometry(new V(t, e, n, r)),
                this.mergeVertices();
            }
            function V(t, e, n, r) {
              F.call(this),
                (this.type = "PlaneBufferGeometry"),
                (this.parameters = {
                  width: t,
                  height: e,
                  widthSegments: n,
                  heightSegments: r,
                }),
                (t = t || 1),
                (e = e || 1);
              var i,
                a,
                o = t / 2,
                s = e / 2,
                c = Math.floor(n) || 1,
                h = Math.floor(r) || 1,
                l = c + 1,
                u = h + 1,
                p = t / c,
                d = e / h,
                f = [],
                m = [],
                g = [],
                v = [];
              for (a = 0; a < u; a++) {
                var y = a * d - s;
                for (i = 0; i < l; i++) {
                  var x = i * p - o;
                  m.push(x, -y, 0),
                    g.push(0, 0, 1),
                    v.push(i / c),
                    v.push(1 - a / h);
                }
              }
              for (a = 0; a < h; a++)
                for (i = 0; i < c; i++) {
                  var b = i + l * a,
                    _ = i + l * (a + 1),
                    w = i + 1 + l * (a + 1),
                    M = i + 1 + l * a;
                  f.push(b, _, M), f.push(_, w, M);
                }
              this.setIndex(f),
                this.addAttribute("position", new N(m, 3)),
                this.addAttribute("normal", new N(g, 3)),
                this.addAttribute("uv", new N(v, 2));
            }
            function k() {
              Object.defineProperty(this, "id", { value: Cc++ }),
                (this.uuid = xc.generateUUID()),
                (this.name = ""),
                (this.type = "Material"),
                (this.fog = !0),
                (this.lights = !0),
                (this.blending = mo),
                (this.side = so),
                (this.flatShading = !1),
                (this.vertexColors = lo),
                (this.opacity = 1),
                (this.transparent = !1),
                (this.blendSrc = Ro),
                (this.blendDst = Co),
                (this.blendEquation = bo),
                (this.blendSrcAlpha = null),
                (this.blendDstAlpha = null),
                (this.blendEquationAlpha = null),
                (this.depthFunc = zo),
                (this.depthTest = !0),
                (this.depthWrite = !0),
                (this.clippingPlanes = null),
                (this.clipIntersection = !1),
                (this.clipShadows = !1),
                (this.shadowSide = null),
                (this.colorWrite = !0),
                (this.precision = null),
                (this.polygonOffset = !1),
                (this.polygonOffsetFactor = 0),
                (this.polygonOffsetUnits = 0),
                (this.dithering = !1),
                (this.alphaTest = 0),
                (this.premultipliedAlpha = !1),
                (this.overdraw = 0),
                (this.visible = !0),
                (this.userData = {}),
                (this.needsUpdate = !0);
            }
            function j(t) {
              k.call(this),
                (this.type = "MeshBasicMaterial"),
                (this.color = new g(16777215)),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = jo),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.lights = !1),
                this.setValues(t);
            }
            function W(t) {
              k.call(this),
                (this.type = "ShaderMaterial"),
                (this.defines = {}),
                (this.uniforms = {}),
                (this.vertexShader =
                  "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
                (this.fragmentShader =
                  "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
                (this.linewidth = 1),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.lights = !1),
                (this.clipping = !1),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                (this.extensions = {
                  derivatives: !1,
                  fragDepth: !1,
                  drawBuffers: !1,
                  shaderTextureLOD: !1,
                }),
                (this.defaultAttributeValues = {
                  color: [1, 1, 1],
                  uv: [0, 0],
                  uv2: [0, 0],
                }),
                (this.index0AttributeName = void 0),
                (this.uniformsNeedUpdate = !1),
                void 0 !== t &&
                  (void 0 !== t.attributes &&
                    console.error(
                      "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                    ),
                  this.setValues(t));
            }
            function X(t, e) {
              (this.origin = void 0 !== t ? t : new a()),
                (this.direction = void 0 !== e ? e : new a());
            }
            function q(t, e, n) {
              (this.a = void 0 !== t ? t : new a()),
                (this.b = void 0 !== e ? e : new a()),
                (this.c = void 0 !== n ? n : new a());
            }
            function Y(t, e) {
              _.call(this),
                (this.type = "Mesh"),
                (this.geometry = void 0 !== t ? t : new F()),
                (this.material =
                  void 0 !== e
                    ? e
                    : new j({ color: 16777215 * Math.random() })),
                (this.drawMode = ac),
                this.updateMorphTargets();
            }
            function J(t, e, n, r) {
              function i(e, r, i, u) {
                var p = r.background;
                null === p ? a(h, l) : p && p.isColor && (a(p, 1), (u = !0)),
                  (t.autoClear || u) &&
                    t.clear(
                      t.autoClearColor,
                      t.autoClearDepth,
                      t.autoClearStencil
                    ),
                  p && p.isCubeTexture
                    ? (void 0 === c &&
                        ((c = new Y(
                          new G(1, 1, 1),
                          new W({
                            uniforms: Sc.cube.uniforms,
                            vertexShader: Sc.cube.vertexShader,
                            fragmentShader: Sc.cube.fragmentShader,
                            side: co,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1,
                          })
                        )),
                        c.geometry.removeAttribute("normal"),
                        c.geometry.removeAttribute("uv"),
                        (c.onBeforeRender = function (t, e, n) {
                          this.matrixWorld.copyPosition(n.matrixWorld);
                        }),
                        n.update(c)),
                      (c.material.uniforms.tCube.value = p),
                      e.push(c, c.geometry, c.material, 0, null))
                    : p &&
                      p.isTexture &&
                      (void 0 === o &&
                        ((o = new M(-1, 1, 1, -1, 0, 1)),
                        (s = new Y(
                          new V(2, 2),
                          new j({ depthTest: !1, depthWrite: !1, fog: !1 })
                        )),
                        n.update(s)),
                      (s.material.map = p),
                      t.renderBufferDirect(
                        o,
                        null,
                        s.geometry,
                        s.material,
                        s,
                        null
                      ));
              }
              function a(t, n) {
                e.buffers.color.setClear(t.r, t.g, t.b, n, r);
              }
              var o,
                s,
                c,
                h = new g(0),
                l = 0;
              return {
                getClearColor: function () {
                  return h;
                },
                setClearColor: function (t, e) {
                  h.set(t), (l = void 0 !== e ? e : 1), a(h, l);
                },
                getClearAlpha: function () {
                  return l;
                },
                setClearAlpha: function (t) {
                  (l = t), a(h, l);
                },
                render: i,
              };
            }
            function Z(t, e, n, r) {
              function i(t) {
                s = t;
              }
              function a(e, r) {
                t.drawArrays(s, e, r), n.update(r, s);
              }
              function o(i, a, o) {
                var c;
                if (r.isWebGL2) c = t;
                else if (null === (c = e.get("ANGLE_instanced_arrays")))
                  return void console.error(
                    "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                  );
                c[
                  r.isWebGL2
                    ? "drawArraysInstanced"
                    : "drawArraysInstancedANGLE"
                ](s, a, o, i.maxInstancedCount),
                  n.update(o, s, i.maxInstancedCount);
              }
              var s;
              (this.setMode = i), (this.render = a), (this.renderInstances = o);
            }
            function Q(t, e, n) {
              function r() {
                if (void 0 !== a) return a;
                var n = e.get("EXT_texture_filter_anisotropic");
                return (a =
                  null !== n
                    ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    : 0);
              }
              function i(e) {
                if ("highp" === e) {
                  if (
                    t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
                      .precision > 0 &&
                    t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                      .precision > 0
                  )
                    return "highp";
                  e = "mediump";
                }
                return "mediump" === e &&
                  t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
                    .precision > 0 &&
                  t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
                    .precision > 0
                  ? "mediump"
                  : "lowp";
              }
              var a,
                o =
                  "undefined" != typeof WebGL2RenderingContext &&
                  t instanceof WebGL2RenderingContext,
                s = void 0 !== n.precision ? n.precision : "highp",
                c = i(s);
              c !== s &&
                (console.warn(
                  "THREE.WebGLRenderer:",
                  s,
                  "not supported, using",
                  c,
                  "instead."
                ),
                (s = c));
              var h = !0 === n.logarithmicDepthBuffer,
                l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                p = t.getParameter(t.MAX_TEXTURE_SIZE),
                d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                g = t.getParameter(t.MAX_VARYING_VECTORS),
                v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                y = u > 0,
                x = o || !!e.get("OES_texture_float");
              return {
                isWebGL2: o,
                getMaxAnisotropy: r,
                getMaxPrecision: i,
                precision: s,
                logarithmicDepthBuffer: h,
                maxTextures: l,
                maxVertexTextures: u,
                maxTextureSize: p,
                maxCubemapSize: d,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: x,
                floatVertexTextures: y && x,
              };
            }
            function K() {
              function t() {
                l.value !== r && ((l.value = r), (l.needsUpdate = i > 0)),
                  (n.numPlanes = i),
                  (n.numIntersection = 0);
              }
              function e(t, e, r, i) {
                var a = null !== t ? t.length : 0,
                  o = null;
                if (0 !== a) {
                  if (((o = l.value), !0 !== i || null === o)) {
                    var s = r + 4 * a,
                      u = e.matrixWorldInverse;
                    h.getNormalMatrix(u),
                      (null === o || o.length < s) && (o = new Float32Array(s));
                    for (var p = 0, d = r; p !== a; ++p, d += 4)
                      c.copy(t[p]).applyMatrix4(u, h),
                        c.normal.toArray(o, d),
                        (o[d + 3] = c.constant);
                  }
                  (l.value = o), (l.needsUpdate = !0);
                }
                return (n.numPlanes = a), o;
              }
              var n = this,
                r = null,
                i = 0,
                a = !1,
                s = !1,
                c = new f(),
                h = new o(),
                l = { value: null, needsUpdate: !1 };
              (this.uniform = l),
                (this.numPlanes = 0),
                (this.numIntersection = 0),
                (this.init = function (t, n, o) {
                  var s = 0 !== t.length || n || 0 !== i || a;
                  return (a = n), (r = e(t, o, 0)), (i = t.length), s;
                }),
                (this.beginShadows = function () {
                  (s = !0), e(null);
                }),
                (this.endShadows = function () {
                  (s = !1), t();
                }),
                (this.setState = function (n, o, c, h, u, p) {
                  if (!a || null === n || 0 === n.length || (s && !c))
                    s ? e(null) : t();
                  else {
                    var d = s ? 0 : i,
                      f = 4 * d,
                      m = u.clippingState || null;
                    (l.value = m), (m = e(n, h, f, p));
                    for (var g = 0; g !== f; ++g) m[g] = r[g];
                    (u.clippingState = m),
                      (this.numIntersection = o ? this.numPlanes : 0),
                      (this.numPlanes += d);
                  }
                });
            }
            function $(t) {
              var e = {};
              return {
                get: function (n) {
                  if (void 0 !== e[n]) return e[n];
                  var r;
                  switch (n) {
                    case "WEBGL_depth_texture":
                      r =
                        t.getExtension("WEBGL_depth_texture") ||
                        t.getExtension("MOZ_WEBGL_depth_texture") ||
                        t.getExtension("WEBKIT_WEBGL_depth_texture");
                      break;
                    case "EXT_texture_filter_anisotropic":
                      r =
                        t.getExtension("EXT_texture_filter_anisotropic") ||
                        t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                        t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                      break;
                    case "WEBGL_compressed_texture_s3tc":
                      r =
                        t.getExtension("WEBGL_compressed_texture_s3tc") ||
                        t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                        t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                      break;
                    case "WEBGL_compressed_texture_pvrtc":
                      r =
                        t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                        t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                      break;
                    default:
                      r = t.getExtension(n);
                  }
                  return (
                    null === r &&
                      console.warn(
                        "THREE.WebGLRenderer: " +
                          n +
                          " extension not supported."
                      ),
                    (e[n] = r),
                    r
                  );
                },
              };
            }
            function tt(t, e, n) {
              function r(t) {
                var i = t.target,
                  a = s[i.id];
                null !== a.index && e.remove(a.index);
                for (var o in a.attributes) e.remove(a.attributes[o]);
                i.removeEventListener("dispose", r), delete s[i.id];
                var h = c[a.id];
                h && (e.remove(h), delete c[a.id]), n.memory.geometries--;
              }
              function i(t, e) {
                var i = s[e.id];
                return (
                  i ||
                  (e.addEventListener("dispose", r),
                  e.isBufferGeometry
                    ? (i = e)
                    : e.isGeometry &&
                      (void 0 === e._bufferGeometry &&
                        (e._bufferGeometry = new F().setFromObject(t)),
                      (i = e._bufferGeometry)),
                  (s[e.id] = i),
                  n.memory.geometries++,
                  i)
                );
              }
              function a(n) {
                var r = n.index,
                  i = n.attributes;
                null !== r && e.update(r, t.ELEMENT_ARRAY_BUFFER);
                for (var a in i) e.update(i[a], t.ARRAY_BUFFER);
                var o = n.morphAttributes;
                for (var a in o)
                  for (var s = o[a], c = 0, h = s.length; c < h; c++)
                    e.update(s[c], t.ARRAY_BUFFER);
              }
              function o(n) {
                var r = c[n.id];
                if (r) return r;
                var i = [],
                  a = n.index,
                  o = n.attributes;
                if (null !== a)
                  for (var s = a.array, h = 0, l = s.length; h < l; h += 3) {
                    var u = s[h + 0],
                      p = s[h + 1],
                      d = s[h + 2];
                    i.push(u, p, p, d, d, u);
                  }
                else
                  for (
                    var s = o.position.array, h = 0, l = s.length / 3 - 1;
                    h < l;
                    h += 3
                  ) {
                    var u = h + 0,
                      p = h + 1,
                      d = h + 2;
                    i.push(u, p, p, d, d, u);
                  }
                return (
                  (r = new (B(i) > 65535 ? I : P)(i, 1)),
                  e.update(r, t.ELEMENT_ARRAY_BUFFER),
                  (c[n.id] = r),
                  r
                );
              }
              var s = {},
                c = {};
              return { get: i, update: a, getWireframeAttribute: o };
            }
            function et(t, e, n, r) {
              function i(t) {
                c = t;
              }
              function a(t) {
                (h = t.type), (l = t.bytesPerElement);
              }
              function o(e, r) {
                t.drawElements(c, r, h, e * l), n.update(r, c);
              }
              function s(i, a, o) {
                var s;
                if (r.isWebGL2) s = t;
                else {
                  var s = e.get("ANGLE_instanced_arrays");
                  if (null === s)
                    return void console.error(
                      "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                    );
                }
                s[
                  r.isWebGL2
                    ? "drawElementsInstanced"
                    : "drawElementsInstancedANGLE"
                ](c, o, h, a * l, i.maxInstancedCount),
                  n.update(o, c, i.maxInstancedCount);
              }
              var c, h, l;
              (this.setMode = i),
                (this.setIndex = a),
                (this.render = o),
                (this.renderInstances = s);
            }
            function nt(t) {
              function e(e, n, r) {
                switch (((r = r || 1), i.calls++, n)) {
                  case t.TRIANGLES:
                    i.triangles += r * (e / 3);
                    break;
                  case t.TRIANGLE_STRIP:
                  case t.TRIANGLE_FAN:
                    i.triangles += r * (e - 2);
                    break;
                  case t.LINES:
                    i.lines += r * (e / 2);
                    break;
                  case t.LINE_STRIP:
                    i.lines += r * (e - 1);
                    break;
                  case t.LINE_LOOP:
                    i.lines += r * e;
                    break;
                  case t.POINTS:
                    i.points += r * e;
                    break;
                  default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n);
                }
              }
              function n() {
                i.frame++,
                  (i.calls = 0),
                  (i.triangles = 0),
                  (i.points = 0),
                  (i.lines = 0);
              }
              var r = { geometries: 0, textures: 0 },
                i = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
              return {
                memory: r,
                render: i,
                programs: null,
                autoReset: !0,
                reset: n,
                update: e,
              };
            }
            function rt(t, e) {
              return Math.abs(e[1]) - Math.abs(t[1]);
            }
            function it(t) {
              function e(e, i, a, o) {
                var s = e.morphTargetInfluences,
                  c = s.length,
                  h = n[i.id];
                if (void 0 === h) {
                  h = [];
                  for (var l = 0; l < c; l++) h[l] = [l, 0];
                  n[i.id] = h;
                }
                for (
                  var u = a.morphTargets && i.morphAttributes.position,
                    p = a.morphNormals && i.morphAttributes.normal,
                    l = 0;
                  l < c;
                  l++
                ) {
                  var d = h[l];
                  0 !== d[1] &&
                    (u && i.removeAttribute("morphTarget" + l),
                    p && i.removeAttribute("morphNormal" + l));
                }
                for (var l = 0; l < c; l++) {
                  var d = h[l];
                  (d[0] = l), (d[1] = s[l]);
                }
                h.sort(rt);
                for (var l = 0; l < 8; l++) {
                  var d = h[l];
                  if (d) {
                    var f = d[0],
                      m = d[1];
                    if (m) {
                      u && i.addAttribute("morphTarget" + l, u[f]),
                        p && i.addAttribute("morphNormal" + l, p[f]),
                        (r[l] = m);
                      continue;
                    }
                  }
                  r[l] = 0;
                }
                o.getUniforms().setValue(t, "morphTargetInfluences", r);
              }
              var n = {},
                r = new Float32Array(8);
              return { update: e };
            }
            function at(t, e) {
              function n(n) {
                var r = e.render.frame,
                  a = n.geometry,
                  o = t.get(n, a);
                return (
                  i[o.id] !== r &&
                    (a.isGeometry && o.updateFromObject(n),
                    t.update(o),
                    (i[o.id] = r)),
                  o
                );
              }
              function r() {
                i = {};
              }
              var i = {};
              return { update: n, dispose: r };
            }
            function ot(t, e, n, r, i, a, o, c, h, l) {
              (t = void 0 !== t ? t : []),
                (e = void 0 !== e ? e : Ko),
                s.call(this, t, e, n, r, i, a, o, c, h, l),
                (this.flipY = !1);
            }
            function st() {
              (this.seq = []), (this.map = {});
            }
            function ct(t, e, n) {
              var r = t[0];
              if (r <= 0 || r > 0) return t;
              var i = e * n,
                a = Ic[i];
              if (
                (void 0 === a && ((a = new Float32Array(i)), (Ic[i] = a)),
                0 !== e)
              ) {
                r.toArray(a, 0);
                for (var o = 1, s = 0; o !== e; ++o)
                  (s += n), t[o].toArray(a, s);
              }
              return a;
            }
            function ht(t, e) {
              if (t.length !== e.length) return !1;
              for (var n = 0, r = t.length; n < r; n++)
                if (t[n] !== e[n]) return !1;
              return !0;
            }
            function lt(t, e) {
              for (var n = 0, r = e.length; n < r; n++) t[n] = e[n];
            }
            function ut(t, e) {
              var n = Nc[e];
              void 0 === n && ((n = new Int32Array(e)), (Nc[e] = n));
              for (var r = 0; r !== e; ++r) n[r] = t.allocTextureUnit();
              return n;
            }
            function pt(t, e) {
              var n = this.cache;
              n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
            }
            function dt(t, e) {
              var n = this.cache;
              n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
            }
            function ft(t, e) {
              var n = this.cache;
              if (void 0 !== e.x)
                (n[0] === e.x && n[1] === e.y) ||
                  (t.uniform2f(this.addr, e.x, e.y),
                  (n[0] = e.x),
                  (n[1] = e.y));
              else {
                if (ht(n, e)) return;
                t.uniform2fv(this.addr, e), lt(n, e);
              }
            }
            function mt(t, e) {
              var n = this.cache;
              if (void 0 !== e.x)
                (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                  (t.uniform3f(this.addr, e.x, e.y, e.z),
                  (n[0] = e.x),
                  (n[1] = e.y),
                  (n[2] = e.z));
              else if (void 0 !== e.r)
                (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                  (t.uniform3f(this.addr, e.r, e.g, e.b),
                  (n[0] = e.r),
                  (n[1] = e.g),
                  (n[2] = e.b));
              else {
                if (ht(n, e)) return;
                t.uniform3fv(this.addr, e), lt(n, e);
              }
            }
            function gt(t, e) {
              var n = this.cache;
              if (void 0 !== e.x)
                (n[0] === e.x &&
                  n[1] === e.y &&
                  n[2] === e.z &&
                  n[3] === e.w) ||
                  (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                  (n[0] = e.x),
                  (n[1] = e.y),
                  (n[2] = e.z),
                  (n[3] = e.w));
              else {
                if (ht(n, e)) return;
                t.uniform4fv(this.addr, e), lt(n, e);
              }
            }
            function vt(t, e) {
              var n = this.cache,
                r = e.elements;
              if (void 0 === r) {
                if (ht(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), lt(n, e);
              } else {
                if (ht(n, r)) return;
                Bc.set(r), t.uniformMatrix2fv(this.addr, !1, Bc), lt(n, r);
              }
            }
            function yt(t, e) {
              var n = this.cache,
                r = e.elements;
              if (void 0 === r) {
                if (ht(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), lt(n, e);
              } else {
                if (ht(n, r)) return;
                Uc.set(r), t.uniformMatrix3fv(this.addr, !1, Uc), lt(n, r);
              }
            }
            function xt(t, e) {
              var n = this.cache,
                r = e.elements;
              if (void 0 === r) {
                if (ht(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), lt(n, e);
              } else {
                if (ht(n, r)) return;
                Dc.set(r), t.uniformMatrix4fv(this.addr, !1, Dc), lt(n, r);
              }
            }
            function bt(t, e, n) {
              var r = this.cache,
                i = n.allocTextureUnit();
              r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                n.setTexture2D(e || Pc, i);
            }
            function _t(t, e, n) {
              var r = this.cache,
                i = n.allocTextureUnit();
              r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                n.setTextureCube(e || Oc, i);
            }
            function wt(t, e) {
              var n = this.cache;
              ht(n, e) || (t.uniform2iv(this.addr, e), lt(n, e));
            }
            function Mt(t, e) {
              var n = this.cache;
              ht(n, e) || (t.uniform3iv(this.addr, e), lt(n, e));
            }
            function Et(t, e) {
              var n = this.cache;
              ht(n, e) || (t.uniform4iv(this.addr, e), lt(n, e));
            }
            function Tt(t) {
              switch (t) {
                case 5126:
                  return pt;
                case 35664:
                  return ft;
                case 35665:
                  return mt;
                case 35666:
                  return gt;
                case 35674:
                  return vt;
                case 35675:
                  return yt;
                case 35676:
                  return xt;
                case 35678:
                case 36198:
                  return bt;
                case 35680:
                  return _t;
                case 5124:
                case 35670:
                  return dt;
                case 35667:
                case 35671:
                  return wt;
                case 35668:
                case 35672:
                  return Mt;
                case 35669:
                case 35673:
                  return Et;
              }
            }
            function St(t, e) {
              var n = this.cache;
              ht(n, e) || (t.uniform1fv(this.addr, e), lt(n, e));
            }
            function At(t, e) {
              var n = this.cache;
              ht(n, e) || (t.uniform1iv(this.addr, e), lt(n, e));
            }
            function Lt(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 2);
              ht(n, r) || (t.uniform2fv(this.addr, r), this.updateCache(r));
            }
            function Rt(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 3);
              ht(n, r) || (t.uniform3fv(this.addr, r), this.updateCache(r));
            }
            function Ct(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 4);
              ht(n, r) || (t.uniform4fv(this.addr, r), this.updateCache(r));
            }
            function Pt(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 4);
              ht(n, r) ||
                (t.uniformMatrix2fv(this.addr, !1, r), this.updateCache(r));
            }
            function Ot(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 9);
              ht(n, r) ||
                (t.uniformMatrix3fv(this.addr, !1, r), this.updateCache(r));
            }
            function It(t, e) {
              var n = this.cache,
                r = ct(e, this.size, 16);
              ht(n, r) ||
                (t.uniformMatrix4fv(this.addr, !1, r), this.updateCache(r));
            }
            function Nt(t, e, n) {
              var r = this.cache,
                i = e.length,
                a = ut(n, i);
              !1 === ht(r, a) && (t.uniform1iv(this.addr, a), lt(r, a));
              for (var o = 0; o !== i; ++o) n.setTexture2D(e[o] || Pc, a[o]);
            }
            function Dt(t, e, n) {
              var r = this.cache,
                i = e.length,
                a = ut(n, i);
              !1 === ht(r, a) && (t.uniform1iv(this.addr, a), lt(r, a));
              for (var o = 0; o !== i; ++o) n.setTextureCube(e[o] || Oc, a[o]);
            }
            function Ut(t) {
              switch (t) {
                case 5126:
                  return St;
                case 35664:
                  return Lt;
                case 35665:
                  return Rt;
                case 35666:
                  return Ct;
                case 35674:
                  return Pt;
                case 35675:
                  return Ot;
                case 35676:
                  return It;
                case 35678:
                  return Nt;
                case 35680:
                  return Dt;
                case 5124:
                case 35670:
                  return At;
                case 35667:
                case 35671:
                  return wt;
                case 35668:
                case 35672:
                  return Mt;
                case 35669:
                case 35673:
                  return Et;
              }
            }
            function Bt(t, e, n) {
              (this.id = t),
                (this.addr = n),
                (this.cache = []),
                (this.setValue = Tt(e.type));
            }
            function Ft(t, e, n) {
              (this.id = t),
                (this.addr = n),
                (this.cache = []),
                (this.size = e.size),
                (this.setValue = Ut(e.type));
            }
            function zt(t) {
              (this.id = t), st.call(this);
            }
            function Gt(t, e) {
              t.seq.push(e), (t.map[e.id] = e);
            }
            function Ht(t, e, n) {
              var r = t.name,
                i = r.length;
              for (Fc.lastIndex = 0; ; ) {
                var a = Fc.exec(r),
                  o = Fc.lastIndex,
                  s = a[1],
                  c = "]" === a[2],
                  h = a[3];
                if (
                  (c && (s |= 0), void 0 === h || ("[" === h && o + 2 === i))
                ) {
                  Gt(n, void 0 === h ? new Bt(s, t, e) : new Ft(s, t, e));
                  break;
                }
                var l = n.map,
                  u = l[s];
                void 0 === u && ((u = new zt(s)), Gt(n, u)), (n = u);
              }
            }
            function Vt(t, e, n) {
              st.call(this), (this.renderer = n);
              for (
                var r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0;
                i < r;
                ++i
              ) {
                var a = t.getActiveUniform(e, i);
                Ht(a, t.getUniformLocation(e, a.name), this);
              }
            }
            function kt(t) {
              for (var e = t.split("\n"), n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
              return e.join("\n");
            }
            function jt(t, e, n) {
              var r = t.createShader(e);
              return (
                t.shaderSource(r, n),
                t.compileShader(r),
                !1 === t.getShaderParameter(r, t.COMPILE_STATUS) &&
                  console.error("THREE.WebGLShader: Shader couldn't compile."),
                "" !== t.getShaderInfoLog(r) &&
                  console.warn(
                    "THREE.WebGLShader: gl.getShaderInfoLog()",
                    e === t.VERTEX_SHADER ? "vertex" : "fragment",
                    t.getShaderInfoLog(r),
                    kt(n)
                  ),
                r
              );
            }
            function Wt(t) {
              switch (t) {
                case cc:
                  return ["Linear", "( value )"];
                case hc:
                  return ["sRGB", "( value )"];
                case uc:
                  return ["RGBE", "( value )"];
                case pc:
                  return ["RGBM", "( value, 7.0 )"];
                case dc:
                  return ["RGBM", "( value, 16.0 )"];
                case fc:
                  return ["RGBD", "( value, 256.0 )"];
                case lc:
                  return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                  throw new Error("unsupported encoding: " + t);
              }
            }
            function Xt(t, e) {
              var n = Wt(e);
              return (
                "vec4 " +
                t +
                "( vec4 value ) { return " +
                n[0] +
                "ToLinear" +
                n[1] +
                "; }"
              );
            }
            function qt(t, e) {
              var n = Wt(e);
              return (
                "vec4 " +
                t +
                "( vec4 value ) { return LinearTo" +
                n[0] +
                n[1] +
                "; }"
              );
            }
            function Yt(t, e) {
              var n;
              switch (e) {
                case Yo:
                  n = "Linear";
                  break;
                case Jo:
                  n = "Reinhard";
                  break;
                case Zo:
                  n = "Uncharted2";
                  break;
                case Qo:
                  n = "OptimizedCineon";
                  break;
                default:
                  throw new Error("unsupported toneMapping: " + e);
              }
              return (
                "vec3 " +
                t +
                "( vec3 color ) { return " +
                n +
                "ToneMapping( color ); }"
              );
            }
            function Jt(t, e, n) {
              return (
                (t = t || {}),
                [
                  t.derivatives ||
                  e.envMapCubeUV ||
                  e.bumpMap ||
                  (e.normalMap && !e.objectSpaceNormalMap) ||
                  e.flatShading
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (t.fragDepth || e.logarithmicDepthBuffer) &&
                  n.get("EXT_frag_depth")
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  t.drawBuffers && n.get("WEBGL_draw_buffers")
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (t.shaderTextureLOD || e.envMap) &&
                  n.get("EXT_shader_texture_lod")
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Kt)
                  .join("\n")
              );
            }
            function Zt(t) {
              var e = [];
              for (var n in t) {
                var r = t[n];
                !1 !== r && e.push("#define " + n + " " + r);
              }
              return e.join("\n");
            }
            function Qt(t, e) {
              for (
                var n = {},
                  r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES),
                  i = 0;
                i < r;
                i++
              ) {
                var a = t.getActiveAttrib(e, i),
                  o = a.name;
                n[o] = t.getAttribLocation(e, o);
              }
              return n;
            }
            function Kt(t) {
              return "" !== t;
            }
            function $t(t, e) {
              return t
                .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
            }
            function te(t, e) {
              return t
                .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                .replace(
                  /UNION_CLIPPING_PLANES/g,
                  e.numClippingPlanes - e.numClipIntersection
                );
            }
            function ee(t) {
              function e(t, e) {
                var n = wc[e];
                if (void 0 === n)
                  throw new Error("Can not resolve #include <" + e + ">");
                return ee(n);
              }
              var n = /^[ \t]*#include +<([\w\d.\/]+)>/gm;
              return t.replace(n, e);
            }
            function ne(t) {
              function e(t, e, n, r) {
                for (var i = "", a = parseInt(e); a < parseInt(n); a++)
                  i += r.replace(/\[ i \]/g, "[ " + a + " ]");
                return i;
              }
              var n =
                /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
              return t.replace(n, e);
            }
            function re(t, e, n, r, i, a, o) {
              var s = t.context,
                c = r.defines,
                h = i.vertexShader,
                l = i.fragmentShader,
                u = "SHADOWMAP_TYPE_BASIC";
              a.shadowMapType === ao
                ? (u = "SHADOWMAP_TYPE_PCF")
                : a.shadowMapType === oo && (u = "SHADOWMAP_TYPE_PCF_SOFT");
              var p = "ENVMAP_TYPE_CUBE",
                d = "ENVMAP_MODE_REFLECTION",
                f = "ENVMAP_BLENDING_MULTIPLY";
              if (a.envMap) {
                switch (r.envMap.mapping) {
                  case Ko:
                  case $o:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                  case rs:
                  case is:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                  case ts:
                  case es:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                  case ns:
                    p = "ENVMAP_TYPE_SPHERE";
                }
                switch (r.envMap.mapping) {
                  case $o:
                  case es:
                    d = "ENVMAP_MODE_REFRACTION";
                }
                switch (r.combine) {
                  case jo:
                    f = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case Wo:
                    f = "ENVMAP_BLENDING_MIX";
                    break;
                  case Xo:
                    f = "ENVMAP_BLENDING_ADD";
                }
              }
              var m,
                g,
                v = t.gammaFactor > 0 ? t.gammaFactor : 1,
                y = o.isWebGL2 ? "" : Jt(r.extensions, a, e),
                x = Zt(c),
                b = s.createProgram();
              if (
                (r.isRawShaderMaterial
                  ? ((m = [x].filter(Kt).join("\n")),
                    m.length > 0 && (m += "\n"),
                    (g = [y, x].filter(Kt).join("\n")),
                    g.length > 0 && (g += "\n"))
                  : ((m = [
                      "precision " + a.precision + " float;",
                      "precision " + a.precision + " int;",
                      "#define SHADER_NAME " + i.name,
                      x,
                      a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                      "#define GAMMA_FACTOR " + v,
                      "#define MAX_BONES " + a.maxBones,
                      a.useFog && a.fog ? "#define USE_FOG" : "",
                      a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
                      a.map ? "#define USE_MAP" : "",
                      a.envMap ? "#define USE_ENVMAP" : "",
                      a.envMap ? "#define " + d : "",
                      a.lightMap ? "#define USE_LIGHTMAP" : "",
                      a.aoMap ? "#define USE_AOMAP" : "",
                      a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                      a.bumpMap ? "#define USE_BUMPMAP" : "",
                      a.normalMap ? "#define USE_NORMALMAP" : "",
                      a.normalMap && a.objectSpaceNormalMap
                        ? "#define OBJECTSPACE_NORMALMAP"
                        : "",
                      a.displacementMap && a.supportsVertexTextures
                        ? "#define USE_DISPLACEMENTMAP"
                        : "",
                      a.specularMap ? "#define USE_SPECULARMAP" : "",
                      a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                      a.metalnessMap ? "#define USE_METALNESSMAP" : "",
                      a.alphaMap ? "#define USE_ALPHAMAP" : "",
                      a.vertexColors ? "#define USE_COLOR" : "",
                      a.flatShading ? "#define FLAT_SHADED" : "",
                      a.skinning ? "#define USE_SKINNING" : "",
                      a.useVertexTexture ? "#define BONE_TEXTURE" : "",
                      a.morphTargets ? "#define USE_MORPHTARGETS" : "",
                      a.morphNormals && !1 === a.flatShading
                        ? "#define USE_MORPHNORMALS"
                        : "",
                      a.doubleSided ? "#define DOUBLE_SIDED" : "",
                      a.flipSided ? "#define FLIP_SIDED" : "",
                      a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                      a.shadowMapEnabled ? "#define " + u : "",
                      a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                      a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                      a.logarithmicDepthBuffer &&
                      (o.isWebGL2 || e.get("EXT_frag_depth"))
                        ? "#define USE_LOGDEPTHBUF_EXT"
                        : "",
                      "uniform mat4 modelMatrix;",
                      "uniform mat4 modelViewMatrix;",
                      "uniform mat4 projectionMatrix;",
                      "uniform mat4 viewMatrix;",
                      "uniform mat3 normalMatrix;",
                      "uniform vec3 cameraPosition;",
                      "attribute vec3 position;",
                      "attribute vec3 normal;",
                      "attribute vec2 uv;",
                      "#ifdef USE_COLOR",
                      "\tattribute vec3 color;",
                      "#endif",
                      "#ifdef USE_MORPHTARGETS",
                      "\tattribute vec3 morphTarget0;",
                      "\tattribute vec3 morphTarget1;",
                      "\tattribute vec3 morphTarget2;",
                      "\tattribute vec3 morphTarget3;",
                      "\t#ifdef USE_MORPHNORMALS",
                      "\t\tattribute vec3 morphNormal0;",
                      "\t\tattribute vec3 morphNormal1;",
                      "\t\tattribute vec3 morphNormal2;",
                      "\t\tattribute vec3 morphNormal3;",
                      "\t#else",
                      "\t\tattribute vec3 morphTarget4;",
                      "\t\tattribute vec3 morphTarget5;",
                      "\t\tattribute vec3 morphTarget6;",
                      "\t\tattribute vec3 morphTarget7;",
                      "\t#endif",
                      "#endif",
                      "#ifdef USE_SKINNING",
                      "\tattribute vec4 skinIndex;",
                      "\tattribute vec4 skinWeight;",
                      "#endif",
                      "\n",
                    ]
                      .filter(Kt)
                      .join("\n")),
                    (g = [
                      y,
                      "precision " + a.precision + " float;",
                      "precision " + a.precision + " int;",
                      "#define SHADER_NAME " + i.name,
                      x,
                      a.alphaTest
                        ? "#define ALPHATEST " +
                          a.alphaTest +
                          (a.alphaTest % 1 ? "" : ".0")
                        : "",
                      "#define GAMMA_FACTOR " + v,
                      a.useFog && a.fog ? "#define USE_FOG" : "",
                      a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
                      a.map ? "#define USE_MAP" : "",
                      a.envMap ? "#define USE_ENVMAP" : "",
                      a.envMap ? "#define " + p : "",
                      a.envMap ? "#define " + d : "",
                      a.envMap ? "#define " + f : "",
                      a.lightMap ? "#define USE_LIGHTMAP" : "",
                      a.aoMap ? "#define USE_AOMAP" : "",
                      a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                      a.bumpMap ? "#define USE_BUMPMAP" : "",
                      a.normalMap ? "#define USE_NORMALMAP" : "",
                      a.normalMap && a.objectSpaceNormalMap
                        ? "#define OBJECTSPACE_NORMALMAP"
                        : "",
                      a.specularMap ? "#define USE_SPECULARMAP" : "",
                      a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                      a.metalnessMap ? "#define USE_METALNESSMAP" : "",
                      a.alphaMap ? "#define USE_ALPHAMAP" : "",
                      a.vertexColors ? "#define USE_COLOR" : "",
                      a.gradientMap ? "#define USE_GRADIENTMAP" : "",
                      a.flatShading ? "#define FLAT_SHADED" : "",
                      a.doubleSided ? "#define DOUBLE_SIDED" : "",
                      a.flipSided ? "#define FLIP_SIDED" : "",
                      a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                      a.shadowMapEnabled ? "#define " + u : "",
                      a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                      a.physicallyCorrectLights
                        ? "#define PHYSICALLY_CORRECT_LIGHTS"
                        : "",
                      a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                      a.logarithmicDepthBuffer &&
                      (o.isWebGL2 || e.get("EXT_frag_depth"))
                        ? "#define USE_LOGDEPTHBUF_EXT"
                        : "",
                      a.envMap &&
                      (o.isWebGL2 || e.get("EXT_shader_texture_lod"))
                        ? "#define TEXTURE_LOD_EXT"
                        : "",
                      "uniform mat4 viewMatrix;",
                      "uniform vec3 cameraPosition;",
                      a.toneMapping !== qo ? "#define TONE_MAPPING" : "",
                      a.toneMapping !== qo ? wc.tonemapping_pars_fragment : "",
                      a.toneMapping !== qo
                        ? Yt("toneMapping", a.toneMapping)
                        : "",
                      a.dithering ? "#define DITHERING" : "",
                      a.outputEncoding ||
                      a.mapEncoding ||
                      a.envMapEncoding ||
                      a.emissiveMapEncoding
                        ? wc.encodings_pars_fragment
                        : "",
                      a.mapEncoding
                        ? Xt("mapTexelToLinear", a.mapEncoding)
                        : "",
                      a.envMapEncoding
                        ? Xt("envMapTexelToLinear", a.envMapEncoding)
                        : "",
                      a.emissiveMapEncoding
                        ? Xt("emissiveMapTexelToLinear", a.emissiveMapEncoding)
                        : "",
                      a.outputEncoding
                        ? qt("linearToOutputTexel", a.outputEncoding)
                        : "",
                      a.depthPacking
                        ? "#define DEPTH_PACKING " + r.depthPacking
                        : "",
                      "\n",
                    ]
                      .filter(Kt)
                      .join("\n"))),
                (h = ee(h)),
                (h = $t(h, a)),
                (h = te(h, a)),
                (l = ee(l)),
                (l = $t(l, a)),
                (l = te(l, a)),
                (h = ne(h)),
                (l = ne(l)),
                o.isWebGL2 && !r.isRawShaderMaterial)
              ) {
                var _ = !1,
                  w = /^\s*#version\s+300\s+es\s*\n/;
                r.isShaderMaterial &&
                  null !== h.match(w) &&
                  null !== l.match(w) &&
                  ((_ = !0), (h = h.replace(w, "")), (l = l.replace(w, ""))),
                  (m =
                    [
                      "#version 300 es\n",
                      "#define attribute in",
                      "#define varying out",
                      "#define texture2D texture",
                    ].join("\n") +
                    "\n" +
                    m),
                  (g =
                    [
                      "#version 300 es\n",
                      "#define varying in",
                      _ ? "" : "out highp vec4 pc_fragColor;",
                      _ ? "" : "#define gl_FragColor pc_fragColor",
                      "#define gl_FragDepthEXT gl_FragDepth",
                      "#define texture2D texture",
                      "#define textureCube texture",
                      "#define texture2DProj textureProj",
                      "#define texture2DLodEXT textureLod",
                      "#define texture2DProjLodEXT textureProjLod",
                      "#define textureCubeLodEXT textureLod",
                      "#define texture2DGradEXT textureGrad",
                      "#define texture2DProjGradEXT textureProjGrad",
                      "#define textureCubeGradEXT textureGrad",
                    ].join("\n") +
                    "\n" +
                    g);
              }
              var M = m + h,
                E = g + l,
                T = jt(s, s.VERTEX_SHADER, M),
                S = jt(s, s.FRAGMENT_SHADER, E);
              s.attachShader(b, T),
                s.attachShader(b, S),
                void 0 !== r.index0AttributeName
                  ? s.bindAttribLocation(b, 0, r.index0AttributeName)
                  : !0 === a.morphTargets &&
                    s.bindAttribLocation(b, 0, "position"),
                s.linkProgram(b);
              var A = s.getProgramInfoLog(b).trim(),
                L = s.getShaderInfoLog(T).trim(),
                R = s.getShaderInfoLog(S).trim(),
                C = !0,
                P = !0;
              !1 === s.getProgramParameter(b, s.LINK_STATUS)
                ? ((C = !1),
                  console.error(
                    "THREE.WebGLProgram: shader error: ",
                    s.getError(),
                    "gl.VALIDATE_STATUS",
                    s.getProgramParameter(b, s.VALIDATE_STATUS),
                    "gl.getProgramInfoLog",
                    A,
                    L,
                    R
                  ))
                : "" !== A
                ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A)
                : ("" !== L && "" !== R) || (P = !1),
                P &&
                  (this.diagnostics = {
                    runnable: C,
                    material: r,
                    programLog: A,
                    vertexShader: { log: L, prefix: m },
                    fragmentShader: { log: R, prefix: g },
                  }),
                s.deleteShader(T),
                s.deleteShader(S);
              var O;
              this.getUniforms = function () {
                return void 0 === O && (O = new Vt(s, b, t)), O;
              };
              var I;
              return (
                (this.getAttributes = function () {
                  return void 0 === I && (I = Qt(s, b)), I;
                }),
                (this.destroy = function () {
                  s.deleteProgram(b), (this.program = void 0);
                }),
                Object.defineProperties(this, {
                  uniforms: {
                    get: function () {
                      return (
                        console.warn(
                          "THREE.WebGLProgram: .uniforms is now .getUniforms()."
                        ),
                        this.getUniforms()
                      );
                    },
                  },
                  attributes: {
                    get: function () {
                      return (
                        console.warn(
                          "THREE.WebGLProgram: .attributes is now .getAttributes()."
                        ),
                        this.getAttributes()
                      );
                    },
                  },
                }),
                (this.name = i.name),
                (this.id = zc++),
                (this.code = n),
                (this.usedTimes = 1),
                (this.program = b),
                (this.vertexShader = T),
                (this.fragmentShader = S),
                this
              );
            }
            function ie(t, e, n) {
              function r(t) {
                var e = t.skeleton,
                  r = e.bones;
                if (n.floatVertexTextures) return 1024;
                var i = n.maxVertexUniforms,
                  a = Math.floor((i - 20) / 4),
                  o = Math.min(a, r.length);
                return o < r.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        r.length +
                        " bones. This GPU supports " +
                        o +
                        "."
                    ),
                    0)
                  : o;
              }
              function i(t, e) {
                var n;
                return (
                  t
                    ? t.isTexture
                      ? (n = t.encoding)
                      : t.isWebGLRenderTarget &&
                        (console.warn(
                          "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                        ),
                        (n = t.texture.encoding))
                    : (n = cc),
                  n === cc && e && (n = lc),
                  n
                );
              }
              var a = [],
                o = {
                  MeshDepthMaterial: "depth",
                  MeshDistanceMaterial: "distanceRGBA",
                  MeshNormalMaterial: "normal",
                  MeshBasicMaterial: "basic",
                  MeshLambertMaterial: "lambert",
                  MeshPhongMaterial: "phong",
                  MeshToonMaterial: "phong",
                  MeshStandardMaterial: "physical",
                  MeshPhysicalMaterial: "physical",
                  LineBasicMaterial: "basic",
                  LineDashedMaterial: "dashed",
                  PointsMaterial: "points",
                  ShadowMaterial: "shadow",
                  SpriteMaterial: "sprite",
                },
                s = [
                  "precision",
                  "supportsVertexTextures",
                  "map",
                  "mapEncoding",
                  "envMap",
                  "envMapMode",
                  "envMapEncoding",
                  "lightMap",
                  "aoMap",
                  "emissiveMap",
                  "emissiveMapEncoding",
                  "bumpMap",
                  "normalMap",
                  "objectSpaceNormalMap",
                  "displacementMap",
                  "specularMap",
                  "roughnessMap",
                  "metalnessMap",
                  "gradientMap",
                  "alphaMap",
                  "combine",
                  "vertexColors",
                  "fog",
                  "useFog",
                  "fogExp",
                  "flatShading",
                  "sizeAttenuation",
                  "logarithmicDepthBuffer",
                  "skinning",
                  "maxBones",
                  "useVertexTexture",
                  "morphTargets",
                  "morphNormals",
                  "maxMorphTargets",
                  "maxMorphNormals",
                  "premultipliedAlpha",
                  "numDirLights",
                  "numPointLights",
                  "numSpotLights",
                  "numHemiLights",
                  "numRectAreaLights",
                  "shadowMapEnabled",
                  "shadowMapType",
                  "toneMapping",
                  "physicallyCorrectLights",
                  "alphaTest",
                  "doubleSided",
                  "flipSided",
                  "numClippingPlanes",
                  "numClipIntersection",
                  "depthPacking",
                  "dithering",
                ];
              (this.getParameters = function (e, a, s, c, h, l, u) {
                var p = o[e.type],
                  d = u.isSkinnedMesh ? r(u) : 0,
                  f = n.precision;
                null !== e.precision &&
                  (f = n.getMaxPrecision(e.precision)) !== e.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    e.precision,
                    "not supported, using",
                    f,
                    "instead."
                  );
                var m = t.getRenderTarget();
                return {
                  shaderID: p,
                  precision: f,
                  supportsVertexTextures: n.vertexTextures,
                  outputEncoding: i(m ? m.texture : null, t.gammaOutput),
                  map: !!e.map,
                  mapEncoding: i(e.map, t.gammaInput),
                  envMap: !!e.envMap,
                  envMapMode: e.envMap && e.envMap.mapping,
                  envMapEncoding: i(e.envMap, t.gammaInput),
                  envMapCubeUV:
                    !!e.envMap &&
                    (e.envMap.mapping === rs || e.envMap.mapping === is),
                  lightMap: !!e.lightMap,
                  aoMap: !!e.aoMap,
                  emissiveMap: !!e.emissiveMap,
                  emissiveMapEncoding: i(e.emissiveMap, t.gammaInput),
                  bumpMap: !!e.bumpMap,
                  normalMap: !!e.normalMap,
                  objectSpaceNormalMap: e.normalMapType === yc,
                  displacementMap: !!e.displacementMap,
                  roughnessMap: !!e.roughnessMap,
                  metalnessMap: !!e.metalnessMap,
                  specularMap: !!e.specularMap,
                  alphaMap: !!e.alphaMap,
                  gradientMap: !!e.gradientMap,
                  combine: e.combine,
                  vertexColors: e.vertexColors,
                  fog: !!c,
                  useFog: e.fog,
                  fogExp: c && c.isFogExp2,
                  flatShading: e.flatShading,
                  sizeAttenuation: e.sizeAttenuation,
                  logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                  skinning: e.skinning && d > 0,
                  maxBones: d,
                  useVertexTexture: n.floatVertexTextures,
                  morphTargets: e.morphTargets,
                  morphNormals: e.morphNormals,
                  maxMorphTargets: t.maxMorphTargets,
                  maxMorphNormals: t.maxMorphNormals,
                  numDirLights: a.directional.length,
                  numPointLights: a.point.length,
                  numSpotLights: a.spot.length,
                  numRectAreaLights: a.rectArea.length,
                  numHemiLights: a.hemi.length,
                  numClippingPlanes: h,
                  numClipIntersection: l,
                  dithering: e.dithering,
                  shadowMapEnabled:
                    t.shadowMap.enabled && u.receiveShadow && s.length > 0,
                  shadowMapType: t.shadowMap.type,
                  toneMapping: t.toneMapping,
                  physicallyCorrectLights: t.physicallyCorrectLights,
                  premultipliedAlpha: e.premultipliedAlpha,
                  alphaTest: e.alphaTest,
                  doubleSided: e.side === ho,
                  flipSided: e.side === co,
                  depthPacking: void 0 !== e.depthPacking && e.depthPacking,
                };
              }),
                (this.getProgramCode = function (e, n) {
                  var r = [];
                  if (
                    (n.shaderID
                      ? r.push(n.shaderID)
                      : (r.push(e.fragmentShader), r.push(e.vertexShader)),
                    void 0 !== e.defines)
                  )
                    for (var i in e.defines) r.push(i), r.push(e.defines[i]);
                  for (var a = 0; a < s.length; a++) r.push(n[s[a]]);
                  return (
                    r.push(e.onBeforeCompile.toString()),
                    r.push(t.gammaOutput),
                    r.join()
                  );
                }),
                (this.acquireProgram = function (r, i, o, s) {
                  for (var c, h = 0, l = a.length; h < l; h++) {
                    var u = a[h];
                    if (u.code === s) {
                      (c = u), ++c.usedTimes;
                      break;
                    }
                  }
                  return (
                    void 0 === c &&
                      ((c = new re(t, e, s, r, i, o, n)), a.push(c)),
                    c
                  );
                }),
                (this.releaseProgram = function (t) {
                  if (0 == --t.usedTimes) {
                    var e = a.indexOf(t);
                    (a[e] = a[a.length - 1]), a.pop(), t.destroy();
                  }
                }),
                (this.programs = a);
            }
            function ae() {
              function t(t) {
                var e = i.get(t);
                return void 0 === e && ((e = {}), i.set(t, e)), e;
              }
              function e(t) {
                i.delete(t);
              }
              function n(t, e, n) {
                i.get(t)[e] = n;
              }
              function r() {
                i = new WeakMap();
              }
              var i = new WeakMap();
              return { get: t, remove: e, update: n, dispose: r };
            }
            function oe(t, e) {
              return t.renderOrder !== e.renderOrder
                ? t.renderOrder - e.renderOrder
                : t.program && e.program && t.program !== e.program
                ? t.program.id - e.program.id
                : t.material.id !== e.material.id
                ? t.material.id - e.material.id
                : t.z !== e.z
                ? t.z - e.z
                : t.id - e.id;
            }
            function se(t, e) {
              return t.renderOrder !== e.renderOrder
                ? t.renderOrder - e.renderOrder
                : t.z !== e.z
                ? e.z - t.z
                : t.id - e.id;
            }
            function ce() {
              function t() {
                (i = 0), (a.length = 0), (o.length = 0);
              }
              function e(t, e, n, s, c) {
                var h = r[i];
                void 0 === h
                  ? ((h = {
                      id: t.id,
                      object: t,
                      geometry: e,
                      material: n,
                      program: n.program,
                      renderOrder: t.renderOrder,
                      z: s,
                      group: c,
                    }),
                    (r[i] = h))
                  : ((h.id = t.id),
                    (h.object = t),
                    (h.geometry = e),
                    (h.material = n),
                    (h.program = n.program),
                    (h.renderOrder = t.renderOrder),
                    (h.z = s),
                    (h.group = c)),
                  (!0 === n.transparent ? o : a).push(h),
                  i++;
              }
              function n() {
                a.length > 1 && a.sort(oe), o.length > 1 && o.sort(se);
              }
              var r = [],
                i = 0,
                a = [],
                o = [];
              return { opaque: a, transparent: o, init: t, push: e, sort: n };
            }
            function he() {
              function t(t, e) {
                var r = t.id + "," + e.id,
                  i = n[r];
                return void 0 === i && ((i = new ce()), (n[r] = i)), i;
              }
              function e() {
                n = {};
              }
              var n = {};
              return { get: t, dispose: e };
            }
            function le() {
              var t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  var r;
                  switch (e.type) {
                    case "DirectionalLight":
                      r = {
                        direction: new a(),
                        color: new g(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new n(),
                      };
                      break;
                    case "SpotLight":
                      r = {
                        position: new a(),
                        direction: new a(),
                        color: new g(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new n(),
                      };
                      break;
                    case "PointLight":
                      r = {
                        position: new a(),
                        color: new g(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new n(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                      break;
                    case "HemisphereLight":
                      r = {
                        direction: new a(),
                        skyColor: new g(),
                        groundColor: new g(),
                      };
                      break;
                    case "RectAreaLight":
                      r = {
                        color: new g(),
                        position: new a(),
                        halfWidth: new a(),
                        halfHeight: new a(),
                      };
                  }
                  return (t[e.id] = r), r;
                },
              };
            }
            function ue() {
              function t(t, r, a) {
                for (
                  var c = 0,
                    h = 0,
                    l = 0,
                    u = 0,
                    p = 0,
                    d = 0,
                    f = 0,
                    m = 0,
                    g = a.matrixWorldInverse,
                    v = 0,
                    y = t.length;
                  v < y;
                  v++
                ) {
                  var x = t[v],
                    b = x.color,
                    _ = x.intensity,
                    w = x.distance,
                    M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                  if (x.isAmbientLight)
                    (c += b.r * _), (h += b.g * _), (l += b.b * _);
                  else if (x.isDirectionalLight) {
                    var E = e.get(x);
                    if (
                      (E.color.copy(x.color).multiplyScalar(x.intensity),
                      E.direction.setFromMatrixPosition(x.matrixWorld),
                      i.setFromMatrixPosition(x.target.matrixWorld),
                      E.direction.sub(i),
                      E.direction.transformDirection(g),
                      (E.shadow = x.castShadow),
                      x.castShadow)
                    ) {
                      var T = x.shadow;
                      (E.shadowBias = T.bias),
                        (E.shadowRadius = T.radius),
                        (E.shadowMapSize = T.mapSize);
                    }
                    (n.directionalShadowMap[u] = M),
                      (n.directionalShadowMatrix[u] = x.shadow.matrix),
                      (n.directional[u] = E),
                      u++;
                  } else if (x.isSpotLight) {
                    var E = e.get(x);
                    if (
                      (E.position.setFromMatrixPosition(x.matrixWorld),
                      E.position.applyMatrix4(g),
                      E.color.copy(b).multiplyScalar(_),
                      (E.distance = w),
                      E.direction.setFromMatrixPosition(x.matrixWorld),
                      i.setFromMatrixPosition(x.target.matrixWorld),
                      E.direction.sub(i),
                      E.direction.transformDirection(g),
                      (E.coneCos = Math.cos(x.angle)),
                      (E.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
                      (E.decay = 0 === x.distance ? 0 : x.decay),
                      (E.shadow = x.castShadow),
                      x.castShadow)
                    ) {
                      var T = x.shadow;
                      (E.shadowBias = T.bias),
                        (E.shadowRadius = T.radius),
                        (E.shadowMapSize = T.mapSize);
                    }
                    (n.spotShadowMap[d] = M),
                      (n.spotShadowMatrix[d] = x.shadow.matrix),
                      (n.spot[d] = E),
                      d++;
                  } else if (x.isRectAreaLight) {
                    var E = e.get(x);
                    E.color.copy(b).multiplyScalar(_),
                      E.position.setFromMatrixPosition(x.matrixWorld),
                      E.position.applyMatrix4(g),
                      s.identity(),
                      o.copy(x.matrixWorld),
                      o.premultiply(g),
                      s.extractRotation(o),
                      E.halfWidth.set(0.5 * x.width, 0, 0),
                      E.halfHeight.set(0, 0.5 * x.height, 0),
                      E.halfWidth.applyMatrix4(s),
                      E.halfHeight.applyMatrix4(s),
                      (n.rectArea[f] = E),
                      f++;
                  } else if (x.isPointLight) {
                    var E = e.get(x);
                    if (
                      (E.position.setFromMatrixPosition(x.matrixWorld),
                      E.position.applyMatrix4(g),
                      E.color.copy(x.color).multiplyScalar(x.intensity),
                      (E.distance = x.distance),
                      (E.decay = 0 === x.distance ? 0 : x.decay),
                      (E.shadow = x.castShadow),
                      x.castShadow)
                    ) {
                      var T = x.shadow;
                      (E.shadowBias = T.bias),
                        (E.shadowRadius = T.radius),
                        (E.shadowMapSize = T.mapSize),
                        (E.shadowCameraNear = T.camera.near),
                        (E.shadowCameraFar = T.camera.far);
                    }
                    (n.pointShadowMap[p] = M),
                      (n.pointShadowMatrix[p] = x.shadow.matrix),
                      (n.point[p] = E),
                      p++;
                  } else if (x.isHemisphereLight) {
                    var E = e.get(x);
                    E.direction.setFromMatrixPosition(x.matrixWorld),
                      E.direction.transformDirection(g),
                      E.direction.normalize(),
                      E.skyColor.copy(x.color).multiplyScalar(_),
                      E.groundColor.copy(x.groundColor).multiplyScalar(_),
                      (n.hemi[m] = E),
                      m++;
                  }
                }
                (n.ambient[0] = c),
                  (n.ambient[1] = h),
                  (n.ambient[2] = l),
                  (n.directional.length = u),
                  (n.spot.length = d),
                  (n.rectArea.length = f),
                  (n.point.length = p),
                  (n.hemi.length = m),
                  (n.hash.stateID = n.id),
                  (n.hash.directionalLength = u),
                  (n.hash.pointLength = p),
                  (n.hash.spotLength = d),
                  (n.hash.rectAreaLength = f),
                  (n.hash.hemiLength = m),
                  (n.hash.shadowsLength = r.length);
              }
              var e = new le(),
                n = {
                  id: Gc++,
                  hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1,
                  },
                  ambient: [0, 0, 0],
                  directional: [],
                  directionalShadowMap: [],
                  directionalShadowMatrix: [],
                  spot: [],
                  spotShadowMap: [],
                  spotShadowMatrix: [],
                  rectArea: [],
                  point: [],
                  pointShadowMap: [],
                  pointShadowMatrix: [],
                  hemi: [],
                },
                i = new a(),
                o = new r(),
                s = new r();
              return { setup: t, state: n };
            }
            function pe() {
              function t() {
                (a.length = 0), (o.length = 0);
              }
              function e(t) {
                a.push(t);
              }
              function n(t) {
                o.push(t);
              }
              function r(t) {
                i.setup(a, o, t);
              }
              var i = new ue(),
                a = [],
                o = [];
              return {
                init: t,
                state: { lightsArray: a, shadowsArray: o, lights: i },
                setupLights: r,
                pushLight: e,
                pushShadow: n,
              };
            }
            function de() {
              function t(t, e) {
                var r;
                return (
                  void 0 === n[t.id]
                    ? ((r = new pe()), (n[t.id] = {}), (n[t.id][e.id] = r))
                    : void 0 === n[t.id][e.id]
                    ? ((r = new pe()), (n[t.id][e.id] = r))
                    : (r = n[t.id][e.id]),
                  r
                );
              }
              function e() {
                n = {};
              }
              var n = {};
              return { get: t, dispose: e };
            }
            function fe(t) {
              k.call(this),
                (this.type = "MeshDepthMaterial"),
                (this.depthPacking = mc),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.map = null),
                (this.alphaMap = null),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.lights = !1),
                this.setValues(t);
            }
            function me(t) {
              k.call(this),
                (this.type = "MeshDistanceMaterial"),
                (this.referencePosition = new a()),
                (this.nearDistance = 1),
                (this.farDistance = 1e3),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.map = null),
                (this.alphaMap = null),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.fog = !1),
                (this.lights = !1),
                this.setValues(t);
            }
            function ge(t, e, i) {
              function o(e, n, r, i, a, o) {
                var s = e.geometry,
                  c = null,
                  h = b,
                  l = e.customDepthMaterial;
                if ((r && ((h = _), (l = e.customDistanceMaterial)), l)) c = l;
                else {
                  var u = !1;
                  n.morphTargets &&
                    (s && s.isBufferGeometry
                      ? (u =
                          s.morphAttributes &&
                          s.morphAttributes.position &&
                          s.morphAttributes.position.length > 0)
                      : s &&
                        s.isGeometry &&
                        (u = s.morphTargets && s.morphTargets.length > 0)),
                    e.isSkinnedMesh &&
                      !1 === n.skinning &&
                      console.warn(
                        "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                        e
                      );
                  var p = e.isSkinnedMesh && n.skinning,
                    d = 0;
                  u && (d |= v), p && (d |= y), (c = h[d]);
                }
                if (
                  t.localClippingEnabled &&
                  !0 === n.clipShadows &&
                  0 !== n.clippingPlanes.length
                ) {
                  var f = c.uuid,
                    m = n.uuid,
                    g = w[f];
                  void 0 === g && ((g = {}), (w[f] = g));
                  var x = g[m];
                  void 0 === x && ((x = c.clone()), (g[m] = x)), (c = x);
                }
                return (
                  (c.visible = n.visible),
                  (c.wireframe = n.wireframe),
                  (c.side = null != n.shadowSide ? n.shadowSide : M[n.side]),
                  (c.clipShadows = n.clipShadows),
                  (c.clippingPlanes = n.clippingPlanes),
                  (c.clipIntersection = n.clipIntersection),
                  (c.wireframeLinewidth = n.wireframeLinewidth),
                  (c.linewidth = n.linewidth),
                  r &&
                    c.isMeshDistanceMaterial &&
                    (c.referencePosition.copy(i),
                    (c.nearDistance = a),
                    (c.farDistance = o)),
                  c
                );
              }
              function s(n, r, i, a) {
                if (!1 !== n.visible) {
                  if (
                    n.layers.test(r.layers) &&
                    (n.isMesh || n.isLine || n.isPoints) &&
                    n.castShadow &&
                    (!n.frustumCulled || l.intersectsObject(n))
                  ) {
                    n.modelViewMatrix.multiplyMatrices(
                      i.matrixWorldInverse,
                      n.matrixWorld
                    );
                    var c = e.update(n),
                      h = n.material;
                    if (Array.isArray(h))
                      for (var u = c.groups, p = 0, d = u.length; p < d; p++) {
                        var f = u[p],
                          m = h[f.materialIndex];
                        if (m && m.visible) {
                          var v = o(n, m, a, g, i.near, i.far);
                          t.renderBufferDirect(i, null, c, v, n, f);
                        }
                      }
                    else if (h.visible) {
                      var v = o(n, h, a, g, i.near, i.far);
                      t.renderBufferDirect(i, null, c, v, n, null);
                    }
                  }
                  for (var y = n.children, x = 0, b = y.length; x < b; x++)
                    s(y[x], r, i, a);
                }
              }
              for (
                var l = new m(),
                  u = new r(),
                  p = new n(),
                  d = new n(i, i),
                  f = new a(),
                  g = new a(),
                  v = 1,
                  y = 2,
                  x = 1 + (v | y),
                  b = new Array(x),
                  _ = new Array(x),
                  w = {},
                  M = { 0: co, 1: so, 2: ho },
                  E = [
                    new a(1, 0, 0),
                    new a(-1, 0, 0),
                    new a(0, 0, 1),
                    new a(0, 0, -1),
                    new a(0, 1, 0),
                    new a(0, -1, 0),
                  ],
                  T = [
                    new a(0, 1, 0),
                    new a(0, 1, 0),
                    new a(0, 1, 0),
                    new a(0, 1, 0),
                    new a(0, 0, 1),
                    new a(0, 0, -1),
                  ],
                  S = [new c(), new c(), new c(), new c(), new c(), new c()],
                  A = 0;
                A !== x;
                ++A
              ) {
                var L = 0 != (A & v),
                  R = 0 != (A & y),
                  C = new fe({
                    depthPacking: gc,
                    morphTargets: L,
                    skinning: R,
                  });
                b[A] = C;
                var P = new me({ morphTargets: L, skinning: R });
                _[A] = P;
              }
              var O = this;
              (this.enabled = !1),
                (this.autoUpdate = !0),
                (this.needsUpdate = !1),
                (this.type = ao),
                (this.render = function (e, n, r) {
                  if (
                    !1 !== O.enabled &&
                    (!1 !== O.autoUpdate || !1 !== O.needsUpdate) &&
                    0 !== e.length
                  ) {
                    var i = t.context,
                      a = t.state;
                    a.disable(i.BLEND),
                      a.buffers.color.setClear(1, 1, 1, 1),
                      a.buffers.depth.setTest(!0),
                      a.setScissorTest(!1);
                    for (var o, c = 0, m = e.length; c < m; c++) {
                      var v = e[c],
                        y = v.shadow,
                        x = v && v.isPointLight;
                      if (void 0 !== y) {
                        var b = y.camera;
                        if ((p.copy(y.mapSize), p.min(d), x)) {
                          var _ = p.x,
                            w = p.y;
                          S[0].set(2 * _, w, _, w),
                            S[1].set(0, w, _, w),
                            S[2].set(3 * _, w, _, w),
                            S[3].set(_, w, _, w),
                            S[4].set(3 * _, 0, _, w),
                            S[5].set(_, 0, _, w),
                            (p.x *= 4),
                            (p.y *= 2);
                        }
                        if (null === y.map) {
                          var M = { minFilter: cs, magFilter: cs, format: Ls };
                          (y.map = new h(p.x, p.y, M)),
                            (y.map.texture.name = v.name + ".shadowMap"),
                            b.updateProjectionMatrix();
                        }
                        y.isSpotLightShadow && y.update(v);
                        var A = y.map,
                          L = y.matrix;
                        g.setFromMatrixPosition(v.matrixWorld),
                          b.position.copy(g),
                          x
                            ? ((o = 6), L.makeTranslation(-g.x, -g.y, -g.z))
                            : ((o = 1),
                              f.setFromMatrixPosition(v.target.matrixWorld),
                              b.lookAt(f),
                              b.updateMatrixWorld(),
                              L.set(
                                0.5,
                                0,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0.5,
                                0,
                                0,
                                0.5,
                                0.5,
                                0,
                                0,
                                0,
                                1
                              ),
                              L.multiply(b.projectionMatrix),
                              L.multiply(b.matrixWorldInverse)),
                          t.setRenderTarget(A),
                          t.clear();
                        for (var R = 0; R < o; R++) {
                          if (x) {
                            f.copy(b.position),
                              f.add(E[R]),
                              b.up.copy(T[R]),
                              b.lookAt(f),
                              b.updateMatrixWorld();
                            var C = S[R];
                            a.viewport(C);
                          }
                          u.multiplyMatrices(
                            b.projectionMatrix,
                            b.matrixWorldInverse
                          ),
                            l.setFromMatrix(u),
                            s(n, r, b, x);
                        }
                      } else
                        console.warn(
                          "THREE.WebGLShadowMap:",
                          v,
                          "has no shadow."
                        );
                    }
                    O.needsUpdate = !1;
                  }
                });
            }
            function ve(t, e, n, r) {
              function i() {
                var e = !1,
                  n = new c(),
                  r = null,
                  i = new c(0, 0, 0, 0);
                return {
                  setMask: function (n) {
                    r === n || e || (t.colorMask(n, n, n, n), (r = n));
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e, r, a, o, s) {
                    !0 === s && ((e *= o), (r *= o), (a *= o)),
                      n.set(e, r, a, o),
                      !1 === i.equals(n) &&
                        (t.clearColor(e, r, a, o), i.copy(n));
                  },
                  reset: function () {
                    (e = !1), (r = null), i.set(-1, 0, 0, 0);
                  },
                };
              }
              function a() {
                var e = !1,
                  n = null,
                  r = null,
                  i = null;
                return {
                  setTest: function (e) {
                    e ? d(t.DEPTH_TEST) : f(t.DEPTH_TEST);
                  },
                  setMask: function (r) {
                    n === r || e || (t.depthMask(r), (n = r));
                  },
                  setFunc: function (e) {
                    if (r !== e) {
                      if (e)
                        switch (e) {
                          case Uo:
                            t.depthFunc(t.NEVER);
                            break;
                          case Bo:
                            t.depthFunc(t.ALWAYS);
                            break;
                          case Fo:
                            t.depthFunc(t.LESS);
                            break;
                          case zo:
                            t.depthFunc(t.LEQUAL);
                            break;
                          case Go:
                            t.depthFunc(t.EQUAL);
                            break;
                          case Ho:
                            t.depthFunc(t.GEQUAL);
                            break;
                          case Vo:
                            t.depthFunc(t.GREATER);
                            break;
                          case ko:
                            t.depthFunc(t.NOTEQUAL);
                            break;
                          default:
                            t.depthFunc(t.LEQUAL);
                        }
                      else t.depthFunc(t.LEQUAL);
                      r = e;
                    }
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e) {
                    i !== e && (t.clearDepth(e), (i = e));
                  },
                  reset: function () {
                    (e = !1), (n = null), (r = null), (i = null);
                  },
                };
              }
              function o() {
                var e = !1,
                  n = null,
                  r = null,
                  i = null,
                  a = null,
                  o = null,
                  s = null,
                  c = null,
                  h = null;
                return {
                  setTest: function (e) {
                    e ? d(t.STENCIL_TEST) : f(t.STENCIL_TEST);
                  },
                  setMask: function (r) {
                    n === r || e || (t.stencilMask(r), (n = r));
                  },
                  setFunc: function (e, n, o) {
                    (r === e && i === n && a === o) ||
                      (t.stencilFunc(e, n, o), (r = e), (i = n), (a = o));
                  },
                  setOp: function (e, n, r) {
                    (o === e && s === n && c === r) ||
                      (t.stencilOp(e, n, r), (o = e), (s = n), (c = r));
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e) {
                    h !== e && (t.clearStencil(e), (h = e));
                  },
                  reset: function () {
                    (e = !1),
                      (n = null),
                      (r = null),
                      (i = null),
                      (a = null),
                      (o = null),
                      (s = null),
                      (c = null),
                      (h = null);
                  },
                };
              }
              function s(e, n, r) {
                var i = new Uint8Array(4),
                  a = t.createTexture();
                t.bindTexture(e, a),
                  t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                  t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (var o = 0; o < r; o++)
                  t.texImage2D(
                    n + o,
                    0,
                    t.RGBA,
                    1,
                    1,
                    0,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    i
                  );
                return a;
              }
              function h() {
                for (var t = 0, e = D.length; t < e; t++) D[t] = 0;
              }
              function l(t) {
                u(t, 0);
              }
              function u(n, i) {
                if (
                  ((D[n] = 1),
                  0 === U[n] && (t.enableVertexAttribArray(n), (U[n] = 1)),
                  B[n] !== i)
                ) {
                  (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                    r.isWebGL2
                      ? "vertexAttribDivisor"
                      : "vertexAttribDivisorANGLE"
                  ](n, i),
                    (B[n] = i);
                }
              }
              function p() {
                for (var e = 0, n = U.length; e !== n; ++e)
                  U[e] !== D[e] && (t.disableVertexAttribArray(e), (U[e] = 0));
              }
              function d(e) {
                !0 !== F[e] && (t.enable(e), (F[e] = !0));
              }
              function f(e) {
                !1 !== F[e] && (t.disable(e), (F[e] = !1));
              }
              function m() {
                if (
                  null === z &&
                  ((z = []),
                  e.get("WEBGL_compressed_texture_pvrtc") ||
                    e.get("WEBGL_compressed_texture_s3tc") ||
                    e.get("WEBGL_compressed_texture_etc1") ||
                    e.get("WEBGL_compressed_texture_astc"))
                )
                  for (
                    var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), r = 0;
                    r < n.length;
                    r++
                  )
                    z.push(n[r]);
                return z;
              }
              function g(e) {
                return G !== e && (t.useProgram(e), (G = e), !0);
              }
              function v(e, r, i, a, o, s, c, h) {
                if ((e !== fo ? d(t.BLEND) : f(t.BLEND), e !== xo)) {
                  if (e !== H || h !== Y)
                    switch (e) {
                      case go:
                        h
                          ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                            t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE))
                          : (t.blendEquation(t.FUNC_ADD),
                            t.blendFunc(t.SRC_ALPHA, t.ONE));
                        break;
                      case vo:
                        h
                          ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                            t.blendFuncSeparate(
                              t.ZERO,
                              t.ZERO,
                              t.ONE_MINUS_SRC_COLOR,
                              t.ONE_MINUS_SRC_ALPHA
                            ))
                          : (t.blendEquation(t.FUNC_ADD),
                            t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                        break;
                      case yo:
                        h
                          ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                            t.blendFuncSeparate(
                              t.ZERO,
                              t.SRC_COLOR,
                              t.ZERO,
                              t.SRC_ALPHA
                            ))
                          : (t.blendEquation(t.FUNC_ADD),
                            t.blendFunc(t.ZERO, t.SRC_COLOR));
                        break;
                      default:
                        h
                          ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                            t.blendFuncSeparate(
                              t.ONE,
                              t.ONE_MINUS_SRC_ALPHA,
                              t.ONE,
                              t.ONE_MINUS_SRC_ALPHA
                            ))
                          : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                            t.blendFuncSeparate(
                              t.SRC_ALPHA,
                              t.ONE_MINUS_SRC_ALPHA,
                              t.ONE,
                              t.ONE_MINUS_SRC_ALPHA
                            ));
                    }
                  (V = null),
                    (k = null),
                    (j = null),
                    (W = null),
                    (X = null),
                    (q = null);
                } else (o = o || r), (s = s || i), (c = c || a), (r === V && o === W) || (t.blendEquationSeparate(n.convert(r), n.convert(o)), (V = r), (W = o)), (i === k && a === j && s === X && c === q) || (t.blendFuncSeparate(n.convert(i), n.convert(a), n.convert(s), n.convert(c)), (k = i), (j = a), (X = s), (q = c));
                (H = e), (Y = h);
              }
              function y(e, n) {
                e.side === ho ? f(t.CULL_FACE) : d(t.CULL_FACE);
                var r = e.side === co;
                n && (r = !r),
                  x(r),
                  e.blending === mo && !1 === e.transparent
                    ? v(fo)
                    : v(
                        e.blending,
                        e.blendEquation,
                        e.blendSrc,
                        e.blendDst,
                        e.blendEquationAlpha,
                        e.blendSrcAlpha,
                        e.blendDstAlpha,
                        e.premultipliedAlpha
                      ),
                  O.setFunc(e.depthFunc),
                  O.setTest(e.depthTest),
                  O.setMask(e.depthWrite),
                  P.setMask(e.colorWrite),
                  w(
                    e.polygonOffset,
                    e.polygonOffsetFactor,
                    e.polygonOffsetUnits
                  );
              }
              function x(e) {
                J !== e &&
                  (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (J = e));
              }
              function b(e) {
                e !== no
                  ? (d(t.CULL_FACE),
                    e !== Z &&
                      (e === ro
                        ? t.cullFace(t.BACK)
                        : e === io
                        ? t.cullFace(t.FRONT)
                        : t.cullFace(t.FRONT_AND_BACK)))
                  : f(t.CULL_FACE),
                  (Z = e);
              }
              function _(e) {
                e !== Q && (et && t.lineWidth(e), (Q = e));
              }
              function w(e, n, r) {
                e
                  ? (d(t.POLYGON_OFFSET_FILL),
                    (K === n && $ === r) ||
                      (t.polygonOffset(n, r), (K = n), ($ = r)))
                  : f(t.POLYGON_OFFSET_FILL);
              }
              function M(e) {
                e ? d(t.SCISSOR_TEST) : f(t.SCISSOR_TEST);
              }
              function E(e) {
                void 0 === e && (e = t.TEXTURE0 + tt - 1),
                  it !== e && (t.activeTexture(e), (it = e));
              }
              function T(e, n) {
                null === it && E();
                var r = at[it];
                void 0 === r &&
                  ((r = { type: void 0, texture: void 0 }), (at[it] = r)),
                  (r.type === e && r.texture === n) ||
                    (t.bindTexture(e, n || ct[e]),
                    (r.type = e),
                    (r.texture = n));
              }
              function S() {
                try {
                  t.compressedTexImage2D.apply(t, arguments);
                } catch (t) {
                  console.error("THREE.WebGLState:", t);
                }
              }
              function A() {
                try {
                  t.texImage2D.apply(t, arguments);
                } catch (t) {
                  console.error("THREE.WebGLState:", t);
                }
              }
              function L(e) {
                !1 === ot.equals(e) &&
                  (t.scissor(e.x, e.y, e.z, e.w), ot.copy(e));
              }
              function R(e) {
                !1 === st.equals(e) &&
                  (t.viewport(e.x, e.y, e.z, e.w), st.copy(e));
              }
              function C() {
                for (var e = 0; e < U.length; e++)
                  1 === U[e] && (t.disableVertexAttribArray(e), (U[e] = 0));
                (F = {}),
                  (z = null),
                  (it = null),
                  (at = {}),
                  (G = null),
                  (H = null),
                  (J = null),
                  (Z = null),
                  P.reset(),
                  O.reset(),
                  I.reset();
              }
              var P = new i(),
                O = new a(),
                I = new o(),
                N = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                D = new Uint8Array(N),
                U = new Uint8Array(N),
                B = new Uint8Array(N),
                F = {},
                z = null,
                G = null,
                H = null,
                V = null,
                k = null,
                j = null,
                W = null,
                X = null,
                q = null,
                Y = !1,
                J = null,
                Z = null,
                Q = null,
                K = null,
                $ = null,
                tt = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                et = !1,
                nt = 0,
                rt = t.getParameter(t.VERSION);
              -1 !== rt.indexOf("WebGL")
                ? ((nt = parseFloat(/^WebGL\ ([0-9])/.exec(rt)[1])),
                  (et = nt >= 1))
                : -1 !== rt.indexOf("OpenGL ES") &&
                  ((nt = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(rt)[1])),
                  (et = nt >= 2));
              var it = null,
                at = {},
                ot = new c(),
                st = new c(),
                ct = {};
              return (
                (ct[t.TEXTURE_2D] = s(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
                (ct[t.TEXTURE_CUBE_MAP] = s(
                  t.TEXTURE_CUBE_MAP,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X,
                  6
                )),
                P.setClear(0, 0, 0, 1),
                O.setClear(1),
                I.setClear(0),
                d(t.DEPTH_TEST),
                O.setFunc(zo),
                x(!1),
                b(ro),
                d(t.CULL_FACE),
                d(t.BLEND),
                v(mo),
                {
                  buffers: { color: P, depth: O, stencil: I },
                  initAttributes: h,
                  enableAttribute: l,
                  enableAttributeAndDivisor: u,
                  disableUnusedAttributes: p,
                  enable: d,
                  disable: f,
                  getCompressedTextureFormats: m,
                  useProgram: g,
                  setBlending: v,
                  setMaterial: y,
                  setFlipSided: x,
                  setCullFace: b,
                  setLineWidth: _,
                  setPolygonOffset: w,
                  setScissorTest: M,
                  activeTexture: E,
                  bindTexture: T,
                  compressedTexImage2D: S,
                  texImage2D: A,
                  scissor: L,
                  viewport: R,
                  reset: C,
                }
              );
            }
            function ye(t, e, n, r, i, a, o) {
              function s(t, e) {
                if (t.width > e || t.height > e) {
                  if ("data" in t)
                    return void console.warn(
                      "THREE.WebGLRenderer: image in DataTexture is too big (" +
                        t.width +
                        "x" +
                        t.height +
                        ")."
                    );
                  var n = e / Math.max(t.width, t.height),
                    r = document.createElementNS(
                      "http://www.w3.org/1999/xhtml",
                      "canvas"
                    );
                  (r.width = Math.floor(t.width * n)),
                    (r.height = Math.floor(t.height * n));
                  return (
                    r
                      .getContext("2d")
                      .drawImage(
                        t,
                        0,
                        0,
                        t.width,
                        t.height,
                        0,
                        0,
                        r.width,
                        r.height
                      ),
                    console.warn(
                      "THREE.WebGLRenderer: image is too big (" +
                        t.width +
                        "x" +
                        t.height +
                        "). Resized to " +
                        r.width +
                        "x" +
                        r.height
                    ),
                    r
                  );
                }
                return t;
              }
              function c(t) {
                return xc.isPowerOfTwo(t.width) && xc.isPowerOfTwo(t.height);
              }
              function h(t) {
                if (
                  t instanceof HTMLImageElement ||
                  t instanceof HTMLCanvasElement ||
                  t instanceof ImageBitmap
                ) {
                  void 0 === P &&
                    (P = document.createElementNS(
                      "http://www.w3.org/1999/xhtml",
                      "canvas"
                    )),
                    (P.width = xc.floorPowerOfTwo(t.width)),
                    (P.height = xc.floorPowerOfTwo(t.height));
                  return (
                    P.getContext("2d").drawImage(t, 0, 0, P.width, P.height),
                    console.warn(
                      "THREE.WebGLRenderer: image is not power of two (" +
                        t.width +
                        "x" +
                        t.height +
                        "). Resized to " +
                        P.width +
                        "x" +
                        P.height
                    ),
                    P
                  );
                }
                return t;
              }
              function l(t) {
                return (
                  !i.isWebGL2 &&
                  (t.wrapS !== os ||
                    t.wrapT !== os ||
                    (t.minFilter !== cs && t.minFilter !== us))
                );
              }
              function u(t, e) {
                return (
                  t.generateMipmaps &&
                  e &&
                  t.minFilter !== cs &&
                  t.minFilter !== us
                );
              }
              function p(e, n, i, a) {
                t.generateMipmap(e),
                  (r.get(n).__maxMipLevel =
                    Math.log(Math.max(i, a)) * Math.LOG2E);
              }
              function d(e, n) {
                if (!i.isWebGL2) return e;
                if (e === t.RGB) {
                  if (n === t.FLOAT) return t.RGB32F;
                  if (n === t.HALF_FLOAT) return t.RGB16F;
                  if (n === t.UNSIGNED_BYTE) return t.RGB8;
                }
                if (e === t.RGBA) {
                  if (n === t.FLOAT) return t.RGBA32F;
                  if (n === t.HALF_FLOAT) return t.RGBA16F;
                  if (n === t.UNSIGNED_BYTE) return t.RGBA8;
                }
                return e;
              }
              function f(e) {
                return e === cs || e === hs || e === ls ? t.NEAREST : t.LINEAR;
              }
              function m(t) {
                var e = t.target;
                e.removeEventListener("dispose", m),
                  v(e),
                  e.isVideoTexture && delete O[e.id],
                  o.memory.textures--;
              }
              function g(t) {
                var e = t.target;
                e.removeEventListener("dispose", g), y(e), o.memory.textures--;
              }
              function v(e) {
                var n = r.get(e);
                if (e.image && n.__image__webglTextureCube)
                  t.deleteTexture(n.__image__webglTextureCube);
                else {
                  if (void 0 === n.__webglInit) return;
                  t.deleteTexture(n.__webglTexture);
                }
                r.remove(e);
              }
              function y(e) {
                var n = r.get(e),
                  i = r.get(e.texture);
                if (e) {
                  if (
                    (void 0 !== i.__webglTexture &&
                      t.deleteTexture(i.__webglTexture),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLRenderTargetCube)
                  )
                    for (var a = 0; a < 6; a++)
                      t.deleteFramebuffer(n.__webglFramebuffer[a]),
                        n.__webglDepthbuffer &&
                          t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                  else
                    t.deleteFramebuffer(n.__webglFramebuffer),
                      n.__webglDepthbuffer &&
                        t.deleteRenderbuffer(n.__webglDepthbuffer);
                  r.remove(e.texture), r.remove(e);
                }
              }
              function x(e, i) {
                var a = r.get(e);
                if (
                  (e.isVideoTexture && C(e),
                  e.version > 0 && a.__version !== e.version)
                ) {
                  var o = e.image;
                  if (void 0 === o)
                    console.warn(
                      "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                    );
                  else {
                    if (!1 !== o.complete) return void M(a, e, i);
                    console.warn(
                      "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                    );
                  }
                }
                n.activeTexture(t.TEXTURE0 + i),
                  n.bindTexture(t.TEXTURE_2D, a.__webglTexture);
              }
              function b(e, h) {
                var l = r.get(e);
                if (6 === e.image.length)
                  if (e.version > 0 && l.__version !== e.version) {
                    l.__image__webglTextureCube ||
                      (e.addEventListener("dispose", m),
                      (l.__image__webglTextureCube = t.createTexture()),
                      o.memory.textures++),
                      n.activeTexture(t.TEXTURE0 + h),
                      n.bindTexture(
                        t.TEXTURE_CUBE_MAP,
                        l.__image__webglTextureCube
                      ),
                      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (
                      var f = e && e.isCompressedTexture,
                        g = e.image[0] && e.image[0].isDataTexture,
                        v = [],
                        y = 0;
                      y < 6;
                      y++
                    )
                      v[y] =
                        f || g
                          ? g
                            ? e.image[y].image
                            : e.image[y]
                          : s(e.image[y], i.maxCubemapSize);
                    var x = v[0],
                      b = c(x),
                      _ = a.convert(e.format),
                      M = a.convert(e.type),
                      E = d(_, M);
                    w(t.TEXTURE_CUBE_MAP, e, b);
                    for (var y = 0; y < 6; y++)
                      if (f)
                        for (
                          var T, S = v[y].mipmaps, A = 0, L = S.length;
                          A < L;
                          A++
                        )
                          (T = S[A]),
                            e.format !== Ls && e.format !== As
                              ? n.getCompressedTextureFormats().indexOf(_) > -1
                                ? n.compressedTexImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + y,
                                    A,
                                    E,
                                    T.width,
                                    T.height,
                                    0,
                                    T.data
                                  )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + y,
                                  A,
                                  E,
                                  T.width,
                                  T.height,
                                  0,
                                  _,
                                  M,
                                  T.data
                                );
                      else
                        g
                          ? n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + y,
                              0,
                              E,
                              v[y].width,
                              v[y].height,
                              0,
                              _,
                              M,
                              v[y].data
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + y,
                              0,
                              E,
                              _,
                              M,
                              v[y]
                            );
                    (l.__maxMipLevel = f ? S.length - 1 : 0),
                      u(e, b) && p(t.TEXTURE_CUBE_MAP, e, x.width, x.height),
                      (l.__version = e.version),
                      e.onUpdate && e.onUpdate(e);
                  } else
                    n.activeTexture(t.TEXTURE0 + h),
                      n.bindTexture(
                        t.TEXTURE_CUBE_MAP,
                        l.__image__webglTextureCube
                      );
              }
              function _(e, i) {
                n.activeTexture(t.TEXTURE0 + i),
                  n.bindTexture(t.TEXTURE_CUBE_MAP, r.get(e).__webglTexture);
              }
              function w(n, o, s) {
                var c;
                if (
                  (s
                    ? (t.texParameteri(n, t.TEXTURE_WRAP_S, a.convert(o.wrapS)),
                      t.texParameteri(n, t.TEXTURE_WRAP_T, a.convert(o.wrapT)),
                      t.texParameteri(
                        n,
                        t.TEXTURE_MAG_FILTER,
                        a.convert(o.magFilter)
                      ),
                      t.texParameteri(
                        n,
                        t.TEXTURE_MIN_FILTER,
                        a.convert(o.minFilter)
                      ))
                    : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                      t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                      (o.wrapS === os && o.wrapT === os) ||
                        console.warn(
                          "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                        ),
                      t.texParameteri(n, t.TEXTURE_MAG_FILTER, f(o.magFilter)),
                      t.texParameteri(n, t.TEXTURE_MIN_FILTER, f(o.minFilter)),
                      o.minFilter !== cs &&
                        o.minFilter !== us &&
                        console.warn(
                          "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                        )),
                  (c = e.get("EXT_texture_filter_anisotropic")))
                ) {
                  if (
                    o.type === bs &&
                    null === e.get("OES_texture_float_linear")
                  )
                    return;
                  if (
                    o.type === _s &&
                    null ===
                      (i.isWebGL2 || e.get("OES_texture_half_float_linear"))
                  )
                    return;
                  (o.anisotropy > 1 || r.get(o).__currentAnisotropy) &&
                    (t.texParameterf(
                      n,
                      c.TEXTURE_MAX_ANISOTROPY_EXT,
                      Math.min(o.anisotropy, i.getMaxAnisotropy())
                    ),
                    (r.get(o).__currentAnisotropy = o.anisotropy));
                }
              }
              function M(e, r, f) {
                void 0 === e.__webglInit &&
                  ((e.__webglInit = !0),
                  r.addEventListener("dispose", m),
                  (e.__webglTexture = t.createTexture()),
                  o.memory.textures++),
                  n.activeTexture(t.TEXTURE0 + f),
                  n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
                  t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                  t.pixelStorei(
                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    r.premultiplyAlpha
                  ),
                  t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment);
                var g = s(r.image, i.maxTextureSize);
                l(r) && !1 === c(g) && (g = h(g));
                var v = c(g),
                  y = a.convert(r.format),
                  x = a.convert(r.type),
                  b = d(y, x);
                w(t.TEXTURE_2D, r, v);
                var _,
                  M = r.mipmaps;
                if (r.isDepthTexture) {
                  if (((b = t.DEPTH_COMPONENT), r.type === bs)) {
                    if (!i.isWebGL2)
                      throw new Error(
                        "Float Depth Texture only supported in WebGL2.0"
                      );
                    b = t.DEPTH_COMPONENT32F;
                  } else i.isWebGL2 && (b = t.DEPTH_COMPONENT16);
                  r.format === Os &&
                    b === t.DEPTH_COMPONENT &&
                    r.type !== vs &&
                    r.type !== xs &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (r.type = vs),
                    (x = a.convert(r.type))),
                    r.format === Is &&
                      ((b = t.DEPTH_STENCIL),
                      r.type !== Ts &&
                        (console.warn(
                          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                        ),
                        (r.type = Ts),
                        (x = a.convert(r.type)))),
                    n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      b,
                      g.width,
                      g.height,
                      0,
                      y,
                      x,
                      null
                    );
                } else if (r.isDataTexture)
                  if (M.length > 0 && v) {
                    for (var E = 0, T = M.length; E < T; E++)
                      (_ = M[E]),
                        n.texImage2D(
                          t.TEXTURE_2D,
                          E,
                          b,
                          _.width,
                          _.height,
                          0,
                          y,
                          x,
                          _.data
                        );
                    (r.generateMipmaps = !1), (e.__maxMipLevel = M.length - 1);
                  } else
                    n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      b,
                      g.width,
                      g.height,
                      0,
                      y,
                      x,
                      g.data
                    ),
                      (e.__maxMipLevel = 0);
                else if (r.isCompressedTexture) {
                  for (var E = 0, T = M.length; E < T; E++)
                    (_ = M[E]),
                      r.format !== Ls && r.format !== As
                        ? n.getCompressedTextureFormats().indexOf(y) > -1
                          ? n.compressedTexImage2D(
                              t.TEXTURE_2D,
                              E,
                              b,
                              _.width,
                              _.height,
                              0,
                              _.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : n.texImage2D(
                            t.TEXTURE_2D,
                            E,
                            b,
                            _.width,
                            _.height,
                            0,
                            y,
                            x,
                            _.data
                          );
                  e.__maxMipLevel = M.length - 1;
                } else if (M.length > 0 && v) {
                  for (var E = 0, T = M.length; E < T; E++)
                    (_ = M[E]), n.texImage2D(t.TEXTURE_2D, E, b, y, x, _);
                  (r.generateMipmaps = !1), (e.__maxMipLevel = M.length - 1);
                } else
                  n.texImage2D(t.TEXTURE_2D, 0, b, y, x, g),
                    (e.__maxMipLevel = 0);
                u(r, v) && p(t.TEXTURE_2D, r, g.width, g.height),
                  (e.__version = r.version),
                  r.onUpdate && r.onUpdate(r);
              }
              function E(e, i, o, s) {
                var c = a.convert(i.texture.format),
                  h = a.convert(i.texture.type),
                  l = d(c, h);
                n.texImage2D(s, 0, l, i.width, i.height, 0, c, h, null),
                  t.bindFramebuffer(t.FRAMEBUFFER, e),
                  t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    o,
                    s,
                    r.get(i.texture).__webglTexture,
                    0
                  ),
                  t.bindFramebuffer(t.FRAMEBUFFER, null);
              }
              function T(e, n) {
                t.bindRenderbuffer(t.RENDERBUFFER, e),
                  n.depthBuffer && !n.stencilBuffer
                    ? (t.renderbufferStorage(
                        t.RENDERBUFFER,
                        t.DEPTH_COMPONENT16,
                        n.width,
                        n.height
                      ),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.DEPTH_ATTACHMENT,
                        t.RENDERBUFFER,
                        e
                      ))
                    : n.depthBuffer && n.stencilBuffer
                    ? (t.renderbufferStorage(
                        t.RENDERBUFFER,
                        t.DEPTH_STENCIL,
                        n.width,
                        n.height
                      ),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.RENDERBUFFER,
                        e
                      ))
                    : t.renderbufferStorage(
                        t.RENDERBUFFER,
                        t.RGBA4,
                        n.width,
                        n.height
                      ),
                  t.bindRenderbuffer(t.RENDERBUFFER, null);
              }
              function S(e, n) {
                if (n && n.isWebGLRenderTargetCube)
                  throw new Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                if (
                  (t.bindFramebuffer(t.FRAMEBUFFER, e),
                  !n.depthTexture || !n.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (r.get(n.depthTexture).__webglTexture &&
                  n.depthTexture.image.width === n.width &&
                  n.depthTexture.image.height === n.height) ||
                  ((n.depthTexture.image.width = n.width),
                  (n.depthTexture.image.height = n.height),
                  (n.depthTexture.needsUpdate = !0)),
                  x(n.depthTexture, 0);
                var i = r.get(n.depthTexture).__webglTexture;
                if (n.depthTexture.format === Os)
                  t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.DEPTH_ATTACHMENT,
                    t.TEXTURE_2D,
                    i,
                    0
                  );
                else {
                  if (n.depthTexture.format !== Is)
                    throw new Error("Unknown depthTexture format");
                  t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.DEPTH_STENCIL_ATTACHMENT,
                    t.TEXTURE_2D,
                    i,
                    0
                  );
                }
              }
              function A(e) {
                var n = r.get(e),
                  i = !0 === e.isWebGLRenderTargetCube;
                if (e.depthTexture) {
                  if (i)
                    throw new Error(
                      "target.depthTexture not supported in Cube render targets"
                    );
                  S(n.__webglFramebuffer, e);
                } else if (i) {
                  n.__webglDepthbuffer = [];
                  for (var a = 0; a < 6; a++)
                    t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]),
                      (n.__webglDepthbuffer[a] = t.createRenderbuffer()),
                      T(n.__webglDepthbuffer[a], e);
                } else
                  t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
                    (n.__webglDepthbuffer = t.createRenderbuffer()),
                    T(n.__webglDepthbuffer, e);
                t.bindFramebuffer(t.FRAMEBUFFER, null);
              }
              function L(e) {
                var i = r.get(e),
                  a = r.get(e.texture);
                e.addEventListener("dispose", g),
                  (a.__webglTexture = t.createTexture()),
                  o.memory.textures++;
                var s = !0 === e.isWebGLRenderTargetCube,
                  h = c(e);
                if (s) {
                  i.__webglFramebuffer = [];
                  for (var l = 0; l < 6; l++)
                    i.__webglFramebuffer[l] = t.createFramebuffer();
                } else i.__webglFramebuffer = t.createFramebuffer();
                if (s) {
                  n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture),
                    w(t.TEXTURE_CUBE_MAP, e.texture, h);
                  for (var l = 0; l < 6; l++)
                    E(
                      i.__webglFramebuffer[l],
                      e,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + l
                    );
                  u(e.texture, h) &&
                    p(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height),
                    n.bindTexture(t.TEXTURE_CUBE_MAP, null);
                } else n.bindTexture(t.TEXTURE_2D, a.__webglTexture), w(t.TEXTURE_2D, e.texture, h), E(i.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), u(e.texture, h) && p(t.TEXTURE_2D, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_2D, null);
                e.depthBuffer && A(e);
              }
              function R(e) {
                var i = e.texture;
                if (u(i, c(e))) {
                  var a = e.isWebGLRenderTargetCube
                      ? t.TEXTURE_CUBE_MAP
                      : t.TEXTURE_2D,
                    o = r.get(i).__webglTexture;
                  n.bindTexture(a, o),
                    p(a, i, e.width, e.height),
                    n.bindTexture(a, null);
                }
              }
              function C(t) {
                var e = t.id,
                  n = o.render.frame;
                O[e] !== n && ((O[e] = n), t.update());
              }
              var P,
                O = {};
              (this.setTexture2D = x),
                (this.setTextureCube = b),
                (this.setTextureCubeDynamic = _),
                (this.setupRenderTarget = L),
                (this.updateRenderTargetMipmap = R);
            }
            function xe(t, e, n) {
              function r(r) {
                var i;
                if (r === as) return t.REPEAT;
                if (r === os) return t.CLAMP_TO_EDGE;
                if (r === ss) return t.MIRRORED_REPEAT;
                if (r === cs) return t.NEAREST;
                if (r === hs) return t.NEAREST_MIPMAP_NEAREST;
                if (r === ls) return t.NEAREST_MIPMAP_LINEAR;
                if (r === us) return t.LINEAR;
                if (r === ps) return t.LINEAR_MIPMAP_NEAREST;
                if (r === ds) return t.LINEAR_MIPMAP_LINEAR;
                if (r === fs) return t.UNSIGNED_BYTE;
                if (r === ws) return t.UNSIGNED_SHORT_4_4_4_4;
                if (r === Ms) return t.UNSIGNED_SHORT_5_5_5_1;
                if (r === Es) return t.UNSIGNED_SHORT_5_6_5;
                if (r === ms) return t.BYTE;
                if (r === gs) return t.SHORT;
                if (r === vs) return t.UNSIGNED_SHORT;
                if (r === ys) return t.INT;
                if (r === xs) return t.UNSIGNED_INT;
                if (r === bs) return t.FLOAT;
                if (r === _s) {
                  if (n.isWebGL2) return t.HALF_FLOAT;
                  if (null !== (i = e.get("OES_texture_half_float")))
                    return i.HALF_FLOAT_OES;
                }
                if (r === Ss) return t.ALPHA;
                if (r === As) return t.RGB;
                if (r === Ls) return t.RGBA;
                if (r === Rs) return t.LUMINANCE;
                if (r === Cs) return t.LUMINANCE_ALPHA;
                if (r === Os) return t.DEPTH_COMPONENT;
                if (r === Is) return t.DEPTH_STENCIL;
                if (r === bo) return t.FUNC_ADD;
                if (r === _o) return t.FUNC_SUBTRACT;
                if (r === wo) return t.FUNC_REVERSE_SUBTRACT;
                if (r === To) return t.ZERO;
                if (r === So) return t.ONE;
                if (r === Ao) return t.SRC_COLOR;
                if (r === Lo) return t.ONE_MINUS_SRC_COLOR;
                if (r === Ro) return t.SRC_ALPHA;
                if (r === Co) return t.ONE_MINUS_SRC_ALPHA;
                if (r === Po) return t.DST_ALPHA;
                if (r === Oo) return t.ONE_MINUS_DST_ALPHA;
                if (r === Io) return t.DST_COLOR;
                if (r === No) return t.ONE_MINUS_DST_COLOR;
                if (r === Do) return t.SRC_ALPHA_SATURATE;
                if (
                  (r === Ns || r === Ds || r === Us || r === Bs) &&
                  null !== (i = e.get("WEBGL_compressed_texture_s3tc"))
                ) {
                  if (r === Ns) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (r === Ds) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (r === Us) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (r === Bs) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
                if (
                  (r === Fs || r === zs || r === Gs || r === Hs) &&
                  null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))
                ) {
                  if (r === Fs) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (r === zs) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (r === Gs) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (r === Hs) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
                if (
                  r === Vs &&
                  null !== (i = e.get("WEBGL_compressed_texture_etc1"))
                )
                  return i.COMPRESSED_RGB_ETC1_WEBGL;
                if (
                  (r === ks ||
                    r === js ||
                    r === Ws ||
                    r === Xs ||
                    r === qs ||
                    r === Ys ||
                    r === Js ||
                    r === Zs ||
                    r === Qs ||
                    r === Ks ||
                    r === $s ||
                    r === tc ||
                    r === ec ||
                    r === nc) &&
                  null !== (i = e.get("WEBGL_compressed_texture_astc"))
                )
                  return r;
                if (r === Mo || r === Eo) {
                  if (n.isWebGL2) {
                    if (r === Mo) return t.MIN;
                    if (r === Eo) return t.MAX;
                  }
                  if (null !== (i = e.get("EXT_blend_minmax"))) {
                    if (r === Mo) return i.MIN_EXT;
                    if (r === Eo) return i.MAX_EXT;
                  }
                }
                if (r === Ts) {
                  if (n.isWebGL2) return t.UNSIGNED_INT_24_8;
                  if (null !== (i = e.get("WEBGL_depth_texture")))
                    return i.UNSIGNED_INT_24_8_WEBGL;
                }
                return 0;
              }
              return { convert: r };
            }
            function be() {
              _.call(this), (this.type = "Group");
            }
            function _e(t, e, n, r) {
              w.call(this),
                (this.type = "PerspectiveCamera"),
                (this.fov = void 0 !== t ? t : 50),
                (this.zoom = 1),
                (this.near = void 0 !== n ? n : 0.1),
                (this.far = void 0 !== r ? r : 2e3),
                (this.focus = 10),
                (this.aspect = void 0 !== e ? e : 1),
                (this.view = null),
                (this.filmGauge = 35),
                (this.filmOffset = 0),
                this.updateProjectionMatrix();
            }
            function we(t) {
              _e.call(this), (this.cameras = t || []);
            }
            function Me(t) {
              function e() {
                return null !== h && !0 === h.isPresenting;
              }
              function n(t) {
                for (
                  var e = navigator.getGamepads && navigator.getGamepads(),
                    n = 0,
                    r = 0,
                    i = e.length;
                  n < i;
                  n++
                ) {
                  var a = e[n];
                  if (
                    a &&
                    ("Daydream Controller" === a.id ||
                      "Gear VR Controller" === a.id ||
                      "Oculus Go Controller" === a.id ||
                      "OpenVR Gamepad" === a.id ||
                      a.id.startsWith("Oculus Touch") ||
                      a.id.startsWith("Spatial Controller"))
                  ) {
                    if (r === t) return a;
                    r++;
                  }
                }
              }
              function o() {
                for (var t = 0; t < p.length; t++) {
                  var e = p[t],
                    r = n(t);
                  if (void 0 !== r && void 0 !== r.pose) {
                    if (null === r.pose) return;
                    var i = r.pose;
                    !1 === i.hasPosition && e.position.set(0.2, -0.6, -0.05),
                      null !== i.position && e.position.fromArray(i.position),
                      null !== i.orientation &&
                        e.quaternion.fromArray(i.orientation),
                      e.matrix.compose(e.position, e.quaternion, e.scale),
                      e.matrix.premultiply(d),
                      e.matrix.decompose(e.position, e.quaternion, e.scale),
                      (e.matrixWorldNeedsUpdate = !0),
                      (e.visible = !0);
                    var a = "Daydream Controller" === r.id ? 0 : 1;
                    w[t] !== r.buttons[a].pressed &&
                      ((w[t] = r.buttons[a].pressed),
                      !0 === w[t]
                        ? e.dispatchEvent({ type: "selectstart" })
                        : (e.dispatchEvent({ type: "selectend" }),
                          e.dispatchEvent({ type: "select" })));
                  } else e.visible = !1;
                }
              }
              if (!window.vrDisabled) {
                var s = this,
                  h = null,
                  l = null,
                  u = null,
                  p = [],
                  d = new r(),
                  f = new r();
                "undefined" != typeof window &&
                  "VRFrameData" in window &&
                  (l = new window.VRFrameData());
                var m = new r(),
                  g = new i(),
                  y = new a(),
                  x = new _e();
                (x.bounds = new c(0, 0, 0.5, 1)), x.layers.enable(1);
                var b = new _e();
                (b.bounds = new c(0.5, 0, 0.5, 1)), b.layers.enable(2);
                var _ = new we([x, b]);
                _.layers.enable(1), _.layers.enable(2);
                var w = [];
                (this.enabled = !1),
                  (this.userHeight = 1.6),
                  (this.getController = function (t) {
                    var e = p[t];
                    return (
                      void 0 === e &&
                        ((e = new be()),
                        (e.matrixAutoUpdate = !1),
                        (e.visible = !1),
                        (p[t] = e)),
                      e
                    );
                  }),
                  (this.getDevice = function () {
                    return h;
                  }),
                  (this.setDevice = function (t) {
                    void 0 !== t && (h = t), M.setContext(t);
                  }),
                  (this.setPoseTarget = function (t) {
                    void 0 !== t && (u = t);
                  }),
                  (this.getCamera = function (t) {
                    if (null === h)
                      return t.position.set(0, s.userHeight, 0), t;
                    (h.depthNear = t.near),
                      (h.depthFar = t.far),
                      h.getFrameData(l);
                    var e = h.stageParameters;
                    e
                      ? d.fromArray(e.sittingToStandingTransform)
                      : d.makeTranslation(0, s.userHeight, 0);
                    var n = l.pose,
                      r = null !== u ? u : t;
                    if (
                      (r.matrix.copy(d),
                      r.matrix.decompose(r.position, r.quaternion, r.scale),
                      null !== n.orientation &&
                        (g.fromArray(n.orientation), r.quaternion.multiply(g)),
                      null !== n.position &&
                        (g.setFromRotationMatrix(d),
                        y.fromArray(n.position),
                        y.applyQuaternion(g),
                        r.position.add(y)),
                      r.updateMatrixWorld(),
                      !1 === h.isPresenting)
                    )
                      return t;
                    (x.near = t.near),
                      (b.near = t.near),
                      (x.far = t.far),
                      (b.far = t.far),
                      _.matrixWorld.copy(t.matrixWorld),
                      _.matrixWorldInverse.copy(t.matrixWorldInverse),
                      x.matrixWorldInverse.fromArray(l.leftViewMatrix),
                      b.matrixWorldInverse.fromArray(l.rightViewMatrix),
                      f.getInverse(d),
                      x.matrixWorldInverse.multiply(f),
                      b.matrixWorldInverse.multiply(f);
                    var i = r.parent;
                    null !== i &&
                      (m.getInverse(i.matrixWorld),
                      x.matrixWorldInverse.multiply(m),
                      b.matrixWorldInverse.multiply(m)),
                      x.matrixWorld.getInverse(x.matrixWorldInverse),
                      b.matrixWorld.getInverse(b.matrixWorldInverse),
                      x.projectionMatrix.fromArray(l.leftProjectionMatrix),
                      b.projectionMatrix.fromArray(l.rightProjectionMatrix),
                      _.projectionMatrix.copy(x.projectionMatrix);
                    var a = h.getLayers();
                    if (a.length) {
                      var c = a[0];
                      null !== c.leftBounds &&
                        4 === c.leftBounds.length &&
                        x.bounds.fromArray(c.leftBounds),
                        null !== c.rightBounds &&
                          4 === c.rightBounds.length &&
                          b.bounds.fromArray(c.rightBounds);
                    }
                    return o(), _;
                  }),
                  (this.getStandingMatrix = function () {
                    return d;
                  }),
                  (this.isPresenting = e);
                var M = new v();
                (this.setAnimationLoop = function (t) {
                  M.setAnimationLoop(t);
                }),
                  (this.submitFrame = function () {
                    e() && h.submitFrame();
                  }),
                  (this.dispose = function () {});
              }
            }
            function Ee(t) {
              function e() {
                return null !== h && null !== l;
              }
              function n(t) {
                var e = p[d.indexOf(t.inputSource)];
                e && e.dispatchEvent({ type: t.type });
              }
              function r() {
                t.setFramebuffer(null), x.stop();
              }
              function i(t, e) {
                null === e
                  ? t.matrixWorld.copy(t.matrix)
                  : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                  t.matrixWorldInverse.getInverse(t.matrixWorld);
              }
              function a(t, e) {
                if (null !== (u = e.getDevicePose(l)))
                  for (
                    var n = h.baseLayer, r = e.views, i = 0;
                    i < r.length;
                    i++
                  ) {
                    var a = r[i],
                      o = n.getViewport(a),
                      s = u.getViewMatrix(a),
                      c = g.cameras[i];
                    c.matrix.fromArray(s).getInverse(c.matrix),
                      c.projectionMatrix.fromArray(a.projectionMatrix),
                      c.viewport.set(o.x, o.y, o.width, o.height),
                      0 === i &&
                        (g.matrix.copy(c.matrix),
                        g.projectionMatrix.copy(c.projectionMatrix));
                  }
                for (var i = 0; i < p.length; i++) {
                  var f = p[i],
                    m = d[i];
                  if (m) {
                    var v = e.getInputPose(m, l);
                    if (null !== v) {
                      (f.matrix.elements = v.pointerMatrix),
                        f.matrix.decompose(f.position, f.rotation, f.scale),
                        (f.visible = !0);
                      continue;
                    }
                  }
                  f.visible = !1;
                }
                y && y(t);
              }
              var o = t.context,
                s = null,
                h = null,
                l = null,
                u = null,
                p = [],
                d = [],
                f = new _e();
              f.layers.enable(1), (f.viewport = new c());
              var m = new _e();
              m.layers.enable(2), (m.viewport = new c());
              var g = new we([f, m]);
              g.layers.enable(1),
                g.layers.enable(2),
                (this.enabled = !1),
                (this.getController = function (t) {
                  var e = p[t];
                  return (
                    void 0 === e &&
                      ((e = new be()),
                      (e.matrixAutoUpdate = !1),
                      (e.visible = !1),
                      (p[t] = e)),
                    e
                  );
                }),
                (this.getDevice = function () {
                  return s;
                }),
                (this.setDevice = function (t) {
                  void 0 !== t && (s = t),
                    t instanceof XRDevice && o.setCompatibleXRDevice(t);
                }),
                (this.setSession = function (e, i) {
                  null !== (h = e) &&
                    (h.addEventListener("select", n),
                    h.addEventListener("selectstart", n),
                    h.addEventListener("selectend", n),
                    h.addEventListener("end", r),
                    (h.baseLayer = new XRWebGLLayer(h, o)),
                    h
                      .requestFrameOfReference(i.frameOfReferenceType)
                      .then(function (e) {
                        (l = e),
                          t.setFramebuffer(h.baseLayer.framebuffer),
                          x.setContext(h),
                          x.start();
                      }),
                    (d = h.getInputSources()),
                    h.addEventListener("inputsourceschange", function () {
                      (d = h.getInputSources()), console.log(d);
                    }));
                }),
                (this.getCamera = function (t) {
                  if (e()) {
                    var n = t.parent,
                      r = g.cameras;
                    i(g, n);
                    for (var a = 0; a < r.length; a++) i(r[a], n);
                    t.matrixWorld.copy(g.matrixWorld);
                    for (var o = t.children, a = 0, s = o.length; a < s; a++)
                      o[a].updateMatrixWorld(!0);
                    return g;
                  }
                  return t;
                }),
                (this.isPresenting = e);
              var y = null,
                x = new v();
              x.setAnimationLoop(a),
                (this.setAnimationLoop = function (t) {
                  y = t;
                }),
                (this.dispose = function () {}),
                (this.getStandingMatrix = function () {
                  return (
                    console.warn(
                      "THREE.WebXRManager: getStandingMatrix() is no longer needed."
                    ),
                    new THREE.Matrix4()
                  );
                }),
                (this.submitFrame = function () {});
            }
            function Te(t) {
              function e() {
                return null === lt ? wt : 1;
              }
              function n() {
                (It = new $(ot)),
                  (Nt = new Q(ot, It, t)),
                  Nt.isWebGL2 ||
                    (It.get("WEBGL_depth_texture"),
                    It.get("OES_texture_float"),
                    It.get("OES_texture_half_float"),
                    It.get("OES_texture_half_float_linear"),
                    It.get("OES_standard_derivatives"),
                    It.get("OES_element_index_uint"),
                    It.get("ANGLE_instanced_arrays")),
                  It.get("OES_texture_float_linear"),
                  (Zt = new xe(ot, It, Nt)),
                  (Dt = new ve(ot, It, Zt, Nt)),
                  Dt.scissor(vt.copy(Et).multiplyScalar(wt)),
                  Dt.viewport(gt.copy(Mt).multiplyScalar(wt)),
                  (Ut = new nt(ot)),
                  (Bt = new ae()),
                  (Ft = new ye(ot, It, Dt, Bt, Nt, Zt, Ut)),
                  (zt = new y(ot)),
                  (Gt = new tt(ot, zt, Ut)),
                  (Ht = new at(Gt, Ut)),
                  (qt = new it(ot)),
                  (kt = new ie(st, It, Nt)),
                  (jt = new he()),
                  (Wt = new de()),
                  (Xt = new J(st, Dt, Ht, W)),
                  (Yt = new Z(ot, It, Ut, Nt)),
                  (Jt = new et(ot, It, Ut, Nt)),
                  (Ut.programs = kt.programs),
                  (st.context = ot),
                  (st.capabilities = Nt),
                  (st.extensions = It),
                  (st.properties = Bt),
                  (st.renderLists = jt),
                  (st.state = Dt),
                  (st.info = Ut);
              }
              function i(t) {
                t.preventDefault(),
                  console.log("THREE.WebGLRenderer: Context Lost."),
                  (ct = !0);
              }
              function o() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                  (ct = !1),
                  n();
              }
              function s(t) {
                var e = t.target;
                e.removeEventListener("dispose", s), h(e);
              }
              function h(t) {
                l(t), Bt.remove(t);
              }
              function l(t) {
                var e = Bt.get(t).program;
                (t.program = void 0), void 0 !== e && kt.releaseProgram(e);
              }
              function p(t, e) {
                t.render(function (t) {
                  st.renderBufferImmediate(t, e);
                });
              }
              function d(t, e, n) {
                if (
                  n &&
                  n.isInstancedBufferGeometry & !Nt.isWebGL2 &&
                  null === It.get("ANGLE_instanced_arrays")
                )
                  return void console.error(
                    "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                  );
                Dt.initAttributes();
                var r = n.attributes,
                  i = e.getAttributes(),
                  a = t.defaultAttributeValues;
                for (var o in i) {
                  var s = i[o];
                  if (s >= 0) {
                    var c = r[o];
                    if (void 0 !== c) {
                      var h = c.normalized,
                        l = c.itemSize,
                        u = zt.get(c);
                      if (void 0 === u) continue;
                      var p = u.buffer,
                        d = u.type,
                        f = u.bytesPerElement;
                      if (c.isInterleavedBufferAttribute) {
                        var m = c.data,
                          g = m.stride,
                          v = c.offset;
                        m && m.isInstancedInterleavedBuffer
                          ? (Dt.enableAttributeAndDivisor(
                              s,
                              m.meshPerAttribute
                            ),
                            void 0 === n.maxInstancedCount &&
                              (n.maxInstancedCount =
                                m.meshPerAttribute * m.count))
                          : Dt.enableAttribute(s),
                          ot.bindBuffer(ot.ARRAY_BUFFER, p),
                          ot.vertexAttribPointer(s, l, d, h, g * f, v * f);
                      } else
                        c.isInstancedBufferAttribute
                          ? (Dt.enableAttributeAndDivisor(
                              s,
                              c.meshPerAttribute
                            ),
                            void 0 === n.maxInstancedCount &&
                              (n.maxInstancedCount =
                                c.meshPerAttribute * c.count))
                          : Dt.enableAttribute(s),
                          ot.bindBuffer(ot.ARRAY_BUFFER, p),
                          ot.vertexAttribPointer(s, l, d, h, 0, 0);
                    } else if (void 0 !== a) {
                      var y = a[o];
                      if (void 0 !== y)
                        switch (y.length) {
                          case 2:
                            ot.vertexAttrib2fv(s, y);
                            break;
                          case 3:
                            ot.vertexAttrib3fv(s, y);
                            break;
                          case 4:
                            ot.vertexAttrib4fv(s, y);
                            break;
                          default:
                            ot.vertexAttrib1fv(s, y);
                        }
                    }
                  }
                }
                Dt.disableUnusedAttributes();
              }
              function f(t) {
                $t && $t(t);
              }
              function g(t, e, n) {
                if (!1 !== t.visible) {
                  if (t.layers.test(e.layers))
                    if (t.isLight)
                      rt.pushLight(t), t.castShadow && rt.pushShadow(t);
                    else if (t.isSprite) {
                      if (!t.frustumCulled || St.intersectsSprite(t)) {
                        n &&
                          Pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(
                            Ct
                          );
                        var r = Ht.update(t),
                          i = t.material;
                        Y.push(t, r, i, Pt.z, null);
                      }
                    } else if (t.isImmediateRenderObject)
                      n &&
                        Pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(
                          Ct
                        ),
                        Y.push(t, null, t.material, Pt.z, null);
                    else if (
                      (t.isMesh || t.isLine || t.isPoints) &&
                      (t.isSkinnedMesh && t.skeleton.update(),
                      !t.frustumCulled || St.intersectsObject(t))
                    ) {
                      n &&
                        Pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(
                          Ct
                        );
                      var r = Ht.update(t),
                        i = t.material;
                      if (Array.isArray(i))
                        for (
                          var a = r.groups, o = 0, s = a.length;
                          o < s;
                          o++
                        ) {
                          var c = a[o],
                            h = i[c.materialIndex];
                          h && h.visible && Y.push(t, r, h, Pt.z, c);
                        }
                      else i.visible && Y.push(t, r, i, Pt.z, null);
                    }
                  for (var l = t.children, o = 0, s = l.length; o < s; o++)
                    g(l[o], e, n);
                }
              }
              function x(t, e, n, r) {
                for (var i = 0, a = t.length; i < a; i++) {
                  var o = t[i],
                    s = o.object,
                    c = o.geometry,
                    h = void 0 === r ? o.material : r,
                    l = o.group;
                  if (n.isArrayCamera) {
                    mt = n;
                    for (var u = n.cameras, p = 0, d = u.length; p < d; p++) {
                      var f = u[p];
                      if (s.layers.test(f.layers)) {
                        if ("viewport" in f) Dt.viewport(gt.copy(f.viewport));
                        else {
                          var m = f.bounds,
                            g = m.x * bt,
                            v = m.y * _t,
                            y = m.z * bt,
                            x = m.w * _t;
                          Dt.viewport(gt.set(g, v, y, x).multiplyScalar(wt));
                        }
                        b(s, e, f, c, h, l);
                      }
                    }
                  } else (mt = null), b(s, e, n, c, h, l);
                }
              }
              function b(t, e, n, r, i, a) {
                if (
                  (t.onBeforeRender(st, e, n, r, i, a),
                  (rt = Wt.get(e, mt || n)),
                  t.modelViewMatrix.multiplyMatrices(
                    n.matrixWorldInverse,
                    t.matrixWorld
                  ),
                  t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                  t.isImmediateRenderObject)
                ) {
                  Dt.setMaterial(i);
                  var o = w(n, e.fog, i, t);
                  (dt.geometry = null),
                    (dt.program = null),
                    (dt.wireframe = !1),
                    p(t, o);
                } else st.renderBufferDirect(n, e.fog, r, i, t, a);
                t.onAfterRender(st, e, n, r, i, a), (rt = Wt.get(e, mt || n));
              }
              function _(t, e, n) {
                var r = Bt.get(t),
                  i = rt.state.lights,
                  a = rt.state.shadowsArray,
                  o = r.lightsHash,
                  c = i.state.hash,
                  h = kt.getParameters(
                    t,
                    i.state,
                    a,
                    e,
                    At.numPlanes,
                    At.numIntersection,
                    n
                  ),
                  u = kt.getProgramCode(t, h),
                  p = r.program,
                  d = !0;
                if (void 0 === p) t.addEventListener("dispose", s);
                else if (p.code !== u) l(t);
                else if (
                  o.stateID !== c.stateID ||
                  o.directionalLength !== c.directionalLength ||
                  o.pointLength !== c.pointLength ||
                  o.spotLength !== c.spotLength ||
                  o.rectAreaLength !== c.rectAreaLength ||
                  o.hemiLength !== c.hemiLength ||
                  o.shadowsLength !== c.shadowsLength
                )
                  (o.stateID = c.stateID),
                    (o.directionalLength = c.directionalLength),
                    (o.pointLength = c.pointLength),
                    (o.spotLength = c.spotLength),
                    (o.rectAreaLength = c.rectAreaLength),
                    (o.hemiLength = c.hemiLength),
                    (o.shadowsLength = c.shadowsLength),
                    (d = !1);
                else {
                  if (void 0 !== h.shaderID) return;
                  d = !1;
                }
                if (d) {
                  if (h.shaderID) {
                    var f = Sc[h.shaderID];
                    r.shader = {
                      name: t.type,
                      uniforms: Mc.clone(f.uniforms),
                      vertexShader: f.vertexShader,
                      fragmentShader: f.fragmentShader,
                    };
                  } else
                    r.shader = {
                      name: t.type,
                      uniforms: t.uniforms,
                      vertexShader: t.vertexShader,
                      fragmentShader: t.fragmentShader,
                    };
                  t.onBeforeCompile(r.shader, st),
                    (u = kt.getProgramCode(t, h)),
                    (p = kt.acquireProgram(t, r.shader, h, u)),
                    (r.program = p),
                    (t.program = p);
                }
                var m = p.getAttributes();
                if (t.morphTargets) {
                  t.numSupportedMorphTargets = 0;
                  for (var g = 0; g < st.maxMorphTargets; g++)
                    m["morphTarget" + g] >= 0 && t.numSupportedMorphTargets++;
                }
                if (t.morphNormals) {
                  t.numSupportedMorphNormals = 0;
                  for (var g = 0; g < st.maxMorphNormals; g++)
                    m["morphNormal" + g] >= 0 && t.numSupportedMorphNormals++;
                }
                var v = r.shader.uniforms;
                ((t.isShaderMaterial || t.isRawShaderMaterial) &&
                  !0 !== t.clipping) ||
                  ((r.numClippingPlanes = At.numPlanes),
                  (r.numIntersection = At.numIntersection),
                  (v.clippingPlanes = At.uniform)),
                  (r.fog = e),
                  void 0 === o && (r.lightsHash = o = {}),
                  (o.stateID = c.stateID),
                  (o.directionalLength = c.directionalLength),
                  (o.pointLength = c.pointLength),
                  (o.spotLength = c.spotLength),
                  (o.rectAreaLength = c.rectAreaLength),
                  (o.hemiLength = c.hemiLength),
                  (o.shadowsLength = c.shadowsLength),
                  t.lights &&
                    ((v.ambientLightColor.value = i.state.ambient),
                    (v.directionalLights.value = i.state.directional),
                    (v.spotLights.value = i.state.spot),
                    (v.rectAreaLights.value = i.state.rectArea),
                    (v.pointLights.value = i.state.point),
                    (v.hemisphereLights.value = i.state.hemi),
                    (v.directionalShadowMap.value =
                      i.state.directionalShadowMap),
                    (v.directionalShadowMatrix.value =
                      i.state.directionalShadowMatrix),
                    (v.spotShadowMap.value = i.state.spotShadowMap),
                    (v.spotShadowMatrix.value = i.state.spotShadowMatrix),
                    (v.pointShadowMap.value = i.state.pointShadowMap),
                    (v.pointShadowMatrix.value = i.state.pointShadowMatrix));
                var y = r.program.getUniforms(),
                  x = Vt.seqWithValue(y.seq, v);
                r.uniformsList = x;
              }
              function w(t, e, n, r) {
                xt = 0;
                var i = Bt.get(n),
                  a = rt.state.lights,
                  o = i.lightsHash,
                  s = a.state.hash;
                if (Lt && (Rt || t !== ft)) {
                  var c = t === ft && n.id === pt;
                  At.setState(
                    n.clippingPlanes,
                    n.clipIntersection,
                    n.clipShadows,
                    t,
                    i,
                    c
                  );
                }
                !1 === n.needsUpdate &&
                  (void 0 === i.program
                    ? (n.needsUpdate = !0)
                    : n.fog && i.fog !== e
                    ? (n.needsUpdate = !0)
                    : !n.lights ||
                      (o.stateID === s.stateID &&
                        o.directionalLength === s.directionalLength &&
                        o.pointLength === s.pointLength &&
                        o.spotLength === s.spotLength &&
                        o.rectAreaLength === s.rectAreaLength &&
                        o.hemiLength === s.hemiLength &&
                        o.shadowsLength === s.shadowsLength)
                    ? void 0 === i.numClippingPlanes ||
                      (i.numClippingPlanes === At.numPlanes &&
                        i.numIntersection === At.numIntersection) ||
                      (n.needsUpdate = !0)
                    : (n.needsUpdate = !0)),
                  n.needsUpdate && (_(n, e, r), (n.needsUpdate = !1));
                var h = !1,
                  l = !1,
                  p = !1,
                  d = i.program,
                  f = d.getUniforms(),
                  m = i.shader.uniforms;
                if (
                  (Dt.useProgram(d.program) && ((h = !0), (l = !0), (p = !0)),
                  n.id !== pt && ((pt = n.id), (l = !0)),
                  h || t !== ft)
                ) {
                  if (
                    (f.setValue(ot, "projectionMatrix", t.projectionMatrix),
                    Nt.logarithmicDepthBuffer &&
                      f.setValue(
                        ot,
                        "logDepthBufFC",
                        2 / (Math.log(t.far + 1) / Math.LN2)
                      ),
                    ft !== (mt || t) && ((ft = mt || t), (l = !0), (p = !0)),
                    n.isShaderMaterial ||
                      n.isMeshPhongMaterial ||
                      n.isMeshStandardMaterial ||
                      n.envMap)
                  ) {
                    var g = f.map.cameraPosition;
                    void 0 !== g &&
                      g.setValue(ot, Pt.setFromMatrixPosition(t.matrixWorld));
                  }
                  (n.isMeshPhongMaterial ||
                    n.isMeshLambertMaterial ||
                    n.isMeshBasicMaterial ||
                    n.isMeshStandardMaterial ||
                    n.isShaderMaterial ||
                    n.skinning) &&
                    f.setValue(ot, "viewMatrix", t.matrixWorldInverse);
                }
                if (n.skinning) {
                  f.setOptional(ot, r, "bindMatrix"),
                    f.setOptional(ot, r, "bindMatrixInverse");
                  var v = r.skeleton;
                  if (v) {
                    var y = v.bones;
                    if (Nt.floatVertexTextures) {
                      if (void 0 === v.boneTexture) {
                        var x = Math.sqrt(4 * y.length);
                        (x = xc.ceilPowerOfTwo(x)), (x = Math.max(x, 4));
                        var b = new Float32Array(x * x * 4);
                        b.set(v.boneMatrices);
                        var w = new u(b, x, x, Ls, bs);
                        (w.needsUpdate = !0),
                          (v.boneMatrices = b),
                          (v.boneTexture = w),
                          (v.boneTextureSize = x);
                      }
                      f.setValue(ot, "boneTexture", v.boneTexture),
                        f.setValue(ot, "boneTextureSize", v.boneTextureSize);
                    } else f.setOptional(ot, v, "boneMatrices");
                  }
                }
                return (
                  l &&
                    (f.setValue(
                      ot,
                      "toneMappingExposure",
                      st.toneMappingExposure
                    ),
                    f.setValue(
                      ot,
                      "toneMappingWhitePoint",
                      st.toneMappingWhitePoint
                    ),
                    n.lights && B(m, p),
                    e && n.fog && L(m, e),
                    n.isMeshBasicMaterial
                      ? M(m, n)
                      : n.isMeshLambertMaterial
                      ? (M(m, n), R(m, n))
                      : n.isMeshPhongMaterial
                      ? (M(m, n), n.isMeshToonMaterial ? P(m, n) : C(m, n))
                      : n.isMeshStandardMaterial
                      ? (M(m, n), n.isMeshPhysicalMaterial ? I(m, n) : O(m, n))
                      : n.isMeshDepthMaterial
                      ? (M(m, n), N(m, n))
                      : n.isMeshDistanceMaterial
                      ? (M(m, n), D(m, n))
                      : n.isMeshNormalMaterial
                      ? (M(m, n), U(m, n))
                      : n.isLineBasicMaterial
                      ? (E(m, n), n.isLineDashedMaterial && T(m, n))
                      : n.isPointsMaterial
                      ? S(m, n)
                      : n.isSpriteMaterial
                      ? A(m, n)
                      : n.isShadowMaterial &&
                        ((m.color.value = n.color),
                        (m.opacity.value = n.opacity)),
                    void 0 !== m.ltc_1 && (m.ltc_1.value = Tc.LTC_1),
                    void 0 !== m.ltc_2 && (m.ltc_2.value = Tc.LTC_2),
                    Vt.upload(ot, i.uniformsList, m, st)),
                  n.isShaderMaterial &&
                    !0 === n.uniformsNeedUpdate &&
                    (Vt.upload(ot, i.uniformsList, m, st),
                    (n.uniformsNeedUpdate = !1)),
                  n.isSpriteMaterial && f.setValue(ot, "center", r.center),
                  f.setValue(ot, "modelViewMatrix", r.modelViewMatrix),
                  f.setValue(ot, "normalMatrix", r.normalMatrix),
                  f.setValue(ot, "modelMatrix", r.matrixWorld),
                  d
                );
              }
              function M(t, e) {
                (t.opacity.value = e.opacity),
                  e.color && (t.diffuse.value = e.color),
                  e.emissive &&
                    t.emissive.value
                      .copy(e.emissive)
                      .multiplyScalar(e.emissiveIntensity),
                  e.map && (t.map.value = e.map),
                  e.alphaMap && (t.alphaMap.value = e.alphaMap),
                  e.specularMap && (t.specularMap.value = e.specularMap),
                  e.envMap &&
                    ((t.envMap.value = e.envMap),
                    (t.flipEnvMap.value =
                      e.envMap && e.envMap.isCubeTexture ? -1 : 1),
                    (t.reflectivity.value = e.reflectivity),
                    (t.refractionRatio.value = e.refractionRatio),
                    (t.maxMipLevel.value = Bt.get(e.envMap).__maxMipLevel)),
                  e.lightMap &&
                    ((t.lightMap.value = e.lightMap),
                    (t.lightMapIntensity.value = e.lightMapIntensity)),
                  e.aoMap &&
                    ((t.aoMap.value = e.aoMap),
                    (t.aoMapIntensity.value = e.aoMapIntensity));
                var n;
                e.map
                  ? (n = e.map)
                  : e.specularMap
                  ? (n = e.specularMap)
                  : e.displacementMap
                  ? (n = e.displacementMap)
                  : e.normalMap
                  ? (n = e.normalMap)
                  : e.bumpMap
                  ? (n = e.bumpMap)
                  : e.roughnessMap
                  ? (n = e.roughnessMap)
                  : e.metalnessMap
                  ? (n = e.metalnessMap)
                  : e.alphaMap
                  ? (n = e.alphaMap)
                  : e.emissiveMap && (n = e.emissiveMap),
                  void 0 !== n &&
                    (n.isWebGLRenderTarget && (n = n.texture),
                    !0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix));
              }
              function E(t, e) {
                (t.diffuse.value = e.color), (t.opacity.value = e.opacity);
              }
              function T(t, e) {
                (t.dashSize.value = e.dashSize),
                  (t.totalSize.value = e.dashSize + e.gapSize),
                  (t.scale.value = e.scale);
              }
              function S(t, e) {
                (t.diffuse.value = e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * wt),
                  (t.scale.value = 0.5 * _t),
                  (t.map.value = e.map),
                  null !== e.map &&
                    (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(),
                    t.uvTransform.value.copy(e.map.matrix));
              }
              function A(t, e) {
                (t.diffuse.value = e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  (t.map.value = e.map),
                  null !== e.map &&
                    (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(),
                    t.uvTransform.value.copy(e.map.matrix));
              }
              function L(t, e) {
                (t.fogColor.value = e.color),
                  e.isFog
                    ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                    : e.isFogExp2 && (t.fogDensity.value = e.density);
              }
              function R(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
              }
              function C(t, e) {
                (t.specular.value = e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === co && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === co && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              }
              function P(t, e) {
                C(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap);
              }
              function O(t, e) {
                (t.roughness.value = e.roughness),
                  (t.metalness.value = e.metalness),
                  e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
                  e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === co && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === co && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                  e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
              }
              function I(t, e) {
                O(t, e),
                  (t.reflectivity.value = e.reflectivity),
                  (t.clearCoat.value = e.clearCoat),
                  (t.clearCoatRoughness.value = e.clearCoatRoughness);
              }
              function N(t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              }
              function D(t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias)),
                  t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              }
              function U(t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === co && (t.bumpScale.value *= -1)),
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === co && t.normalScale.value.negate()),
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
              }
              function B(t, e) {
                (t.ambientLightColor.needsUpdate = e),
                  (t.directionalLights.needsUpdate = e),
                  (t.pointLights.needsUpdate = e),
                  (t.spotLights.needsUpdate = e),
                  (t.rectAreaLights.needsUpdate = e),
                  (t.hemisphereLights.needsUpdate = e);
              }
              function F() {
                var t = xt;
                return (
                  t >= Nt.maxTextures &&
                    console.warn(
                      "THREE.WebGLRenderer: Trying to use " +
                        t +
                        " texture units while this GPU supports only " +
                        Nt.maxTextures
                    ),
                  (xt += 1),
                  t
                );
              }
              console.log("THREE.WebGLRenderer", to), (t = t || {});
              var z =
                  void 0 !== t.canvas
                    ? t.canvas
                    : document.createElementNS(
                        "http://www.w3.org/1999/xhtml",
                        "canvas"
                      ),
                G = void 0 !== t.context ? t.context : null,
                H = void 0 !== t.alpha && t.alpha,
                V = void 0 === t.depth || t.depth,
                k = void 0 === t.stencil || t.stencil,
                j = void 0 !== t.antialias && t.antialias,
                W = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                X =
                  void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                q =
                  void 0 !== t.powerPreference ? t.powerPreference : "default",
                Y = null,
                rt = null;
              (this.domElement = z),
                (this.context = null),
                (this.autoClear = !0),
                (this.autoClearColor = !0),
                (this.autoClearDepth = !0),
                (this.autoClearStencil = !0),
                (this.sortObjects = !0),
                (this.clippingPlanes = []),
                (this.localClippingEnabled = !1),
                (this.gammaFactor = 2),
                (this.gammaInput = !1),
                (this.gammaOutput = !1),
                (this.physicallyCorrectLights = !1),
                (this.toneMapping = Yo),
                (this.toneMappingExposure = 1),
                (this.toneMappingWhitePoint = 1),
                (this.maxMorphTargets = 8),
                (this.maxMorphNormals = 4);
              var ot,
                st = this,
                ct = !1,
                ht = null,
                lt = null,
                ut = null,
                pt = -1,
                dt = { geometry: null, program: null, wireframe: !1 },
                ft = null,
                mt = null,
                gt = new c(),
                vt = new c(),
                yt = null,
                xt = 0,
                bt = z.width,
                _t = z.height,
                wt = 1,
                Mt = new c(0, 0, bt, _t),
                Et = new c(0, 0, bt, _t),
                Tt = !1,
                St = new m(),
                At = new K(),
                Lt = !1,
                Rt = !1,
                Ct = new r(),
                Pt = new a();
              try {
                var Ot = {
                  alpha: H,
                  depth: V,
                  stencil: k,
                  antialias: j,
                  premultipliedAlpha: W,
                  preserveDrawingBuffer: X,
                  powerPreference: q,
                };
                if (
                  (z.addEventListener("webglcontextlost", i, !1),
                  z.addEventListener("webglcontextrestored", o, !1),
                  null ===
                    (ot =
                      G ||
                      z.getContext("webgl", Ot) ||
                      z.getContext("experimental-webgl", Ot)))
                )
                  throw null !== z.getContext("webgl")
                    ? new Error(
                        "Error creating WebGL context with your selected attributes."
                      )
                    : new Error("Error creating WebGL context.");
                void 0 === ot.getShaderPrecisionFormat &&
                  (ot.getShaderPrecisionFormat = function () {
                    return { rangeMin: 1, rangeMax: 1, precision: 1 };
                  });
              } catch (t) {
                console.error("THREE.WebGLRenderer: " + t.message);
              }
              var It,
                Nt,
                Dt,
                Ut,
                Bt,
                Ft,
                zt,
                Gt,
                Ht,
                kt,
                jt,
                Wt,
                Xt,
                qt,
                Yt,
                Jt,
                Zt;
              n();
              var Qt = "xr" in navigator ? new Ee(st) : new Me(st);
              this.vr = Qt;
              var Kt = new ge(st, Ht, Nt.maxTextureSize);
              (this.shadowMap = Kt),
                (this.getContext = function () {
                  return ot;
                }),
                (this.getContextAttributes = function () {
                  return ot.getContextAttributes();
                }),
                (this.forceContextLoss = function () {
                  var t = It.get("WEBGL_lose_context");
                  t && t.loseContext();
                }),
                (this.forceContextRestore = function () {
                  var t = It.get("WEBGL_lose_context");
                  t && t.restoreContext();
                }),
                (this.getPixelRatio = function () {
                  return wt;
                }),
                (this.setPixelRatio = function (t) {
                  void 0 !== t && ((wt = t), this.setSize(bt, _t, !1));
                }),
                (this.getSize = function () {
                  return { width: bt, height: _t };
                }),
                (this.setSize = function (t, e, n) {
                  (bt = t),
                    (_t = e),
                    (z.width = t * wt),
                    (z.height = e * wt),
                    !1 !== n &&
                      ((z.style.width = t + "px"), (z.style.height = e + "px")),
                    this.setViewport(0, 0, t, e);
                }),
                (this.getDrawingBufferSize = function () {
                  return { width: bt * wt, height: _t * wt };
                }),
                (this.setDrawingBufferSize = function (t, e, n) {
                  (bt = t),
                    (_t = e),
                    (wt = n),
                    (z.width = t * n),
                    (z.height = e * n),
                    this.setViewport(0, 0, t, e);
                }),
                (this.getCurrentViewport = function () {
                  return gt;
                }),
                (this.setViewport = function (t, e, n, r) {
                  Mt.set(t, _t - e - r, n, r),
                    Dt.viewport(gt.copy(Mt).multiplyScalar(wt));
                }),
                (this.setScissor = function (t, e, n, r) {
                  Et.set(t, _t - e - r, n, r),
                    Dt.scissor(vt.copy(Et).multiplyScalar(wt));
                }),
                (this.setScissorTest = function (t) {
                  Dt.setScissorTest((Tt = t));
                }),
                (this.getClearColor = function () {
                  return Xt.getClearColor();
                }),
                (this.setClearColor = function () {
                  Xt.setClearColor.apply(Xt, arguments);
                }),
                (this.getClearAlpha = function () {
                  return Xt.getClearAlpha();
                }),
                (this.setClearAlpha = function () {
                  Xt.setClearAlpha.apply(Xt, arguments);
                }),
                (this.clear = function (t, e, n) {
                  var r = 0;
                  (void 0 === t || t) && (r |= ot.COLOR_BUFFER_BIT),
                    (void 0 === e || e) && (r |= ot.DEPTH_BUFFER_BIT),
                    (void 0 === n || n) && (r |= ot.STENCIL_BUFFER_BIT),
                    ot.clear(r);
                }),
                (this.clearColor = function () {
                  this.clear(!0, !1, !1);
                }),
                (this.clearDepth = function () {
                  this.clear(!1, !0, !1);
                }),
                (this.clearStencil = function () {
                  this.clear(!1, !1, !0);
                }),
                (this.clearTarget = function (t, e, n, r) {
                  this.setRenderTarget(t), this.clear(e, n, r);
                }),
                (this.dispose = function () {
                  z.removeEventListener("webglcontextlost", i, !1),
                    z.removeEventListener("webglcontextrestored", o, !1),
                    jt.dispose(),
                    Wt.dispose(),
                    Bt.dispose(),
                    Ht.dispose(),
                    Qt.dispose(),
                    te.stop();
                }),
                (this.renderBufferImmediate = function (t, e) {
                  Dt.initAttributes();
                  var n = Bt.get(t);
                  t.hasPositions &&
                    !n.position &&
                    (n.position = ot.createBuffer()),
                    t.hasNormals && !n.normal && (n.normal = ot.createBuffer()),
                    t.hasUvs && !n.uv && (n.uv = ot.createBuffer()),
                    t.hasColors && !n.color && (n.color = ot.createBuffer());
                  var r = e.getAttributes();
                  t.hasPositions &&
                    (ot.bindBuffer(ot.ARRAY_BUFFER, n.position),
                    ot.bufferData(
                      ot.ARRAY_BUFFER,
                      t.positionArray,
                      ot.DYNAMIC_DRAW
                    ),
                    Dt.enableAttribute(r.position),
                    ot.vertexAttribPointer(r.position, 3, ot.FLOAT, !1, 0, 0)),
                    t.hasNormals &&
                      (ot.bindBuffer(ot.ARRAY_BUFFER, n.normal),
                      ot.bufferData(
                        ot.ARRAY_BUFFER,
                        t.normalArray,
                        ot.DYNAMIC_DRAW
                      ),
                      Dt.enableAttribute(r.normal),
                      ot.vertexAttribPointer(r.normal, 3, ot.FLOAT, !1, 0, 0)),
                    t.hasUvs &&
                      (ot.bindBuffer(ot.ARRAY_BUFFER, n.uv),
                      ot.bufferData(
                        ot.ARRAY_BUFFER,
                        t.uvArray,
                        ot.DYNAMIC_DRAW
                      ),
                      Dt.enableAttribute(r.uv),
                      ot.vertexAttribPointer(r.uv, 2, ot.FLOAT, !1, 0, 0)),
                    t.hasColors &&
                      (ot.bindBuffer(ot.ARRAY_BUFFER, n.color),
                      ot.bufferData(
                        ot.ARRAY_BUFFER,
                        t.colorArray,
                        ot.DYNAMIC_DRAW
                      ),
                      Dt.enableAttribute(r.color),
                      ot.vertexAttribPointer(r.color, 3, ot.FLOAT, !1, 0, 0)),
                    Dt.disableUnusedAttributes(),
                    ot.drawArrays(ot.TRIANGLES, 0, t.count),
                    (t.count = 0);
                }),
                (this.renderBufferDirect = function (t, n, r, i, a, o) {
                  var s = a.isMesh && a.normalMatrix.determinant() < 0;
                  Dt.setMaterial(i, s);
                  var c = w(t, n, i, a),
                    h = !1;
                  (dt.geometry === r.id &&
                    dt.program === c.id &&
                    dt.wireframe === (!0 === i.wireframe)) ||
                    ((dt.geometry = r.id),
                    (dt.program = c.id),
                    (dt.wireframe = !0 === i.wireframe),
                    (h = !0)),
                    a.morphTargetInfluences &&
                      (qt.update(a, r, i, c), (h = !0));
                  var l = r.index,
                    u = r.attributes.position,
                    p = 1;
                  !0 === i.wireframe &&
                    ((l = Gt.getWireframeAttribute(r)), (p = 2));
                  var f,
                    m = Yt;
                  null !== l && ((f = zt.get(l)), (m = Jt), m.setIndex(f)),
                    h &&
                      (d(i, c, r),
                      null !== l &&
                        ot.bindBuffer(ot.ELEMENT_ARRAY_BUFFER, f.buffer));
                  var g = 1 / 0;
                  null !== l ? (g = l.count) : void 0 !== u && (g = u.count);
                  var v = r.drawRange.start * p,
                    y = r.drawRange.count * p,
                    x = null !== o ? o.start * p : 0,
                    b = null !== o ? o.count * p : 1 / 0,
                    _ = Math.max(v, x),
                    M = Math.min(g, v + y, x + b) - 1,
                    E = Math.max(0, M - _ + 1);
                  if (0 !== E) {
                    if (a.isMesh)
                      if (!0 === i.wireframe)
                        Dt.setLineWidth(i.wireframeLinewidth * e()),
                          m.setMode(ot.LINES);
                      else
                        switch (a.drawMode) {
                          case ac:
                            m.setMode(ot.TRIANGLES);
                            break;
                          case oc:
                            m.setMode(ot.TRIANGLE_STRIP);
                            break;
                          case sc:
                            m.setMode(ot.TRIANGLE_FAN);
                        }
                    else if (a.isLine) {
                      var T = i.linewidth;
                      void 0 === T && (T = 1),
                        Dt.setLineWidth(T * e()),
                        a.isLineSegments
                          ? m.setMode(ot.LINES)
                          : a.isLineLoop
                          ? m.setMode(ot.LINE_LOOP)
                          : m.setMode(ot.LINE_STRIP);
                    } else
                      a.isPoints
                        ? m.setMode(ot.POINTS)
                        : a.isSprite && m.setMode(ot.TRIANGLES);
                    r && r.isInstancedBufferGeometry
                      ? r.maxInstancedCount > 0 && m.renderInstances(r, _, E)
                      : m.render(_, E);
                  }
                }),
                (this.compile = function (t, e) {
                  (rt = Wt.get(t, e)),
                    rt.init(),
                    t.traverse(function (t) {
                      t.isLight &&
                        (rt.pushLight(t), t.castShadow && rt.pushShadow(t));
                    }),
                    rt.setupLights(e),
                    t.traverse(function (e) {
                      if (e.material)
                        if (Array.isArray(e.material))
                          for (var n = 0; n < e.material.length; n++)
                            _(e.material[n], t.fog, e);
                        else _(e.material, t.fog, e);
                    });
                });
              var $t = null,
                te = new v();
              te.setAnimationLoop(f),
                "undefined" != typeof window && te.setContext(window),
                (this.setAnimationLoop = function (t) {
                  ($t = t), te.start();
                }),
                (this.render = function (t, e, n, r) {
                  if (!e || !e.isCamera)
                    return void console.error(
                      "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                    );
                  if (!ct) {
                    (dt.geometry = null),
                      (dt.program = null),
                      (dt.wireframe = !1),
                      (pt = -1),
                      (ft = null),
                      !0 === t.autoUpdate && t.updateMatrixWorld(),
                      null === e.parent && e.updateMatrixWorld(),
                      Qt.enabled && (e = Qt.getCamera(e)),
                      (rt = Wt.get(t, e)),
                      rt.init(),
                      t.onBeforeRender(st, t, e, n),
                      Ct.multiplyMatrices(
                        e.projectionMatrix,
                        e.matrixWorldInverse
                      ),
                      St.setFromMatrix(Ct),
                      (Rt = this.localClippingEnabled),
                      (Lt = At.init(this.clippingPlanes, Rt, e)),
                      (Y = jt.get(t, e)),
                      Y.init(),
                      g(t, e, st.sortObjects),
                      !0 === st.sortObjects && Y.sort(),
                      Lt && At.beginShadows();
                    var i = rt.state.shadowsArray;
                    Kt.render(i, t, e),
                      rt.setupLights(e),
                      Lt && At.endShadows(),
                      this.info.autoReset && this.info.reset(),
                      void 0 === n && (n = null),
                      this.setRenderTarget(n),
                      Xt.render(Y, t, e, r);
                    var a = Y.opaque,
                      o = Y.transparent;
                    if (t.overrideMaterial) {
                      var s = t.overrideMaterial;
                      a.length && x(a, t, e, s), o.length && x(o, t, e, s);
                    } else a.length && x(a, t, e), o.length && x(o, t, e);
                    n && Ft.updateRenderTargetMipmap(n),
                      Dt.buffers.depth.setTest(!0),
                      Dt.buffers.depth.setMask(!0),
                      Dt.buffers.color.setMask(!0),
                      Dt.setPolygonOffset(!1),
                      t.onAfterRender(st, t, e),
                      Qt.enabled && Qt.submitFrame(),
                      (Y = null),
                      (rt = null);
                  }
                }),
                (this.allocTextureUnit = F),
                (this.setTexture2D = (function () {
                  var t = !1;
                  return function (e, n) {
                    e &&
                      e.isWebGLRenderTarget &&
                      (t ||
                        (console.warn(
                          "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
                        ),
                        (t = !0)),
                      (e = e.texture)),
                      Ft.setTexture2D(e, n);
                  };
                })()),
                (this.setTexture = (function () {
                  var t = !1;
                  return function (e, n) {
                    t ||
                      (console.warn(
                        "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
                      ),
                      (t = !0)),
                      Ft.setTexture2D(e, n);
                  };
                })()),
                (this.setTextureCube = (function () {
                  var t = !1;
                  return function (e, n) {
                    e &&
                      e.isWebGLRenderTargetCube &&
                      (t ||
                        (console.warn(
                          "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                        ),
                        (t = !0)),
                      (e = e.texture)),
                      (e && e.isCubeTexture) ||
                      (Array.isArray(e.image) && 6 === e.image.length)
                        ? Ft.setTextureCube(e, n)
                        : Ft.setTextureCubeDynamic(e, n);
                  };
                })()),
                (this.setFramebuffer = function (t) {
                  ht = t;
                }),
                (this.getRenderTarget = function () {
                  return lt;
                }),
                (this.setRenderTarget = function (t) {
                  (lt = t),
                    t &&
                      void 0 === Bt.get(t).__webglFramebuffer &&
                      Ft.setupRenderTarget(t);
                  var e = ht,
                    n = !1;
                  if (t) {
                    var r = Bt.get(t).__webglFramebuffer;
                    t.isWebGLRenderTargetCube
                      ? ((e = r[t.activeCubeFace]), (n = !0))
                      : (e = r),
                      gt.copy(t.viewport),
                      vt.copy(t.scissor),
                      (yt = t.scissorTest);
                  } else
                    gt.copy(Mt).multiplyScalar(wt),
                      vt.copy(Et).multiplyScalar(wt),
                      (yt = Tt);
                  if (
                    (ut !== e &&
                      (ot.bindFramebuffer(ot.FRAMEBUFFER, e), (ut = e)),
                    Dt.viewport(gt),
                    Dt.scissor(vt),
                    Dt.setScissorTest(yt),
                    n)
                  ) {
                    var i = Bt.get(t.texture);
                    ot.framebufferTexture2D(
                      ot.FRAMEBUFFER,
                      ot.COLOR_ATTACHMENT0,
                      ot.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace,
                      i.__webglTexture,
                      t.activeMipMapLevel
                    );
                  }
                }),
                (this.readRenderTargetPixels = function (t, e, n, r, i, a) {
                  if (!t || !t.isWebGLRenderTarget)
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                    );
                  var o = Bt.get(t).__webglFramebuffer;
                  if (o) {
                    var s = !1;
                    o !== ut &&
                      (ot.bindFramebuffer(ot.FRAMEBUFFER, o), (s = !0));
                    try {
                      var c = t.texture,
                        h = c.format,
                        l = c.type;
                      if (
                        h !== Ls &&
                        Zt.convert(h) !==
                          ot.getParameter(ot.IMPLEMENTATION_COLOR_READ_FORMAT)
                      )
                        return void console.error(
                          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                        );
                      if (
                        !(
                          l === fs ||
                          Zt.convert(l) ===
                            ot.getParameter(
                              ot.IMPLEMENTATION_COLOR_READ_TYPE
                            ) ||
                          (l === bs &&
                            (Nt.isWebGL2 ||
                              It.get("OES_texture_float") ||
                              It.get("WEBGL_color_buffer_float"))) ||
                          (l === _s &&
                            (Nt.isWebGL2
                              ? It.get("EXT_color_buffer_float")
                              : It.get("EXT_color_buffer_half_float")))
                        )
                      )
                        return void console.error(
                          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                        );
                      ot.checkFramebufferStatus(ot.FRAMEBUFFER) ===
                      ot.FRAMEBUFFER_COMPLETE
                        ? e >= 0 &&
                          e <= t.width - r &&
                          n >= 0 &&
                          n <= t.height - i &&
                          ot.readPixels(
                            e,
                            n,
                            r,
                            i,
                            Zt.convert(h),
                            Zt.convert(l),
                            a
                          )
                        : console.error(
                            "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                          );
                    } finally {
                      s && ot.bindFramebuffer(ot.FRAMEBUFFER, ut);
                    }
                  }
                }),
                (this.copyFramebufferToTexture = function (t, e, n) {
                  var r = e.image.width,
                    i = e.image.height,
                    a = Zt.convert(e.format);
                  this.setTexture2D(e, 0),
                    ot.copyTexImage2D(
                      ot.TEXTURE_2D,
                      n || 0,
                      a,
                      t.x,
                      t.y,
                      r,
                      i,
                      0
                    );
                }),
                (this.copyTextureToTexture = function (t, e, n, r) {
                  var i = e.image.width,
                    a = e.image.height,
                    o = Zt.convert(n.format),
                    s = Zt.convert(n.type);
                  this.setTexture2D(n, 0),
                    e.isDataTexture
                      ? ot.texSubImage2D(
                          ot.TEXTURE_2D,
                          r || 0,
                          t.x,
                          t.y,
                          i,
                          a,
                          o,
                          s,
                          e.image.data
                        )
                      : ot.texSubImage2D(
                          ot.TEXTURE_2D,
                          r || 0,
                          t.x,
                          t.y,
                          o,
                          s,
                          e.image
                        );
                });
            }
            function Se(t, e) {
              (this.name = ""),
                (this.color = new g(t)),
                (this.density = void 0 !== e ? e : 25e-5);
            }
            function Ae(t, e, n) {
              (this.name = ""),
                (this.color = new g(t)),
                (this.near = void 0 !== e ? e : 1),
                (this.far = void 0 !== n ? n : 1e3);
            }
            function Le() {
              _.call(this),
                (this.type = "Scene"),
                (this.background = null),
                (this.fog = null),
                (this.overrideMaterial = null),
                (this.autoUpdate = !0);
            }
            function Re(t, e) {
              (this.array = t),
                (this.stride = e),
                (this.count = void 0 !== t ? t.length / e : 0),
                (this.dynamic = !1),
                (this.updateRange = { offset: 0, count: -1 }),
                (this.version = 0);
            }
            function Ce(t, e, n, r) {
              (this.data = t),
                (this.itemSize = e),
                (this.offset = n),
                (this.normalized = !0 === r);
            }
            function Pe(t) {
              k.call(this),
                (this.type = "SpriteMaterial"),
                (this.color = new g(16777215)),
                (this.map = null),
                (this.rotation = 0),
                (this.lights = !1),
                (this.transparent = !0),
                this.setValues(t);
            }
            function Oe(t) {
              if ((_.call(this), (this.type = "Sprite"), void 0 === Hc)) {
                Hc = new F();
                var e = new Float32Array([
                    -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                    -0.5, 0.5, 0, 0, 1,
                  ]),
                  r = new Re(e, 5);
                Hc.setIndex([0, 1, 2, 0, 2, 3]),
                  Hc.addAttribute("position", new Ce(r, 3, 0, !1)),
                  Hc.addAttribute("uv", new Ce(r, 2, 3, !1));
              }
              (this.geometry = Hc),
                (this.material = void 0 !== t ? t : new Pe()),
                (this.center = new n(0.5, 0.5));
            }
            function Ie() {
              _.call(this),
                (this.type = "LOD"),
                Object.defineProperties(this, {
                  levels: { enumerable: !0, value: [] },
                });
            }
            function Ne(t, e) {
              if (
                ((t = t || []),
                (this.bones = t.slice(0)),
                (this.boneMatrices = new Float32Array(16 * this.bones.length)),
                void 0 === e)
              )
                this.calculateInverses();
              else if (this.bones.length === e.length)
                this.boneInverses = e.slice(0);
              else {
                console.warn(
                  "THREE.Skeleton boneInverses is the wrong length."
                ),
                  (this.boneInverses = []);
                for (var n = 0, i = this.bones.length; n < i; n++)
                  this.boneInverses.push(new r());
              }
            }
            function De() {
              _.call(this), (this.type = "Bone");
            }
            function Ue(t, e) {
              Y.call(this, t, e),
                (this.type = "SkinnedMesh"),
                (this.bindMode = "attached"),
                (this.bindMatrix = new r()),
                (this.bindMatrixInverse = new r());
              var n = this.initBones(),
                i = new Ne(n);
              this.bind(i, this.matrixWorld), this.normalizeSkinWeights();
            }
            function Be(t) {
              k.call(this),
                (this.type = "LineBasicMaterial"),
                (this.color = new g(16777215)),
                (this.linewidth = 1),
                (this.linecap = "round"),
                (this.linejoin = "round"),
                (this.lights = !1),
                this.setValues(t);
            }
            function Fe(t, e, n) {
              1 === n &&
                console.error(
                  "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
                ),
                _.call(this),
                (this.type = "Line"),
                (this.geometry = void 0 !== t ? t : new F()),
                (this.material =
                  void 0 !== e
                    ? e
                    : new Be({ color: 16777215 * Math.random() }));
            }
            function ze(t, e) {
              Fe.call(this, t, e), (this.type = "LineSegments");
            }
            function Ge(t, e) {
              Fe.call(this, t, e), (this.type = "LineLoop");
            }
            function He(t) {
              k.call(this),
                (this.type = "PointsMaterial"),
                (this.color = new g(16777215)),
                (this.map = null),
                (this.size = 1),
                (this.sizeAttenuation = !0),
                (this.morphTargets = !1),
                (this.lights = !1),
                this.setValues(t);
            }
            function Ve(t, e) {
              _.call(this),
                (this.type = "Points"),
                (this.geometry = void 0 !== t ? t : new F()),
                (this.material =
                  void 0 !== e
                    ? e
                    : new He({ color: 16777215 * Math.random() }));
            }
            function ke(t, e, n, r, i, a, o, c, h) {
              s.call(this, t, e, n, r, i, a, o, c, h),
                (this.generateMipmaps = !1);
            }
            function je(t, e, n, r, i, a, o, c, h, l, u, p) {
              s.call(this, null, a, o, c, h, l, r, i, u, p),
                (this.image = { width: e, height: n }),
                (this.mipmaps = t),
                (this.flipY = !1),
                (this.generateMipmaps = !1);
            }
            function We(t, e, n, r, i, a, o, c, h) {
              s.call(this, t, e, n, r, i, a, o, c, h), (this.needsUpdate = !0);
            }
            function Xe(t, e, n, r, i, a, o, c, h, l) {
              if ((l = void 0 !== l ? l : Os) !== Os && l !== Is)
                throw new Error(
                  "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
                );
              void 0 === n && l === Os && (n = vs),
                void 0 === n && l === Is && (n = Ts),
                s.call(this, null, r, i, a, o, c, l, n, h),
                (this.image = { width: t, height: e }),
                (this.magFilter = void 0 !== o ? o : cs),
                (this.minFilter = void 0 !== c ? c : cs),
                (this.flipY = !1),
                (this.generateMipmaps = !1);
            }
            function qe(t) {
              F.call(this), (this.type = "WireframeGeometry");
              var e,
                n,
                r,
                i,
                o,
                s,
                c,
                h,
                l,
                u,
                p = [],
                d = [0, 0],
                f = {},
                m = ["a", "b", "c"];
              if (t && t.isGeometry) {
                var g = t.faces;
                for (e = 0, r = g.length; e < r; e++) {
                  var v = g[e];
                  for (n = 0; n < 3; n++)
                    (c = v[m[n]]),
                      (h = v[m[(n + 1) % 3]]),
                      (d[0] = Math.min(c, h)),
                      (d[1] = Math.max(c, h)),
                      (l = d[0] + "," + d[1]),
                      void 0 === f[l] &&
                        (f[l] = { index1: d[0], index2: d[1] });
                }
                for (l in f)
                  (s = f[l]),
                    (u = t.vertices[s.index1]),
                    p.push(u.x, u.y, u.z),
                    (u = t.vertices[s.index2]),
                    p.push(u.x, u.y, u.z);
              } else if (t && t.isBufferGeometry) {
                var y, x, b, _, w, M, E, T;
                if (((u = new a()), null !== t.index)) {
                  for (
                    y = t.attributes.position,
                      x = t.index,
                      b = t.groups,
                      0 === b.length &&
                        (b = [{ start: 0, count: x.count, materialIndex: 0 }]),
                      i = 0,
                      o = b.length;
                    i < o;
                    ++i
                  )
                    for (
                      _ = b[i], w = _.start, M = _.count, e = w, r = w + M;
                      e < r;
                      e += 3
                    )
                      for (n = 0; n < 3; n++)
                        (c = x.getX(e + n)),
                          (h = x.getX(e + ((n + 1) % 3))),
                          (d[0] = Math.min(c, h)),
                          (d[1] = Math.max(c, h)),
                          (l = d[0] + "," + d[1]),
                          void 0 === f[l] &&
                            (f[l] = { index1: d[0], index2: d[1] });
                  for (l in f)
                    (s = f[l]),
                      u.fromBufferAttribute(y, s.index1),
                      p.push(u.x, u.y, u.z),
                      u.fromBufferAttribute(y, s.index2),
                      p.push(u.x, u.y, u.z);
                } else
                  for (
                    y = t.attributes.position, e = 0, r = y.count / 3;
                    e < r;
                    e++
                  )
                    for (n = 0; n < 3; n++)
                      (E = 3 * e + n),
                        u.fromBufferAttribute(y, E),
                        p.push(u.x, u.y, u.z),
                        (T = 3 * e + ((n + 1) % 3)),
                        u.fromBufferAttribute(y, T),
                        p.push(u.x, u.y, u.z);
              }
              this.addAttribute("position", new N(p, 3));
            }
            function Ye(t, e, n) {
              T.call(this),
                (this.type = "ParametricGeometry"),
                (this.parameters = { func: t, slices: e, stacks: n }),
                this.fromBufferGeometry(new Je(t, e, n)),
                this.mergeVertices();
            }
            function Je(t, e, n) {
              F.call(this),
                (this.type = "ParametricBufferGeometry"),
                (this.parameters = { func: t, slices: e, stacks: n });
              var r,
                i,
                o = [],
                s = [],
                c = [],
                h = [],
                l = new a(),
                u = new a(),
                p = new a(),
                d = new a(),
                f = new a();
              t.length < 3 &&
                console.error(
                  "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
                );
              var m = e + 1;
              for (r = 0; r <= n; r++) {
                var g = r / n;
                for (i = 0; i <= e; i++) {
                  var v = i / e;
                  t(v, g, u),
                    s.push(u.x, u.y, u.z),
                    v - 1e-5 >= 0
                      ? (t(v - 1e-5, g, p), d.subVectors(u, p))
                      : (t(v + 1e-5, g, p), d.subVectors(p, u)),
                    g - 1e-5 >= 0
                      ? (t(v, g - 1e-5, p), f.subVectors(u, p))
                      : (t(v, g + 1e-5, p), f.subVectors(p, u)),
                    l.crossVectors(d, f).normalize(),
                    c.push(l.x, l.y, l.z),
                    h.push(v, g);
                }
              }
              for (r = 0; r < n; r++)
                for (i = 0; i < e; i++) {
                  var y = r * m + i,
                    x = r * m + i + 1,
                    b = (r + 1) * m + i + 1,
                    _ = (r + 1) * m + i;
                  o.push(y, x, _), o.push(x, b, _);
                }
              this.setIndex(o),
                this.addAttribute("position", new N(s, 3)),
                this.addAttribute("normal", new N(c, 3)),
                this.addAttribute("uv", new N(h, 2));
            }
            function Ze(t, e, n, r) {
              T.call(this),
                (this.type = "PolyhedronGeometry"),
                (this.parameters = {
                  vertices: t,
                  indices: e,
                  radius: n,
                  detail: r,
                }),
                this.fromBufferGeometry(new Qe(t, e, n, r)),
                this.mergeVertices();
            }
            function Qe(t, e, r, i) {
              function o(t, e, n, r) {
                var i,
                  a,
                  o = Math.pow(2, r),
                  s = [];
                for (i = 0; i <= o; i++) {
                  s[i] = [];
                  var h = t.clone().lerp(n, i / o),
                    l = e.clone().lerp(n, i / o),
                    u = o - i;
                  for (a = 0; a <= u; a++)
                    s[i][a] = 0 === a && i === o ? h : h.clone().lerp(l, a / u);
                }
                for (i = 0; i < o; i++)
                  for (a = 0; a < 2 * (o - i) - 1; a++) {
                    var p = Math.floor(a / 2);
                    a % 2 == 0
                      ? (c(s[i][p + 1]), c(s[i + 1][p]), c(s[i][p]))
                      : (c(s[i][p + 1]), c(s[i + 1][p + 1]), c(s[i + 1][p]));
                  }
              }
              function s() {
                for (var t = 0; t < m.length; t += 6) {
                  var e = m[t + 0],
                    n = m[t + 2],
                    r = m[t + 4],
                    i = Math.max(e, n, r),
                    a = Math.min(e, n, r);
                  i > 0.9 &&
                    a < 0.1 &&
                    (e < 0.2 && (m[t + 0] += 1),
                    n < 0.2 && (m[t + 2] += 1),
                    r < 0.2 && (m[t + 4] += 1));
                }
              }
              function c(t) {
                f.push(t.x, t.y, t.z);
              }
              function h(e, n) {
                var r = 3 * e;
                (n.x = t[r + 0]), (n.y = t[r + 1]), (n.z = t[r + 2]);
              }
              function l() {
                for (
                  var t = new a(),
                    e = new a(),
                    r = new a(),
                    i = new a(),
                    o = new n(),
                    s = new n(),
                    c = new n(),
                    h = 0,
                    l = 0;
                  h < f.length;
                  h += 9, l += 6
                ) {
                  t.set(f[h + 0], f[h + 1], f[h + 2]),
                    e.set(f[h + 3], f[h + 4], f[h + 5]),
                    r.set(f[h + 6], f[h + 7], f[h + 8]),
                    o.set(m[l + 0], m[l + 1]),
                    s.set(m[l + 2], m[l + 3]),
                    c.set(m[l + 4], m[l + 5]),
                    i.copy(t).add(e).add(r).divideScalar(3);
                  var d = p(i);
                  u(o, l + 0, t, d), u(s, l + 2, e, d), u(c, l + 4, r, d);
                }
              }
              function u(t, e, n, r) {
                r < 0 && 1 === t.x && (m[e] = t.x - 1),
                  0 === n.x && 0 === n.z && (m[e] = r / 2 / Math.PI + 0.5);
              }
              function p(t) {
                return Math.atan2(t.z, -t.x);
              }
              function d(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
              }
              F.call(this),
                (this.type = "PolyhedronBufferGeometry"),
                (this.parameters = {
                  vertices: t,
                  indices: e,
                  radius: r,
                  detail: i,
                }),
                (r = r || 1),
                (i = i || 0);
              var f = [],
                m = [];
              !(function (t) {
                for (
                  var n = new a(), r = new a(), i = new a(), s = 0;
                  s < e.length;
                  s += 3
                )
                  h(e[s + 0], n), h(e[s + 1], r), h(e[s + 2], i), o(n, r, i, t);
              })(i),
                (function (t) {
                  for (var e = new a(), n = 0; n < f.length; n += 3)
                    (e.x = f[n + 0]),
                      (e.y = f[n + 1]),
                      (e.z = f[n + 2]),
                      e.normalize().multiplyScalar(t),
                      (f[n + 0] = e.x),
                      (f[n + 1] = e.y),
                      (f[n + 2] = e.z);
                })(r),
                (function () {
                  for (var t = new a(), e = 0; e < f.length; e += 3) {
                    (t.x = f[e + 0]), (t.y = f[e + 1]), (t.z = f[e + 2]);
                    var n = p(t) / 2 / Math.PI + 0.5,
                      r = d(t) / Math.PI + 0.5;
                    m.push(n, 1 - r);
                  }
                  l(), s();
                })(),
                this.addAttribute("position", new N(f, 3)),
                this.addAttribute("normal", new N(f.slice(), 3)),
                this.addAttribute("uv", new N(m, 2)),
                0 === i ? this.computeVertexNormals() : this.normalizeNormals();
            }
            function Ke(t, e) {
              T.call(this),
                (this.type = "TetrahedronGeometry"),
                (this.parameters = { radius: t, detail: e }),
                this.fromBufferGeometry(new $e(t, e)),
                this.mergeVertices();
            }
            function $e(t, e) {
              var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
              Qe.call(this, n, r, t, e),
                (this.type = "TetrahedronBufferGeometry"),
                (this.parameters = { radius: t, detail: e });
            }
            function tn(t, e) {
              T.call(this),
                (this.type = "OctahedronGeometry"),
                (this.parameters = { radius: t, detail: e }),
                this.fromBufferGeometry(new en(t, e)),
                this.mergeVertices();
            }
            function en(t, e) {
              var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                r = [
                  0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
                  1, 4, 2,
                ];
              Qe.call(this, n, r, t, e),
                (this.type = "OctahedronBufferGeometry"),
                (this.parameters = { radius: t, detail: e });
            }
            function nn(t, e) {
              T.call(this),
                (this.type = "IcosahedronGeometry"),
                (this.parameters = { radius: t, detail: e }),
                this.fromBufferGeometry(new rn(t, e)),
                this.mergeVertices();
            }
            function rn(t, e) {
              var n = (1 + Math.sqrt(5)) / 2,
                r = [
                  -1,
                  n,
                  0,
                  1,
                  n,
                  0,
                  -1,
                  -n,
                  0,
                  1,
                  -n,
                  0,
                  0,
                  -1,
                  n,
                  0,
                  1,
                  n,
                  0,
                  -1,
                  -n,
                  0,
                  1,
                  -n,
                  n,
                  0,
                  -1,
                  n,
                  0,
                  1,
                  -n,
                  0,
                  -1,
                  -n,
                  0,
                  1,
                ],
                i = [
                  0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
                  11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2,
                  6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9,
                  8, 1,
                ];
              Qe.call(this, r, i, t, e),
                (this.type = "IcosahedronBufferGeometry"),
                (this.parameters = { radius: t, detail: e });
            }
            function an(t, e) {
              T.call(this),
                (this.type = "DodecahedronGeometry"),
                (this.parameters = { radius: t, detail: e }),
                this.fromBufferGeometry(new on(t, e)),
                this.mergeVertices();
            }
            function on(t, e) {
              var n = (1 + Math.sqrt(5)) / 2,
                r = 1 / n,
                i = [
                  -1,
                  -1,
                  -1,
                  -1,
                  -1,
                  1,
                  -1,
                  1,
                  -1,
                  -1,
                  1,
                  1,
                  1,
                  -1,
                  -1,
                  1,
                  -1,
                  1,
                  1,
                  1,
                  -1,
                  1,
                  1,
                  1,
                  0,
                  -r,
                  -n,
                  0,
                  -r,
                  n,
                  0,
                  r,
                  -n,
                  0,
                  r,
                  n,
                  -r,
                  -n,
                  0,
                  -r,
                  n,
                  0,
                  r,
                  -n,
                  0,
                  r,
                  n,
                  0,
                  -n,
                  0,
                  -r,
                  n,
                  0,
                  -r,
                  -n,
                  0,
                  r,
                  n,
                  0,
                  r,
                ],
                a = [
                  3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                  17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10,
                  0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15,
                  2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3,
                  4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7,
                  19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
                ];
              Qe.call(this, i, a, t, e),
                (this.type = "DodecahedronBufferGeometry"),
                (this.parameters = { radius: t, detail: e });
            }
            function sn(t, e, n, r, i, a) {
              T.call(this),
                (this.type = "TubeGeometry"),
                (this.parameters = {
                  path: t,
                  tubularSegments: e,
                  radius: n,
                  radialSegments: r,
                  closed: i,
                }),
                void 0 !== a &&
                  console.warn("THREE.TubeGeometry: taper has been removed.");
              var o = new cn(t, e, n, r, i);
              (this.tangents = o.tangents),
                (this.normals = o.normals),
                (this.binormals = o.binormals),
                this.fromBufferGeometry(o),
                this.mergeVertices();
            }
            function cn(t, e, r, i, o) {
              function s(n) {
                g = t.getPointAt(n / e, g);
                var a = l.normals[n],
                  o = l.binormals[n];
                for (p = 0; p <= i; p++) {
                  var s = (p / i) * Math.PI * 2,
                    c = Math.sin(s),
                    h = -Math.cos(s);
                  (f.x = h * a.x + c * o.x),
                    (f.y = h * a.y + c * o.y),
                    (f.z = h * a.z + c * o.z),
                    f.normalize(),
                    y.push(f.x, f.y, f.z),
                    (d.x = g.x + r * f.x),
                    (d.y = g.y + r * f.y),
                    (d.z = g.z + r * f.z),
                    v.push(d.x, d.y, d.z);
                }
              }
              function c() {
                for (p = 1; p <= e; p++)
                  for (u = 1; u <= i; u++) {
                    var t = (i + 1) * (p - 1) + (u - 1),
                      n = (i + 1) * p + (u - 1),
                      r = (i + 1) * p + u,
                      a = (i + 1) * (p - 1) + u;
                    b.push(t, n, a), b.push(n, r, a);
                  }
              }
              function h() {
                for (u = 0; u <= e; u++)
                  for (p = 0; p <= i; p++)
                    (m.x = u / e), (m.y = p / i), x.push(m.x, m.y);
              }
              F.call(this),
                (this.type = "TubeBufferGeometry"),
                (this.parameters = {
                  path: t,
                  tubularSegments: e,
                  radius: r,
                  radialSegments: i,
                  closed: o,
                }),
                (e = e || 64),
                (r = r || 1),
                (i = i || 8),
                (o = o || !1);
              var l = t.computeFrenetFrames(e, o);
              (this.tangents = l.tangents),
                (this.normals = l.normals),
                (this.binormals = l.binormals);
              var u,
                p,
                d = new a(),
                f = new a(),
                m = new n(),
                g = new a(),
                v = [],
                y = [],
                x = [],
                b = [];
              !(function () {
                for (u = 0; u < e; u++) s(u);
                s(!1 === o ? e : 0), h(), c();
              })(),
                this.setIndex(b),
                this.addAttribute("position", new N(v, 3)),
                this.addAttribute("normal", new N(y, 3)),
                this.addAttribute("uv", new N(x, 2));
            }
            function hn(t, e, n, r, i, a, o) {
              T.call(this),
                (this.type = "TorusKnotGeometry"),
                (this.parameters = {
                  radius: t,
                  tube: e,
                  tubularSegments: n,
                  radialSegments: r,
                  p: i,
                  q: a,
                }),
                void 0 !== o &&
                  console.warn(
                    "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
                  ),
                this.fromBufferGeometry(new ln(t, e, n, r, i, a)),
                this.mergeVertices();
            }
            function ln(t, e, n, r, i, o) {
              function s(t, e, n, r, i) {
                var a = Math.cos(t),
                  o = Math.sin(t),
                  s = (n / e) * t,
                  c = Math.cos(s);
                (i.x = r * (2 + c) * 0.5 * a),
                  (i.y = r * (2 + c) * o * 0.5),
                  (i.z = r * Math.sin(s) * 0.5);
              }
              F.call(this),
                (this.type = "TorusKnotBufferGeometry"),
                (this.parameters = {
                  radius: t,
                  tube: e,
                  tubularSegments: n,
                  radialSegments: r,
                  p: i,
                  q: o,
                }),
                (t = t || 1),
                (e = e || 0.4),
                (n = Math.floor(n) || 64),
                (r = Math.floor(r) || 8),
                (i = i || 2),
                (o = o || 3);
              var c,
                h,
                l = [],
                u = [],
                p = [],
                d = [],
                f = new a(),
                m = new a(),
                g = new a(),
                v = new a(),
                y = new a(),
                x = new a(),
                b = new a();
              for (c = 0; c <= n; ++c) {
                var _ = (c / n) * i * Math.PI * 2;
                for (
                  s(_, i, o, t, g),
                    s(_ + 0.01, i, o, t, v),
                    x.subVectors(v, g),
                    b.addVectors(v, g),
                    y.crossVectors(x, b),
                    b.crossVectors(y, x),
                    y.normalize(),
                    b.normalize(),
                    h = 0;
                  h <= r;
                  ++h
                ) {
                  var w = (h / r) * Math.PI * 2,
                    M = -e * Math.cos(w),
                    E = e * Math.sin(w);
                  (f.x = g.x + (M * b.x + E * y.x)),
                    (f.y = g.y + (M * b.y + E * y.y)),
                    (f.z = g.z + (M * b.z + E * y.z)),
                    u.push(f.x, f.y, f.z),
                    m.subVectors(f, g).normalize(),
                    p.push(m.x, m.y, m.z),
                    d.push(c / n),
                    d.push(h / r);
                }
              }
              for (h = 1; h <= n; h++)
                for (c = 1; c <= r; c++) {
                  var T = (r + 1) * (h - 1) + (c - 1),
                    S = (r + 1) * h + (c - 1),
                    A = (r + 1) * h + c,
                    L = (r + 1) * (h - 1) + c;
                  l.push(T, S, L), l.push(S, A, L);
                }
              this.setIndex(l),
                this.addAttribute("position", new N(u, 3)),
                this.addAttribute("normal", new N(p, 3)),
                this.addAttribute("uv", new N(d, 2));
            }
            function un(t, e, n, r, i) {
              T.call(this),
                (this.type = "TorusGeometry"),
                (this.parameters = {
                  radius: t,
                  tube: e,
                  radialSegments: n,
                  tubularSegments: r,
                  arc: i,
                }),
                this.fromBufferGeometry(new pn(t, e, n, r, i)),
                this.mergeVertices();
            }
            function pn(t, e, n, r, i) {
              F.call(this),
                (this.type = "TorusBufferGeometry"),
                (this.parameters = {
                  radius: t,
                  tube: e,
                  radialSegments: n,
                  tubularSegments: r,
                  arc: i,
                }),
                (t = t || 1),
                (e = e || 0.4),
                (n = Math.floor(n) || 8),
                (r = Math.floor(r) || 6),
                (i = i || 2 * Math.PI);
              var o,
                s,
                c = [],
                h = [],
                l = [],
                u = [],
                p = new a(),
                d = new a(),
                f = new a();
              for (o = 0; o <= n; o++)
                for (s = 0; s <= r; s++) {
                  var m = (s / r) * i,
                    g = (o / n) * Math.PI * 2;
                  (d.x = (t + e * Math.cos(g)) * Math.cos(m)),
                    (d.y = (t + e * Math.cos(g)) * Math.sin(m)),
                    (d.z = e * Math.sin(g)),
                    h.push(d.x, d.y, d.z),
                    (p.x = t * Math.cos(m)),
                    (p.y = t * Math.sin(m)),
                    f.subVectors(d, p).normalize(),
                    l.push(f.x, f.y, f.z),
                    u.push(s / r),
                    u.push(o / n);
                }
              for (o = 1; o <= n; o++)
                for (s = 1; s <= r; s++) {
                  var v = (r + 1) * o + s - 1,
                    y = (r + 1) * (o - 1) + s - 1,
                    x = (r + 1) * (o - 1) + s,
                    b = (r + 1) * o + s;
                  c.push(v, y, b), c.push(y, x, b);
                }
              this.setIndex(c),
                this.addAttribute("position", new N(h, 3)),
                this.addAttribute("normal", new N(l, 3)),
                this.addAttribute("uv", new N(u, 2));
            }
            function dn(t, e, n, r, i) {
              var a, o;
              if (i === Gn(t, e, n, r) > 0)
                for (a = e; a < n; a += r) o = Bn(a, t[a], t[a + 1], o);
              else for (a = n - r; a >= e; a -= r) o = Bn(a, t[a], t[a + 1], o);
              return o && Pn(o, o.next) && (Fn(o), (o = o.next)), o;
            }
            function fn(t, e) {
              if (!t) return t;
              e || (e = t);
              var n,
                r = t;
              do {
                if (
                  ((n = !1),
                  r.steiner || (!Pn(r, r.next) && 0 !== Cn(r.prev, r, r.next)))
                )
                  r = r.next;
                else {
                  if ((Fn(r), (r = e = r.prev) === r.next)) break;
                  n = !0;
                }
              } while (n || r !== e);
              return e;
            }
            function mn(t, e, n, r, i, a, o) {
              if (t) {
                !o && a && En(t, r, i, a);
                for (var s, c, h = t; t.prev !== t.next; )
                  if (((s = t.prev), (c = t.next), a ? vn(t, r, i, a) : gn(t)))
                    e.push(s.i / n),
                      e.push(t.i / n),
                      e.push(c.i / n),
                      Fn(t),
                      (t = c.next),
                      (h = c.next);
                  else if ((t = c) === h) {
                    o
                      ? 1 === o
                        ? ((t = yn(t, e, n)), mn(t, e, n, r, i, a, 2))
                        : 2 === o && xn(t, e, n, r, i, a)
                      : mn(fn(t), e, n, r, i, a, 1);
                    break;
                  }
              }
            }
            function gn(t) {
              var e = t.prev,
                n = t,
                r = t.next;
              if (Cn(e, n, r) >= 0) return !1;
              for (var i = t.next.next; i !== t.prev; ) {
                if (
                  Ln(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
                  Cn(i.prev, i, i.next) >= 0
                )
                  return !1;
                i = i.next;
              }
              return !0;
            }
            function vn(t, e, n, r) {
              var i = t.prev,
                a = t,
                o = t.next;
              if (Cn(i, a, o) >= 0) return !1;
              for (
                var s =
                    i.x < a.x ? (i.x < o.x ? i.x : o.x) : a.x < o.x ? a.x : o.x,
                  c =
                    i.y < a.y ? (i.y < o.y ? i.y : o.y) : a.y < o.y ? a.y : o.y,
                  h =
                    i.x > a.x ? (i.x > o.x ? i.x : o.x) : a.x > o.x ? a.x : o.x,
                  l =
                    i.y > a.y ? (i.y > o.y ? i.y : o.y) : a.y > o.y ? a.y : o.y,
                  u = Sn(s, c, e, n, r),
                  p = Sn(h, l, e, n, r),
                  d = t.nextZ;
                d && d.z <= p;

              ) {
                if (
                  d !== t.prev &&
                  d !== t.next &&
                  Ln(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                  Cn(d.prev, d, d.next) >= 0
                )
                  return !1;
                d = d.nextZ;
              }
              for (d = t.prevZ; d && d.z >= u; ) {
                if (
                  d !== t.prev &&
                  d !== t.next &&
                  Ln(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                  Cn(d.prev, d, d.next) >= 0
                )
                  return !1;
                d = d.prevZ;
              }
              return !0;
            }
            function yn(t, e, n) {
              var r = t;
              do {
                var i = r.prev,
                  a = r.next.next;
                !Pn(i, a) &&
                  On(i, r, r.next, a) &&
                  Nn(i, a) &&
                  Nn(a, i) &&
                  (e.push(i.i / n),
                  e.push(r.i / n),
                  e.push(a.i / n),
                  Fn(r),
                  Fn(r.next),
                  (r = t = a)),
                  (r = r.next);
              } while (r !== t);
              return r;
            }
            function xn(t, e, n, r, i, a) {
              var o = t;
              do {
                for (var s = o.next.next; s !== o.prev; ) {
                  if (o.i !== s.i && Rn(o, s)) {
                    var c = Un(o, s);
                    return (
                      (o = fn(o, o.next)),
                      (c = fn(c, c.next)),
                      mn(o, e, n, r, i, a),
                      void mn(c, e, n, r, i, a)
                    );
                  }
                  s = s.next;
                }
                o = o.next;
              } while (o !== t);
            }
            function bn(t, e, n, r) {
              var i,
                a,
                o,
                s,
                c,
                h = [];
              for (i = 0, a = e.length; i < a; i++)
                (o = e[i] * r),
                  (s = i < a - 1 ? e[i + 1] * r : t.length),
                  (c = dn(t, o, s, r, !1)),
                  c === c.next && (c.steiner = !0),
                  h.push(An(c));
              for (h.sort(_n), i = 0; i < h.length; i++)
                wn(h[i], n), (n = fn(n, n.next));
              return n;
            }
            function _n(t, e) {
              return t.x - e.x;
            }
            function wn(t, e) {
              if ((e = Mn(t, e))) {
                var n = Un(e, t);
                fn(n, n.next);
              }
            }
            function Mn(t, e) {
              var n,
                r = e,
                i = t.x,
                a = t.y,
                o = -1 / 0;
              do {
                if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                  var s =
                    r.x + ((a - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
                  if (s <= i && s > o) {
                    if (((o = s), s === i)) {
                      if (a === r.y) return r;
                      if (a === r.next.y) return r.next;
                    }
                    n = r.x < r.next.x ? r : r.next;
                  }
                }
                r = r.next;
              } while (r !== e);
              if (!n) return null;
              if (i === o) return n.prev;
              var c,
                h = n,
                l = n.x,
                u = n.y,
                p = 1 / 0;
              for (r = n.next; r !== h; )
                i >= r.x &&
                  r.x >= l &&
                  i !== r.x &&
                  Ln(a < u ? i : o, a, l, u, a < u ? o : i, a, r.x, r.y) &&
                  ((c = Math.abs(a - r.y) / (i - r.x)) < p ||
                    (c === p && r.x > n.x)) &&
                  Nn(r, t) &&
                  ((n = r), (p = c)),
                  (r = r.next);
              return n;
            }
            function En(t, e, n, r) {
              var i = t;
              do {
                null === i.z && (i.z = Sn(i.x, i.y, e, n, r)),
                  (i.prevZ = i.prev),
                  (i.nextZ = i.next),
                  (i = i.next);
              } while (i !== t);
              (i.prevZ.nextZ = null), (i.prevZ = null), Tn(i);
            }
            function Tn(t) {
              var e,
                n,
                r,
                i,
                a,
                o,
                s,
                c,
                h = 1;
              do {
                for (n = t, t = null, a = null, o = 0; n; ) {
                  for (
                    o++, r = n, s = 0, e = 0;
                    e < h && (s++, (r = r.nextZ));
                    e++
                  );
                  for (c = h; s > 0 || (c > 0 && r); )
                    0 !== s && (0 === c || !r || n.z <= r.z)
                      ? ((i = n), (n = n.nextZ), s--)
                      : ((i = r), (r = r.nextZ), c--),
                      a ? (a.nextZ = i) : (t = i),
                      (i.prevZ = a),
                      (a = i);
                  n = r;
                }
                (a.nextZ = null), (h *= 2);
              } while (o > 1);
              return t;
            }
            function Sn(t, e, n, r, i) {
              return (
                (t = 32767 * (t - n) * i),
                (e = 32767 * (e - r) * i),
                (t = 16711935 & (t | (t << 8))),
                (t = 252645135 & (t | (t << 4))),
                (t = 858993459 & (t | (t << 2))),
                (t = 1431655765 & (t | (t << 1))),
                (e = 16711935 & (e | (e << 8))),
                (e = 252645135 & (e | (e << 4))),
                (e = 858993459 & (e | (e << 2))),
                (e = 1431655765 & (e | (e << 1))),
                t | (e << 1)
              );
            }
            function An(t) {
              var e = t,
                n = t;
              do {
                e.x < n.x && (n = e), (e = e.next);
              } while (e !== t);
              return n;
            }
            function Ln(t, e, n, r, i, a, o, s) {
              return (
                (i - o) * (e - s) - (t - o) * (a - s) >= 0 &&
                (t - o) * (r - s) - (n - o) * (e - s) >= 0 &&
                (n - o) * (a - s) - (i - o) * (r - s) >= 0
              );
            }
            function Rn(t, e) {
              return (
                t.next.i !== e.i &&
                t.prev.i !== e.i &&
                !In(t, e) &&
                Nn(t, e) &&
                Nn(e, t) &&
                Dn(t, e)
              );
            }
            function Cn(t, e, n) {
              return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
            }
            function Pn(t, e) {
              return t.x === e.x && t.y === e.y;
            }
            function On(t, e, n, r) {
              return (
                !!((Pn(t, e) && Pn(n, r)) || (Pn(t, r) && Pn(n, e))) ||
                (Cn(t, e, n) > 0 != Cn(t, e, r) > 0 &&
                  Cn(n, r, t) > 0 != Cn(n, r, e) > 0)
              );
            }
            function In(t, e) {
              var n = t;
              do {
                if (
                  n.i !== t.i &&
                  n.next.i !== t.i &&
                  n.i !== e.i &&
                  n.next.i !== e.i &&
                  On(n, n.next, t, e)
                )
                  return !0;
                n = n.next;
              } while (n !== t);
              return !1;
            }
            function Nn(t, e) {
              return Cn(t.prev, t, t.next) < 0
                ? Cn(t, e, t.next) >= 0 && Cn(t, t.prev, e) >= 0
                : Cn(t, e, t.prev) < 0 || Cn(t, t.next, e) < 0;
            }
            function Dn(t, e) {
              var n = t,
                r = !1,
                i = (t.x + e.x) / 2,
                a = (t.y + e.y) / 2;
              do {
                n.y > a != n.next.y > a &&
                  n.next.y !== n.y &&
                  i < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
                  (r = !r),
                  (n = n.next);
              } while (n !== t);
              return r;
            }
            function Un(t, e) {
              var n = new zn(t.i, t.x, t.y),
                r = new zn(e.i, e.x, e.y),
                i = t.next,
                a = e.prev;
              return (
                (t.next = e),
                (e.prev = t),
                (n.next = i),
                (i.prev = n),
                (r.next = n),
                (n.prev = r),
                (a.next = r),
                (r.prev = a),
                r
              );
            }
            function Bn(t, e, n, r) {
              var i = new zn(t, e, n);
              return (
                r
                  ? ((i.next = r.next),
                    (i.prev = r),
                    (r.next.prev = i),
                    (r.next = i))
                  : ((i.prev = i), (i.next = i)),
                i
              );
            }
            function Fn(t) {
              (t.next.prev = t.prev),
                (t.prev.next = t.next),
                t.prevZ && (t.prevZ.nextZ = t.nextZ),
                t.nextZ && (t.nextZ.prevZ = t.prevZ);
            }
            function zn(t, e, n) {
              (this.i = t),
                (this.x = e),
                (this.y = n),
                (this.prev = null),
                (this.next = null),
                (this.z = null),
                (this.prevZ = null),
                (this.nextZ = null),
                (this.steiner = !1);
            }
            function Gn(t, e, n, r) {
              for (var i = 0, a = e, o = n - r; a < n; a += r)
                (i += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
              return i;
            }
            function Hn(t) {
              var e = t.length;
              e > 2 && t[e - 1].equals(t[0]) && t.pop();
            }
            function Vn(t, e) {
              for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
            }
            function kn(t, e) {
              T.call(this),
                (this.type = "ExtrudeGeometry"),
                (this.parameters = { shapes: t, options: e }),
                this.fromBufferGeometry(new jn(t, e)),
                this.mergeVertices();
            }
            function jn(t, e) {
              F.call(this),
                (this.type = "ExtrudeBufferGeometry"),
                (this.parameters = { shapes: t, options: e }),
                (t = Array.isArray(t) ? t : [t]);
              for (
                var r = this, i = [], o = [], s = 0, c = t.length;
                s < c;
                s++
              ) {
                var h = t[s];
                !(function (t) {
                  function s(t, e, n) {
                    return (
                      e ||
                        console.error(
                          "THREE.ExtrudeGeometry: vec does not exist"
                        ),
                      e.clone().multiplyScalar(n).add(t)
                    );
                  }
                  function c(t, e, r) {
                    var i,
                      a,
                      o,
                      s = t.x - e.x,
                      c = t.y - e.y,
                      h = r.x - t.x,
                      l = r.y - t.y,
                      u = s * s + c * c,
                      p = s * l - c * h;
                    if (Math.abs(p) > Number.EPSILON) {
                      var d = Math.sqrt(u),
                        f = Math.sqrt(h * h + l * l),
                        m = e.x - c / d,
                        g = e.y + s / d,
                        v = r.x - l / f,
                        y = r.y + h / f,
                        x = ((v - m) * l - (y - g) * h) / (s * l - c * h);
                      (i = m + s * x - t.x), (a = g + c * x - t.y);
                      var b = i * i + a * a;
                      if (b <= 2) return new n(i, a);
                      o = Math.sqrt(b / 2);
                    } else {
                      var _ = !1;
                      s > Number.EPSILON
                        ? h > Number.EPSILON && (_ = !0)
                        : s < -Number.EPSILON
                        ? h < -Number.EPSILON && (_ = !0)
                        : Math.sign(c) === Math.sign(l) && (_ = !0),
                        _
                          ? ((i = -c), (a = s), (o = Math.sqrt(u)))
                          : ((i = s), (a = c), (o = Math.sqrt(u / 2)));
                    }
                    return new n(i / o, a / o);
                  }
                  function h(t, e) {
                    var n, r;
                    for (Y = t.length; --Y >= 0; ) {
                      (n = Y), (r = Y - 1) < 0 && (r = t.length - 1);
                      var i = 0,
                        a = v + 2 * w;
                      for (i = 0; i < a; i++) {
                        var o = W * i,
                          s = W * (i + 1);
                        p(e + n + o, e + r + o, e + r + s, e + n + s);
                      }
                    }
                  }
                  function l(t, e, n) {
                    m.push(t), m.push(e), m.push(n);
                  }
                  function u(t, e, n) {
                    d(t), d(e), d(n);
                    var a = i.length / 3,
                      o = E.generateTopUV(r, i, a - 3, a - 2, a - 1);
                    f(o[0]), f(o[1]), f(o[2]);
                  }
                  function p(t, e, n, a) {
                    d(t), d(e), d(a), d(e), d(n), d(a);
                    var o = i.length / 3,
                      s = E.generateSideWallUV(
                        r,
                        i,
                        o - 6,
                        o - 3,
                        o - 2,
                        o - 1
                      );
                    f(s[0]), f(s[1]), f(s[3]), f(s[1]), f(s[2]), f(s[3]);
                  }
                  function d(t) {
                    i.push(m[3 * t + 0]),
                      i.push(m[3 * t + 1]),
                      i.push(m[3 * t + 2]);
                  }
                  function f(t) {
                    o.push(t.x), o.push(t.y);
                  }
                  var m = [],
                    g = void 0 !== e.curveSegments ? e.curveSegments : 12,
                    v = void 0 !== e.steps ? e.steps : 1,
                    y = void 0 !== e.depth ? e.depth : 100,
                    x = void 0 === e.bevelEnabled || e.bevelEnabled,
                    b = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                    _ = void 0 !== e.bevelSize ? e.bevelSize : b - 2,
                    w = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                    M = e.extrudePath,
                    E = void 0 !== e.UVGenerator ? e.UVGenerator : jc;
                  void 0 !== e.amount &&
                    (console.warn(
                      "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                    ),
                    (y = e.amount));
                  var T,
                    S,
                    A,
                    L,
                    R,
                    C = !1;
                  M &&
                    ((T = M.getSpacedPoints(v)),
                    (C = !0),
                    (x = !1),
                    (S = M.computeFrenetFrames(v, !1)),
                    (A = new a()),
                    (L = new a()),
                    (R = new a())),
                    x || ((w = 0), (b = 0), (_ = 0));
                  var P,
                    O,
                    I,
                    N = t.extractPoints(g),
                    D = N.shape,
                    U = N.holes;
                  if (!kc.isClockWise(D))
                    for (D = D.reverse(), O = 0, I = U.length; O < I; O++)
                      (P = U[O]), kc.isClockWise(P) && (U[O] = P.reverse());
                  var B = kc.triangulateShape(D, U),
                    F = D;
                  for (O = 0, I = U.length; O < I; O++)
                    (P = U[O]), (D = D.concat(P));
                  for (
                    var z,
                      G,
                      H,
                      V,
                      k,
                      j,
                      W = D.length,
                      X = B.length,
                      q = [],
                      Y = 0,
                      J = F.length,
                      Z = J - 1,
                      Q = Y + 1;
                    Y < J;
                    Y++, Z++, Q++
                  )
                    Z === J && (Z = 0),
                      Q === J && (Q = 0),
                      (q[Y] = c(F[Y], F[Z], F[Q]));
                  var K,
                    $ = [],
                    tt = q.concat();
                  for (O = 0, I = U.length; O < I; O++) {
                    for (
                      P = U[O],
                        K = [],
                        Y = 0,
                        J = P.length,
                        Z = J - 1,
                        Q = Y + 1;
                      Y < J;
                      Y++, Z++, Q++
                    )
                      Z === J && (Z = 0),
                        Q === J && (Q = 0),
                        (K[Y] = c(P[Y], P[Z], P[Q]));
                    $.push(K), (tt = tt.concat(K));
                  }
                  for (z = 0; z < w; z++) {
                    for (
                      H = z / w,
                        V = b * Math.cos((H * Math.PI) / 2),
                        G = _ * Math.sin((H * Math.PI) / 2),
                        Y = 0,
                        J = F.length;
                      Y < J;
                      Y++
                    )
                      (k = s(F[Y], q[Y], G)), l(k.x, k.y, -V);
                    for (O = 0, I = U.length; O < I; O++)
                      for (P = U[O], K = $[O], Y = 0, J = P.length; Y < J; Y++)
                        (k = s(P[Y], K[Y], G)), l(k.x, k.y, -V);
                  }
                  for (G = _, Y = 0; Y < W; Y++)
                    (k = x ? s(D[Y], tt[Y], G) : D[Y]),
                      C
                        ? (L.copy(S.normals[0]).multiplyScalar(k.x),
                          A.copy(S.binormals[0]).multiplyScalar(k.y),
                          R.copy(T[0]).add(L).add(A),
                          l(R.x, R.y, R.z))
                        : l(k.x, k.y, 0);
                  var et;
                  for (et = 1; et <= v; et++)
                    for (Y = 0; Y < W; Y++)
                      (k = x ? s(D[Y], tt[Y], G) : D[Y]),
                        C
                          ? (L.copy(S.normals[et]).multiplyScalar(k.x),
                            A.copy(S.binormals[et]).multiplyScalar(k.y),
                            R.copy(T[et]).add(L).add(A),
                            l(R.x, R.y, R.z))
                          : l(k.x, k.y, (y / v) * et);
                  for (z = w - 1; z >= 0; z--) {
                    for (
                      H = z / w,
                        V = b * Math.cos((H * Math.PI) / 2),
                        G = _ * Math.sin((H * Math.PI) / 2),
                        Y = 0,
                        J = F.length;
                      Y < J;
                      Y++
                    )
                      (k = s(F[Y], q[Y], G)), l(k.x, k.y, y + V);
                    for (O = 0, I = U.length; O < I; O++)
                      for (P = U[O], K = $[O], Y = 0, J = P.length; Y < J; Y++)
                        (k = s(P[Y], K[Y], G)),
                          C
                            ? l(k.x, k.y + T[v - 1].y, T[v - 1].x + V)
                            : l(k.x, k.y, y + V);
                  }
                  !(function () {
                    var t = i.length / 3;
                    if (x) {
                      var e = 0,
                        n = W * e;
                      for (Y = 0; Y < X; Y++)
                        (j = B[Y]), u(j[2] + n, j[1] + n, j[0] + n);
                      for (e = v + 2 * w, n = W * e, Y = 0; Y < X; Y++)
                        (j = B[Y]), u(j[0] + n, j[1] + n, j[2] + n);
                    } else {
                      for (Y = 0; Y < X; Y++) (j = B[Y]), u(j[2], j[1], j[0]);
                      for (Y = 0; Y < X; Y++)
                        (j = B[Y]), u(j[0] + W * v, j[1] + W * v, j[2] + W * v);
                    }
                    r.addGroup(t, i.length / 3 - t, 0);
                  })(),
                    (function () {
                      var t = i.length / 3,
                        e = 0;
                      for (
                        h(F, e), e += F.length, O = 0, I = U.length;
                        O < I;
                        O++
                      )
                        (P = U[O]), h(P, e), (e += P.length);
                      r.addGroup(t, i.length / 3 - t, 1);
                    })();
                })(h);
              }
              this.addAttribute("position", new N(i, 3)),
                this.addAttribute("uv", new N(o, 2)),
                this.computeVertexNormals();
            }
            function Wn(t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (var r = 0, i = t.length; r < i; r++) {
                  var a = t[r];
                  n.shapes.push(a.uuid);
                }
              else n.shapes.push(t.uuid);
              return (
                void 0 !== e.extrudePath &&
                  (n.options.extrudePath = e.extrudePath.toJSON()),
                n
              );
            }
            function Xn(t, e) {
              T.call(this),
                (this.type = "TextGeometry"),
                (this.parameters = { text: t, parameters: e }),
                this.fromBufferGeometry(new qn(t, e)),
                this.mergeVertices();
            }
            function qn(t, e) {
              e = e || {};
              var n = e.font;
              if (!n || !n.isFont)
                return (
                  console.error(
                    "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
                  ),
                  new T()
                );
              var r = n.generateShapes(t, e.size);
              (e.depth = void 0 !== e.height ? e.height : 50),
                void 0 === e.bevelThickness && (e.bevelThickness = 10),
                void 0 === e.bevelSize && (e.bevelSize = 8),
                void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
                jn.call(this, r, e),
                (this.type = "TextBufferGeometry");
            }
            function Yn(t, e, n, r, i, a, o) {
              T.call(this),
                (this.type = "SphereGeometry"),
                (this.parameters = {
                  radius: t,
                  widthSegments: e,
                  heightSegments: n,
                  phiStart: r,
                  phiLength: i,
                  thetaStart: a,
                  thetaLength: o,
                }),
                this.fromBufferGeometry(new Jn(t, e, n, r, i, a, o)),
                this.mergeVertices();
            }
            function Jn(t, e, n, r, i, o, s) {
              F.call(this),
                (this.type = "SphereBufferGeometry"),
                (this.parameters = {
                  radius: t,
                  widthSegments: e,
                  heightSegments: n,
                  phiStart: r,
                  phiLength: i,
                  thetaStart: o,
                  thetaLength: s,
                }),
                (t = t || 1),
                (e = Math.max(3, Math.floor(e) || 8)),
                (n = Math.max(2, Math.floor(n) || 6)),
                (r = void 0 !== r ? r : 0),
                (i = void 0 !== i ? i : 2 * Math.PI),
                (o = void 0 !== o ? o : 0),
                (s = void 0 !== s ? s : Math.PI);
              var c,
                h,
                l = o + s,
                u = 0,
                p = [],
                d = new a(),
                f = new a(),
                m = [],
                g = [],
                v = [],
                y = [];
              for (h = 0; h <= n; h++) {
                var x = [],
                  b = h / n;
                for (c = 0; c <= e; c++) {
                  var _ = c / e;
                  (d.x = -t * Math.cos(r + _ * i) * Math.sin(o + b * s)),
                    (d.y = t * Math.cos(o + b * s)),
                    (d.z = t * Math.sin(r + _ * i) * Math.sin(o + b * s)),
                    g.push(d.x, d.y, d.z),
                    f.set(d.x, d.y, d.z).normalize(),
                    v.push(f.x, f.y, f.z),
                    y.push(_, 1 - b),
                    x.push(u++);
                }
                p.push(x);
              }
              for (h = 0; h < n; h++)
                for (c = 0; c < e; c++) {
                  var w = p[h][c + 1],
                    M = p[h][c],
                    E = p[h + 1][c],
                    T = p[h + 1][c + 1];
                  (0 !== h || o > 0) && m.push(w, M, T),
                    (h !== n - 1 || l < Math.PI) && m.push(M, E, T);
                }
              this.setIndex(m),
                this.addAttribute("position", new N(g, 3)),
                this.addAttribute("normal", new N(v, 3)),
                this.addAttribute("uv", new N(y, 2));
            }
            function Zn(t, e, n, r, i, a) {
              T.call(this),
                (this.type = "RingGeometry"),
                (this.parameters = {
                  innerRadius: t,
                  outerRadius: e,
                  thetaSegments: n,
                  phiSegments: r,
                  thetaStart: i,
                  thetaLength: a,
                }),
                this.fromBufferGeometry(new Qn(t, e, n, r, i, a)),
                this.mergeVertices();
            }
            function Qn(t, e, r, i, o, s) {
              F.call(this),
                (this.type = "RingBufferGeometry"),
                (this.parameters = {
                  innerRadius: t,
                  outerRadius: e,
                  thetaSegments: r,
                  phiSegments: i,
                  thetaStart: o,
                  thetaLength: s,
                }),
                (t = t || 0.5),
                (e = e || 1),
                (o = void 0 !== o ? o : 0),
                (s = void 0 !== s ? s : 2 * Math.PI),
                (r = void 0 !== r ? Math.max(3, r) : 8),
                (i = void 0 !== i ? Math.max(1, i) : 1);
              var c,
                h,
                l,
                u = [],
                p = [],
                d = [],
                f = [],
                m = t,
                g = (e - t) / i,
                v = new a(),
                y = new n();
              for (h = 0; h <= i; h++) {
                for (l = 0; l <= r; l++)
                  (c = o + (l / r) * s),
                    (v.x = m * Math.cos(c)),
                    (v.y = m * Math.sin(c)),
                    p.push(v.x, v.y, v.z),
                    d.push(0, 0, 1),
                    (y.x = (v.x / e + 1) / 2),
                    (y.y = (v.y / e + 1) / 2),
                    f.push(y.x, y.y);
                m += g;
              }
              for (h = 0; h < i; h++) {
                var x = h * (r + 1);
                for (l = 0; l < r; l++) {
                  c = l + x;
                  var b = c,
                    _ = c + r + 1,
                    w = c + r + 2,
                    M = c + 1;
                  u.push(b, _, M), u.push(_, w, M);
                }
              }
              this.setIndex(u),
                this.addAttribute("position", new N(p, 3)),
                this.addAttribute("normal", new N(d, 3)),
                this.addAttribute("uv", new N(f, 2));
            }
            function Kn(t, e, n, r) {
              T.call(this),
                (this.type = "LatheGeometry"),
                (this.parameters = {
                  points: t,
                  segments: e,
                  phiStart: n,
                  phiLength: r,
                }),
                this.fromBufferGeometry(new $n(t, e, n, r)),
                this.mergeVertices();
            }
            function $n(t, e, r, i) {
              F.call(this),
                (this.type = "LatheBufferGeometry"),
                (this.parameters = {
                  points: t,
                  segments: e,
                  phiStart: r,
                  phiLength: i,
                }),
                (e = Math.floor(e) || 12),
                (r = r || 0),
                (i = i || 2 * Math.PI),
                (i = xc.clamp(i, 0, 2 * Math.PI));
              var o,
                s,
                c,
                h = [],
                l = [],
                u = [],
                p = 1 / e,
                d = new a(),
                f = new n();
              for (s = 0; s <= e; s++) {
                var m = r + s * p * i,
                  g = Math.sin(m),
                  v = Math.cos(m);
                for (c = 0; c <= t.length - 1; c++)
                  (d.x = t[c].x * g),
                    (d.y = t[c].y),
                    (d.z = t[c].x * v),
                    l.push(d.x, d.y, d.z),
                    (f.x = s / e),
                    (f.y = c / (t.length - 1)),
                    u.push(f.x, f.y);
              }
              for (s = 0; s < e; s++)
                for (c = 0; c < t.length - 1; c++) {
                  o = c + s * t.length;
                  var y = o,
                    x = o + t.length,
                    b = o + t.length + 1,
                    _ = o + 1;
                  h.push(y, x, _), h.push(x, b, _);
                }
              if (
                (this.setIndex(h),
                this.addAttribute("position", new N(l, 3)),
                this.addAttribute("uv", new N(u, 2)),
                this.computeVertexNormals(),
                i === 2 * Math.PI)
              ) {
                var w = this.attributes.normal.array,
                  M = new a(),
                  E = new a(),
                  T = new a();
                for (
                  o = e * t.length * 3, s = 0, c = 0;
                  s < t.length;
                  s++, c += 3
                )
                  (M.x = w[c + 0]),
                    (M.y = w[c + 1]),
                    (M.z = w[c + 2]),
                    (E.x = w[o + c + 0]),
                    (E.y = w[o + c + 1]),
                    (E.z = w[o + c + 2]),
                    T.addVectors(M, E).normalize(),
                    (w[c + 0] = w[o + c + 0] = T.x),
                    (w[c + 1] = w[o + c + 1] = T.y),
                    (w[c + 2] = w[o + c + 2] = T.z);
              }
            }
            function tr(t, e) {
              T.call(this),
                (this.type = "ShapeGeometry"),
                "object" == typeof e &&
                  (console.warn(
                    "THREE.ShapeGeometry: Options parameter has been removed."
                  ),
                  (e = e.curveSegments)),
                (this.parameters = { shapes: t, curveSegments: e }),
                this.fromBufferGeometry(new er(t, e)),
                this.mergeVertices();
            }
            function er(t, e) {
              function n(t) {
                var n,
                  s,
                  h,
                  l = i.length / 3,
                  u = t.extractPoints(e),
                  p = u.shape,
                  d = u.holes;
                if (!1 === kc.isClockWise(p))
                  for (p = p.reverse(), n = 0, s = d.length; n < s; n++)
                    (h = d[n]),
                      !0 === kc.isClockWise(h) && (d[n] = h.reverse());
                var f = kc.triangulateShape(p, d);
                for (n = 0, s = d.length; n < s; n++)
                  (h = d[n]), (p = p.concat(h));
                for (n = 0, s = p.length; n < s; n++) {
                  var m = p[n];
                  i.push(m.x, m.y, 0), a.push(0, 0, 1), o.push(m.x, m.y);
                }
                for (n = 0, s = f.length; n < s; n++) {
                  var g = f[n],
                    v = g[0] + l,
                    y = g[1] + l,
                    x = g[2] + l;
                  r.push(v, y, x), (c += 3);
                }
              }
              F.call(this),
                (this.type = "ShapeBufferGeometry"),
                (this.parameters = { shapes: t, curveSegments: e }),
                (e = e || 12);
              var r = [],
                i = [],
                a = [],
                o = [],
                s = 0,
                c = 0;
              if (!1 === Array.isArray(t)) n(t);
              else
                for (var h = 0; h < t.length; h++)
                  n(t[h]), this.addGroup(s, c, h), (s += c), (c = 0);
              this.setIndex(r),
                this.addAttribute("position", new N(i, 3)),
                this.addAttribute("normal", new N(a, 3)),
                this.addAttribute("uv", new N(o, 2));
            }
            function nr(t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (var n = 0, r = t.length; n < r; n++) {
                  var i = t[n];
                  e.shapes.push(i.uuid);
                }
              else e.shapes.push(t.uuid);
              return e;
            }
            function rr(t, e) {
              F.call(this),
                (this.type = "EdgesGeometry"),
                (this.parameters = { thresholdAngle: e }),
                (e = void 0 !== e ? e : 1);
              var n,
                r,
                i,
                a,
                o = [],
                s = Math.cos(xc.DEG2RAD * e),
                c = [0, 0],
                h = {},
                l = ["a", "b", "c"];
              t.isBufferGeometry
                ? ((a = new T()), a.fromBufferGeometry(t))
                : (a = t.clone()),
                a.mergeVertices(),
                a.computeFaceNormals();
              for (
                var u = a.vertices, p = a.faces, d = 0, f = p.length;
                d < f;
                d++
              )
                for (var m = p[d], g = 0; g < 3; g++)
                  (n = m[l[g]]),
                    (r = m[l[(g + 1) % 3]]),
                    (c[0] = Math.min(n, r)),
                    (c[1] = Math.max(n, r)),
                    (i = c[0] + "," + c[1]),
                    void 0 === h[i]
                      ? (h[i] = {
                          index1: c[0],
                          index2: c[1],
                          face1: d,
                          face2: void 0,
                        })
                      : (h[i].face2 = d);
              for (i in h) {
                var v = h[i];
                if (
                  void 0 === v.face2 ||
                  p[v.face1].normal.dot(p[v.face2].normal) <= s
                ) {
                  var y = u[v.index1];
                  o.push(y.x, y.y, y.z),
                    (y = u[v.index2]),
                    o.push(y.x, y.y, y.z);
                }
              }
              this.addAttribute("position", new N(o, 3));
            }
            function ir(t, e, n, r, i, a, o, s) {
              T.call(this),
                (this.type = "CylinderGeometry"),
                (this.parameters = {
                  radiusTop: t,
                  radiusBottom: e,
                  height: n,
                  radialSegments: r,
                  heightSegments: i,
                  openEnded: a,
                  thetaStart: o,
                  thetaLength: s,
                }),
                this.fromBufferGeometry(new ar(t, e, n, r, i, a, o, s)),
                this.mergeVertices();
            }
            function ar(t, e, r, i, o, s, c, h) {
              function l(r) {
                var o,
                  s,
                  l,
                  v = new n(),
                  b = new a(),
                  _ = 0,
                  w = !0 === r ? t : e,
                  M = !0 === r ? 1 : -1;
                for (s = g, o = 1; o <= i; o++)
                  d.push(0, y * M, 0), f.push(0, M, 0), m.push(0.5, 0.5), g++;
                for (l = g, o = 0; o <= i; o++) {
                  var E = o / i,
                    T = E * h + c,
                    S = Math.cos(T),
                    A = Math.sin(T);
                  (b.x = w * A),
                    (b.y = y * M),
                    (b.z = w * S),
                    d.push(b.x, b.y, b.z),
                    f.push(0, M, 0),
                    (v.x = 0.5 * S + 0.5),
                    (v.y = 0.5 * A * M + 0.5),
                    m.push(v.x, v.y),
                    g++;
                }
                for (o = 0; o < i; o++) {
                  var L = s + o,
                    R = l + o;
                  !0 === r ? p.push(R, R + 1, L) : p.push(R + 1, R, L),
                    (_ += 3);
                }
                u.addGroup(x, _, !0 === r ? 1 : 2), (x += _);
              }
              F.call(this),
                (this.type = "CylinderBufferGeometry"),
                (this.parameters = {
                  radiusTop: t,
                  radiusBottom: e,
                  height: r,
                  radialSegments: i,
                  heightSegments: o,
                  openEnded: s,
                  thetaStart: c,
                  thetaLength: h,
                });
              var u = this;
              (t = void 0 !== t ? t : 1),
                (e = void 0 !== e ? e : 1),
                (r = r || 1),
                (i = Math.floor(i) || 8),
                (o = Math.floor(o) || 1),
                (s = void 0 !== s && s),
                (c = void 0 !== c ? c : 0),
                (h = void 0 !== h ? h : 2 * Math.PI);
              var p = [],
                d = [],
                f = [],
                m = [],
                g = 0,
                v = [],
                y = r / 2,
                x = 0;
              !(function () {
                var n,
                  s,
                  l = new a(),
                  b = new a(),
                  _ = 0,
                  w = (e - t) / r;
                for (s = 0; s <= o; s++) {
                  var M = [],
                    E = s / o,
                    T = E * (e - t) + t;
                  for (n = 0; n <= i; n++) {
                    var S = n / i,
                      A = S * h + c,
                      L = Math.sin(A),
                      R = Math.cos(A);
                    (b.x = T * L),
                      (b.y = -E * r + y),
                      (b.z = T * R),
                      d.push(b.x, b.y, b.z),
                      l.set(L, w, R).normalize(),
                      f.push(l.x, l.y, l.z),
                      m.push(S, 1 - E),
                      M.push(g++);
                  }
                  v.push(M);
                }
                for (n = 0; n < i; n++)
                  for (s = 0; s < o; s++) {
                    var C = v[s][n],
                      P = v[s + 1][n],
                      O = v[s + 1][n + 1],
                      I = v[s][n + 1];
                    p.push(C, P, I), p.push(P, O, I), (_ += 6);
                  }
                u.addGroup(x, _, 0), (x += _);
              })(),
                !1 === s && (t > 0 && l(!0), e > 0 && l(!1)),
                this.setIndex(p),
                this.addAttribute("position", new N(d, 3)),
                this.addAttribute("normal", new N(f, 3)),
                this.addAttribute("uv", new N(m, 2));
            }
            function or(t, e, n, r, i, a, o) {
              ir.call(this, 0, t, e, n, r, i, a, o),
                (this.type = "ConeGeometry"),
                (this.parameters = {
                  radius: t,
                  height: e,
                  radialSegments: n,
                  heightSegments: r,
                  openEnded: i,
                  thetaStart: a,
                  thetaLength: o,
                });
            }
            function sr(t, e, n, r, i, a, o) {
              ar.call(this, 0, t, e, n, r, i, a, o),
                (this.type = "ConeBufferGeometry"),
                (this.parameters = {
                  radius: t,
                  height: e,
                  radialSegments: n,
                  heightSegments: r,
                  openEnded: i,
                  thetaStart: a,
                  thetaLength: o,
                });
            }
            function cr(t, e, n, r) {
              T.call(this),
                (this.type = "CircleGeometry"),
                (this.parameters = {
                  radius: t,
                  segments: e,
                  thetaStart: n,
                  thetaLength: r,
                }),
                this.fromBufferGeometry(new hr(t, e, n, r)),
                this.mergeVertices();
            }
            function hr(t, e, r, i) {
              F.call(this),
                (this.type = "CircleBufferGeometry"),
                (this.parameters = {
                  radius: t,
                  segments: e,
                  thetaStart: r,
                  thetaLength: i,
                }),
                (t = t || 1),
                (e = void 0 !== e ? Math.max(3, e) : 8),
                (r = void 0 !== r ? r : 0),
                (i = void 0 !== i ? i : 2 * Math.PI);
              var o,
                s,
                c = [],
                h = [],
                l = [],
                u = [],
                p = new a(),
                d = new n();
              for (
                h.push(0, 0, 0),
                  l.push(0, 0, 1),
                  u.push(0.5, 0.5),
                  s = 0,
                  o = 3;
                s <= e;
                s++, o += 3
              ) {
                var f = r + (s / e) * i;
                (p.x = t * Math.cos(f)),
                  (p.y = t * Math.sin(f)),
                  h.push(p.x, p.y, p.z),
                  l.push(0, 0, 1),
                  (d.x = (h[o] / t + 1) / 2),
                  (d.y = (h[o + 1] / t + 1) / 2),
                  u.push(d.x, d.y);
              }
              for (o = 1; o <= e; o++) c.push(o, o + 1, 0);
              this.setIndex(c),
                this.addAttribute("position", new N(h, 3)),
                this.addAttribute("normal", new N(l, 3)),
                this.addAttribute("uv", new N(u, 2));
            }
            function lr(t) {
              k.call(this),
                (this.type = "ShadowMaterial"),
                (this.color = new g(0)),
                (this.transparent = !0),
                this.setValues(t);
            }
            function ur(t) {
              W.call(this, t), (this.type = "RawShaderMaterial");
            }
            function pr(t) {
              k.call(this),
                (this.defines = { STANDARD: "" }),
                (this.type = "MeshStandardMaterial"),
                (this.color = new g(16777215)),
                (this.roughness = 0.5),
                (this.metalness = 0.5),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new g(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = vc),
                (this.normalScale = new n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.roughnessMap = null),
                (this.metalnessMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.envMapIntensity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(t);
            }
            function dr(t) {
              pr.call(this),
                (this.defines = { PHYSICAL: "" }),
                (this.type = "MeshPhysicalMaterial"),
                (this.reflectivity = 0.5),
                (this.clearCoat = 0),
                (this.clearCoatRoughness = 0),
                this.setValues(t);
            }
            function fr(t) {
              k.call(this),
                (this.type = "MeshPhongMaterial"),
                (this.color = new g(16777215)),
                (this.specular = new g(1118481)),
                (this.shininess = 30),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new g(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = vc),
                (this.normalScale = new n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = jo),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(t);
            }
            function mr(t) {
              fr.call(this),
                (this.defines = { TOON: "" }),
                (this.type = "MeshToonMaterial"),
                (this.gradientMap = null),
                this.setValues(t);
            }
            function gr(t) {
              k.call(this),
                (this.type = "MeshNormalMaterial"),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = vc),
                (this.normalScale = new n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.lights = !1),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(t);
            }
            function vr(t) {
              k.call(this),
                (this.type = "MeshLambertMaterial"),
                (this.color = new g(16777215)),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new g(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = jo),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(t);
            }
            function yr(t) {
              Be.call(this),
                (this.type = "LineDashedMaterial"),
                (this.scale = 1),
                (this.dashSize = 3),
                (this.gapSize = 1),
                this.setValues(t);
            }
            function xr(t, e, n) {
              var r = this,
                i = !1,
                a = 0,
                o = 0,
                s = void 0;
              (this.onStart = void 0),
                (this.onLoad = t),
                (this.onProgress = e),
                (this.onError = n),
                (this.itemStart = function (t) {
                  o++,
                    !1 === i && void 0 !== r.onStart && r.onStart(t, a, o),
                    (i = !0);
                }),
                (this.itemEnd = function (t) {
                  a++,
                    void 0 !== r.onProgress && r.onProgress(t, a, o),
                    a === o && ((i = !1), void 0 !== r.onLoad && r.onLoad());
                }),
                (this.itemError = function (t) {
                  void 0 !== r.onError && r.onError(t);
                }),
                (this.resolveURL = function (t) {
                  return s ? s(t) : t;
                }),
                (this.setURLModifier = function (t) {
                  return (s = t), this;
                });
            }
            function br(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function _r(t) {
              (this.manager = void 0 !== t ? t : Yc), (this._parser = null);
            }
            function wr(t) {
              (this.manager = void 0 !== t ? t : Yc), (this._parser = null);
            }
            function Mr(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Er(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Tr(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Sr() {
              (this.type = "Curve"), (this.arcLengthDivisions = 200);
            }
            function Ar(t, e, n, r, i, a, o, s) {
              Sr.call(this),
                (this.type = "EllipseCurve"),
                (this.aX = t || 0),
                (this.aY = e || 0),
                (this.xRadius = n || 1),
                (this.yRadius = r || 1),
                (this.aStartAngle = i || 0),
                (this.aEndAngle = a || 2 * Math.PI),
                (this.aClockwise = o || !1),
                (this.aRotation = s || 0);
            }
            function Lr(t, e, n, r, i, a) {
              Ar.call(this, t, e, n, n, r, i, a), (this.type = "ArcCurve");
            }
            function Rr() {
              function t(t, a, o, s) {
                (e = t),
                  (n = o),
                  (r = -3 * t + 3 * a - 2 * o - s),
                  (i = 2 * t - 2 * a + o + s);
              }
              var e = 0,
                n = 0,
                r = 0,
                i = 0;
              return {
                initCatmullRom: function (e, n, r, i, a) {
                  t(n, r, a * (r - e), a * (i - n));
                },
                initNonuniformCatmullRom: function (e, n, r, i, a, o, s) {
                  var c = (n - e) / a - (r - e) / (a + o) + (r - n) / o,
                    h = (r - n) / o - (i - n) / (o + s) + (i - r) / s;
                  (c *= o), (h *= o), t(n, r, c, h);
                },
                calc: function (t) {
                  var a = t * t;
                  return e + n * t + r * a + i * (a * t);
                },
              };
            }
            function Cr(t, e, n, r) {
              Sr.call(this),
                (this.type = "CatmullRomCurve3"),
                (this.points = t || []),
                (this.closed = e || !1),
                (this.curveType = n || "centripetal"),
                (this.tension = r || 0.5);
            }
            function Pr(t, e, n, r, i) {
              var a = 0.5 * (r - e),
                o = 0.5 * (i - n),
                s = t * t;
              return (
                (2 * n - 2 * r + a + o) * (t * s) +
                (-3 * n + 3 * r - 2 * a - o) * s +
                a * t +
                n
              );
            }
            function Or(t, e) {
              var n = 1 - t;
              return n * n * e;
            }
            function Ir(t, e) {
              return 2 * (1 - t) * t * e;
            }
            function Nr(t, e) {
              return t * t * e;
            }
            function Dr(t, e, n, r) {
              return Or(t, e) + Ir(t, n) + Nr(t, r);
            }
            function Ur(t, e) {
              var n = 1 - t;
              return n * n * n * e;
            }
            function Br(t, e) {
              var n = 1 - t;
              return 3 * n * n * t * e;
            }
            function Fr(t, e) {
              return 3 * (1 - t) * t * t * e;
            }
            function zr(t, e) {
              return t * t * t * e;
            }
            function Gr(t, e, n, r, i) {
              return Ur(t, e) + Br(t, n) + Fr(t, r) + zr(t, i);
            }
            function Hr(t, e, r, i) {
              Sr.call(this),
                (this.type = "CubicBezierCurve"),
                (this.v0 = t || new n()),
                (this.v1 = e || new n()),
                (this.v2 = r || new n()),
                (this.v3 = i || new n());
            }
            function Vr(t, e, n, r) {
              Sr.call(this),
                (this.type = "CubicBezierCurve3"),
                (this.v0 = t || new a()),
                (this.v1 = e || new a()),
                (this.v2 = n || new a()),
                (this.v3 = r || new a());
            }
            function kr(t, e) {
              Sr.call(this),
                (this.type = "LineCurve"),
                (this.v1 = t || new n()),
                (this.v2 = e || new n());
            }
            function jr(t, e) {
              Sr.call(this),
                (this.type = "LineCurve3"),
                (this.v1 = t || new a()),
                (this.v2 = e || new a());
            }
            function Wr(t, e, r) {
              Sr.call(this),
                (this.type = "QuadraticBezierCurve"),
                (this.v0 = t || new n()),
                (this.v1 = e || new n()),
                (this.v2 = r || new n());
            }
            function Xr(t, e, n) {
              Sr.call(this),
                (this.type = "QuadraticBezierCurve3"),
                (this.v0 = t || new a()),
                (this.v1 = e || new a()),
                (this.v2 = n || new a());
            }
            function qr(t) {
              Sr.call(this),
                (this.type = "SplineCurve"),
                (this.points = t || []);
            }
            function Yr() {
              Sr.call(this),
                (this.type = "CurvePath"),
                (this.curves = []),
                (this.autoClose = !1);
            }
            function Jr(t) {
              Yr.call(this),
                (this.type = "Path"),
                (this.currentPoint = new n()),
                t && this.setFromPoints(t);
            }
            function Zr(t) {
              Jr.call(this, t),
                (this.uuid = xc.generateUUID()),
                (this.type = "Shape"),
                (this.holes = []);
            }
            function Qr(t, e) {
              _.call(this),
                (this.type = "Light"),
                (this.color = new g(t)),
                (this.intensity = void 0 !== e ? e : 1),
                (this.receiveShadow = void 0);
            }
            function Kr(t, e, n) {
              Qr.call(this, t, n),
                (this.type = "HemisphereLight"),
                (this.castShadow = void 0),
                this.position.copy(_.DefaultUp),
                this.updateMatrix(),
                (this.groundColor = new g(e));
            }
            function $r(t) {
              (this.camera = t),
                (this.bias = 0),
                (this.radius = 1),
                (this.mapSize = new n(512, 512)),
                (this.map = null),
                (this.matrix = new r());
            }
            function ti() {
              $r.call(this, new _e(50, 1, 0.5, 500));
            }
            function ei(t, e, n, r, i, a) {
              Qr.call(this, t, e),
                (this.type = "SpotLight"),
                this.position.copy(_.DefaultUp),
                this.updateMatrix(),
                (this.target = new _()),
                Object.defineProperty(this, "power", {
                  get: function () {
                    return this.intensity * Math.PI;
                  },
                  set: function (t) {
                    this.intensity = t / Math.PI;
                  },
                }),
                (this.distance = void 0 !== n ? n : 0),
                (this.angle = void 0 !== r ? r : Math.PI / 3),
                (this.penumbra = void 0 !== i ? i : 0),
                (this.decay = void 0 !== a ? a : 1),
                (this.shadow = new ti());
            }
            function ni(t, e, n, r) {
              Qr.call(this, t, e),
                (this.type = "PointLight"),
                Object.defineProperty(this, "power", {
                  get: function () {
                    return 4 * this.intensity * Math.PI;
                  },
                  set: function (t) {
                    this.intensity = t / (4 * Math.PI);
                  },
                }),
                (this.distance = void 0 !== n ? n : 0),
                (this.decay = void 0 !== r ? r : 1),
                (this.shadow = new $r(new _e(90, 1, 0.5, 500)));
            }
            function ri() {
              $r.call(this, new M(-5, 5, 5, -5, 0.5, 500));
            }
            function ii(t, e) {
              Qr.call(this, t, e),
                (this.type = "DirectionalLight"),
                this.position.copy(_.DefaultUp),
                this.updateMatrix(),
                (this.target = new _()),
                (this.shadow = new ri());
            }
            function ai(t, e) {
              Qr.call(this, t, e),
                (this.type = "AmbientLight"),
                (this.castShadow = void 0);
            }
            function oi(t, e, n, r) {
              Qr.call(this, t, e),
                (this.type = "RectAreaLight"),
                (this.width = void 0 !== n ? n : 10),
                (this.height = void 0 !== r ? r : 10);
            }
            function si(t, e, n, r) {
              (this.parameterPositions = t),
                (this._cachedIndex = 0),
                (this.resultBuffer = void 0 !== r ? r : new e.constructor(n)),
                (this.sampleValues = e),
                (this.valueSize = n);
            }
            function ci(t, e, n, r) {
              si.call(this, t, e, n, r),
                (this._weightPrev = -0),
                (this._offsetPrev = -0),
                (this._weightNext = -0),
                (this._offsetNext = -0);
            }
            function hi(t, e, n, r) {
              si.call(this, t, e, n, r);
            }
            function li(t, e, n, r) {
              si.call(this, t, e, n, r);
            }
            function ui(t, e, n, r) {
              if (void 0 === t)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
              if (void 0 === e || 0 === e.length)
                throw new Error(
                  "THREE.KeyframeTrack: no keyframes in track named " + t
                );
              (this.name = t),
                (this.times = eh.convertArray(e, this.TimeBufferType)),
                (this.values = eh.convertArray(n, this.ValueBufferType)),
                this.setInterpolation(r || this.DefaultInterpolation);
            }
            function pi(t, e, n) {
              ui.call(this, t, e, n);
            }
            function di(t, e, n, r) {
              ui.call(this, t, e, n, r);
            }
            function fi(t, e, n, r) {
              ui.call(this, t, e, n, r);
            }
            function mi(t, e, n, r) {
              si.call(this, t, e, n, r);
            }
            function gi(t, e, n, r) {
              ui.call(this, t, e, n, r);
            }
            function vi(t, e, n, r) {
              ui.call(this, t, e, n, r);
            }
            function yi(t, e, n, r) {
              ui.call(this, t, e, n, r);
            }
            function xi(t, e, n) {
              (this.name = t),
                (this.tracks = n),
                (this.duration = void 0 !== e ? e : -1),
                (this.uuid = xc.generateUUID()),
                this.duration < 0 && this.resetDuration();
            }
            function bi(t) {
              switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                  return fi;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                  return yi;
                case "color":
                  return di;
                case "quaternion":
                  return gi;
                case "bool":
                case "boolean":
                  return pi;
                case "string":
                  return vi;
              }
              throw new Error(
                "THREE.KeyframeTrack: Unsupported typeName: " + t
              );
            }
            function _i(t) {
              if (void 0 === t.type)
                throw new Error(
                  "THREE.KeyframeTrack: track type undefined, can not parse"
                );
              var e = bi(t.type);
              if (void 0 === t.times) {
                var n = [],
                  r = [];
                eh.flattenJSON(t.keys, n, r, "value"),
                  (t.times = n),
                  (t.values = r);
              }
              return void 0 !== e.parse
                ? e.parse(t)
                : new e(t.name, t.times, t.values, t.interpolation);
            }
            function wi(t) {
              (this.manager = void 0 !== t ? t : Yc), (this.textures = {});
            }
            function Mi(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Ei() {}
            function Ti(t) {
              "boolean" == typeof t &&
                (console.warn(
                  "THREE.JSONLoader: showStatus parameter has been removed from constructor."
                ),
                (t = void 0)),
                (this.manager = void 0 !== t ? t : Yc),
                (this.withCredentials = !1);
            }
            function Si(t) {
              (this.manager = void 0 !== t ? t : Yc), (this.texturePath = "");
            }
            function Ai(t) {
              "undefined" == typeof createImageBitmap &&
                console.warn(
                  "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                ),
                "undefined" == typeof fetch &&
                  console.warn(
                    "THREE.ImageBitmapLoader: fetch() not supported."
                  ),
                (this.manager = void 0 !== t ? t : Yc),
                (this.options = void 0);
            }
            function Li() {
              (this.type = "ShapePath"),
                (this.color = new g()),
                (this.subPaths = []),
                (this.currentPath = null);
            }
            function Ri(t) {
              (this.type = "Font"), (this.data = t);
            }
            function Ci(t, e, n) {
              for (
                var r = Array.from ? Array.from(t) : String(t).split(""),
                  i = e / n.resolution,
                  a =
                    (n.boundingBox.yMax -
                      n.boundingBox.yMin +
                      n.underlineThickness) *
                    i,
                  o = [],
                  s = 0,
                  c = 0,
                  h = 0;
                h < r.length;
                h++
              ) {
                var l = r[h];
                if ("\n" === l) (s = 0), (c -= a);
                else {
                  var u = Pi(l, i, s, c, n);
                  (s += u.offsetX), o.push(u.path);
                }
              }
              return o;
            }
            function Pi(t, e, n, r, i) {
              var a = i.glyphs[t] || i.glyphs["?"];
              if (a) {
                var o,
                  s,
                  c,
                  h,
                  l,
                  u,
                  p,
                  d,
                  f = new Li();
                if (a.o)
                  for (
                    var m =
                        a._cachedOutline || (a._cachedOutline = a.o.split(" ")),
                      g = 0,
                      v = m.length;
                    g < v;

                  ) {
                    var y = m[g++];
                    switch (y) {
                      case "m":
                        (o = m[g++] * e + n),
                          (s = m[g++] * e + r),
                          f.moveTo(o, s);
                        break;
                      case "l":
                        (o = m[g++] * e + n),
                          (s = m[g++] * e + r),
                          f.lineTo(o, s);
                        break;
                      case "q":
                        (c = m[g++] * e + n),
                          (h = m[g++] * e + r),
                          (l = m[g++] * e + n),
                          (u = m[g++] * e + r),
                          f.quadraticCurveTo(l, u, c, h);
                        break;
                      case "b":
                        (c = m[g++] * e + n),
                          (h = m[g++] * e + r),
                          (l = m[g++] * e + n),
                          (u = m[g++] * e + r),
                          (p = m[g++] * e + n),
                          (d = m[g++] * e + r),
                          f.bezierCurveTo(l, u, p, d, c, h);
                    }
                  }
                return { offsetX: a.ha * e, path: f };
              }
            }
            function Oi(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Ii(t) {
              this.manager = void 0 !== t ? t : Yc;
            }
            function Ni() {
              (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new _e()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new _e()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1);
            }
            function Di(t, e, n) {
              _.call(this), (this.type = "CubeCamera");
              var r = new _e(90, 1, t, e);
              r.up.set(0, -1, 0), r.lookAt(new a(1, 0, 0)), this.add(r);
              var i = new _e(90, 1, t, e);
              i.up.set(0, -1, 0), i.lookAt(new a(-1, 0, 0)), this.add(i);
              var o = new _e(90, 1, t, e);
              o.up.set(0, 0, 1), o.lookAt(new a(0, 1, 0)), this.add(o);
              var s = new _e(90, 1, t, e);
              s.up.set(0, 0, -1), s.lookAt(new a(0, -1, 0)), this.add(s);
              var c = new _e(90, 1, t, e);
              c.up.set(0, -1, 0), c.lookAt(new a(0, 0, 1)), this.add(c);
              var h = new _e(90, 1, t, e);
              h.up.set(0, -1, 0), h.lookAt(new a(0, 0, -1)), this.add(h);
              var u = { format: As, magFilter: us, minFilter: us };
              (this.renderTarget = new l(n, n, u)),
                (this.renderTarget.texture.name = "CubeCamera"),
                (this.update = function (t, e) {
                  null === this.parent && this.updateMatrixWorld();
                  var n = this.renderTarget,
                    a = n.texture.generateMipmaps;
                  (n.texture.generateMipmaps = !1),
                    (n.activeCubeFace = 0),
                    t.render(e, r, n),
                    (n.activeCubeFace = 1),
                    t.render(e, i, n),
                    (n.activeCubeFace = 2),
                    t.render(e, o, n),
                    (n.activeCubeFace = 3),
                    t.render(e, s, n),
                    (n.activeCubeFace = 4),
                    t.render(e, c, n),
                    (n.texture.generateMipmaps = a),
                    (n.activeCubeFace = 5),
                    t.render(e, h, n),
                    t.setRenderTarget(null);
                }),
                (this.clear = function (t, e, n, r) {
                  for (var i = this.renderTarget, a = 0; a < 6; a++)
                    (i.activeCubeFace = a),
                      t.setRenderTarget(i),
                      t.clear(e, n, r);
                  t.setRenderTarget(null);
                });
            }
            function Ui() {
              _.call(this),
                (this.type = "AudioListener"),
                (this.context = ch.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null);
            }
            function Bi(t) {
              _.call(this),
                (this.type = "Audio"),
                (this.context = t.context),
                (this.gain = this.context.createGain()),
                this.gain.connect(t.getInput()),
                (this.autoplay = !1),
                (this.buffer = null),
                (this.loop = !1),
                (this.startTime = 0),
                (this.offset = 0),
                (this.playbackRate = 1),
                (this.isPlaying = !1),
                (this.hasPlaybackControl = !0),
                (this.sourceType = "empty"),
                (this.filters = []);
            }
            function Fi(t) {
              Bi.call(this, t),
                (this.panner = this.context.createPanner()),
                this.panner.connect(this.gain);
            }
            function zi(t, e) {
              (this.analyser = t.context.createAnalyser()),
                (this.analyser.fftSize = void 0 !== e ? e : 2048),
                (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
                t.getOutput().connect(this.analyser);
            }
            function Gi(t, e, n) {
              (this.binding = t), (this.valueSize = n);
              var r,
                i = Float64Array;
              switch (e) {
                case "quaternion":
                  r = this._slerp;
                  break;
                case "string":
                case "bool":
                  (i = Array), (r = this._select);
                  break;
                default:
                  r = this._lerp;
              }
              (this.buffer = new i(4 * n)),
                (this._mixBufferRegion = r),
                (this.cumulativeWeight = 0),
                (this.useCount = 0),
                (this.referenceCount = 0);
            }
            function Hi(t, e, n) {
              var r = n || Vi.parseTrackName(e);
              (this._targetGroup = t), (this._bindings = t.subscribe_(e, r));
            }
            function Vi(t, e, n) {
              (this.path = e),
                (this.parsedPath = n || Vi.parseTrackName(e)),
                (this.node = Vi.findNode(t, this.parsedPath.nodeName) || t),
                (this.rootNode = t);
            }
            function ki() {
              (this.uuid = xc.generateUUID()),
                (this._objects = Array.prototype.slice.call(arguments)),
                (this.nCachedObjects_ = 0);
              var t = {};
              this._indicesByUUID = t;
              for (var e = 0, n = arguments.length; e !== n; ++e)
                t[arguments[e].uuid] = e;
              (this._paths = []),
                (this._parsedPaths = []),
                (this._bindings = []),
                (this._bindingsIndicesByPath = {});
              var r = this;
              this.stats = {
                objects: {
                  get total() {
                    return r._objects.length;
                  },
                  get inUse() {
                    return this.total - r.nCachedObjects_;
                  },
                },
                get bindingsPerObject() {
                  return r._bindings.length;
                },
              };
            }
            function ji(t, e, n) {
              (this._mixer = t),
                (this._clip = e),
                (this._localRoot = n || null);
              for (
                var r = e.tracks,
                  i = r.length,
                  a = new Array(i),
                  o = { endingStart: ic, endingEnd: ic },
                  s = 0;
                s !== i;
                ++s
              ) {
                var c = r[s].createInterpolant(null);
                (a[s] = c), (c.settings = o);
              }
              (this._interpolantSettings = o),
                (this._interpolants = a),
                (this._propertyBindings = new Array(i)),
                (this._cacheIndex = null),
                (this._byClipCacheIndex = null),
                (this._timeScaleInterpolant = null),
                (this._weightInterpolant = null),
                (this.loop = rc),
                (this._loopCount = -1),
                (this._startTime = null),
                (this.time = 0),
                (this.timeScale = 1),
                (this._effectiveTimeScale = 1),
                (this.weight = 1),
                (this._effectiveWeight = 1),
                (this.repetitions = 1 / 0),
                (this.paused = !1),
                (this.enabled = !0),
                (this.clampWhenFinished = !1),
                (this.zeroSlopeAtStart = !0),
                (this.zeroSlopeAtEnd = !0);
            }
            function Wi(t) {
              (this._root = t),
                this._initMemoryManager(),
                (this._accuIndex = 0),
                (this.time = 0),
                (this.timeScale = 1);
            }
            function Xi(t) {
              "string" == typeof t &&
                (console.warn(
                  "THREE.Uniform: Type parameter is no longer needed."
                ),
                (t = arguments[1])),
                (this.value = t);
            }
            function qi() {
              F.call(this),
                (this.type = "InstancedBufferGeometry"),
                (this.maxInstancedCount = void 0);
            }
            function Yi(t, e, n) {
              Re.call(this, t, e), (this.meshPerAttribute = n || 1);
            }
            function Ji(t, e, n) {
              S.call(this, t, e), (this.meshPerAttribute = n || 1);
            }
            function Zi(t, e, n, r) {
              (this.ray = new X(t, e)),
                (this.near = n || 0),
                (this.far = r || 1 / 0),
                (this.params = {
                  Mesh: {},
                  Line: {},
                  LOD: {},
                  Points: { threshold: 1 },
                  Sprite: {},
                }),
                Object.defineProperties(this.params, {
                  PointCloud: {
                    get: function () {
                      return (
                        console.warn(
                          "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                        ),
                        this.Points
                      );
                    },
                  },
                });
            }
            function Qi(t, e) {
              return t.distance - e.distance;
            }
            function Ki(t, e, n, r) {
              if (!1 !== t.visible && (t.raycast(e, n), !0 === r))
                for (var i = t.children, a = 0, o = i.length; a < o; a++)
                  Ki(i[a], e, n, !0);
            }
            function $i(t) {
              (this.autoStart = void 0 === t || t),
                (this.startTime = 0),
                (this.oldTime = 0),
                (this.elapsedTime = 0),
                (this.running = !1);
            }
            function ta(t, e, n) {
              return (
                (this.radius = void 0 !== t ? t : 1),
                (this.phi = void 0 !== e ? e : 0),
                (this.theta = void 0 !== n ? n : 0),
                this
              );
            }
            function ea(t, e, n) {
              return (
                (this.radius = void 0 !== t ? t : 1),
                (this.theta = void 0 !== e ? e : 0),
                (this.y = void 0 !== n ? n : 0),
                this
              );
            }
            function na(t, e) {
              (this.min = void 0 !== t ? t : new n(1 / 0, 1 / 0)),
                (this.max = void 0 !== e ? e : new n(-1 / 0, -1 / 0));
            }
            function ra(t, e) {
              (this.start = void 0 !== t ? t : new a()),
                (this.end = void 0 !== e ? e : new a());
            }
            function ia(t) {
              _.call(this), (this.material = t), (this.render = function () {});
            }
            function aa(t, e, n, r) {
              (this.object = t), (this.size = void 0 !== e ? e : 1);
              var i = void 0 !== n ? n : 16711680,
                a = void 0 !== r ? r : 1,
                o = 0,
                s = this.object.geometry;
              s && s.isGeometry
                ? (o = 3 * s.faces.length)
                : s && s.isBufferGeometry && (o = s.attributes.normal.count);
              var c = new F(),
                h = new N(2 * o * 3, 3);
              c.addAttribute("position", h),
                ze.call(this, c, new Be({ color: i, linewidth: a })),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            function oa(t, e) {
              _.call(this),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = e);
              for (
                var n = new F(),
                  r = [
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
                    0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                  ],
                  i = 0,
                  a = 1;
                i < 32;
                i++, a++
              ) {
                var o = (i / 32) * Math.PI * 2,
                  s = (a / 32) * Math.PI * 2;
                r.push(
                  Math.cos(o),
                  Math.sin(o),
                  1,
                  Math.cos(s),
                  Math.sin(s),
                  1
                );
              }
              n.addAttribute("position", new N(r, 3));
              var c = new Be({ fog: !1 });
              (this.cone = new ze(n, c)), this.add(this.cone), this.update();
            }
            function sa(t) {
              var e = [];
              t && t.isBone && e.push(t);
              for (var n = 0; n < t.children.length; n++)
                e.push.apply(e, sa(t.children[n]));
              return e;
            }
            function ca(t) {
              for (
                var e = sa(t),
                  n = new F(),
                  r = [],
                  i = [],
                  a = new g(0, 0, 1),
                  o = new g(0, 1, 0),
                  s = 0;
                s < e.length;
                s++
              ) {
                var c = e[s];
                c.parent &&
                  c.parent.isBone &&
                  (r.push(0, 0, 0),
                  r.push(0, 0, 0),
                  i.push(a.r, a.g, a.b),
                  i.push(o.r, o.g, o.b));
              }
              n.addAttribute("position", new N(r, 3)),
                n.addAttribute("color", new N(i, 3));
              var h = new Be({
                vertexColors: po,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0,
              });
              ze.call(this, n, h),
                (this.root = t),
                (this.bones = e),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1);
            }
            function ha(t, e, n) {
              (this.light = t),
                this.light.updateMatrixWorld(),
                (this.color = n);
              var r = new Jn(e, 4, 2),
                i = new j({ wireframe: !0, fog: !1 });
              Y.call(this, r, i),
                (this.matrix = this.light.matrixWorld),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            function la(t, e) {
              _.call(this),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = e);
              var n = new Be({ fog: !1 }),
                r = new F();
              r.addAttribute("position", new S(new Float32Array(15), 3)),
                (this.line = new Fe(r, n)),
                this.add(this.line),
                this.update();
            }
            function ua(t, e, n) {
              _.call(this),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n);
              var r = new en(e);
              r.rotateY(0.5 * Math.PI),
                (this.material = new j({ wireframe: !0, fog: !1 })),
                void 0 === this.color && (this.material.vertexColors = po);
              var i = r.getAttribute("position"),
                a = new Float32Array(3 * i.count);
              r.addAttribute("color", new S(a, 3)),
                this.add(new Y(r, this.material)),
                this.update();
            }
            function pa(t, e, n, r) {
              (t = t || 10),
                (e = e || 10),
                (n = new g(void 0 !== n ? n : 4473924)),
                (r = new g(void 0 !== r ? r : 8947848));
              for (
                var i = e / 2,
                  a = t / e,
                  o = t / 2,
                  s = [],
                  c = [],
                  h = 0,
                  l = 0,
                  u = -o;
                h <= e;
                h++, u += a
              ) {
                s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
                var p = h === i ? n : r;
                p.toArray(c, l),
                  (l += 3),
                  p.toArray(c, l),
                  (l += 3),
                  p.toArray(c, l),
                  (l += 3),
                  p.toArray(c, l),
                  (l += 3);
              }
              var d = new F();
              d.addAttribute("position", new N(s, 3)),
                d.addAttribute("color", new N(c, 3));
              var f = new Be({ vertexColors: po });
              ze.call(this, d, f);
            }
            function da(t, e, n, r, i, a) {
              (t = t || 10),
                (e = e || 16),
                (n = n || 8),
                (r = r || 64),
                (i = new g(void 0 !== i ? i : 4473924)),
                (a = new g(void 0 !== a ? a : 8947848));
              var o,
                s,
                c,
                h,
                l,
                u,
                p,
                d = [],
                f = [];
              for (h = 0; h <= e; h++)
                (c = (h / e) * (2 * Math.PI)),
                  (o = Math.sin(c) * t),
                  (s = Math.cos(c) * t),
                  d.push(0, 0, 0),
                  d.push(o, 0, s),
                  (p = 1 & h ? i : a),
                  f.push(p.r, p.g, p.b),
                  f.push(p.r, p.g, p.b);
              for (h = 0; h <= n; h++)
                for (p = 1 & h ? i : a, u = t - (t / n) * h, l = 0; l < r; l++)
                  (c = (l / r) * (2 * Math.PI)),
                    (o = Math.sin(c) * u),
                    (s = Math.cos(c) * u),
                    d.push(o, 0, s),
                    f.push(p.r, p.g, p.b),
                    (c = ((l + 1) / r) * (2 * Math.PI)),
                    (o = Math.sin(c) * u),
                    (s = Math.cos(c) * u),
                    d.push(o, 0, s),
                    f.push(p.r, p.g, p.b);
              var m = new F();
              m.addAttribute("position", new N(d, 3)),
                m.addAttribute("color", new N(f, 3));
              var v = new Be({ vertexColors: po });
              ze.call(this, m, v);
            }
            function fa(t, e, n, r) {
              (this.object = t), (this.size = void 0 !== e ? e : 1);
              var i = void 0 !== n ? n : 16776960,
                a = void 0 !== r ? r : 1,
                o = 0,
                s = this.object.geometry;
              s && s.isGeometry
                ? (o = s.faces.length)
                : console.warn(
                    "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
                  );
              var c = new F(),
                h = new N(2 * o * 3, 3);
              c.addAttribute("position", h),
                ze.call(this, c, new Be({ color: i, linewidth: a })),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            function ma(t, e, n) {
              _.call(this),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                void 0 === e && (e = 1);
              var r = new F();
              r.addAttribute(
                "position",
                new N([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
              );
              var i = new Be({ fog: !1 });
              (this.lightPlane = new Fe(r, i)),
                this.add(this.lightPlane),
                (r = new F()),
                r.addAttribute("position", new N([0, 0, 0, 0, 0, 1], 3)),
                (this.targetLine = new Fe(r, i)),
                this.add(this.targetLine),
                this.update();
            }
            function ga(t) {
              function e(t, e, r) {
                n(t, r), n(e, r);
              }
              function n(t, e) {
                a.push(0, 0, 0),
                  o.push(e.r, e.g, e.b),
                  void 0 === s[t] && (s[t] = []),
                  s[t].push(a.length / 3 - 1);
              }
              var r = new F(),
                i = new Be({ color: 16777215, vertexColors: uo }),
                a = [],
                o = [],
                s = {},
                c = new g(16755200),
                h = new g(16711680),
                l = new g(43775),
                u = new g(16777215),
                p = new g(3355443);
              e("n1", "n2", c),
                e("n2", "n4", c),
                e("n4", "n3", c),
                e("n3", "n1", c),
                e("f1", "f2", c),
                e("f2", "f4", c),
                e("f4", "f3", c),
                e("f3", "f1", c),
                e("n1", "f1", c),
                e("n2", "f2", c),
                e("n3", "f3", c),
                e("n4", "f4", c),
                e("p", "n1", h),
                e("p", "n2", h),
                e("p", "n3", h),
                e("p", "n4", h),
                e("u1", "u2", l),
                e("u2", "u3", l),
                e("u3", "u1", l),
                e("c", "t", u),
                e("p", "c", p),
                e("cn1", "cn2", p),
                e("cn3", "cn4", p),
                e("cf1", "cf2", p),
                e("cf3", "cf4", p),
                r.addAttribute("position", new N(a, 3)),
                r.addAttribute("color", new N(o, 3)),
                ze.call(this, r, i),
                (this.camera = t),
                this.camera.updateProjectionMatrix &&
                  this.camera.updateProjectionMatrix(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = s),
                this.update();
            }
            function va(t, e) {
              (this.object = t), void 0 === e && (e = 16776960);
              var n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                  6, 3, 7,
                ]),
                r = new Float32Array(24),
                i = new F();
              i.setIndex(new S(n, 1)),
                i.addAttribute("position", new S(r, 3)),
                ze.call(this, i, new Be({ color: e })),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            function ya(t, e) {
              (this.type = "Box3Helper"), (this.box = t);
              var n = void 0 !== e ? e : 16776960,
                r = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                  6, 3, 7,
                ]),
                i = [
                  1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                  -1, -1, -1, 1, -1, -1,
                ],
                a = new F();
              a.setIndex(new S(r, 1)),
                a.addAttribute("position", new N(i, 3)),
                ze.call(this, a, new Be({ color: n })),
                this.geometry.computeBoundingSphere();
            }
            function xa(t, e, n) {
              (this.type = "PlaneHelper"),
                (this.plane = t),
                (this.size = void 0 === e ? 1 : e);
              var r = void 0 !== n ? n : 16776960,
                i = [
                  1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                  1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                ],
                a = new F();
              a.addAttribute("position", new N(i, 3)),
                a.computeBoundingSphere(),
                Fe.call(this, a, new Be({ color: r }));
              var o = [
                  1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,
                ],
                s = new F();
              s.addAttribute("position", new N(o, 3)),
                s.computeBoundingSphere(),
                this.add(
                  new Y(
                    s,
                    new j({
                      color: r,
                      opacity: 0.2,
                      transparent: !0,
                      depthWrite: !1,
                    })
                  )
                );
            }
            function ba(t, e, n, r, i, a) {
              _.call(this),
                void 0 === r && (r = 16776960),
                void 0 === n && (n = 1),
                void 0 === i && (i = 0.2 * n),
                void 0 === a && (a = 0.2 * i),
                void 0 === lh &&
                  ((lh = new F()),
                  lh.addAttribute("position", new N([0, 0, 0, 0, 1, 0], 3)),
                  (uh = new ar(0, 0.5, 1, 5, 1)),
                  uh.translate(0, -0.5, 0)),
                this.position.copy(e),
                (this.line = new Fe(lh, new Be({ color: r }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new Y(uh, new j({ color: r }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(t),
                this.setLength(n, i, a);
            }
            function _a(t) {
              t = t || 1;
              var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                n = [
                  1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1,
                ],
                r = new F();
              r.addAttribute("position", new N(e, 3)),
                r.addAttribute("color", new N(n, 3));
              var i = new Be({ vertexColors: po });
              ze.call(this, r, i);
            }
            function wa(t, e, n, r, i, a, o) {
              return (
                console.warn(
                  "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
                ),
                new E(t, e, n, i, a, o)
              );
            }
            function Ma(t) {
              return (
                console.warn(
                  "THREE.MeshFaceMaterial has been removed. Use an Array instead."
                ),
                t
              );
            }
            function Ea(t) {
              return (
                void 0 === t && (t = []),
                console.warn(
                  "THREE.MultiMaterial has been removed. Use an Array instead."
                ),
                (t.isMultiMaterial = !0),
                (t.materials = t),
                (t.clone = function () {
                  return t.slice();
                }),
                t
              );
            }
            function Ta(t, e) {
              return (
                console.warn(
                  "THREE.PointCloud has been renamed to THREE.Points."
                ),
                new Ve(t, e)
              );
            }
            function Sa(t) {
              return (
                console.warn(
                  "THREE.Particle has been renamed to THREE.Sprite."
                ),
                new Oe(t)
              );
            }
            function Aa(t, e) {
              return (
                console.warn(
                  "THREE.ParticleSystem has been renamed to THREE.Points."
                ),
                new Ve(t, e)
              );
            }
            function La(t) {
              return (
                console.warn(
                  "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
                ),
                new He(t)
              );
            }
            function Ra(t) {
              return (
                console.warn(
                  "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
                ),
                new He(t)
              );
            }
            function Ca(t) {
              return (
                console.warn(
                  "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
                ),
                new He(t)
              );
            }
            function Pa(t, e, n) {
              return (
                console.warn(
                  "THREE.Vertex has been removed. Use THREE.Vector3 instead."
                ),
                new a(t, e, n)
              );
            }
            function Oa(t, e) {
              return (
                console.warn(
                  "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
                ),
                new S(t, e).setDynamic(!0)
              );
            }
            function Ia(t, e) {
              return (
                console.warn(
                  "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
                ),
                new A(t, e)
              );
            }
            function Na(t, e) {
              return (
                console.warn(
                  "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
                ),
                new L(t, e)
              );
            }
            function Da(t, e) {
              return (
                console.warn(
                  "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
                ),
                new R(t, e)
              );
            }
            function Ua(t, e) {
              return (
                console.warn(
                  "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
                ),
                new C(t, e)
              );
            }
            function Ba(t, e) {
              return (
                console.warn(
                  "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
                ),
                new P(t, e)
              );
            }
            function Fa(t, e) {
              return (
                console.warn(
                  "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
                ),
                new O(t, e)
              );
            }
            function za(t, e) {
              return (
                console.warn(
                  "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
                ),
                new I(t, e)
              );
            }
            function Ga(t, e) {
              return (
                console.warn(
                  "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
                ),
                new N(t, e)
              );
            }
            function Ha(t, e) {
              return (
                console.warn(
                  "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
                ),
                new D(t, e)
              );
            }
            function Va(t) {
              console.warn(
                "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
              ),
                Cr.call(this, t),
                (this.type = "catmullrom"),
                (this.closed = !0);
            }
            function ka(t) {
              console.warn(
                "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
              ),
                Cr.call(this, t),
                (this.type = "catmullrom");
            }
            function ja(t) {
              console.warn(
                "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
              ),
                Cr.call(this, t),
                (this.type = "catmullrom");
            }
            function Wa(t) {
              return (
                console.warn(
                  "THREE.AxisHelper has been renamed to THREE.AxesHelper."
                ),
                new _a(t)
              );
            }
            function Xa(t, e) {
              return (
                console.warn(
                  "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
                ),
                new va(t, e)
              );
            }
            function qa(t, e) {
              return (
                console.warn(
                  "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
                ),
                new ze(
                  new rr(t.geometry),
                  new Be({ color: void 0 !== e ? e : 16777215 })
                )
              );
            }
            function Ya(t, e) {
              return (
                console.warn(
                  "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
                ),
                new ze(
                  new qe(t.geometry),
                  new Be({ color: void 0 !== e ? e : 16777215 })
                )
              );
            }
            function Ja(t) {
              return (
                console.warn(
                  "THREE.XHRLoader has been renamed to THREE.FileLoader."
                ),
                new br(t)
              );
            }
            function Za(t) {
              return (
                console.warn(
                  "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
                ),
                new wr(t)
              );
            }
            function Qa() {
              console.error(
                "THREE.Projector has been moved to /examples/js/renderers/Projector.js."
              ),
                (this.projectVector = function (t, e) {
                  console.warn(
                    "THREE.Projector: .projectVector() is now vector.project()."
                  ),
                    t.project(e);
                }),
                (this.unprojectVector = function (t, e) {
                  console.warn(
                    "THREE.Projector: .unprojectVector() is now vector.unproject()."
                  ),
                    t.unproject(e);
                }),
                (this.pickingRay = function () {
                  console.error(
                    "THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."
                  );
                });
            }
            function Ka() {
              console.error(
                "THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"
              ),
                (this.domElement = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                )),
                (this.clear = function () {}),
                (this.render = function () {}),
                (this.setClearColor = function () {}),
                (this.setSize = function () {});
            }
            function $a() {
              console.error(
                "THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"
              );
            }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
              void 0 === Number.isInteger &&
                (Number.isInteger = function (t) {
                  return (
                    "number" == typeof t && isFinite(t) && Math.floor(t) === t
                  );
                }),
              void 0 === Math.sign &&
                (Math.sign = function (t) {
                  return t < 0 ? -1 : t > 0 ? 1 : +t;
                }),
              "name" in Function.prototype == !1 &&
                Object.defineProperty(Function.prototype, "name", {
                  get: function () {
                    return this.toString().match(
                      /^\s*function\s*([^\(\s]*)/
                    )[1];
                  },
                }),
              void 0 === Object.assign &&
                (function () {
                  Object.assign = function (t) {
                    if (void 0 === t || null === t)
                      throw new TypeError(
                        "Cannot convert undefined or null to object"
                      );
                    for (var e = Object(t), n = 1; n < arguments.length; n++) {
                      var r = arguments[n];
                      if (void 0 !== r && null !== r)
                        for (var i in r)
                          Object.prototype.hasOwnProperty.call(r, i) &&
                            (e[i] = r[i]);
                    }
                    return e;
                  };
                })(),
              Object.assign(e.prototype, {
                addEventListener: function (t, e) {
                  void 0 === this._listeners && (this._listeners = {});
                  var n = this._listeners;
                  void 0 === n[t] && (n[t] = []),
                    -1 === n[t].indexOf(e) && n[t].push(e);
                },
                hasEventListener: function (t, e) {
                  if (void 0 === this._listeners) return !1;
                  var n = this._listeners;
                  return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                },
                removeEventListener: function (t, e) {
                  if (void 0 !== this._listeners) {
                    var n = this._listeners,
                      r = n[t];
                    if (void 0 !== r) {
                      var i = r.indexOf(e);
                      -1 !== i && r.splice(i, 1);
                    }
                  }
                },
                dispatchEvent: function (t) {
                  if (void 0 !== this._listeners) {
                    var e = this._listeners,
                      n = e[t.type];
                    if (void 0 !== n) {
                      t.target = this;
                      for (var r = n.slice(0), i = 0, a = r.length; i < a; i++)
                        r[i].call(this, t);
                    }
                  }
                },
              });
            var to = "95",
              eo = { LEFT: 0, MIDDLE: 1, RIGHT: 2 },
              no = 0,
              ro = 1,
              io = 2,
              ao = 1,
              oo = 2,
              so = 0,
              co = 1,
              ho = 2,
              lo = 0,
              uo = 1,
              po = 2,
              fo = 0,
              mo = 1,
              go = 2,
              vo = 3,
              yo = 4,
              xo = 5,
              bo = 100,
              _o = 101,
              wo = 102,
              Mo = 103,
              Eo = 104,
              To = 200,
              So = 201,
              Ao = 202,
              Lo = 203,
              Ro = 204,
              Co = 205,
              Po = 206,
              Oo = 207,
              Io = 208,
              No = 209,
              Do = 210,
              Uo = 0,
              Bo = 1,
              Fo = 2,
              zo = 3,
              Go = 4,
              Ho = 5,
              Vo = 6,
              ko = 7,
              jo = 0,
              Wo = 1,
              Xo = 2,
              qo = 0,
              Yo = 1,
              Jo = 2,
              Zo = 3,
              Qo = 4,
              Ko = 301,
              $o = 302,
              ts = 303,
              es = 304,
              ns = 305,
              rs = 306,
              is = 307,
              as = 1e3,
              os = 1001,
              ss = 1002,
              cs = 1003,
              hs = 1004,
              ls = 1005,
              us = 1006,
              ps = 1007,
              ds = 1008,
              fs = 1009,
              ms = 1010,
              gs = 1011,
              vs = 1012,
              ys = 1013,
              xs = 1014,
              bs = 1015,
              _s = 1016,
              ws = 1017,
              Ms = 1018,
              Es = 1019,
              Ts = 1020,
              Ss = 1021,
              As = 1022,
              Ls = 1023,
              Rs = 1024,
              Cs = 1025,
              Ps = Ls,
              Os = 1026,
              Is = 1027,
              Ns = 33776,
              Ds = 33777,
              Us = 33778,
              Bs = 33779,
              Fs = 35840,
              zs = 35841,
              Gs = 35842,
              Hs = 35843,
              Vs = 36196,
              ks = 37808,
              js = 37809,
              Ws = 37810,
              Xs = 37811,
              qs = 37812,
              Ys = 37813,
              Js = 37814,
              Zs = 37815,
              Qs = 37816,
              Ks = 37817,
              $s = 37818,
              tc = 37819,
              ec = 37820,
              nc = 37821,
              rc = 2201,
              ic = 2400,
              ac = 0,
              oc = 1,
              sc = 2,
              cc = 3e3,
              hc = 3001,
              lc = 3007,
              uc = 3002,
              pc = 3004,
              dc = 3005,
              fc = 3006,
              mc = 3200,
              gc = 3201,
              vc = 0,
              yc = 1,
              xc = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: (function () {
                  for (var t = [], e = 0; e < 256; e++)
                    t[e] = (e < 16 ? "0" : "") + e.toString(16);
                  return function () {
                    var e = (4294967295 * Math.random()) | 0,
                      n = (4294967295 * Math.random()) | 0,
                      r = (4294967295 * Math.random()) | 0,
                      i = (4294967295 * Math.random()) | 0;
                    return (
                      t[255 & e] +
                      t[(e >> 8) & 255] +
                      t[(e >> 16) & 255] +
                      t[(e >> 24) & 255] +
                      "-" +
                      t[255 & n] +
                      t[(n >> 8) & 255] +
                      "-" +
                      t[((n >> 16) & 15) | 64] +
                      t[(n >> 24) & 255] +
                      "-" +
                      t[(63 & r) | 128] +
                      t[(r >> 8) & 255] +
                      "-" +
                      t[(r >> 16) & 255] +
                      t[(r >> 24) & 255] +
                      t[255 & i] +
                      t[(i >> 8) & 255] +
                      t[(i >> 16) & 255] +
                      t[(i >> 24) & 255]
                    ).toUpperCase();
                  };
                })(),
                clamp: function (t, e, n) {
                  return Math.max(e, Math.min(n, t));
                },
                euclideanModulo: function (t, e) {
                  return ((t % e) + e) % e;
                },
                mapLinear: function (t, e, n, r, i) {
                  return r + ((t - e) * (i - r)) / (n - e);
                },
                lerp: function (t, e, n) {
                  return (1 - n) * t + n * e;
                },
                smoothstep: function (t, e, n) {
                  return t <= e
                    ? 0
                    : t >= n
                    ? 1
                    : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
                },
                smootherstep: function (t, e, n) {
                  return t <= e
                    ? 0
                    : t >= n
                    ? 1
                    : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
                },
                randInt: function (t, e) {
                  return t + Math.floor(Math.random() * (e - t + 1));
                },
                randFloat: function (t, e) {
                  return t + Math.random() * (e - t);
                },
                randFloatSpread: function (t) {
                  return t * (0.5 - Math.random());
                },
                degToRad: function (t) {
                  return t * xc.DEG2RAD;
                },
                radToDeg: function (t) {
                  return t * xc.RAD2DEG;
                },
                isPowerOfTwo: function (t) {
                  return 0 == (t & (t - 1)) && 0 !== t;
                },
                ceilPowerOfTwo: function (t) {
                  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
                },
                floorPowerOfTwo: function (t) {
                  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
                },
              };
            Object.defineProperties(n.prototype, {
              width: {
                get: function () {
                  return this.x;
                },
                set: function (t) {
                  this.x = t;
                },
              },
              height: {
                get: function () {
                  return this.y;
                },
                set: function (t) {
                  this.y = t;
                },
              },
            }),
              Object.assign(n.prototype, {
                isVector2: !0,
                set: function (t, e) {
                  return (this.x = t), (this.y = e), this;
                },
                setScalar: function (t) {
                  return (this.x = t), (this.y = t), this;
                },
                setX: function (t) {
                  return (this.x = t), this;
                },
                setY: function (t) {
                  return (this.y = t), this;
                },
                setComponent: function (t, e) {
                  switch (t) {
                    case 0:
                      this.x = e;
                      break;
                    case 1:
                      this.y = e;
                      break;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                  return this;
                },
                getComponent: function (t) {
                  switch (t) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                },
                clone: function () {
                  return new this.constructor(this.x, this.y);
                },
                copy: function (t) {
                  return (this.x = t.x), (this.y = t.y), this;
                },
                add: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                      ),
                      this.addVectors(t, e))
                    : ((this.x += t.x), (this.y += t.y), this);
                },
                addScalar: function (t) {
                  return (this.x += t), (this.y += t), this;
                },
                addVectors: function (t, e) {
                  return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                },
                addScaledVector: function (t, e) {
                  return (this.x += t.x * e), (this.y += t.y * e), this;
                },
                sub: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                      ),
                      this.subVectors(t, e))
                    : ((this.x -= t.x), (this.y -= t.y), this);
                },
                subScalar: function (t) {
                  return (this.x -= t), (this.y -= t), this;
                },
                subVectors: function (t, e) {
                  return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                },
                multiply: function (t) {
                  return (this.x *= t.x), (this.y *= t.y), this;
                },
                multiplyScalar: function (t) {
                  return (this.x *= t), (this.y *= t), this;
                },
                divide: function (t) {
                  return (this.x /= t.x), (this.y /= t.y), this;
                },
                divideScalar: function (t) {
                  return this.multiplyScalar(1 / t);
                },
                applyMatrix3: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = t.elements;
                  return (
                    (this.x = r[0] * e + r[3] * n + r[6]),
                    (this.y = r[1] * e + r[4] * n + r[7]),
                    this
                  );
                },
                min: function (t) {
                  return (
                    (this.x = Math.min(this.x, t.x)),
                    (this.y = Math.min(this.y, t.y)),
                    this
                  );
                },
                max: function (t) {
                  return (
                    (this.x = Math.max(this.x, t.x)),
                    (this.y = Math.max(this.y, t.y)),
                    this
                  );
                },
                clamp: function (t, e) {
                  return (
                    (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                    (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                    this
                  );
                },
                clampScalar: (function () {
                  var t = new n(),
                    e = new n();
                  return function (n, r) {
                    return t.set(n, n), e.set(r, r), this.clamp(t, e);
                  };
                })(),
                clampLength: function (t, e) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(t, Math.min(e, n))
                  );
                },
                floor: function () {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    this
                  );
                },
                ceil: function () {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    this
                  );
                },
                round: function () {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    this
                  );
                },
                roundToZero: function () {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    this
                  );
                },
                negate: function () {
                  return (this.x = -this.x), (this.y = -this.y), this;
                },
                dot: function (t) {
                  return this.x * t.x + this.y * t.y;
                },
                cross: function (t) {
                  return this.x * t.y - this.y * t.x;
                },
                lengthSq: function () {
                  return this.x * this.x + this.y * this.y;
                },
                length: function () {
                  return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                manhattanLength: function () {
                  return Math.abs(this.x) + Math.abs(this.y);
                },
                normalize: function () {
                  return this.divideScalar(this.length() || 1);
                },
                angle: function () {
                  var t = Math.atan2(this.y, this.x);
                  return t < 0 && (t += 2 * Math.PI), t;
                },
                distanceTo: function (t) {
                  return Math.sqrt(this.distanceToSquared(t));
                },
                distanceToSquared: function (t) {
                  var e = this.x - t.x,
                    n = this.y - t.y;
                  return e * e + n * n;
                },
                manhattanDistanceTo: function (t) {
                  return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                },
                setLength: function (t) {
                  return this.normalize().multiplyScalar(t);
                },
                lerp: function (t, e) {
                  return (
                    (this.x += (t.x - this.x) * e),
                    (this.y += (t.y - this.y) * e),
                    this
                  );
                },
                lerpVectors: function (t, e, n) {
                  return this.subVectors(e, t).multiplyScalar(n).add(t);
                },
                equals: function (t) {
                  return t.x === this.x && t.y === this.y;
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this.x = t[e]),
                    (this.y = t[e + 1]),
                    this
                  );
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this.x),
                    (t[e + 1] = this.y),
                    t
                  );
                },
                fromBufferAttribute: function (t, e, n) {
                  return (
                    void 0 !== n &&
                      console.warn(
                        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                      ),
                    (this.x = t.getX(e)),
                    (this.y = t.getY(e)),
                    this
                  );
                },
                rotateAround: function (t, e) {
                  var n = Math.cos(e),
                    r = Math.sin(e),
                    i = this.x - t.x,
                    a = this.y - t.y;
                  return (
                    (this.x = i * n - a * r + t.x),
                    (this.y = i * r + a * n + t.y),
                    this
                  );
                },
              }),
              Object.assign(r.prototype, {
                isMatrix4: !0,
                set: function (t, e, n, r, i, a, o, s, c, h, l, u, p, d, f, m) {
                  var g = this.elements;
                  return (
                    (g[0] = t),
                    (g[4] = e),
                    (g[8] = n),
                    (g[12] = r),
                    (g[1] = i),
                    (g[5] = a),
                    (g[9] = o),
                    (g[13] = s),
                    (g[2] = c),
                    (g[6] = h),
                    (g[10] = l),
                    (g[14] = u),
                    (g[3] = p),
                    (g[7] = d),
                    (g[11] = f),
                    (g[15] = m),
                    this
                  );
                },
                identity: function () {
                  return (
                    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
                clone: function () {
                  return new r().fromArray(this.elements);
                },
                copy: function (t) {
                  var e = this.elements,
                    n = t.elements;
                  return (
                    (e[0] = n[0]),
                    (e[1] = n[1]),
                    (e[2] = n[2]),
                    (e[3] = n[3]),
                    (e[4] = n[4]),
                    (e[5] = n[5]),
                    (e[6] = n[6]),
                    (e[7] = n[7]),
                    (e[8] = n[8]),
                    (e[9] = n[9]),
                    (e[10] = n[10]),
                    (e[11] = n[11]),
                    (e[12] = n[12]),
                    (e[13] = n[13]),
                    (e[14] = n[14]),
                    (e[15] = n[15]),
                    this
                  );
                },
                copyPosition: function (t) {
                  var e = this.elements,
                    n = t.elements;
                  return (
                    (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
                  );
                },
                extractBasis: function (t, e, n) {
                  return (
                    t.setFromMatrixColumn(this, 0),
                    e.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this
                  );
                },
                makeBasis: function (t, e, n) {
                  return (
                    this.set(
                      t.x,
                      e.x,
                      n.x,
                      0,
                      t.y,
                      e.y,
                      n.y,
                      0,
                      t.z,
                      e.z,
                      n.z,
                      0,
                      0,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
                extractRotation: (function () {
                  var t = new a();
                  return function (e) {
                    var n = this.elements,
                      r = e.elements,
                      i = 1 / t.setFromMatrixColumn(e, 0).length(),
                      a = 1 / t.setFromMatrixColumn(e, 1).length(),
                      o = 1 / t.setFromMatrixColumn(e, 2).length();
                    return (
                      (n[0] = r[0] * i),
                      (n[1] = r[1] * i),
                      (n[2] = r[2] * i),
                      (n[3] = 0),
                      (n[4] = r[4] * a),
                      (n[5] = r[5] * a),
                      (n[6] = r[6] * a),
                      (n[7] = 0),
                      (n[8] = r[8] * o),
                      (n[9] = r[9] * o),
                      (n[10] = r[10] * o),
                      (n[11] = 0),
                      (n[12] = 0),
                      (n[13] = 0),
                      (n[14] = 0),
                      (n[15] = 1),
                      this
                    );
                  };
                })(),
                makeRotationFromEuler: function (t) {
                  (t && t.isEuler) ||
                    console.error(
                      "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
                    );
                  var e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z,
                    a = Math.cos(n),
                    o = Math.sin(n),
                    s = Math.cos(r),
                    c = Math.sin(r),
                    h = Math.cos(i),
                    l = Math.sin(i);
                  if ("XYZ" === t.order) {
                    var u = a * h,
                      p = a * l,
                      d = o * h,
                      f = o * l;
                    (e[0] = s * h),
                      (e[4] = -s * l),
                      (e[8] = c),
                      (e[1] = p + d * c),
                      (e[5] = u - f * c),
                      (e[9] = -o * s),
                      (e[2] = f - u * c),
                      (e[6] = d + p * c),
                      (e[10] = a * s);
                  } else if ("YXZ" === t.order) {
                    var m = s * h,
                      g = s * l,
                      v = c * h,
                      y = c * l;
                    (e[0] = m + y * o),
                      (e[4] = v * o - g),
                      (e[8] = a * c),
                      (e[1] = a * l),
                      (e[5] = a * h),
                      (e[9] = -o),
                      (e[2] = g * o - v),
                      (e[6] = y + m * o),
                      (e[10] = a * s);
                  } else if ("ZXY" === t.order) {
                    var m = s * h,
                      g = s * l,
                      v = c * h,
                      y = c * l;
                    (e[0] = m - y * o),
                      (e[4] = -a * l),
                      (e[8] = v + g * o),
                      (e[1] = g + v * o),
                      (e[5] = a * h),
                      (e[9] = y - m * o),
                      (e[2] = -a * c),
                      (e[6] = o),
                      (e[10] = a * s);
                  } else if ("ZYX" === t.order) {
                    var u = a * h,
                      p = a * l,
                      d = o * h,
                      f = o * l;
                    (e[0] = s * h),
                      (e[4] = d * c - p),
                      (e[8] = u * c + f),
                      (e[1] = s * l),
                      (e[5] = f * c + u),
                      (e[9] = p * c - d),
                      (e[2] = -c),
                      (e[6] = o * s),
                      (e[10] = a * s);
                  } else if ("YZX" === t.order) {
                    var x = a * s,
                      b = a * c,
                      _ = o * s,
                      w = o * c;
                    (e[0] = s * h),
                      (e[4] = w - x * l),
                      (e[8] = _ * l + b),
                      (e[1] = l),
                      (e[5] = a * h),
                      (e[9] = -o * h),
                      (e[2] = -c * h),
                      (e[6] = b * l + _),
                      (e[10] = x - w * l);
                  } else if ("XZY" === t.order) {
                    var x = a * s,
                      b = a * c,
                      _ = o * s,
                      w = o * c;
                    (e[0] = s * h),
                      (e[4] = -l),
                      (e[8] = c * h),
                      (e[1] = x * l + w),
                      (e[5] = a * h),
                      (e[9] = b * l - _),
                      (e[2] = _ * l - b),
                      (e[6] = o * h),
                      (e[10] = w * l + x);
                  }
                  return (
                    (e[3] = 0),
                    (e[7] = 0),
                    (e[11] = 0),
                    (e[12] = 0),
                    (e[13] = 0),
                    (e[14] = 0),
                    (e[15] = 1),
                    this
                  );
                },
                makeRotationFromQuaternion: (function () {
                  var t = new a(0, 0, 0),
                    e = new a(1, 1, 1);
                  return function (n) {
                    return this.compose(t, n, e);
                  };
                })(),
                lookAt: (function () {
                  var t = new a(),
                    e = new a(),
                    n = new a();
                  return function (r, i, a) {
                    var o = this.elements;
                    return (
                      n.subVectors(r, i),
                      0 === n.lengthSq() && (n.z = 1),
                      n.normalize(),
                      t.crossVectors(a, n),
                      0 === t.lengthSq() &&
                        (1 === Math.abs(a.z) ? (n.x += 1e-4) : (n.z += 1e-4),
                        n.normalize(),
                        t.crossVectors(a, n)),
                      t.normalize(),
                      e.crossVectors(n, t),
                      (o[0] = t.x),
                      (o[4] = e.x),
                      (o[8] = n.x),
                      (o[1] = t.y),
                      (o[5] = e.y),
                      (o[9] = n.y),
                      (o[2] = t.z),
                      (o[6] = e.z),
                      (o[10] = n.z),
                      this
                    );
                  };
                })(),
                multiply: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                      ),
                      this.multiplyMatrices(t, e))
                    : this.multiplyMatrices(this, t);
                },
                premultiply: function (t) {
                  return this.multiplyMatrices(t, this);
                },
                multiplyMatrices: function (t, e) {
                  var n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[4],
                    s = n[8],
                    c = n[12],
                    h = n[1],
                    l = n[5],
                    u = n[9],
                    p = n[13],
                    d = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    x = n[11],
                    b = n[15],
                    _ = r[0],
                    w = r[4],
                    M = r[8],
                    E = r[12],
                    T = r[1],
                    S = r[5],
                    A = r[9],
                    L = r[13],
                    R = r[2],
                    C = r[6],
                    P = r[10],
                    O = r[14],
                    I = r[3],
                    N = r[7],
                    D = r[11],
                    U = r[15];
                  return (
                    (i[0] = a * _ + o * T + s * R + c * I),
                    (i[4] = a * w + o * S + s * C + c * N),
                    (i[8] = a * M + o * A + s * P + c * D),
                    (i[12] = a * E + o * L + s * O + c * U),
                    (i[1] = h * _ + l * T + u * R + p * I),
                    (i[5] = h * w + l * S + u * C + p * N),
                    (i[9] = h * M + l * A + u * P + p * D),
                    (i[13] = h * E + l * L + u * O + p * U),
                    (i[2] = d * _ + f * T + m * R + g * I),
                    (i[6] = d * w + f * S + m * C + g * N),
                    (i[10] = d * M + f * A + m * P + g * D),
                    (i[14] = d * E + f * L + m * O + g * U),
                    (i[3] = v * _ + y * T + x * R + b * I),
                    (i[7] = v * w + y * S + x * C + b * N),
                    (i[11] = v * M + y * A + x * P + b * D),
                    (i[15] = v * E + y * L + x * O + b * U),
                    this
                  );
                },
                multiplyScalar: function (t) {
                  var e = this.elements;
                  return (
                    (e[0] *= t),
                    (e[4] *= t),
                    (e[8] *= t),
                    (e[12] *= t),
                    (e[1] *= t),
                    (e[5] *= t),
                    (e[9] *= t),
                    (e[13] *= t),
                    (e[2] *= t),
                    (e[6] *= t),
                    (e[10] *= t),
                    (e[14] *= t),
                    (e[3] *= t),
                    (e[7] *= t),
                    (e[11] *= t),
                    (e[15] *= t),
                    this
                  );
                },
                applyToBufferAttribute: (function () {
                  var t = new a();
                  return function (e) {
                    for (var n = 0, r = e.count; n < r; n++)
                      (t.x = e.getX(n)),
                        (t.y = e.getY(n)),
                        (t.z = e.getZ(n)),
                        t.applyMatrix4(this),
                        e.setXYZ(n, t.x, t.y, t.z);
                    return e;
                  };
                })(),
                determinant: function () {
                  var t = this.elements,
                    e = t[0],
                    n = t[4],
                    r = t[8],
                    i = t[12],
                    a = t[1],
                    o = t[5],
                    s = t[9],
                    c = t[13],
                    h = t[2],
                    l = t[6],
                    u = t[10],
                    p = t[14];
                  return (
                    t[3] *
                      (+i * s * l -
                        r * c * l -
                        i * o * u +
                        n * c * u +
                        r * o * p -
                        n * s * p) +
                    t[7] *
                      (+e * s * p -
                        e * c * u +
                        i * a * u -
                        r * a * p +
                        r * c * h -
                        i * s * h) +
                    t[11] *
                      (+e * c * l -
                        e * o * p -
                        i * a * l +
                        n * a * p +
                        i * o * h -
                        n * c * h) +
                    t[15] *
                      (-r * o * h -
                        e * s * l +
                        e * o * u +
                        r * a * l -
                        n * a * u +
                        n * s * h)
                  );
                },
                transpose: function () {
                  var t,
                    e = this.elements;
                  return (
                    (t = e[1]),
                    (e[1] = e[4]),
                    (e[4] = t),
                    (t = e[2]),
                    (e[2] = e[8]),
                    (e[8] = t),
                    (t = e[6]),
                    (e[6] = e[9]),
                    (e[9] = t),
                    (t = e[3]),
                    (e[3] = e[12]),
                    (e[12] = t),
                    (t = e[7]),
                    (e[7] = e[13]),
                    (e[13] = t),
                    (t = e[11]),
                    (e[11] = e[14]),
                    (e[14] = t),
                    this
                  );
                },
                setPosition: function (t) {
                  var e = this.elements;
                  return (e[12] = t.x), (e[13] = t.y), (e[14] = t.z), this;
                },
                getInverse: function (t, e) {
                  var n = this.elements,
                    r = t.elements,
                    i = r[0],
                    a = r[1],
                    o = r[2],
                    s = r[3],
                    c = r[4],
                    h = r[5],
                    l = r[6],
                    u = r[7],
                    p = r[8],
                    d = r[9],
                    f = r[10],
                    m = r[11],
                    g = r[12],
                    v = r[13],
                    y = r[14],
                    x = r[15],
                    b =
                      d * y * u -
                      v * f * u +
                      v * l * m -
                      h * y * m -
                      d * l * x +
                      h * f * x,
                    _ =
                      g * f * u -
                      p * y * u -
                      g * l * m +
                      c * y * m +
                      p * l * x -
                      c * f * x,
                    w =
                      p * v * u -
                      g * d * u +
                      g * h * m -
                      c * v * m -
                      p * h * x +
                      c * d * x,
                    M =
                      g * d * l -
                      p * v * l -
                      g * h * f +
                      c * v * f +
                      p * h * y -
                      c * d * y,
                    E = i * b + a * _ + o * w + s * M;
                  if (0 === E) {
                    var T =
                      "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(T);
                    return console.warn(T), this.identity();
                  }
                  var S = 1 / E;
                  return (
                    (n[0] = b * S),
                    (n[1] =
                      (v * f * s -
                        d * y * s -
                        v * o * m +
                        a * y * m +
                        d * o * x -
                        a * f * x) *
                      S),
                    (n[2] =
                      (h * y * s -
                        v * l * s +
                        v * o * u -
                        a * y * u -
                        h * o * x +
                        a * l * x) *
                      S),
                    (n[3] =
                      (d * l * s -
                        h * f * s -
                        d * o * u +
                        a * f * u +
                        h * o * m -
                        a * l * m) *
                      S),
                    (n[4] = _ * S),
                    (n[5] =
                      (p * y * s -
                        g * f * s +
                        g * o * m -
                        i * y * m -
                        p * o * x +
                        i * f * x) *
                      S),
                    (n[6] =
                      (g * l * s -
                        c * y * s -
                        g * o * u +
                        i * y * u +
                        c * o * x -
                        i * l * x) *
                      S),
                    (n[7] =
                      (c * f * s -
                        p * l * s +
                        p * o * u -
                        i * f * u -
                        c * o * m +
                        i * l * m) *
                      S),
                    (n[8] = w * S),
                    (n[9] =
                      (g * d * s -
                        p * v * s -
                        g * a * m +
                        i * v * m +
                        p * a * x -
                        i * d * x) *
                      S),
                    (n[10] =
                      (c * v * s -
                        g * h * s +
                        g * a * u -
                        i * v * u -
                        c * a * x +
                        i * h * x) *
                      S),
                    (n[11] =
                      (p * h * s -
                        c * d * s -
                        p * a * u +
                        i * d * u +
                        c * a * m -
                        i * h * m) *
                      S),
                    (n[12] = M * S),
                    (n[13] =
                      (p * v * o -
                        g * d * o +
                        g * a * f -
                        i * v * f -
                        p * a * y +
                        i * d * y) *
                      S),
                    (n[14] =
                      (g * h * o -
                        c * v * o -
                        g * a * l +
                        i * v * l +
                        c * a * y -
                        i * h * y) *
                      S),
                    (n[15] =
                      (c * d * o -
                        p * h * o +
                        p * a * l -
                        i * d * l -
                        c * a * f +
                        i * h * f) *
                      S),
                    this
                  );
                },
                scale: function (t) {
                  var e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z;
                  return (
                    (e[0] *= n),
                    (e[4] *= r),
                    (e[8] *= i),
                    (e[1] *= n),
                    (e[5] *= r),
                    (e[9] *= i),
                    (e[2] *= n),
                    (e[6] *= r),
                    (e[10] *= i),
                    (e[3] *= n),
                    (e[7] *= r),
                    (e[11] *= i),
                    this
                  );
                },
                getMaxScaleOnAxis: function () {
                  var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                  return Math.sqrt(Math.max(e, n, r));
                },
                makeTranslation: function (t, e, n) {
                  return (
                    this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                    this
                  );
                },
                makeRotationX: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t);
                  return (
                    this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                    this
                  );
                },
                makeRotationY: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t);
                  return (
                    this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                    this
                  );
                },
                makeRotationZ: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t);
                  return (
                    this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
                makeRotationAxis: function (t, e) {
                  var n = Math.cos(e),
                    r = Math.sin(e),
                    i = 1 - n,
                    a = t.x,
                    o = t.y,
                    s = t.z,
                    c = i * a,
                    h = i * o;
                  return (
                    this.set(
                      c * a + n,
                      c * o - r * s,
                      c * s + r * o,
                      0,
                      c * o + r * s,
                      h * o + n,
                      h * s - r * a,
                      0,
                      c * s - r * o,
                      h * s + r * a,
                      i * s * s + n,
                      0,
                      0,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
                makeScale: function (t, e, n) {
                  return (
                    this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
                  );
                },
                makeShear: function (t, e, n) {
                  return (
                    this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
                compose: function (t, e, n) {
                  var r = this.elements,
                    i = e._x,
                    a = e._y,
                    o = e._z,
                    s = e._w,
                    c = i + i,
                    h = a + a,
                    l = o + o,
                    u = i * c,
                    p = i * h,
                    d = i * l,
                    f = a * h,
                    m = a * l,
                    g = o * l,
                    v = s * c,
                    y = s * h,
                    x = s * l,
                    b = n.x,
                    _ = n.y,
                    w = n.z;
                  return (
                    (r[0] = (1 - (f + g)) * b),
                    (r[1] = (p + x) * b),
                    (r[2] = (d - y) * b),
                    (r[3] = 0),
                    (r[4] = (p - x) * _),
                    (r[5] = (1 - (u + g)) * _),
                    (r[6] = (m + v) * _),
                    (r[7] = 0),
                    (r[8] = (d + y) * w),
                    (r[9] = (m - v) * w),
                    (r[10] = (1 - (u + f)) * w),
                    (r[11] = 0),
                    (r[12] = t.x),
                    (r[13] = t.y),
                    (r[14] = t.z),
                    (r[15] = 1),
                    this
                  );
                },
                decompose: (function () {
                  var t = new a(),
                    e = new r();
                  return function (n, r, i) {
                    var a = this.elements,
                      o = t.set(a[0], a[1], a[2]).length(),
                      s = t.set(a[4], a[5], a[6]).length(),
                      c = t.set(a[8], a[9], a[10]).length();
                    this.determinant() < 0 && (o = -o),
                      (n.x = a[12]),
                      (n.y = a[13]),
                      (n.z = a[14]),
                      e.copy(this);
                    var h = 1 / o,
                      l = 1 / s,
                      u = 1 / c;
                    return (
                      (e.elements[0] *= h),
                      (e.elements[1] *= h),
                      (e.elements[2] *= h),
                      (e.elements[4] *= l),
                      (e.elements[5] *= l),
                      (e.elements[6] *= l),
                      (e.elements[8] *= u),
                      (e.elements[9] *= u),
                      (e.elements[10] *= u),
                      r.setFromRotationMatrix(e),
                      (i.x = o),
                      (i.y = s),
                      (i.z = c),
                      this
                    );
                  };
                })(),
                makePerspective: function (t, e, n, r, i, a) {
                  void 0 === a &&
                    console.warn(
                      "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
                    );
                  var o = this.elements,
                    s = (2 * i) / (e - t),
                    c = (2 * i) / (n - r),
                    h = (e + t) / (e - t),
                    l = (n + r) / (n - r),
                    u = -(a + i) / (a - i),
                    p = (-2 * a * i) / (a - i);
                  return (
                    (o[0] = s),
                    (o[4] = 0),
                    (o[8] = h),
                    (o[12] = 0),
                    (o[1] = 0),
                    (o[5] = c),
                    (o[9] = l),
                    (o[13] = 0),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = u),
                    (o[14] = p),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = -1),
                    (o[15] = 0),
                    this
                  );
                },
                makeOrthographic: function (t, e, n, r, i, a) {
                  var o = this.elements,
                    s = 1 / (e - t),
                    c = 1 / (n - r),
                    h = 1 / (a - i),
                    l = (e + t) * s,
                    u = (n + r) * c,
                    p = (a + i) * h;
                  return (
                    (o[0] = 2 * s),
                    (o[4] = 0),
                    (o[8] = 0),
                    (o[12] = -l),
                    (o[1] = 0),
                    (o[5] = 2 * c),
                    (o[9] = 0),
                    (o[13] = -u),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = -2 * h),
                    (o[14] = -p),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = 0),
                    (o[15] = 1),
                    this
                  );
                },
                equals: function (t) {
                  for (
                    var e = this.elements, n = t.elements, r = 0;
                    r < 16;
                    r++
                  )
                    if (e[r] !== n[r]) return !1;
                  return !0;
                },
                fromArray: function (t, e) {
                  void 0 === e && (e = 0);
                  for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                  return this;
                },
                toArray: function (t, e) {
                  void 0 === t && (t = []), void 0 === e && (e = 0);
                  var n = this.elements;
                  return (
                    (t[e] = n[0]),
                    (t[e + 1] = n[1]),
                    (t[e + 2] = n[2]),
                    (t[e + 3] = n[3]),
                    (t[e + 4] = n[4]),
                    (t[e + 5] = n[5]),
                    (t[e + 6] = n[6]),
                    (t[e + 7] = n[7]),
                    (t[e + 8] = n[8]),
                    (t[e + 9] = n[9]),
                    (t[e + 10] = n[10]),
                    (t[e + 11] = n[11]),
                    (t[e + 12] = n[12]),
                    (t[e + 13] = n[13]),
                    (t[e + 14] = n[14]),
                    (t[e + 15] = n[15]),
                    t
                  );
                },
              }),
              Object.assign(i, {
                slerp: function (t, e, n, r) {
                  return n.copy(t).slerp(e, r);
                },
                slerpFlat: function (t, e, n, r, i, a, o) {
                  var s = n[r + 0],
                    c = n[r + 1],
                    h = n[r + 2],
                    l = n[r + 3],
                    u = i[a + 0],
                    p = i[a + 1],
                    d = i[a + 2],
                    f = i[a + 3];
                  if (l !== f || s !== u || c !== p || h !== d) {
                    var m = 1 - o,
                      g = s * u + c * p + h * d + l * f,
                      v = g >= 0 ? 1 : -1,
                      y = 1 - g * g;
                    if (y > Number.EPSILON) {
                      var x = Math.sqrt(y),
                        b = Math.atan2(x, g * v);
                      (m = Math.sin(m * b) / x), (o = Math.sin(o * b) / x);
                    }
                    var _ = o * v;
                    if (
                      ((s = s * m + u * _),
                      (c = c * m + p * _),
                      (h = h * m + d * _),
                      (l = l * m + f * _),
                      m === 1 - o)
                    ) {
                      var w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
                      (s *= w), (c *= w), (h *= w), (l *= w);
                    }
                  }
                  (t[e] = s), (t[e + 1] = c), (t[e + 2] = h), (t[e + 3] = l);
                },
              }),
              Object.defineProperties(i.prototype, {
                x: {
                  get: function () {
                    return this._x;
                  },
                  set: function (t) {
                    (this._x = t), this.onChangeCallback();
                  },
                },
                y: {
                  get: function () {
                    return this._y;
                  },
                  set: function (t) {
                    (this._y = t), this.onChangeCallback();
                  },
                },
                z: {
                  get: function () {
                    return this._z;
                  },
                  set: function (t) {
                    (this._z = t), this.onChangeCallback();
                  },
                },
                w: {
                  get: function () {
                    return this._w;
                  },
                  set: function (t) {
                    (this._w = t), this.onChangeCallback();
                  },
                },
              }),
              Object.assign(i.prototype, {
                set: function (t, e, n, r) {
                  return (
                    (this._x = t),
                    (this._y = e),
                    (this._z = n),
                    (this._w = r),
                    this.onChangeCallback(),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor(
                    this._x,
                    this._y,
                    this._z,
                    this._w
                  );
                },
                copy: function (t) {
                  return (
                    (this._x = t.x),
                    (this._y = t.y),
                    (this._z = t.z),
                    (this._w = t.w),
                    this.onChangeCallback(),
                    this
                  );
                },
                setFromEuler: function (t, e) {
                  if (!t || !t.isEuler)
                    throw new Error(
                      "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
                    );
                  var n = t._x,
                    r = t._y,
                    i = t._z,
                    a = t.order,
                    o = Math.cos,
                    s = Math.sin,
                    c = o(n / 2),
                    h = o(r / 2),
                    l = o(i / 2),
                    u = s(n / 2),
                    p = s(r / 2),
                    d = s(i / 2);
                  return (
                    "XYZ" === a
                      ? ((this._x = u * h * l + c * p * d),
                        (this._y = c * p * l - u * h * d),
                        (this._z = c * h * d + u * p * l),
                        (this._w = c * h * l - u * p * d))
                      : "YXZ" === a
                      ? ((this._x = u * h * l + c * p * d),
                        (this._y = c * p * l - u * h * d),
                        (this._z = c * h * d - u * p * l),
                        (this._w = c * h * l + u * p * d))
                      : "ZXY" === a
                      ? ((this._x = u * h * l - c * p * d),
                        (this._y = c * p * l + u * h * d),
                        (this._z = c * h * d + u * p * l),
                        (this._w = c * h * l - u * p * d))
                      : "ZYX" === a
                      ? ((this._x = u * h * l - c * p * d),
                        (this._y = c * p * l + u * h * d),
                        (this._z = c * h * d - u * p * l),
                        (this._w = c * h * l + u * p * d))
                      : "YZX" === a
                      ? ((this._x = u * h * l + c * p * d),
                        (this._y = c * p * l + u * h * d),
                        (this._z = c * h * d - u * p * l),
                        (this._w = c * h * l - u * p * d))
                      : "XZY" === a &&
                        ((this._x = u * h * l - c * p * d),
                        (this._y = c * p * l - u * h * d),
                        (this._z = c * h * d + u * p * l),
                        (this._w = c * h * l + u * p * d)),
                    !1 !== e && this.onChangeCallback(),
                    this
                  );
                },
                setFromAxisAngle: function (t, e) {
                  var n = e / 2,
                    r = Math.sin(n);
                  return (
                    (this._x = t.x * r),
                    (this._y = t.y * r),
                    (this._z = t.z * r),
                    (this._w = Math.cos(n)),
                    this.onChangeCallback(),
                    this
                  );
                },
                setFromRotationMatrix: function (t) {
                  var e,
                    n = t.elements,
                    r = n[0],
                    i = n[4],
                    a = n[8],
                    o = n[1],
                    s = n[5],
                    c = n[9],
                    h = n[2],
                    l = n[6],
                    u = n[10],
                    p = r + s + u;
                  return (
                    p > 0
                      ? ((e = 0.5 / Math.sqrt(p + 1)),
                        (this._w = 0.25 / e),
                        (this._x = (l - c) * e),
                        (this._y = (a - h) * e),
                        (this._z = (o - i) * e))
                      : r > s && r > u
                      ? ((e = 2 * Math.sqrt(1 + r - s - u)),
                        (this._w = (l - c) / e),
                        (this._x = 0.25 * e),
                        (this._y = (i + o) / e),
                        (this._z = (a + h) / e))
                      : s > u
                      ? ((e = 2 * Math.sqrt(1 + s - r - u)),
                        (this._w = (a - h) / e),
                        (this._x = (i + o) / e),
                        (this._y = 0.25 * e),
                        (this._z = (c + l) / e))
                      : ((e = 2 * Math.sqrt(1 + u - r - s)),
                        (this._w = (o - i) / e),
                        (this._x = (a + h) / e),
                        (this._y = (c + l) / e),
                        (this._z = 0.25 * e)),
                    this.onChangeCallback(),
                    this
                  );
                },
                setFromUnitVectors: (function () {
                  var t,
                    e = new a();
                  return function (n, r) {
                    return (
                      void 0 === e && (e = new a()),
                      (t = n.dot(r) + 1),
                      t < 1e-6
                        ? ((t = 0),
                          Math.abs(n.x) > Math.abs(n.z)
                            ? e.set(-n.y, n.x, 0)
                            : e.set(0, -n.z, n.y))
                        : e.crossVectors(n, r),
                      (this._x = e.x),
                      (this._y = e.y),
                      (this._z = e.z),
                      (this._w = t),
                      this.normalize()
                    );
                  };
                })(),
                angleTo: function (t) {
                  return 2 * Math.acos(Math.abs(xc.clamp(this.dot(t), -1, 1)));
                },
                rotateTowards: function (t, e) {
                  var n = this.angleTo(t);
                  if (0 === n) return this;
                  var r = Math.min(1, e / n);
                  return this.slerp(t, r), this;
                },
                inverse: function () {
                  return this.conjugate();
                },
                conjugate: function () {
                  return (
                    (this._x *= -1),
                    (this._y *= -1),
                    (this._z *= -1),
                    this.onChangeCallback(),
                    this
                  );
                },
                dot: function (t) {
                  return (
                    this._x * t._x +
                    this._y * t._y +
                    this._z * t._z +
                    this._w * t._w
                  );
                },
                lengthSq: function () {
                  return (
                    this._x * this._x +
                    this._y * this._y +
                    this._z * this._z +
                    this._w * this._w
                  );
                },
                length: function () {
                  return Math.sqrt(
                    this._x * this._x +
                      this._y * this._y +
                      this._z * this._z +
                      this._w * this._w
                  );
                },
                normalize: function () {
                  var t = this.length();
                  return (
                    0 === t
                      ? ((this._x = 0),
                        (this._y = 0),
                        (this._z = 0),
                        (this._w = 1))
                      : ((t = 1 / t),
                        (this._x = this._x * t),
                        (this._y = this._y * t),
                        (this._z = this._z * t),
                        (this._w = this._w * t)),
                    this.onChangeCallback(),
                    this
                  );
                },
                multiply: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                      ),
                      this.multiplyQuaternions(t, e))
                    : this.multiplyQuaternions(this, t);
                },
                premultiply: function (t) {
                  return this.multiplyQuaternions(t, this);
                },
                multiplyQuaternions: function (t, e) {
                  var n = t._x,
                    r = t._y,
                    i = t._z,
                    a = t._w,
                    o = e._x,
                    s = e._y,
                    c = e._z,
                    h = e._w;
                  return (
                    (this._x = n * h + a * o + r * c - i * s),
                    (this._y = r * h + a * s + i * o - n * c),
                    (this._z = i * h + a * c + n * s - r * o),
                    (this._w = a * h - n * o - r * s - i * c),
                    this.onChangeCallback(),
                    this
                  );
                },
                slerp: function (t, e) {
                  if (0 === e) return this;
                  if (1 === e) return this.copy(t);
                  var n = this._x,
                    r = this._y,
                    i = this._z,
                    a = this._w,
                    o = a * t._w + n * t._x + r * t._y + i * t._z;
                  if (
                    (o < 0
                      ? ((this._w = -t._w),
                        (this._x = -t._x),
                        (this._y = -t._y),
                        (this._z = -t._z),
                        (o = -o))
                      : this.copy(t),
                    o >= 1)
                  )
                    return (
                      (this._w = a),
                      (this._x = n),
                      (this._y = r),
                      (this._z = i),
                      this
                    );
                  var s = 1 - o * o;
                  if (s <= Number.EPSILON) {
                    var c = 1 - e;
                    return (
                      (this._w = c * a + e * this._w),
                      (this._x = c * n + e * this._x),
                      (this._y = c * r + e * this._y),
                      (this._z = c * i + e * this._z),
                      this.normalize()
                    );
                  }
                  var h = Math.sqrt(s),
                    l = Math.atan2(h, o),
                    u = Math.sin((1 - e) * l) / h,
                    p = Math.sin(e * l) / h;
                  return (
                    (this._w = a * u + this._w * p),
                    (this._x = n * u + this._x * p),
                    (this._y = r * u + this._y * p),
                    (this._z = i * u + this._z * p),
                    this.onChangeCallback(),
                    this
                  );
                },
                equals: function (t) {
                  return (
                    t._x === this._x &&
                    t._y === this._y &&
                    t._z === this._z &&
                    t._w === this._w
                  );
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this._x = t[e]),
                    (this._y = t[e + 1]),
                    (this._z = t[e + 2]),
                    (this._w = t[e + 3]),
                    this.onChangeCallback(),
                    this
                  );
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this._x),
                    (t[e + 1] = this._y),
                    (t[e + 2] = this._z),
                    (t[e + 3] = this._w),
                    t
                  );
                },
                onChange: function (t) {
                  return (this.onChangeCallback = t), this;
                },
                onChangeCallback: function () {},
              }),
              Object.assign(a.prototype, {
                isVector3: !0,
                set: function (t, e, n) {
                  return (this.x = t), (this.y = e), (this.z = n), this;
                },
                setScalar: function (t) {
                  return (this.x = t), (this.y = t), (this.z = t), this;
                },
                setX: function (t) {
                  return (this.x = t), this;
                },
                setY: function (t) {
                  return (this.y = t), this;
                },
                setZ: function (t) {
                  return (this.z = t), this;
                },
                setComponent: function (t, e) {
                  switch (t) {
                    case 0:
                      this.x = e;
                      break;
                    case 1:
                      this.y = e;
                      break;
                    case 2:
                      this.z = e;
                      break;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                  return this;
                },
                getComponent: function (t) {
                  switch (t) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                },
                clone: function () {
                  return new this.constructor(this.x, this.y, this.z);
                },
                copy: function (t) {
                  return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
                },
                add: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                      ),
                      this.addVectors(t, e))
                    : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
                },
                addScalar: function (t) {
                  return (this.x += t), (this.y += t), (this.z += t), this;
                },
                addVectors: function (t, e) {
                  return (
                    (this.x = t.x + e.x),
                    (this.y = t.y + e.y),
                    (this.z = t.z + e.z),
                    this
                  );
                },
                addScaledVector: function (t, e) {
                  return (
                    (this.x += t.x * e),
                    (this.y += t.y * e),
                    (this.z += t.z * e),
                    this
                  );
                },
                sub: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                      ),
                      this.subVectors(t, e))
                    : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
                },
                subScalar: function (t) {
                  return (this.x -= t), (this.y -= t), (this.z -= t), this;
                },
                subVectors: function (t, e) {
                  return (
                    (this.x = t.x - e.x),
                    (this.y = t.y - e.y),
                    (this.z = t.z - e.z),
                    this
                  );
                },
                multiply: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                      ),
                      this.multiplyVectors(t, e))
                    : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
                },
                multiplyScalar: function (t) {
                  return (this.x *= t), (this.y *= t), (this.z *= t), this;
                },
                multiplyVectors: function (t, e) {
                  return (
                    (this.x = t.x * e.x),
                    (this.y = t.y * e.y),
                    (this.z = t.z * e.z),
                    this
                  );
                },
                applyEuler: (function () {
                  var t = new i();
                  return function (e) {
                    return (
                      (e && e.isEuler) ||
                        console.error(
                          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                        ),
                      this.applyQuaternion(t.setFromEuler(e))
                    );
                  };
                })(),
                applyAxisAngle: (function () {
                  var t = new i();
                  return function (e, n) {
                    return this.applyQuaternion(t.setFromAxisAngle(e, n));
                  };
                })(),
                applyMatrix3: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                  return (
                    (this.x = i[0] * e + i[3] * n + i[6] * r),
                    (this.y = i[1] * e + i[4] * n + i[7] * r),
                    (this.z = i[2] * e + i[5] * n + i[8] * r),
                    this
                  );
                },
                applyMatrix4: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements,
                    a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                  return (
                    (this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a),
                    (this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a),
                    (this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a),
                    this
                  );
                },
                applyQuaternion: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.x,
                    a = t.y,
                    o = t.z,
                    s = t.w,
                    c = s * e + a * r - o * n,
                    h = s * n + o * e - i * r,
                    l = s * r + i * n - a * e,
                    u = -i * e - a * n - o * r;
                  return (
                    (this.x = c * s + u * -i + h * -o - l * -a),
                    (this.y = h * s + u * -a + l * -i - c * -o),
                    (this.z = l * s + u * -o + c * -a - h * -i),
                    this
                  );
                },
                project: (function () {
                  var t = new r();
                  return function (e) {
                    return (
                      t.multiplyMatrices(
                        e.projectionMatrix,
                        t.getInverse(e.matrixWorld)
                      ),
                      this.applyMatrix4(t)
                    );
                  };
                })(),
                unproject: (function () {
                  var t = new r();
                  return function (e) {
                    return (
                      t.multiplyMatrices(
                        e.matrixWorld,
                        t.getInverse(e.projectionMatrix)
                      ),
                      this.applyMatrix4(t)
                    );
                  };
                })(),
                transformDirection: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements;
                  return (
                    (this.x = i[0] * e + i[4] * n + i[8] * r),
                    (this.y = i[1] * e + i[5] * n + i[9] * r),
                    (this.z = i[2] * e + i[6] * n + i[10] * r),
                    this.normalize()
                  );
                },
                divide: function (t) {
                  return (
                    (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
                  );
                },
                divideScalar: function (t) {
                  return this.multiplyScalar(1 / t);
                },
                min: function (t) {
                  return (
                    (this.x = Math.min(this.x, t.x)),
                    (this.y = Math.min(this.y, t.y)),
                    (this.z = Math.min(this.z, t.z)),
                    this
                  );
                },
                max: function (t) {
                  return (
                    (this.x = Math.max(this.x, t.x)),
                    (this.y = Math.max(this.y, t.y)),
                    (this.z = Math.max(this.z, t.z)),
                    this
                  );
                },
                clamp: function (t, e) {
                  return (
                    (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                    (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                    (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                    this
                  );
                },
                clampScalar: (function () {
                  var t = new a(),
                    e = new a();
                  return function (n, r) {
                    return t.set(n, n, n), e.set(r, r, r), this.clamp(t, e);
                  };
                })(),
                clampLength: function (t, e) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(t, Math.min(e, n))
                  );
                },
                floor: function () {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    (this.z = Math.floor(this.z)),
                    this
                  );
                },
                ceil: function () {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    (this.z = Math.ceil(this.z)),
                    this
                  );
                },
                round: function () {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    (this.z = Math.round(this.z)),
                    this
                  );
                },
                roundToZero: function () {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    (this.z =
                      this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                    this
                  );
                },
                negate: function () {
                  return (
                    (this.x = -this.x),
                    (this.y = -this.y),
                    (this.z = -this.z),
                    this
                  );
                },
                dot: function (t) {
                  return this.x * t.x + this.y * t.y + this.z * t.z;
                },
                lengthSq: function () {
                  return this.x * this.x + this.y * this.y + this.z * this.z;
                },
                length: function () {
                  return Math.sqrt(
                    this.x * this.x + this.y * this.y + this.z * this.z
                  );
                },
                manhattanLength: function () {
                  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                },
                normalize: function () {
                  return this.divideScalar(this.length() || 1);
                },
                setLength: function (t) {
                  return this.normalize().multiplyScalar(t);
                },
                lerp: function (t, e) {
                  return (
                    (this.x += (t.x - this.x) * e),
                    (this.y += (t.y - this.y) * e),
                    (this.z += (t.z - this.z) * e),
                    this
                  );
                },
                lerpVectors: function (t, e, n) {
                  return this.subVectors(e, t).multiplyScalar(n).add(t);
                },
                cross: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                      ),
                      this.crossVectors(t, e))
                    : this.crossVectors(this, t);
                },
                crossVectors: function (t, e) {
                  var n = t.x,
                    r = t.y,
                    i = t.z,
                    a = e.x,
                    o = e.y,
                    s = e.z;
                  return (
                    (this.x = r * s - i * o),
                    (this.y = i * a - n * s),
                    (this.z = n * o - r * a),
                    this
                  );
                },
                projectOnVector: function (t) {
                  var e = t.dot(this) / t.lengthSq();
                  return this.copy(t).multiplyScalar(e);
                },
                projectOnPlane: (function () {
                  var t = new a();
                  return function (e) {
                    return t.copy(this).projectOnVector(e), this.sub(t);
                  };
                })(),
                reflect: (function () {
                  var t = new a();
                  return function (e) {
                    return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
                  };
                })(),
                angleTo: function (t) {
                  var e =
                    this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                  return Math.acos(xc.clamp(e, -1, 1));
                },
                distanceTo: function (t) {
                  return Math.sqrt(this.distanceToSquared(t));
                },
                distanceToSquared: function (t) {
                  var e = this.x - t.x,
                    n = this.y - t.y,
                    r = this.z - t.z;
                  return e * e + n * n + r * r;
                },
                manhattanDistanceTo: function (t) {
                  return (
                    Math.abs(this.x - t.x) +
                    Math.abs(this.y - t.y) +
                    Math.abs(this.z - t.z)
                  );
                },
                setFromSpherical: function (t) {
                  var e = Math.sin(t.phi) * t.radius;
                  return (
                    (this.x = e * Math.sin(t.theta)),
                    (this.y = Math.cos(t.phi) * t.radius),
                    (this.z = e * Math.cos(t.theta)),
                    this
                  );
                },
                setFromCylindrical: function (t) {
                  return (
                    (this.x = t.radius * Math.sin(t.theta)),
                    (this.y = t.y),
                    (this.z = t.radius * Math.cos(t.theta)),
                    this
                  );
                },
                setFromMatrixPosition: function (t) {
                  var e = t.elements;
                  return (
                    (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
                  );
                },
                setFromMatrixScale: function (t) {
                  var e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length();
                  return (this.x = e), (this.y = n), (this.z = r), this;
                },
                setFromMatrixColumn: function (t, e) {
                  return this.fromArray(t.elements, 4 * e);
                },
                equals: function (t) {
                  return t.x === this.x && t.y === this.y && t.z === this.z;
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this.x = t[e]),
                    (this.y = t[e + 1]),
                    (this.z = t[e + 2]),
                    this
                  );
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this.x),
                    (t[e + 1] = this.y),
                    (t[e + 2] = this.z),
                    t
                  );
                },
                fromBufferAttribute: function (t, e, n) {
                  return (
                    void 0 !== n &&
                      console.warn(
                        "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                      ),
                    (this.x = t.getX(e)),
                    (this.y = t.getY(e)),
                    (this.z = t.getZ(e)),
                    this
                  );
                },
              }),
              Object.assign(o.prototype, {
                isMatrix3: !0,
                set: function (t, e, n, r, i, a, o, s, c) {
                  var h = this.elements;
                  return (
                    (h[0] = t),
                    (h[1] = r),
                    (h[2] = o),
                    (h[3] = e),
                    (h[4] = i),
                    (h[5] = s),
                    (h[6] = n),
                    (h[7] = a),
                    (h[8] = c),
                    this
                  );
                },
                identity: function () {
                  return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                },
                clone: function () {
                  return new this.constructor().fromArray(this.elements);
                },
                copy: function (t) {
                  var e = this.elements,
                    n = t.elements;
                  return (
                    (e[0] = n[0]),
                    (e[1] = n[1]),
                    (e[2] = n[2]),
                    (e[3] = n[3]),
                    (e[4] = n[4]),
                    (e[5] = n[5]),
                    (e[6] = n[6]),
                    (e[7] = n[7]),
                    (e[8] = n[8]),
                    this
                  );
                },
                setFromMatrix4: function (t) {
                  var e = t.elements;
                  return (
                    this.set(
                      e[0],
                      e[4],
                      e[8],
                      e[1],
                      e[5],
                      e[9],
                      e[2],
                      e[6],
                      e[10]
                    ),
                    this
                  );
                },
                applyToBufferAttribute: (function () {
                  var t = new a();
                  return function (e) {
                    for (var n = 0, r = e.count; n < r; n++)
                      (t.x = e.getX(n)),
                        (t.y = e.getY(n)),
                        (t.z = e.getZ(n)),
                        t.applyMatrix3(this),
                        e.setXYZ(n, t.x, t.y, t.z);
                    return e;
                  };
                })(),
                multiply: function (t) {
                  return this.multiplyMatrices(this, t);
                },
                premultiply: function (t) {
                  return this.multiplyMatrices(t, this);
                },
                multiplyMatrices: function (t, e) {
                  var n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[3],
                    s = n[6],
                    c = n[1],
                    h = n[4],
                    l = n[7],
                    u = n[2],
                    p = n[5],
                    d = n[8],
                    f = r[0],
                    m = r[3],
                    g = r[6],
                    v = r[1],
                    y = r[4],
                    x = r[7],
                    b = r[2],
                    _ = r[5],
                    w = r[8];
                  return (
                    (i[0] = a * f + o * v + s * b),
                    (i[3] = a * m + o * y + s * _),
                    (i[6] = a * g + o * x + s * w),
                    (i[1] = c * f + h * v + l * b),
                    (i[4] = c * m + h * y + l * _),
                    (i[7] = c * g + h * x + l * w),
                    (i[2] = u * f + p * v + d * b),
                    (i[5] = u * m + p * y + d * _),
                    (i[8] = u * g + p * x + d * w),
                    this
                  );
                },
                multiplyScalar: function (t) {
                  var e = this.elements;
                  return (
                    (e[0] *= t),
                    (e[3] *= t),
                    (e[6] *= t),
                    (e[1] *= t),
                    (e[4] *= t),
                    (e[7] *= t),
                    (e[2] *= t),
                    (e[5] *= t),
                    (e[8] *= t),
                    this
                  );
                },
                determinant: function () {
                  var t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    i = t[3],
                    a = t[4],
                    o = t[5],
                    s = t[6],
                    c = t[7],
                    h = t[8];
                  return (
                    e * a * h -
                    e * o * c -
                    n * i * h +
                    n * o * s +
                    r * i * c -
                    r * a * s
                  );
                },
                getInverse: function (t, e) {
                  t &&
                    t.isMatrix4 &&
                    console.error(
                      "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
                    );
                  var n = t.elements,
                    r = this.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    c = n[4],
                    h = n[5],
                    l = n[6],
                    u = n[7],
                    p = n[8],
                    d = p * c - h * u,
                    f = h * l - p * s,
                    m = u * s - c * l,
                    g = i * d + a * f + o * m;
                  if (0 === g) {
                    var v =
                      "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === e) throw new Error(v);
                    return console.warn(v), this.identity();
                  }
                  var y = 1 / g;
                  return (
                    (r[0] = d * y),
                    (r[1] = (o * u - p * a) * y),
                    (r[2] = (h * a - o * c) * y),
                    (r[3] = f * y),
                    (r[4] = (p * i - o * l) * y),
                    (r[5] = (o * s - h * i) * y),
                    (r[6] = m * y),
                    (r[7] = (a * l - u * i) * y),
                    (r[8] = (c * i - a * s) * y),
                    this
                  );
                },
                transpose: function () {
                  var t,
                    e = this.elements;
                  return (
                    (t = e[1]),
                    (e[1] = e[3]),
                    (e[3] = t),
                    (t = e[2]),
                    (e[2] = e[6]),
                    (e[6] = t),
                    (t = e[5]),
                    (e[5] = e[7]),
                    (e[7] = t),
                    this
                  );
                },
                getNormalMatrix: function (t) {
                  return this.setFromMatrix4(t).getInverse(this).transpose();
                },
                transposeIntoArray: function (t) {
                  var e = this.elements;
                  return (
                    (t[0] = e[0]),
                    (t[1] = e[3]),
                    (t[2] = e[6]),
                    (t[3] = e[1]),
                    (t[4] = e[4]),
                    (t[5] = e[7]),
                    (t[6] = e[2]),
                    (t[7] = e[5]),
                    (t[8] = e[8]),
                    this
                  );
                },
                setUvTransform: function (t, e, n, r, i, a, o) {
                  var s = Math.cos(i),
                    c = Math.sin(i);
                  this.set(
                    n * s,
                    n * c,
                    -n * (s * a + c * o) + a + t,
                    -r * c,
                    r * s,
                    -r * (-c * a + s * o) + o + e,
                    0,
                    0,
                    1
                  );
                },
                scale: function (t, e) {
                  var n = this.elements;
                  return (
                    (n[0] *= t),
                    (n[3] *= t),
                    (n[6] *= t),
                    (n[1] *= e),
                    (n[4] *= e),
                    (n[7] *= e),
                    this
                  );
                },
                rotate: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t),
                    r = this.elements,
                    i = r[0],
                    a = r[3],
                    o = r[6],
                    s = r[1],
                    c = r[4],
                    h = r[7];
                  return (
                    (r[0] = e * i + n * s),
                    (r[3] = e * a + n * c),
                    (r[6] = e * o + n * h),
                    (r[1] = -n * i + e * s),
                    (r[4] = -n * a + e * c),
                    (r[7] = -n * o + e * h),
                    this
                  );
                },
                translate: function (t, e) {
                  var n = this.elements;
                  return (
                    (n[0] += t * n[2]),
                    (n[3] += t * n[5]),
                    (n[6] += t * n[8]),
                    (n[1] += e * n[2]),
                    (n[4] += e * n[5]),
                    (n[7] += e * n[8]),
                    this
                  );
                },
                equals: function (t) {
                  for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
                    if (e[r] !== n[r]) return !1;
                  return !0;
                },
                fromArray: function (t, e) {
                  void 0 === e && (e = 0);
                  for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                  return this;
                },
                toArray: function (t, e) {
                  void 0 === t && (t = []), void 0 === e && (e = 0);
                  var n = this.elements;
                  return (
                    (t[e] = n[0]),
                    (t[e + 1] = n[1]),
                    (t[e + 2] = n[2]),
                    (t[e + 3] = n[3]),
                    (t[e + 4] = n[4]),
                    (t[e + 5] = n[5]),
                    (t[e + 6] = n[6]),
                    (t[e + 7] = n[7]),
                    (t[e + 8] = n[8]),
                    t
                  );
                },
              });
            var bc = {
                getDataURL: function (t) {
                  var e;
                  if (t instanceof HTMLCanvasElement) e = t;
                  else {
                    "undefined" != typeof OffscreenCanvas
                      ? (e = new OffscreenCanvas(t.width, t.height))
                      : ((e = document.createElementNS(
                          "http://www.w3.org/1999/xhtml",
                          "canvas"
                        )),
                        (e.width = t.width),
                        (e.height = t.height));
                    var n = e.getContext("2d");
                    t instanceof ImageData
                      ? n.putImageData(t, 0, 0)
                      : n.drawImage(t, 0, 0, t.width, t.height);
                  }
                  return e.width > 2048 || e.height > 2048
                    ? e.toDataURL("image/jpeg", 0.6)
                    : e.toDataURL("image/png");
                },
              },
              _c = 0;
            (s.DEFAULT_IMAGE = void 0),
              (s.DEFAULT_MAPPING = 300),
              (s.prototype = Object.assign(Object.create(e.prototype), {
                constructor: s,
                isTexture: !0,
                updateMatrix: function () {
                  this.matrix.setUvTransform(
                    this.offset.x,
                    this.offset.y,
                    this.repeat.x,
                    this.repeat.y,
                    this.rotation,
                    this.center.x,
                    this.center.y
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    (this.name = t.name),
                    (this.image = t.image),
                    (this.mipmaps = t.mipmaps.slice(0)),
                    (this.mapping = t.mapping),
                    (this.wrapS = t.wrapS),
                    (this.wrapT = t.wrapT),
                    (this.magFilter = t.magFilter),
                    (this.minFilter = t.minFilter),
                    (this.anisotropy = t.anisotropy),
                    (this.format = t.format),
                    (this.type = t.type),
                    this.offset.copy(t.offset),
                    this.repeat.copy(t.repeat),
                    this.center.copy(t.center),
                    (this.rotation = t.rotation),
                    (this.matrixAutoUpdate = t.matrixAutoUpdate),
                    this.matrix.copy(t.matrix),
                    (this.generateMipmaps = t.generateMipmaps),
                    (this.premultiplyAlpha = t.premultiplyAlpha),
                    (this.flipY = t.flipY),
                    (this.unpackAlignment = t.unpackAlignment),
                    (this.encoding = t.encoding),
                    this
                  );
                },
                toJSON: function (t) {
                  var e = void 0 === t || "string" == typeof t;
                  if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                  var n = {
                    metadata: {
                      version: 4.5,
                      type: "Texture",
                      generator: "Texture.toJSON",
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                  };
                  if (void 0 !== this.image) {
                    var r = this.image;
                    if (
                      (void 0 === r.uuid && (r.uuid = xc.generateUUID()),
                      !e && void 0 === t.images[r.uuid])
                    ) {
                      var i;
                      if (Array.isArray(r)) {
                        i = [];
                        for (var a = 0, o = r.length; a < o; a++)
                          i.push(bc.getDataURL(r[a]));
                      } else i = bc.getDataURL(r);
                      t.images[r.uuid] = { uuid: r.uuid, url: i };
                    }
                    n.image = r.uuid;
                  }
                  return e || (t.textures[this.uuid] = n), n;
                },
                dispose: function () {
                  this.dispatchEvent({ type: "dispose" });
                },
                transformUv: function (t) {
                  if (300 === this.mapping) {
                    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                      switch (this.wrapS) {
                        case as:
                          t.x = t.x - Math.floor(t.x);
                          break;
                        case os:
                          t.x = t.x < 0 ? 0 : 1;
                          break;
                        case ss:
                          1 === Math.abs(Math.floor(t.x) % 2)
                            ? (t.x = Math.ceil(t.x) - t.x)
                            : (t.x = t.x - Math.floor(t.x));
                      }
                    if (t.y < 0 || t.y > 1)
                      switch (this.wrapT) {
                        case as:
                          t.y = t.y - Math.floor(t.y);
                          break;
                        case os:
                          t.y = t.y < 0 ? 0 : 1;
                          break;
                        case ss:
                          1 === Math.abs(Math.floor(t.y) % 2)
                            ? (t.y = Math.ceil(t.y) - t.y)
                            : (t.y = t.y - Math.floor(t.y));
                      }
                    this.flipY && (t.y = 1 - t.y);
                  }
                },
              })),
              Object.defineProperty(s.prototype, "needsUpdate", {
                set: function (t) {
                  !0 === t && this.version++;
                },
              }),
              Object.assign(c.prototype, {
                isVector4: !0,
                set: function (t, e, n, r) {
                  return (
                    (this.x = t), (this.y = e), (this.z = n), (this.w = r), this
                  );
                },
                setScalar: function (t) {
                  return (
                    (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
                  );
                },
                setX: function (t) {
                  return (this.x = t), this;
                },
                setY: function (t) {
                  return (this.y = t), this;
                },
                setZ: function (t) {
                  return (this.z = t), this;
                },
                setW: function (t) {
                  return (this.w = t), this;
                },
                setComponent: function (t, e) {
                  switch (t) {
                    case 0:
                      this.x = e;
                      break;
                    case 1:
                      this.y = e;
                      break;
                    case 2:
                      this.z = e;
                      break;
                    case 3:
                      this.w = e;
                      break;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                  return this;
                },
                getComponent: function (t) {
                  switch (t) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    case 3:
                      return this.w;
                    default:
                      throw new Error("index is out of range: " + t);
                  }
                },
                clone: function () {
                  return new this.constructor(this.x, this.y, this.z, this.w);
                },
                copy: function (t) {
                  return (
                    (this.x = t.x),
                    (this.y = t.y),
                    (this.z = t.z),
                    (this.w = void 0 !== t.w ? t.w : 1),
                    this
                  );
                },
                add: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                      ),
                      this.addVectors(t, e))
                    : ((this.x += t.x),
                      (this.y += t.y),
                      (this.z += t.z),
                      (this.w += t.w),
                      this);
                },
                addScalar: function (t) {
                  return (
                    (this.x += t),
                    (this.y += t),
                    (this.z += t),
                    (this.w += t),
                    this
                  );
                },
                addVectors: function (t, e) {
                  return (
                    (this.x = t.x + e.x),
                    (this.y = t.y + e.y),
                    (this.z = t.z + e.z),
                    (this.w = t.w + e.w),
                    this
                  );
                },
                addScaledVector: function (t, e) {
                  return (
                    (this.x += t.x * e),
                    (this.y += t.y * e),
                    (this.z += t.z * e),
                    (this.w += t.w * e),
                    this
                  );
                },
                sub: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                      ),
                      this.subVectors(t, e))
                    : ((this.x -= t.x),
                      (this.y -= t.y),
                      (this.z -= t.z),
                      (this.w -= t.w),
                      this);
                },
                subScalar: function (t) {
                  return (
                    (this.x -= t),
                    (this.y -= t),
                    (this.z -= t),
                    (this.w -= t),
                    this
                  );
                },
                subVectors: function (t, e) {
                  return (
                    (this.x = t.x - e.x),
                    (this.y = t.y - e.y),
                    (this.z = t.z - e.z),
                    (this.w = t.w - e.w),
                    this
                  );
                },
                multiplyScalar: function (t) {
                  return (
                    (this.x *= t),
                    (this.y *= t),
                    (this.z *= t),
                    (this.w *= t),
                    this
                  );
                },
                applyMatrix4: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    a = t.elements;
                  return (
                    (this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i),
                    (this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i),
                    (this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i),
                    (this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i),
                    this
                  );
                },
                divideScalar: function (t) {
                  return this.multiplyScalar(1 / t);
                },
                setAxisAngleFromQuaternion: function (t) {
                  this.w = 2 * Math.acos(t.w);
                  var e = Math.sqrt(1 - t.w * t.w);
                  return (
                    e < 1e-4
                      ? ((this.x = 1), (this.y = 0), (this.z = 0))
                      : ((this.x = t.x / e),
                        (this.y = t.y / e),
                        (this.z = t.z / e)),
                    this
                  );
                },
                setAxisAngleFromRotationMatrix: function (t) {
                  var e,
                    n,
                    r,
                    i,
                    a = t.elements,
                    o = a[0],
                    s = a[4],
                    c = a[8],
                    h = a[1],
                    l = a[5],
                    u = a[9],
                    p = a[2],
                    d = a[6],
                    f = a[10];
                  if (
                    Math.abs(s - h) < 0.01 &&
                    Math.abs(c - p) < 0.01 &&
                    Math.abs(u - d) < 0.01
                  ) {
                    if (
                      Math.abs(s + h) < 0.1 &&
                      Math.abs(c + p) < 0.1 &&
                      Math.abs(u + d) < 0.1 &&
                      Math.abs(o + l + f - 3) < 0.1
                    )
                      return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var m = (o + 1) / 2,
                      g = (l + 1) / 2,
                      v = (f + 1) / 2,
                      y = (s + h) / 4,
                      x = (c + p) / 4,
                      b = (u + d) / 4;
                    return (
                      m > g && m > v
                        ? m < 0.01
                          ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                          : ((n = Math.sqrt(m)), (r = y / n), (i = x / n))
                        : g > v
                        ? g < 0.01
                          ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                          : ((r = Math.sqrt(g)), (n = y / r), (i = b / r))
                        : v < 0.01
                        ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                        : ((i = Math.sqrt(v)), (n = x / i), (r = b / i)),
                      this.set(n, r, i, e),
                      this
                    );
                  }
                  var _ = Math.sqrt(
                    (d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s)
                  );
                  return (
                    Math.abs(_) < 0.001 && (_ = 1),
                    (this.x = (d - u) / _),
                    (this.y = (c - p) / _),
                    (this.z = (h - s) / _),
                    (this.w = Math.acos((o + l + f - 1) / 2)),
                    this
                  );
                },
                min: function (t) {
                  return (
                    (this.x = Math.min(this.x, t.x)),
                    (this.y = Math.min(this.y, t.y)),
                    (this.z = Math.min(this.z, t.z)),
                    (this.w = Math.min(this.w, t.w)),
                    this
                  );
                },
                max: function (t) {
                  return (
                    (this.x = Math.max(this.x, t.x)),
                    (this.y = Math.max(this.y, t.y)),
                    (this.z = Math.max(this.z, t.z)),
                    (this.w = Math.max(this.w, t.w)),
                    this
                  );
                },
                clamp: function (t, e) {
                  return (
                    (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                    (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                    (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                    (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                    this
                  );
                },
                clampScalar: (function () {
                  var t, e;
                  return function (n, r) {
                    return (
                      void 0 === t && ((t = new c()), (e = new c())),
                      t.set(n, n, n, n),
                      e.set(r, r, r, r),
                      this.clamp(t, e)
                    );
                  };
                })(),
                clampLength: function (t, e) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(t, Math.min(e, n))
                  );
                },
                floor: function () {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    (this.z = Math.floor(this.z)),
                    (this.w = Math.floor(this.w)),
                    this
                  );
                },
                ceil: function () {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    (this.z = Math.ceil(this.z)),
                    (this.w = Math.ceil(this.w)),
                    this
                  );
                },
                round: function () {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    (this.z = Math.round(this.z)),
                    (this.w = Math.round(this.w)),
                    this
                  );
                },
                roundToZero: function () {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    (this.z =
                      this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                    (this.w =
                      this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                    this
                  );
                },
                negate: function () {
                  return (
                    (this.x = -this.x),
                    (this.y = -this.y),
                    (this.z = -this.z),
                    (this.w = -this.w),
                    this
                  );
                },
                dot: function (t) {
                  return (
                    this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                  );
                },
                lengthSq: function () {
                  return (
                    this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                  );
                },
                length: function () {
                  return Math.sqrt(
                    this.x * this.x +
                      this.y * this.y +
                      this.z * this.z +
                      this.w * this.w
                  );
                },
                manhattanLength: function () {
                  return (
                    Math.abs(this.x) +
                    Math.abs(this.y) +
                    Math.abs(this.z) +
                    Math.abs(this.w)
                  );
                },
                normalize: function () {
                  return this.divideScalar(this.length() || 1);
                },
                setLength: function (t) {
                  return this.normalize().multiplyScalar(t);
                },
                lerp: function (t, e) {
                  return (
                    (this.x += (t.x - this.x) * e),
                    (this.y += (t.y - this.y) * e),
                    (this.z += (t.z - this.z) * e),
                    (this.w += (t.w - this.w) * e),
                    this
                  );
                },
                lerpVectors: function (t, e, n) {
                  return this.subVectors(e, t).multiplyScalar(n).add(t);
                },
                equals: function (t) {
                  return (
                    t.x === this.x &&
                    t.y === this.y &&
                    t.z === this.z &&
                    t.w === this.w
                  );
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this.x = t[e]),
                    (this.y = t[e + 1]),
                    (this.z = t[e + 2]),
                    (this.w = t[e + 3]),
                    this
                  );
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this.x),
                    (t[e + 1] = this.y),
                    (t[e + 2] = this.z),
                    (t[e + 3] = this.w),
                    t
                  );
                },
                fromBufferAttribute: function (t, e, n) {
                  return (
                    void 0 !== n &&
                      console.warn(
                        "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                      ),
                    (this.x = t.getX(e)),
                    (this.y = t.getY(e)),
                    (this.z = t.getZ(e)),
                    (this.w = t.getW(e)),
                    this
                  );
                },
              }),
              (h.prototype = Object.assign(Object.create(e.prototype), {
                constructor: h,
                isWebGLRenderTarget: !0,
                setSize: function (t, e) {
                  (this.width === t && this.height === e) ||
                    ((this.width = t), (this.height = e), this.dispose()),
                    this.viewport.set(0, 0, t, e),
                    this.scissor.set(0, 0, t, e);
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    (this.width = t.width),
                    (this.height = t.height),
                    this.viewport.copy(t.viewport),
                    (this.texture = t.texture.clone()),
                    (this.depthBuffer = t.depthBuffer),
                    (this.stencilBuffer = t.stencilBuffer),
                    (this.depthTexture = t.depthTexture),
                    this
                  );
                },
                dispose: function () {
                  this.dispatchEvent({ type: "dispose" });
                },
              })),
              (l.prototype = Object.create(h.prototype)),
              (l.prototype.constructor = l),
              (l.prototype.isWebGLRenderTargetCube = !0),
              (u.prototype = Object.create(s.prototype)),
              (u.prototype.constructor = u),
              (u.prototype.isDataTexture = !0),
              Object.assign(p.prototype, {
                isBox3: !0,
                set: function (t, e) {
                  return this.min.copy(t), this.max.copy(e), this;
                },
                setFromArray: function (t) {
                  for (
                    var e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      c = t.length;
                    s < c;
                    s += 3
                  ) {
                    var h = t[s],
                      l = t[s + 1],
                      u = t[s + 2];
                    h < e && (e = h),
                      l < n && (n = l),
                      u < r && (r = u),
                      h > i && (i = h),
                      l > a && (a = l),
                      u > o && (o = u);
                  }
                  return this.min.set(e, n, r), this.max.set(i, a, o), this;
                },
                setFromBufferAttribute: function (t) {
                  for (
                    var e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      c = t.count;
                    s < c;
                    s++
                  ) {
                    var h = t.getX(s),
                      l = t.getY(s),
                      u = t.getZ(s);
                    h < e && (e = h),
                      l < n && (n = l),
                      u < r && (r = u),
                      h > i && (i = h),
                      l > a && (a = l),
                      u > o && (o = u);
                  }
                  return this.min.set(e, n, r), this.max.set(i, a, o), this;
                },
                setFromPoints: function (t) {
                  this.makeEmpty();
                  for (var e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                  return this;
                },
                setFromCenterAndSize: (function () {
                  var t = new a();
                  return function (e, n) {
                    var r = t.copy(n).multiplyScalar(0.5);
                    return (
                      this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                    );
                  };
                })(),
                setFromObject: function (t) {
                  return this.makeEmpty(), this.expandByObject(t);
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return this.min.copy(t.min), this.max.copy(t.max), this;
                },
                makeEmpty: function () {
                  return (
                    (this.min.x = this.min.y = this.min.z = 1 / 0),
                    (this.max.x = this.max.y = this.max.z = -1 / 0),
                    this
                  );
                },
                isEmpty: function () {
                  return (
                    this.max.x < this.min.x ||
                    this.max.y < this.min.y ||
                    this.max.z < this.min.z
                  );
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Box3: .getCenter() target is now required"
                      ),
                      (t = new a())),
                    this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
                  );
                },
                getSize: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Box3: .getSize() target is now required"
                      ),
                      (t = new a())),
                    this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.subVectors(this.max, this.min)
                  );
                },
                expandByPoint: function (t) {
                  return this.min.min(t), this.max.max(t), this;
                },
                expandByVector: function (t) {
                  return this.min.sub(t), this.max.add(t), this;
                },
                expandByScalar: function (t) {
                  return this.min.addScalar(-t), this.max.addScalar(t), this;
                },
                expandByObject: (function () {
                  function t(t) {
                    var a = t.geometry;
                    if (void 0 !== a)
                      if (a.isGeometry) {
                        var o = a.vertices;
                        for (n = 0, r = o.length; n < r; n++)
                          i.copy(o[n]),
                            i.applyMatrix4(t.matrixWorld),
                            e.expandByPoint(i);
                      } else if (a.isBufferGeometry) {
                        var s = a.attributes.position;
                        if (void 0 !== s)
                          for (n = 0, r = s.count; n < r; n++)
                            i
                              .fromBufferAttribute(s, n)
                              .applyMatrix4(t.matrixWorld),
                              e.expandByPoint(i);
                      }
                  }
                  var e,
                    n,
                    r,
                    i = new a();
                  return function (n) {
                    return (
                      (e = this), n.updateMatrixWorld(!0), n.traverse(t), this
                    );
                  };
                })(),
                containsPoint: function (t) {
                  return !(
                    t.x < this.min.x ||
                    t.x > this.max.x ||
                    t.y < this.min.y ||
                    t.y > this.max.y ||
                    t.z < this.min.z ||
                    t.z > this.max.z
                  );
                },
                containsBox: function (t) {
                  return (
                    this.min.x <= t.min.x &&
                    t.max.x <= this.max.x &&
                    this.min.y <= t.min.y &&
                    t.max.y <= this.max.y &&
                    this.min.z <= t.min.z &&
                    t.max.z <= this.max.z
                  );
                },
                getParameter: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Box3: .getParameter() target is now required"
                      ),
                      (e = new a())),
                    e.set(
                      (t.x - this.min.x) / (this.max.x - this.min.x),
                      (t.y - this.min.y) / (this.max.y - this.min.y),
                      (t.z - this.min.z) / (this.max.z - this.min.z)
                    )
                  );
                },
                intersectsBox: function (t) {
                  return !(
                    t.max.x < this.min.x ||
                    t.min.x > this.max.x ||
                    t.max.y < this.min.y ||
                    t.min.y > this.max.y ||
                    t.max.z < this.min.z ||
                    t.min.z > this.max.z
                  );
                },
                intersectsSphere: (function () {
                  var t = new a();
                  return function (e) {
                    return (
                      this.clampPoint(e.center, t),
                      t.distanceToSquared(e.center) <= e.radius * e.radius
                    );
                  };
                })(),
                intersectsPlane: function (t) {
                  var e, n;
                  return (
                    t.normal.x > 0
                      ? ((e = t.normal.x * this.min.x),
                        (n = t.normal.x * this.max.x))
                      : ((e = t.normal.x * this.max.x),
                        (n = t.normal.x * this.min.x)),
                    t.normal.y > 0
                      ? ((e += t.normal.y * this.min.y),
                        (n += t.normal.y * this.max.y))
                      : ((e += t.normal.y * this.max.y),
                        (n += t.normal.y * this.min.y)),
                    t.normal.z > 0
                      ? ((e += t.normal.z * this.min.z),
                        (n += t.normal.z * this.max.z))
                      : ((e += t.normal.z * this.max.z),
                        (n += t.normal.z * this.min.z)),
                    e <= t.constant && n >= t.constant
                  );
                },
                intersectsTriangle: (function () {
                  function t(t) {
                    var i, a;
                    for (i = 0, a = t.length - 3; i <= a; i += 3) {
                      c.fromArray(t, i);
                      var o =
                          l.x * Math.abs(c.x) +
                          l.y * Math.abs(c.y) +
                          l.z * Math.abs(c.z),
                        s = e.dot(c),
                        h = n.dot(c),
                        u = r.dot(c);
                      if (Math.max(-Math.max(s, h, u), Math.min(s, h, u)) > o)
                        return !1;
                    }
                    return !0;
                  }
                  var e = new a(),
                    n = new a(),
                    r = new a(),
                    i = new a(),
                    o = new a(),
                    s = new a(),
                    c = new a(),
                    h = new a(),
                    l = new a(),
                    u = new a();
                  return function (a) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(h),
                      l.subVectors(this.max, h),
                      e.subVectors(a.a, h),
                      n.subVectors(a.b, h),
                      r.subVectors(a.c, h),
                      i.subVectors(n, e),
                      o.subVectors(r, n),
                      s.subVectors(e, r);
                    var c = [
                      0,
                      -i.z,
                      i.y,
                      0,
                      -o.z,
                      o.y,
                      0,
                      -s.z,
                      s.y,
                      i.z,
                      0,
                      -i.x,
                      o.z,
                      0,
                      -o.x,
                      s.z,
                      0,
                      -s.x,
                      -i.y,
                      i.x,
                      0,
                      -o.y,
                      o.x,
                      0,
                      -s.y,
                      s.x,
                      0,
                    ];
                    return (
                      !!t(c) &&
                      ((c = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                      !!t(c) &&
                        (u.crossVectors(i, o), (c = [u.x, u.y, u.z]), t(c)))
                    );
                  };
                })(),
                clampPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Box3: .clampPoint() target is now required"
                      ),
                      (e = new a())),
                    e.copy(t).clamp(this.min, this.max)
                  );
                },
                distanceToPoint: (function () {
                  var t = new a();
                  return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length();
                  };
                })(),
                getBoundingSphere: (function () {
                  var t = new a();
                  return function (e) {
                    return (
                      void 0 === e &&
                        (console.warn(
                          "THREE.Box3: .getBoundingSphere() target is now required"
                        ),
                        (e = new d())),
                      this.getCenter(e.center),
                      (e.radius = 0.5 * this.getSize(t).length()),
                      e
                    );
                  };
                })(),
                intersect: function (t) {
                  return (
                    this.min.max(t.min),
                    this.max.min(t.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                  );
                },
                union: function (t) {
                  return this.min.min(t.min), this.max.max(t.max), this;
                },
                applyMatrix4: function (t) {
                  if (this.isEmpty()) return this;
                  var e = t.elements,
                    n = e[0] * this.min.x,
                    r = e[1] * this.min.x,
                    i = e[2] * this.min.x,
                    a = e[0] * this.max.x,
                    o = e[1] * this.max.x,
                    s = e[2] * this.max.x,
                    c = e[4] * this.min.y,
                    h = e[5] * this.min.y,
                    l = e[6] * this.min.y,
                    u = e[4] * this.max.y,
                    p = e[5] * this.max.y,
                    d = e[6] * this.max.y,
                    f = e[8] * this.min.z,
                    m = e[9] * this.min.z,
                    g = e[10] * this.min.z,
                    v = e[8] * this.max.z,
                    y = e[9] * this.max.z,
                    x = e[10] * this.max.z;
                  return (
                    (this.min.x =
                      Math.min(n, a) + Math.min(c, u) + Math.min(f, v) + e[12]),
                    (this.min.y =
                      Math.min(r, o) + Math.min(h, p) + Math.min(m, y) + e[13]),
                    (this.min.z =
                      Math.min(i, s) + Math.min(l, d) + Math.min(g, x) + e[14]),
                    (this.max.x =
                      Math.max(n, a) + Math.max(c, u) + Math.max(f, v) + e[12]),
                    (this.max.y =
                      Math.max(r, o) + Math.max(h, p) + Math.max(m, y) + e[13]),
                    (this.max.z =
                      Math.max(i, s) + Math.max(l, d) + Math.max(g, x) + e[14]),
                    this
                  );
                },
                translate: function (t) {
                  return this.min.add(t), this.max.add(t), this;
                },
                equals: function (t) {
                  return t.min.equals(this.min) && t.max.equals(this.max);
                },
              }),
              Object.assign(d.prototype, {
                set: function (t, e) {
                  return this.center.copy(t), (this.radius = e), this;
                },
                setFromPoints: (function () {
                  var t = new p();
                  return function (e, n) {
                    var r = this.center;
                    void 0 !== n ? r.copy(n) : t.setFromPoints(e).getCenter(r);
                    for (var i = 0, a = 0, o = e.length; a < o; a++)
                      i = Math.max(i, r.distanceToSquared(e[a]));
                    return (this.radius = Math.sqrt(i)), this;
                  };
                })(),
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    this.center.copy(t.center), (this.radius = t.radius), this
                  );
                },
                empty: function () {
                  return this.radius <= 0;
                },
                containsPoint: function (t) {
                  return (
                    t.distanceToSquared(this.center) <=
                    this.radius * this.radius
                  );
                },
                distanceToPoint: function (t) {
                  return t.distanceTo(this.center) - this.radius;
                },
                intersectsSphere: function (t) {
                  var e = this.radius + t.radius;
                  return t.center.distanceToSquared(this.center) <= e * e;
                },
                intersectsBox: function (t) {
                  return t.intersectsSphere(this);
                },
                intersectsPlane: function (t) {
                  return (
                    Math.abs(t.distanceToPoint(this.center)) <= this.radius
                  );
                },
                clampPoint: function (t, e) {
                  var n = this.center.distanceToSquared(t);
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Sphere: .clampPoint() target is now required"
                      ),
                      (e = new a())),
                    e.copy(t),
                    n > this.radius * this.radius &&
                      (e.sub(this.center).normalize(),
                      e.multiplyScalar(this.radius).add(this.center)),
                    e
                  );
                },
                getBoundingBox: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Sphere: .getBoundingBox() target is now required"
                      ),
                      (t = new p())),
                    t.set(this.center, this.center),
                    t.expandByScalar(this.radius),
                    t
                  );
                },
                applyMatrix4: function (t) {
                  return (
                    this.center.applyMatrix4(t),
                    (this.radius = this.radius * t.getMaxScaleOnAxis()),
                    this
                  );
                },
                translate: function (t) {
                  return this.center.add(t), this;
                },
                equals: function (t) {
                  return (
                    t.center.equals(this.center) && t.radius === this.radius
                  );
                },
              }),
              Object.assign(f.prototype, {
                set: function (t, e) {
                  return this.normal.copy(t), (this.constant = e), this;
                },
                setComponents: function (t, e, n, r) {
                  return this.normal.set(t, e, n), (this.constant = r), this;
                },
                setFromNormalAndCoplanarPoint: function (t, e) {
                  return (
                    this.normal.copy(t),
                    (this.constant = -e.dot(this.normal)),
                    this
                  );
                },
                setFromCoplanarPoints: (function () {
                  var t = new a(),
                    e = new a();
                  return function (n, r, i) {
                    var a = t
                      .subVectors(i, r)
                      .cross(e.subVectors(n, r))
                      .normalize();
                    return this.setFromNormalAndCoplanarPoint(a, n), this;
                  };
                })(),
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    this.normal.copy(t.normal),
                    (this.constant = t.constant),
                    this
                  );
                },
                normalize: function () {
                  var t = 1 / this.normal.length();
                  return (
                    this.normal.multiplyScalar(t), (this.constant *= t), this
                  );
                },
                negate: function () {
                  return (this.constant *= -1), this.normal.negate(), this;
                },
                distanceToPoint: function (t) {
                  return this.normal.dot(t) + this.constant;
                },
                distanceToSphere: function (t) {
                  return this.distanceToPoint(t.center) - t.radius;
                },
                projectPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Plane: .projectPoint() target is now required"
                      ),
                      (e = new a())),
                    e
                      .copy(this.normal)
                      .multiplyScalar(-this.distanceToPoint(t))
                      .add(t)
                  );
                },
                intersectLine: (function () {
                  var t = new a();
                  return function (e, n) {
                    void 0 === n &&
                      (console.warn(
                        "THREE.Plane: .intersectLine() target is now required"
                      ),
                      (n = new a()));
                    var r = e.delta(t),
                      i = this.normal.dot(r);
                    if (0 !== i) {
                      var o = -(e.start.dot(this.normal) + this.constant) / i;
                      if (!(o < 0 || o > 1))
                        return n.copy(r).multiplyScalar(o).add(e.start);
                    } else if (0 === this.distanceToPoint(e.start))
                      return n.copy(e.start);
                  };
                })(),
                intersectsLine: function (t) {
                  var e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                  return (e < 0 && n > 0) || (n < 0 && e > 0);
                },
                intersectsBox: function (t) {
                  return t.intersectsPlane(this);
                },
                intersectsSphere: function (t) {
                  return t.intersectsPlane(this);
                },
                coplanarPoint: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Plane: .coplanarPoint() target is now required"
                      ),
                      (t = new a())),
                    t.copy(this.normal).multiplyScalar(-this.constant)
                  );
                },
                applyMatrix4: (function () {
                  var t = new a(),
                    e = new o();
                  return function (n, r) {
                    var i = r || e.getNormalMatrix(n),
                      a = this.coplanarPoint(t).applyMatrix4(n),
                      o = this.normal.applyMatrix3(i).normalize();
                    return (this.constant = -a.dot(o)), this;
                  };
                })(),
                translate: function (t) {
                  return (this.constant -= t.dot(this.normal)), this;
                },
                equals: function (t) {
                  return (
                    t.normal.equals(this.normal) && t.constant === this.constant
                  );
                },
              }),
              Object.assign(m.prototype, {
                set: function (t, e, n, r, i, a) {
                  var o = this.planes;
                  return (
                    o[0].copy(t),
                    o[1].copy(e),
                    o[2].copy(n),
                    o[3].copy(r),
                    o[4].copy(i),
                    o[5].copy(a),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  for (var e = this.planes, n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                  return this;
                },
                setFromMatrix: function (t) {
                  var e = this.planes,
                    n = t.elements,
                    r = n[0],
                    i = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    c = n[5],
                    h = n[6],
                    l = n[7],
                    u = n[8],
                    p = n[9],
                    d = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = n[15];
                  return (
                    e[0].setComponents(o - r, l - s, f - u, y - m).normalize(),
                    e[1].setComponents(o + r, l + s, f + u, y + m).normalize(),
                    e[2].setComponents(o + i, l + c, f + p, y + g).normalize(),
                    e[3].setComponents(o - i, l - c, f - p, y - g).normalize(),
                    e[4].setComponents(o - a, l - h, f - d, y - v).normalize(),
                    e[5].setComponents(o + a, l + h, f + d, y + v).normalize(),
                    this
                  );
                },
                intersectsObject: (function () {
                  var t = new d();
                  return function (e) {
                    var n = e.geometry;
                    return (
                      null === n.boundingSphere && n.computeBoundingSphere(),
                      t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
                      this.intersectsSphere(t)
                    );
                  };
                })(),
                intersectsSprite: (function () {
                  var t = new d();
                  return function (e) {
                    return (
                      t.center.set(0, 0, 0),
                      (t.radius = 0.7071067811865476),
                      t.applyMatrix4(e.matrixWorld),
                      this.intersectsSphere(t)
                    );
                  };
                })(),
                intersectsSphere: function (t) {
                  for (
                    var e = this.planes, n = t.center, r = -t.radius, i = 0;
                    i < 6;
                    i++
                  ) {
                    if (e[i].distanceToPoint(n) < r) return !1;
                  }
                  return !0;
                },
                intersectsBox: (function () {
                  var t = new a();
                  return function (e) {
                    for (var n = this.planes, r = 0; r < 6; r++) {
                      var i = n[r];
                      if (
                        ((t.x = i.normal.x > 0 ? e.max.x : e.min.x),
                        (t.y = i.normal.y > 0 ? e.max.y : e.min.y),
                        (t.z = i.normal.z > 0 ? e.max.z : e.min.z),
                        i.distanceToPoint(t) < 0)
                      )
                        return !1;
                    }
                    return !0;
                  };
                })(),
                containsPoint: function (t) {
                  for (var e = this.planes, n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                  return !0;
                },
              });
            var wc = {
                alphamap_fragment:
                  "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment:
                  "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment:
                  "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment:
                  "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment:
                  "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs:
                  "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment:
                  "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment:
                  "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment:
                  "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex:
                  "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex:
                  "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment:
                  "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment:
                  "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex:
                  "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex:
                  "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common:
                  "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                cube_uv_reflection_fragment:
                  "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex:
                  "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                displacementmap_pars_vertex:
                  "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex:
                  "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment:
                  "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment:
                  "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment:
                  "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment:
                  "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment:
                  "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment:
                  "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex:
                  "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_physical_pars_fragment:
                  "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                envmap_vertex:
                  "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex:
                  "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex:
                  "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment:
                  "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment:
                  "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment:
                  "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment:
                  "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment:
                  "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex:
                  "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars_begin:
                  "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
                lights_phong_fragment:
                  "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment:
                  "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment:
                  "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment:
                  "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_fragment_begin:
                  "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
                lights_fragment_maps:
                  "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
                lights_fragment_end:
                  "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment:
                  "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment:
                  "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex:
                  "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex:
                  "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment:
                  "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment:
                  "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment:
                  "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment:
                  "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment:
                  "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment:
                  "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex:
                  "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex:
                  "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex:
                  "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_fragment_begin:
                  "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
                normal_fragment_maps:
                  "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment:
                  "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
                packing:
                  "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment:
                  "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex:
                  "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment:
                  "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment:
                  "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment:
                  "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment:
                  "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment:
                  "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex:
                  "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex:
                  "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment:
                  "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex:
                  "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex:
                  "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex:
                  "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                skinnormal_vertex:
                  "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment:
                  "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment:
                  "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment:
                  "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment:
                  "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment:
                  "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex:
                  "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                uv_vertex:
                  "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment:
                  "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex:
                  "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex:
                  "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex:
                  "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                cube_frag:
                  "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert:
                  "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                depth_frag:
                  "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert:
                  "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag:
                  "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                distanceRGBA_vert:
                  "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                equirect_frag:
                  "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert:
                  "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag:
                  "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert:
                  "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag:
                  "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert:
                  "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag:
                  "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert:
                  "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag:
                  "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert:
                  "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag:
                  "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert:
                  "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag:
                  "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert:
                  "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag:
                  "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert:
                  "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag:
                  "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                shadow_vert:
                  "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                sprite_frag:
                  "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                sprite_vert:
                  "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
              },
              Mc = {
                merge: function (t) {
                  for (var e = {}, n = 0; n < t.length; n++) {
                    var r = this.clone(t[n]);
                    for (var i in r) e[i] = r[i];
                  }
                  return e;
                },
                clone: function (t) {
                  var e = {};
                  for (var n in t) {
                    e[n] = {};
                    for (var r in t[n]) {
                      var i = t[n][r];
                      i &&
                      (i.isColor ||
                        i.isMatrix3 ||
                        i.isMatrix4 ||
                        i.isVector2 ||
                        i.isVector3 ||
                        i.isVector4 ||
                        i.isTexture)
                        ? (e[n][r] = i.clone())
                        : Array.isArray(i)
                        ? (e[n][r] = i.slice())
                        : (e[n][r] = i);
                    }
                  }
                  return e;
                },
              },
              Ec = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074,
              };
            Object.assign(g.prototype, {
              isColor: !0,
              r: 1,
              g: 1,
              b: 1,
              set: function (t) {
                return (
                  t && t.isColor
                    ? this.copy(t)
                    : "number" == typeof t
                    ? this.setHex(t)
                    : "string" == typeof t && this.setStyle(t),
                  this
                );
              },
              setScalar: function (t) {
                return (this.r = t), (this.g = t), (this.b = t), this;
              },
              setHex: function (t) {
                return (
                  (t = Math.floor(t)),
                  (this.r = ((t >> 16) & 255) / 255),
                  (this.g = ((t >> 8) & 255) / 255),
                  (this.b = (255 & t) / 255),
                  this
                );
              },
              setRGB: function (t, e, n) {
                return (this.r = t), (this.g = e), (this.b = n), this;
              },
              setHSL: (function () {
                function t(t, e, n) {
                  return (
                    n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6
                      ? t + 6 * (e - t) * n
                      : n < 0.5
                      ? e
                      : n < 2 / 3
                      ? t + 6 * (e - t) * (2 / 3 - n)
                      : t
                  );
                }
                return function (e, n, r) {
                  if (
                    ((e = xc.euclideanModulo(e, 1)),
                    (n = xc.clamp(n, 0, 1)),
                    (r = xc.clamp(r, 0, 1)),
                    0 === n)
                  )
                    this.r = this.g = this.b = r;
                  else {
                    var i = r <= 0.5 ? r * (1 + n) : r + n - r * n,
                      a = 2 * r - i;
                    (this.r = t(a, i, e + 1 / 3)),
                      (this.g = t(a, i, e)),
                      (this.b = t(a, i, e - 1 / 3));
                  }
                  return this;
                };
              })(),
              setStyle: function (t) {
                function e(e) {
                  void 0 !== e &&
                    parseFloat(e) < 1 &&
                    console.warn(
                      "THREE.Color: Alpha component of " +
                        t +
                        " will be ignored."
                    );
                }
                var n;
                if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
                  var r,
                    i = n[1],
                    a = n[2];
                  switch (i) {
                    case "rgb":
                    case "rgba":
                      if (
                        (r =
                          /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                            a
                          ))
                      )
                        return (
                          (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                          (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                          (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                          e(r[5]),
                          this
                        );
                      if (
                        (r =
                          /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                            a
                          ))
                      )
                        return (
                          (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                          (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                          (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                          e(r[5]),
                          this
                        );
                      break;
                    case "hsl":
                    case "hsla":
                      if (
                        (r =
                          /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                            a
                          ))
                      ) {
                        var o = parseFloat(r[1]) / 360,
                          s = parseInt(r[2], 10) / 100,
                          c = parseInt(r[3], 10) / 100;
                        return e(r[5]), this.setHSL(o, s, c);
                      }
                  }
                } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
                  var h = n[1],
                    l = h.length;
                  if (3 === l)
                    return (
                      (this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255),
                      (this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255),
                      (this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255),
                      this
                    );
                  if (6 === l)
                    return (
                      (this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255),
                      (this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255),
                      (this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255),
                      this
                    );
                }
                if (t && t.length > 0) {
                  var h = Ec[t];
                  void 0 !== h
                    ? this.setHex(h)
                    : console.warn("THREE.Color: Unknown color " + t);
                }
                return this;
              },
              clone: function () {
                return new this.constructor(this.r, this.g, this.b);
              },
              copy: function (t) {
                return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
              },
              copyGammaToLinear: function (t, e) {
                return (
                  void 0 === e && (e = 2),
                  (this.r = Math.pow(t.r, e)),
                  (this.g = Math.pow(t.g, e)),
                  (this.b = Math.pow(t.b, e)),
                  this
                );
              },
              copyLinearToGamma: function (t, e) {
                void 0 === e && (e = 2);
                var n = e > 0 ? 1 / e : 1;
                return (
                  (this.r = Math.pow(t.r, n)),
                  (this.g = Math.pow(t.g, n)),
                  (this.b = Math.pow(t.b, n)),
                  this
                );
              },
              convertGammaToLinear: function (t) {
                return this.copyGammaToLinear(this, t), this;
              },
              convertLinearToGamma: function (t) {
                return this.copyLinearToGamma(this, t), this;
              },
              copySRGBToLinear: (function () {
                function t(t) {
                  return t < 0.04045
                    ? 0.0773993808 * t
                    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
                }
                return function (e) {
                  return (
                    (this.r = t(e.r)),
                    (this.g = t(e.g)),
                    (this.b = t(e.b)),
                    this
                  );
                };
              })(),
              copyLinearToSRGB: (function () {
                function t(t) {
                  return t < 0.0031308
                    ? 12.92 * t
                    : 1.055 * Math.pow(t, 0.41666) - 0.055;
                }
                return function (e) {
                  return (
                    (this.r = t(e.r)),
                    (this.g = t(e.g)),
                    (this.b = t(e.b)),
                    this
                  );
                };
              })(),
              convertSRGBToLinear: function () {
                return this.copySRGBToLinear(this), this;
              },
              convertLinearToSRGB: function () {
                return this.copyLinearToSRGB(this), this;
              },
              getHex: function () {
                return (
                  ((255 * this.r) << 16) ^
                  ((255 * this.g) << 8) ^
                  ((255 * this.b) << 0)
                );
              },
              getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6);
              },
              getHSL: function (t) {
                void 0 === t &&
                  (console.warn(
                    "THREE.Color: .getHSL() target is now required"
                  ),
                  (t = { h: 0, s: 0, l: 0 }));
                var e,
                  n,
                  r = this.r,
                  i = this.g,
                  a = this.b,
                  o = Math.max(r, i, a),
                  s = Math.min(r, i, a),
                  c = (s + o) / 2;
                if (s === o) (e = 0), (n = 0);
                else {
                  var h = o - s;
                  switch (((n = c <= 0.5 ? h / (o + s) : h / (2 - o - s)), o)) {
                    case r:
                      e = (i - a) / h + (i < a ? 6 : 0);
                      break;
                    case i:
                      e = (a - r) / h + 2;
                      break;
                    case a:
                      e = (r - i) / h + 4;
                  }
                  e /= 6;
                }
                return (t.h = e), (t.s = n), (t.l = c), t;
              },
              getStyle: function () {
                return (
                  "rgb(" +
                  ((255 * this.r) | 0) +
                  "," +
                  ((255 * this.g) | 0) +
                  "," +
                  ((255 * this.b) | 0) +
                  ")"
                );
              },
              offsetHSL: (function () {
                var t = {};
                return function (e, n, r) {
                  return (
                    this.getHSL(t),
                    (t.h += e),
                    (t.s += n),
                    (t.l += r),
                    this.setHSL(t.h, t.s, t.l),
                    this
                  );
                };
              })(),
              add: function (t) {
                return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
              },
              addColors: function (t, e) {
                return (
                  (this.r = t.r + e.r),
                  (this.g = t.g + e.g),
                  (this.b = t.b + e.b),
                  this
                );
              },
              addScalar: function (t) {
                return (this.r += t), (this.g += t), (this.b += t), this;
              },
              sub: function (t) {
                return (
                  (this.r = Math.max(0, this.r - t.r)),
                  (this.g = Math.max(0, this.g - t.g)),
                  (this.b = Math.max(0, this.b - t.b)),
                  this
                );
              },
              multiply: function (t) {
                return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
              },
              multiplyScalar: function (t) {
                return (this.r *= t), (this.g *= t), (this.b *= t), this;
              },
              lerp: function (t, e) {
                return (
                  (this.r += (t.r - this.r) * e),
                  (this.g += (t.g - this.g) * e),
                  (this.b += (t.b - this.b) * e),
                  this
                );
              },
              equals: function (t) {
                return t.r === this.r && t.g === this.g && t.b === this.b;
              },
              fromArray: function (t, e) {
                return (
                  void 0 === e && (e = 0),
                  (this.r = t[e]),
                  (this.g = t[e + 1]),
                  (this.b = t[e + 2]),
                  this
                );
              },
              toArray: function (t, e) {
                return (
                  void 0 === t && (t = []),
                  void 0 === e && (e = 0),
                  (t[e] = this.r),
                  (t[e + 1] = this.g),
                  (t[e + 2] = this.b),
                  t
                );
              },
              toJSON: function () {
                return this.getHex();
              },
            });
            var Tc = {
                common: {
                  diffuse: { value: new g(15658734) },
                  opacity: { value: 1 },
                  map: { value: null },
                  uvTransform: { value: new o() },
                  alphaMap: { value: null },
                },
                specularmap: { specularMap: { value: null } },
                envmap: {
                  envMap: { value: null },
                  flipEnvMap: { value: -1 },
                  reflectivity: { value: 1 },
                  refractionRatio: { value: 0.98 },
                  maxMipLevel: { value: 0 },
                },
                aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
                lightmap: {
                  lightMap: { value: null },
                  lightMapIntensity: { value: 1 },
                },
                emissivemap: { emissiveMap: { value: null } },
                bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
                normalmap: {
                  normalMap: { value: null },
                  normalScale: { value: new n(1, 1) },
                },
                displacementmap: {
                  displacementMap: { value: null },
                  displacementScale: { value: 1 },
                  displacementBias: { value: 0 },
                },
                roughnessmap: { roughnessMap: { value: null } },
                metalnessmap: { metalnessMap: { value: null } },
                gradientmap: { gradientMap: { value: null } },
                fog: {
                  fogDensity: { value: 25e-5 },
                  fogNear: { value: 1 },
                  fogFar: { value: 2e3 },
                  fogColor: { value: new g(16777215) },
                },
                lights: {
                  ambientLightColor: { value: [] },
                  directionalLights: {
                    value: [],
                    properties: {
                      direction: {},
                      color: {},
                      shadow: {},
                      shadowBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                    },
                  },
                  directionalShadowMap: { value: [] },
                  directionalShadowMatrix: { value: [] },
                  spotLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      direction: {},
                      distance: {},
                      coneCos: {},
                      penumbraCos: {},
                      decay: {},
                      shadow: {},
                      shadowBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                    },
                  },
                  spotShadowMap: { value: [] },
                  spotShadowMatrix: { value: [] },
                  pointLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      decay: {},
                      distance: {},
                      shadow: {},
                      shadowBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                      shadowCameraNear: {},
                      shadowCameraFar: {},
                    },
                  },
                  pointShadowMap: { value: [] },
                  pointShadowMatrix: { value: [] },
                  hemisphereLights: {
                    value: [],
                    properties: {
                      direction: {},
                      skyColor: {},
                      groundColor: {},
                    },
                  },
                  rectAreaLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      width: {},
                      height: {},
                    },
                  },
                },
                points: {
                  diffuse: { value: new g(15658734) },
                  opacity: { value: 1 },
                  size: { value: 1 },
                  scale: { value: 1 },
                  map: { value: null },
                  uvTransform: { value: new o() },
                },
                sprite: {
                  diffuse: { value: new g(15658734) },
                  opacity: { value: 1 },
                  center: { value: new n(0.5, 0.5) },
                  rotation: { value: 0 },
                  map: { value: null },
                  uvTransform: { value: new o() },
                },
              },
              Sc = {
                basic: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.specularmap,
                    Tc.envmap,
                    Tc.aomap,
                    Tc.lightmap,
                    Tc.fog,
                  ]),
                  vertexShader: wc.meshbasic_vert,
                  fragmentShader: wc.meshbasic_frag,
                },
                lambert: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.specularmap,
                    Tc.envmap,
                    Tc.aomap,
                    Tc.lightmap,
                    Tc.emissivemap,
                    Tc.fog,
                    Tc.lights,
                    { emissive: { value: new g(0) } },
                  ]),
                  vertexShader: wc.meshlambert_vert,
                  fragmentShader: wc.meshlambert_frag,
                },
                phong: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.specularmap,
                    Tc.envmap,
                    Tc.aomap,
                    Tc.lightmap,
                    Tc.emissivemap,
                    Tc.bumpmap,
                    Tc.normalmap,
                    Tc.displacementmap,
                    Tc.gradientmap,
                    Tc.fog,
                    Tc.lights,
                    {
                      emissive: { value: new g(0) },
                      specular: { value: new g(1118481) },
                      shininess: { value: 30 },
                    },
                  ]),
                  vertexShader: wc.meshphong_vert,
                  fragmentShader: wc.meshphong_frag,
                },
                standard: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.envmap,
                    Tc.aomap,
                    Tc.lightmap,
                    Tc.emissivemap,
                    Tc.bumpmap,
                    Tc.normalmap,
                    Tc.displacementmap,
                    Tc.roughnessmap,
                    Tc.metalnessmap,
                    Tc.fog,
                    Tc.lights,
                    {
                      emissive: { value: new g(0) },
                      roughness: { value: 0.5 },
                      metalness: { value: 0.5 },
                      envMapIntensity: { value: 1 },
                    },
                  ]),
                  vertexShader: wc.meshphysical_vert,
                  fragmentShader: wc.meshphysical_frag,
                },
                points: {
                  uniforms: Mc.merge([Tc.points, Tc.fog]),
                  vertexShader: wc.points_vert,
                  fragmentShader: wc.points_frag,
                },
                dashed: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.fog,
                    {
                      scale: { value: 1 },
                      dashSize: { value: 1 },
                      totalSize: { value: 2 },
                    },
                  ]),
                  vertexShader: wc.linedashed_vert,
                  fragmentShader: wc.linedashed_frag,
                },
                depth: {
                  uniforms: Mc.merge([Tc.common, Tc.displacementmap]),
                  vertexShader: wc.depth_vert,
                  fragmentShader: wc.depth_frag,
                },
                normal: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.bumpmap,
                    Tc.normalmap,
                    Tc.displacementmap,
                    { opacity: { value: 1 } },
                  ]),
                  vertexShader: wc.normal_vert,
                  fragmentShader: wc.normal_frag,
                },
                sprite: {
                  uniforms: Mc.merge([Tc.sprite, Tc.fog]),
                  vertexShader: wc.sprite_vert,
                  fragmentShader: wc.sprite_frag,
                },
                cube: {
                  uniforms: {
                    tCube: { value: null },
                    tFlip: { value: -1 },
                    opacity: { value: 1 },
                  },
                  vertexShader: wc.cube_vert,
                  fragmentShader: wc.cube_frag,
                },
                equirect: {
                  uniforms: { tEquirect: { value: null } },
                  vertexShader: wc.equirect_vert,
                  fragmentShader: wc.equirect_frag,
                },
                distanceRGBA: {
                  uniforms: Mc.merge([
                    Tc.common,
                    Tc.displacementmap,
                    {
                      referencePosition: { value: new a() },
                      nearDistance: { value: 1 },
                      farDistance: { value: 1e3 },
                    },
                  ]),
                  vertexShader: wc.distanceRGBA_vert,
                  fragmentShader: wc.distanceRGBA_frag,
                },
                shadow: {
                  uniforms: Mc.merge([
                    Tc.lights,
                    Tc.fog,
                    { color: { value: new g(0) }, opacity: { value: 1 } },
                  ]),
                  vertexShader: wc.shadow_vert,
                  fragmentShader: wc.shadow_frag,
                },
              };
            (Sc.physical = {
              uniforms: Mc.merge([
                Sc.standard.uniforms,
                { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } },
              ]),
              vertexShader: wc.meshphysical_vert,
              fragmentShader: wc.meshphysical_frag,
            }),
              (x.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
              (x.DefaultOrder = "XYZ"),
              Object.defineProperties(x.prototype, {
                x: {
                  get: function () {
                    return this._x;
                  },
                  set: function (t) {
                    (this._x = t), this.onChangeCallback();
                  },
                },
                y: {
                  get: function () {
                    return this._y;
                  },
                  set: function (t) {
                    (this._y = t), this.onChangeCallback();
                  },
                },
                z: {
                  get: function () {
                    return this._z;
                  },
                  set: function (t) {
                    (this._z = t), this.onChangeCallback();
                  },
                },
                order: {
                  get: function () {
                    return this._order;
                  },
                  set: function (t) {
                    (this._order = t), this.onChangeCallback();
                  },
                },
              }),
              Object.assign(x.prototype, {
                isEuler: !0,
                set: function (t, e, n, r) {
                  return (
                    (this._x = t),
                    (this._y = e),
                    (this._z = n),
                    (this._order = r || this._order),
                    this.onChangeCallback(),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor(
                    this._x,
                    this._y,
                    this._z,
                    this._order
                  );
                },
                copy: function (t) {
                  return (
                    (this._x = t._x),
                    (this._y = t._y),
                    (this._z = t._z),
                    (this._order = t._order),
                    this.onChangeCallback(),
                    this
                  );
                },
                setFromRotationMatrix: function (t, e, n) {
                  var r = xc.clamp,
                    i = t.elements,
                    a = i[0],
                    o = i[4],
                    s = i[8],
                    c = i[1],
                    h = i[5],
                    l = i[9],
                    u = i[2],
                    p = i[6],
                    d = i[10];
                  return (
                    (e = e || this._order),
                    "XYZ" === e
                      ? ((this._y = Math.asin(r(s, -1, 1))),
                        Math.abs(s) < 0.99999
                          ? ((this._x = Math.atan2(-l, d)),
                            (this._z = Math.atan2(-o, a)))
                          : ((this._x = Math.atan2(p, h)), (this._z = 0)))
                      : "YXZ" === e
                      ? ((this._x = Math.asin(-r(l, -1, 1))),
                        Math.abs(l) < 0.99999
                          ? ((this._y = Math.atan2(s, d)),
                            (this._z = Math.atan2(c, h)))
                          : ((this._y = Math.atan2(-u, a)), (this._z = 0)))
                      : "ZXY" === e
                      ? ((this._x = Math.asin(r(p, -1, 1))),
                        Math.abs(p) < 0.99999
                          ? ((this._y = Math.atan2(-u, d)),
                            (this._z = Math.atan2(-o, h)))
                          : ((this._y = 0), (this._z = Math.atan2(c, a))))
                      : "ZYX" === e
                      ? ((this._y = Math.asin(-r(u, -1, 1))),
                        Math.abs(u) < 0.99999
                          ? ((this._x = Math.atan2(p, d)),
                            (this._z = Math.atan2(c, a)))
                          : ((this._x = 0), (this._z = Math.atan2(-o, h))))
                      : "YZX" === e
                      ? ((this._z = Math.asin(r(c, -1, 1))),
                        Math.abs(c) < 0.99999
                          ? ((this._x = Math.atan2(-l, h)),
                            (this._y = Math.atan2(-u, a)))
                          : ((this._x = 0), (this._y = Math.atan2(s, d))))
                      : "XZY" === e
                      ? ((this._z = Math.asin(-r(o, -1, 1))),
                        Math.abs(o) < 0.99999
                          ? ((this._x = Math.atan2(p, h)),
                            (this._y = Math.atan2(s, a)))
                          : ((this._x = Math.atan2(-l, d)), (this._y = 0)))
                      : console.warn(
                          "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                            e
                        ),
                    (this._order = e),
                    !1 !== n && this.onChangeCallback(),
                    this
                  );
                },
                setFromQuaternion: (function () {
                  var t = new r();
                  return function (e, n, r) {
                    return (
                      t.makeRotationFromQuaternion(e),
                      this.setFromRotationMatrix(t, n, r)
                    );
                  };
                })(),
                setFromVector3: function (t, e) {
                  return this.set(t.x, t.y, t.z, e || this._order);
                },
                reorder: (function () {
                  var t = new i();
                  return function (e) {
                    return t.setFromEuler(this), this.setFromQuaternion(t, e);
                  };
                })(),
                equals: function (t) {
                  return (
                    t._x === this._x &&
                    t._y === this._y &&
                    t._z === this._z &&
                    t._order === this._order
                  );
                },
                fromArray: function (t) {
                  return (
                    (this._x = t[0]),
                    (this._y = t[1]),
                    (this._z = t[2]),
                    void 0 !== t[3] && (this._order = t[3]),
                    this.onChangeCallback(),
                    this
                  );
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this._x),
                    (t[e + 1] = this._y),
                    (t[e + 2] = this._z),
                    (t[e + 3] = this._order),
                    t
                  );
                },
                toVector3: function (t) {
                  return t
                    ? t.set(this._x, this._y, this._z)
                    : new a(this._x, this._y, this._z);
                },
                onChange: function (t) {
                  return (this.onChangeCallback = t), this;
                },
                onChangeCallback: function () {},
              }),
              Object.assign(b.prototype, {
                set: function (t) {
                  this.mask = (1 << t) | 0;
                },
                enable: function (t) {
                  this.mask |= (1 << t) | 0;
                },
                toggle: function (t) {
                  this.mask ^= (1 << t) | 0;
                },
                disable: function (t) {
                  this.mask &= ~((1 << t) | 0);
                },
                test: function (t) {
                  return 0 != (this.mask & t.mask);
                },
              });
            var Ac = 0;
            (_.DefaultUp = new a(0, 1, 0)),
              (_.DefaultMatrixAutoUpdate = !0),
              (_.prototype = Object.assign(Object.create(e.prototype), {
                constructor: _,
                isObject3D: !0,
                onBeforeRender: function () {},
                onAfterRender: function () {},
                applyMatrix: function (t) {
                  this.matrix.multiplyMatrices(t, this.matrix),
                    this.matrix.decompose(
                      this.position,
                      this.quaternion,
                      this.scale
                    );
                },
                applyQuaternion: function (t) {
                  return this.quaternion.premultiply(t), this;
                },
                setRotationFromAxisAngle: function (t, e) {
                  this.quaternion.setFromAxisAngle(t, e);
                },
                setRotationFromEuler: function (t) {
                  this.quaternion.setFromEuler(t, !0);
                },
                setRotationFromMatrix: function (t) {
                  this.quaternion.setFromRotationMatrix(t);
                },
                setRotationFromQuaternion: function (t) {
                  this.quaternion.copy(t);
                },
                rotateOnAxis: (function () {
                  var t = new i();
                  return function (e, n) {
                    return (
                      t.setFromAxisAngle(e, n),
                      this.quaternion.multiply(t),
                      this
                    );
                  };
                })(),
                rotateOnWorldAxis: (function () {
                  var t = new i();
                  return function (e, n) {
                    return (
                      t.setFromAxisAngle(e, n),
                      this.quaternion.premultiply(t),
                      this
                    );
                  };
                })(),
                rotateX: (function () {
                  var t = new a(1, 0, 0);
                  return function (e) {
                    return this.rotateOnAxis(t, e);
                  };
                })(),
                rotateY: (function () {
                  var t = new a(0, 1, 0);
                  return function (e) {
                    return this.rotateOnAxis(t, e);
                  };
                })(),
                rotateZ: (function () {
                  var t = new a(0, 0, 1);
                  return function (e) {
                    return this.rotateOnAxis(t, e);
                  };
                })(),
                translateOnAxis: (function () {
                  var t = new a();
                  return function (e, n) {
                    return (
                      t.copy(e).applyQuaternion(this.quaternion),
                      this.position.add(t.multiplyScalar(n)),
                      this
                    );
                  };
                })(),
                translateX: (function () {
                  var t = new a(1, 0, 0);
                  return function (e) {
                    return this.translateOnAxis(t, e);
                  };
                })(),
                translateY: (function () {
                  var t = new a(0, 1, 0);
                  return function (e) {
                    return this.translateOnAxis(t, e);
                  };
                })(),
                translateZ: (function () {
                  var t = new a(0, 0, 1);
                  return function (e) {
                    return this.translateOnAxis(t, e);
                  };
                })(),
                localToWorld: function (t) {
                  return t.applyMatrix4(this.matrixWorld);
                },
                worldToLocal: (function () {
                  var t = new r();
                  return function (e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld));
                  };
                })(),
                lookAt: (function () {
                  var t = new r(),
                    e = new a();
                  return function (n, r, i) {
                    n.isVector3 ? e.copy(n) : e.set(n, r, i),
                      this.isCamera
                        ? t.lookAt(this.position, e, this.up)
                        : t.lookAt(e, this.position, this.up),
                      this.quaternion.setFromRotationMatrix(t);
                  };
                })(),
                add: function (t) {
                  if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++)
                      this.add(arguments[e]);
                    return this;
                  }
                  return t === this
                    ? (console.error(
                        "THREE.Object3D.add: object can't be added as a child of itself.",
                        t
                      ),
                      this)
                    : (t && t.isObject3D
                        ? (null !== t.parent && t.parent.remove(t),
                          (t.parent = this),
                          t.dispatchEvent({ type: "added" }),
                          this.children.push(t))
                        : console.error(
                            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                            t
                          ),
                      this);
                },
                remove: function (t) {
                  if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++)
                      this.remove(arguments[e]);
                    return this;
                  }
                  var n = this.children.indexOf(t);
                  return (
                    -1 !== n &&
                      ((t.parent = null),
                      t.dispatchEvent({ type: "removed" }),
                      this.children.splice(n, 1)),
                    this
                  );
                },
                getObjectById: function (t) {
                  return this.getObjectByProperty("id", t);
                },
                getObjectByName: function (t) {
                  return this.getObjectByProperty("name", t);
                },
                getObjectByProperty: function (t, e) {
                  if (this[t] === e) return this;
                  for (var n = 0, r = this.children.length; n < r; n++) {
                    var i = this.children[n],
                      a = i.getObjectByProperty(t, e);
                    if (void 0 !== a) return a;
                  }
                },
                getWorldPosition: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Object3D: .getWorldPosition() target is now required"
                      ),
                      (t = new a())),
                    this.updateMatrixWorld(!0),
                    t.setFromMatrixPosition(this.matrixWorld)
                  );
                },
                getWorldQuaternion: (function () {
                  var t = new a(),
                    e = new a();
                  return function (n) {
                    return (
                      void 0 === n &&
                        (console.warn(
                          "THREE.Object3D: .getWorldQuaternion() target is now required"
                        ),
                        (n = new i())),
                      this.updateMatrixWorld(!0),
                      this.matrixWorld.decompose(t, n, e),
                      n
                    );
                  };
                })(),
                getWorldScale: (function () {
                  var t = new a(),
                    e = new i();
                  return function (n) {
                    return (
                      void 0 === n &&
                        (console.warn(
                          "THREE.Object3D: .getWorldScale() target is now required"
                        ),
                        (n = new a())),
                      this.updateMatrixWorld(!0),
                      this.matrixWorld.decompose(t, e, n),
                      n
                    );
                  };
                })(),
                getWorldDirection: (function () {
                  var t = new i();
                  return function (e) {
                    return (
                      void 0 === e &&
                        (console.warn(
                          "THREE.Object3D: .getWorldDirection() target is now required"
                        ),
                        (e = new a())),
                      this.getWorldQuaternion(t),
                      e.set(0, 0, 1).applyQuaternion(t)
                    );
                  };
                })(),
                raycast: function () {},
                traverse: function (t) {
                  t(this);
                  for (var e = this.children, n = 0, r = e.length; n < r; n++)
                    e[n].traverse(t);
                },
                traverseVisible: function (t) {
                  if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, n = 0, r = e.length; n < r; n++)
                      e[n].traverseVisible(t);
                  }
                },
                traverseAncestors: function (t) {
                  var e = this.parent;
                  null !== e && (t(e), e.traverseAncestors(t));
                },
                updateMatrix: function () {
                  this.matrix.compose(
                    this.position,
                    this.quaternion,
                    this.scale
                  ),
                    (this.matrixWorldNeedsUpdate = !0);
                },
                updateMatrixWorld: function (t) {
                  this.matrixAutoUpdate && this.updateMatrix(),
                    (this.matrixWorldNeedsUpdate || t) &&
                      (null === this.parent
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                            this.parent.matrixWorld,
                            this.matrix
                          ),
                      (this.matrixWorldNeedsUpdate = !1),
                      (t = !0));
                  for (var e = this.children, n = 0, r = e.length; n < r; n++)
                    e[n].updateMatrixWorld(t);
                },
                toJSON: function (t) {
                  function e(e, n) {
                    return (
                      void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    );
                  }
                  function n(t) {
                    var e = [];
                    for (var n in t) {
                      var r = t[n];
                      delete r.metadata, e.push(r);
                    }
                    return e;
                  }
                  var r = void 0 === t || "string" == typeof t,
                    i = {};
                  r &&
                    ((t = {
                      geometries: {},
                      materials: {},
                      textures: {},
                      images: {},
                      shapes: {},
                    }),
                    (i.metadata = {
                      version: 4.5,
                      type: "Object",
                      generator: "Object3D.toJSON",
                    }));
                  var a = {};
                  if (
                    ((a.uuid = this.uuid),
                    (a.type = this.type),
                    "" !== this.name && (a.name = this.name),
                    !0 === this.castShadow && (a.castShadow = !0),
                    !0 === this.receiveShadow && (a.receiveShadow = !0),
                    !1 === this.visible && (a.visible = !1),
                    !1 === this.frustumCulled && (a.frustumCulled = !1),
                    0 !== this.renderOrder &&
                      (a.renderOrder = this.renderOrder),
                    "{}" !== JSON.stringify(this.userData) &&
                      (a.userData = this.userData),
                    (a.layers = this.layers.mask),
                    (a.matrix = this.matrix.toArray()),
                    !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1),
                    this.isMesh || this.isLine || this.isPoints)
                  ) {
                    a.geometry = e(t.geometries, this.geometry);
                    var o = this.geometry.parameters;
                    if (void 0 !== o && void 0 !== o.shapes) {
                      var s = o.shapes;
                      if (Array.isArray(s))
                        for (var c = 0, h = s.length; c < h; c++) {
                          var l = s[c];
                          e(t.shapes, l);
                        }
                      else e(t.shapes, s);
                    }
                  }
                  if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                      for (
                        var u = [], c = 0, h = this.material.length;
                        c < h;
                        c++
                      )
                        u.push(e(t.materials, this.material[c]));
                      a.material = u;
                    } else a.material = e(t.materials, this.material);
                  if (this.children.length > 0) {
                    a.children = [];
                    for (var c = 0; c < this.children.length; c++)
                      a.children.push(this.children[c].toJSON(t).object);
                  }
                  if (r) {
                    var p = n(t.geometries),
                      d = n(t.materials),
                      f = n(t.textures),
                      m = n(t.images),
                      s = n(t.shapes);
                    p.length > 0 && (i.geometries = p),
                      d.length > 0 && (i.materials = d),
                      f.length > 0 && (i.textures = f),
                      m.length > 0 && (i.images = m),
                      s.length > 0 && (i.shapes = s);
                  }
                  return (i.object = a), i;
                },
                clone: function (t) {
                  return new this.constructor().copy(this, t);
                },
                copy: function (t, e) {
                  if (
                    (void 0 === e && (e = !0),
                    (this.name = t.name),
                    this.up.copy(t.up),
                    this.position.copy(t.position),
                    this.quaternion.copy(t.quaternion),
                    this.scale.copy(t.scale),
                    this.matrix.copy(t.matrix),
                    this.matrixWorld.copy(t.matrixWorld),
                    (this.matrixAutoUpdate = t.matrixAutoUpdate),
                    (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                    (this.layers.mask = t.layers.mask),
                    (this.visible = t.visible),
                    (this.castShadow = t.castShadow),
                    (this.receiveShadow = t.receiveShadow),
                    (this.frustumCulled = t.frustumCulled),
                    (this.renderOrder = t.renderOrder),
                    (this.userData = JSON.parse(JSON.stringify(t.userData))),
                    !0 === e)
                  )
                    for (var n = 0; n < t.children.length; n++) {
                      var r = t.children[n];
                      this.add(r.clone());
                    }
                  return this;
                },
              })),
              (w.prototype = Object.assign(Object.create(_.prototype), {
                constructor: w,
                isCamera: !0,
                copy: function (t, e) {
                  return (
                    _.prototype.copy.call(this, t, e),
                    this.matrixWorldInverse.copy(t.matrixWorldInverse),
                    this.projectionMatrix.copy(t.projectionMatrix),
                    this
                  );
                },
                getWorldDirection: (function () {
                  var t = new i();
                  return function (e) {
                    return (
                      void 0 === e &&
                        (console.warn(
                          "THREE.Camera: .getWorldDirection() target is now required"
                        ),
                        (e = new a())),
                      this.getWorldQuaternion(t),
                      e.set(0, 0, -1).applyQuaternion(t)
                    );
                  };
                })(),
                updateMatrixWorld: function (t) {
                  _.prototype.updateMatrixWorld.call(this, t),
                    this.matrixWorldInverse.getInverse(this.matrixWorld);
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
              })),
              (M.prototype = Object.assign(Object.create(w.prototype), {
                constructor: M,
                isOrthographicCamera: !0,
                copy: function (t, e) {
                  return (
                    w.prototype.copy.call(this, t, e),
                    (this.left = t.left),
                    (this.right = t.right),
                    (this.top = t.top),
                    (this.bottom = t.bottom),
                    (this.near = t.near),
                    (this.far = t.far),
                    (this.zoom = t.zoom),
                    (this.view =
                      null === t.view ? null : Object.assign({}, t.view)),
                    this
                  );
                },
                setViewOffset: function (t, e, n, r, i, a) {
                  null === this.view &&
                    (this.view = {
                      enabled: !0,
                      fullWidth: 1,
                      fullHeight: 1,
                      offsetX: 0,
                      offsetY: 0,
                      width: 1,
                      height: 1,
                    }),
                    (this.view.enabled = !0),
                    (this.view.fullWidth = t),
                    (this.view.fullHeight = e),
                    (this.view.offsetX = n),
                    (this.view.offsetY = r),
                    (this.view.width = i),
                    (this.view.height = a),
                    this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                  null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                  var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2,
                    i = n - t,
                    a = n + t,
                    o = r + e,
                    s = r - e;
                  if (null !== this.view && this.view.enabled) {
                    var c = this.zoom / (this.view.width / this.view.fullWidth),
                      h = this.zoom / (this.view.height / this.view.fullHeight),
                      l = (this.right - this.left) / this.view.width,
                      u = (this.top - this.bottom) / this.view.height;
                    (i += l * (this.view.offsetX / c)),
                      (a = i + l * (this.view.width / c)),
                      (o -= u * (this.view.offsetY / h)),
                      (s = o - u * (this.view.height / h));
                  }
                  this.projectionMatrix.makeOrthographic(
                    i,
                    a,
                    o,
                    s,
                    this.near,
                    this.far
                  );
                },
                toJSON: function (t) {
                  var e = _.prototype.toJSON.call(this, t);
                  return (
                    (e.object.zoom = this.zoom),
                    (e.object.left = this.left),
                    (e.object.right = this.right),
                    (e.object.top = this.top),
                    (e.object.bottom = this.bottom),
                    (e.object.near = this.near),
                    (e.object.far = this.far),
                    null !== this.view &&
                      (e.object.view = Object.assign({}, this.view)),
                    e
                  );
                },
              })),
              Object.assign(E.prototype, {
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  (this.a = t.a),
                    (this.b = t.b),
                    (this.c = t.c),
                    this.normal.copy(t.normal),
                    this.color.copy(t.color),
                    (this.materialIndex = t.materialIndex);
                  for (var e = 0, n = t.vertexNormals.length; e < n; e++)
                    this.vertexNormals[e] = t.vertexNormals[e].clone();
                  for (var e = 0, n = t.vertexColors.length; e < n; e++)
                    this.vertexColors[e] = t.vertexColors[e].clone();
                  return this;
                },
              });
            var Lc = 0;
            (T.prototype = Object.assign(Object.create(e.prototype), {
              constructor: T,
              isGeometry: !0,
              applyMatrix: function (t) {
                for (
                  var e = new o().getNormalMatrix(t),
                    n = 0,
                    r = this.vertices.length;
                  n < r;
                  n++
                ) {
                  this.vertices[n].applyMatrix4(t);
                }
                for (var n = 0, r = this.faces.length; n < r; n++) {
                  var i = this.faces[n];
                  i.normal.applyMatrix3(e).normalize();
                  for (var a = 0, s = i.vertexNormals.length; a < s; a++)
                    i.vertexNormals[a].applyMatrix3(e).normalize();
                }
                return (
                  null !== this.boundingBox && this.computeBoundingBox(),
                  null !== this.boundingSphere && this.computeBoundingSphere(),
                  (this.verticesNeedUpdate = !0),
                  (this.normalsNeedUpdate = !0),
                  this
                );
              },
              rotateX: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationX(e), this.applyMatrix(t), this;
                };
              })(),
              rotateY: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationY(e), this.applyMatrix(t), this;
                };
              })(),
              rotateZ: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationZ(e), this.applyMatrix(t), this;
                };
              })(),
              translate: (function () {
                var t = new r();
                return function (e, n, r) {
                  return t.makeTranslation(e, n, r), this.applyMatrix(t), this;
                };
              })(),
              scale: (function () {
                var t = new r();
                return function (e, n, r) {
                  return t.makeScale(e, n, r), this.applyMatrix(t), this;
                };
              })(),
              lookAt: (function () {
                var t = new _();
                return function (e) {
                  t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
                };
              })(),
              fromBufferGeometry: function (t) {
                function e(t, e, n, i) {
                  var a =
                      void 0 !== c
                        ? [p[t].clone(), p[e].clone(), p[n].clone()]
                        : [],
                    o =
                      void 0 !== h
                        ? [
                            r.colors[t].clone(),
                            r.colors[e].clone(),
                            r.colors[n].clone(),
                          ]
                        : [],
                    s = new E(t, e, n, a, o, i);
                  r.faces.push(s),
                    void 0 !== l &&
                      r.faceVertexUvs[0].push([
                        d[t].clone(),
                        d[e].clone(),
                        d[n].clone(),
                      ]),
                    void 0 !== u &&
                      r.faceVertexUvs[1].push([
                        f[t].clone(),
                        f[e].clone(),
                        f[n].clone(),
                      ]);
                }
                var r = this,
                  i = null !== t.index ? t.index.array : void 0,
                  o = t.attributes,
                  s = o.position.array,
                  c = void 0 !== o.normal ? o.normal.array : void 0,
                  h = void 0 !== o.color ? o.color.array : void 0,
                  l = void 0 !== o.uv ? o.uv.array : void 0,
                  u = void 0 !== o.uv2 ? o.uv2.array : void 0;
                void 0 !== u && (this.faceVertexUvs[1] = []);
                for (
                  var p = [], d = [], f = [], m = 0, v = 0;
                  m < s.length;
                  m += 3, v += 2
                )
                  r.vertices.push(new a(s[m], s[m + 1], s[m + 2])),
                    void 0 !== c && p.push(new a(c[m], c[m + 1], c[m + 2])),
                    void 0 !== h &&
                      r.colors.push(new g(h[m], h[m + 1], h[m + 2])),
                    void 0 !== l && d.push(new n(l[v], l[v + 1])),
                    void 0 !== u && f.push(new n(u[v], u[v + 1]));
                var y = t.groups;
                if (y.length > 0)
                  for (var m = 0; m < y.length; m++)
                    for (
                      var x = y[m], b = x.start, _ = x.count, v = b, w = b + _;
                      v < w;
                      v += 3
                    )
                      void 0 !== i
                        ? e(i[v], i[v + 1], i[v + 2], x.materialIndex)
                        : e(v, v + 1, v + 2, x.materialIndex);
                else if (void 0 !== i)
                  for (var m = 0; m < i.length; m += 3)
                    e(i[m], i[m + 1], i[m + 2]);
                else
                  for (var m = 0; m < s.length / 3; m += 3) e(m, m + 1, m + 2);
                return (
                  this.computeFaceNormals(),
                  null !== t.boundingBox &&
                    (this.boundingBox = t.boundingBox.clone()),
                  null !== t.boundingSphere &&
                    (this.boundingSphere = t.boundingSphere.clone()),
                  this
                );
              },
              center: (function () {
                var t = new a();
                return function () {
                  return (
                    this.computeBoundingBox(),
                    this.boundingBox.getCenter(t).negate(),
                    this.translate(t.x, t.y, t.z),
                    this
                  );
                };
              })(),
              normalize: function () {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                  e = this.boundingSphere.radius,
                  n = 0 === e ? 1 : 1 / e,
                  i = new r();
                return (
                  i.set(
                    n,
                    0,
                    0,
                    -n * t.x,
                    0,
                    n,
                    0,
                    -n * t.y,
                    0,
                    0,
                    n,
                    -n * t.z,
                    0,
                    0,
                    0,
                    1
                  ),
                  this.applyMatrix(i),
                  this
                );
              },
              computeFaceNormals: function () {
                for (
                  var t = new a(), e = new a(), n = 0, r = this.faces.length;
                  n < r;
                  n++
                ) {
                  var i = this.faces[n],
                    o = this.vertices[i.a],
                    s = this.vertices[i.b],
                    c = this.vertices[i.c];
                  t.subVectors(c, s),
                    e.subVectors(o, s),
                    t.cross(e),
                    t.normalize(),
                    i.normal.copy(t);
                }
              },
              computeVertexNormals: function (t) {
                void 0 === t && (t = !0);
                var e, n, r, i, o, s;
                for (
                  s = new Array(this.vertices.length),
                    e = 0,
                    n = this.vertices.length;
                  e < n;
                  e++
                )
                  s[e] = new a();
                if (t) {
                  var c,
                    h,
                    l,
                    u = new a(),
                    p = new a();
                  for (r = 0, i = this.faces.length; r < i; r++)
                    (o = this.faces[r]),
                      (c = this.vertices[o.a]),
                      (h = this.vertices[o.b]),
                      (l = this.vertices[o.c]),
                      u.subVectors(l, h),
                      p.subVectors(c, h),
                      u.cross(p),
                      s[o.a].add(u),
                      s[o.b].add(u),
                      s[o.c].add(u);
                } else
                  for (
                    this.computeFaceNormals(), r = 0, i = this.faces.length;
                    r < i;
                    r++
                  )
                    (o = this.faces[r]),
                      s[o.a].add(o.normal),
                      s[o.b].add(o.normal),
                      s[o.c].add(o.normal);
                for (e = 0, n = this.vertices.length; e < n; e++)
                  s[e].normalize();
                for (r = 0, i = this.faces.length; r < i; r++) {
                  o = this.faces[r];
                  var d = o.vertexNormals;
                  3 === d.length
                    ? (d[0].copy(s[o.a]), d[1].copy(s[o.b]), d[2].copy(s[o.c]))
                    : ((d[0] = s[o.a].clone()),
                      (d[1] = s[o.b].clone()),
                      (d[2] = s[o.c].clone()));
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0);
              },
              computeFlatVertexNormals: function () {
                var t, e, n;
                for (
                  this.computeFaceNormals(), t = 0, e = this.faces.length;
                  t < e;
                  t++
                ) {
                  n = this.faces[t];
                  var r = n.vertexNormals;
                  3 === r.length
                    ? (r[0].copy(n.normal),
                      r[1].copy(n.normal),
                      r[2].copy(n.normal))
                    : ((r[0] = n.normal.clone()),
                      (r[1] = n.normal.clone()),
                      (r[2] = n.normal.clone()));
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0);
              },
              computeMorphNormals: function () {
                var t, e, n, r, i;
                for (n = 0, r = this.faces.length; n < r; n++)
                  for (
                    i = this.faces[n],
                      i.__originalFaceNormal
                        ? i.__originalFaceNormal.copy(i.normal)
                        : (i.__originalFaceNormal = i.normal.clone()),
                      i.__originalVertexNormals ||
                        (i.__originalVertexNormals = []),
                      t = 0,
                      e = i.vertexNormals.length;
                    t < e;
                    t++
                  )
                    i.__originalVertexNormals[t]
                      ? i.__originalVertexNormals[t].copy(i.vertexNormals[t])
                      : (i.__originalVertexNormals[t] =
                          i.vertexNormals[t].clone());
                var o = new T();
                for (
                  o.faces = this.faces, t = 0, e = this.morphTargets.length;
                  t < e;
                  t++
                ) {
                  if (!this.morphNormals[t]) {
                    (this.morphNormals[t] = {}),
                      (this.morphNormals[t].faceNormals = []),
                      (this.morphNormals[t].vertexNormals = []);
                    var s,
                      c,
                      h = this.morphNormals[t].faceNormals,
                      l = this.morphNormals[t].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++)
                      (s = new a()),
                        (c = { a: new a(), b: new a(), c: new a() }),
                        h.push(s),
                        l.push(c);
                  }
                  var u = this.morphNormals[t];
                  (o.vertices = this.morphTargets[t].vertices),
                    o.computeFaceNormals(),
                    o.computeVertexNormals();
                  var s, c;
                  for (n = 0, r = this.faces.length; n < r; n++)
                    (i = this.faces[n]),
                      (s = u.faceNormals[n]),
                      (c = u.vertexNormals[n]),
                      s.copy(i.normal),
                      c.a.copy(i.vertexNormals[0]),
                      c.b.copy(i.vertexNormals[1]),
                      c.c.copy(i.vertexNormals[2]);
                }
                for (n = 0, r = this.faces.length; n < r; n++)
                  (i = this.faces[n]),
                    (i.normal = i.__originalFaceNormal),
                    (i.vertexNormals = i.__originalVertexNormals);
              },
              computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new p()),
                  this.boundingBox.setFromPoints(this.vertices);
              },
              computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new d()),
                  this.boundingSphere.setFromPoints(this.vertices);
              },
              merge: function (t, e, n) {
                if (!t || !t.isGeometry)
                  return void console.error(
                    "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
                    t
                  );
                var r,
                  i = this.vertices.length,
                  a = this.vertices,
                  s = t.vertices,
                  c = this.faces,
                  h = t.faces,
                  l = this.faceVertexUvs[0],
                  u = t.faceVertexUvs[0],
                  p = this.colors,
                  d = t.colors;
                void 0 === n && (n = 0),
                  void 0 !== e && (r = new o().getNormalMatrix(e));
                for (var f = 0, m = s.length; f < m; f++) {
                  var g = s[f],
                    v = g.clone();
                  void 0 !== e && v.applyMatrix4(e), a.push(v);
                }
                for (var f = 0, m = d.length; f < m; f++) p.push(d[f].clone());
                for (f = 0, m = h.length; f < m; f++) {
                  var y,
                    x,
                    b,
                    _ = h[f],
                    w = _.vertexNormals,
                    M = _.vertexColors;
                  (y = new E(_.a + i, _.b + i, _.c + i)),
                    y.normal.copy(_.normal),
                    void 0 !== r && y.normal.applyMatrix3(r).normalize();
                  for (var T = 0, S = w.length; T < S; T++)
                    (x = w[T].clone()),
                      void 0 !== r && x.applyMatrix3(r).normalize(),
                      y.vertexNormals.push(x);
                  y.color.copy(_.color);
                  for (var T = 0, S = M.length; T < S; T++)
                    (b = M[T]), y.vertexColors.push(b.clone());
                  (y.materialIndex = _.materialIndex + n), c.push(y);
                }
                for (f = 0, m = u.length; f < m; f++) {
                  var A = u[f],
                    L = [];
                  if (void 0 !== A) {
                    for (var T = 0, S = A.length; T < S; T++)
                      L.push(A[T].clone());
                    l.push(L);
                  }
                }
              },
              mergeMesh: function (t) {
                if (!t || !t.isMesh)
                  return void console.error(
                    "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                    t
                  );
                t.matrixAutoUpdate && t.updateMatrix(),
                  this.merge(t.geometry, t.matrix);
              },
              mergeVertices: function () {
                var t,
                  e,
                  n,
                  r,
                  i,
                  a,
                  o,
                  s,
                  c = {},
                  h = [],
                  l = [],
                  u = Math.pow(10, 4);
                for (n = 0, r = this.vertices.length; n < r; n++)
                  (t = this.vertices[n]),
                    (e =
                      Math.round(t.x * u) +
                      "_" +
                      Math.round(t.y * u) +
                      "_" +
                      Math.round(t.z * u)),
                    void 0 === c[e]
                      ? ((c[e] = n),
                        h.push(this.vertices[n]),
                        (l[n] = h.length - 1))
                      : (l[n] = l[c[e]]);
                var p = [];
                for (n = 0, r = this.faces.length; n < r; n++) {
                  (i = this.faces[n]),
                    (i.a = l[i.a]),
                    (i.b = l[i.b]),
                    (i.c = l[i.c]),
                    (a = [i.a, i.b, i.c]);
                  for (var d = 0; d < 3; d++)
                    if (a[d] === a[(d + 1) % 3]) {
                      p.push(n);
                      break;
                    }
                }
                for (n = p.length - 1; n >= 0; n--) {
                  var f = p[n];
                  for (
                    this.faces.splice(f, 1),
                      o = 0,
                      s = this.faceVertexUvs.length;
                    o < s;
                    o++
                  )
                    this.faceVertexUvs[o].splice(f, 1);
                }
                var m = this.vertices.length - h.length;
                return (this.vertices = h), m;
              },
              setFromPoints: function (t) {
                this.vertices = [];
                for (var e = 0, n = t.length; e < n; e++) {
                  var r = t[e];
                  this.vertices.push(new a(r.x, r.y, r.z || 0));
                }
                return this;
              },
              sortFacesByMaterialIndex: function () {
                function t(t, e) {
                  return t.materialIndex - e.materialIndex;
                }
                for (var e = this.faces, n = e.length, r = 0; r < n; r++)
                  e[r]._id = r;
                e.sort(t);
                var i,
                  a,
                  o = this.faceVertexUvs[0],
                  s = this.faceVertexUvs[1];
                o && o.length === n && (i = []),
                  s && s.length === n && (a = []);
                for (var r = 0; r < n; r++) {
                  var c = e[r]._id;
                  i && i.push(o[c]), a && a.push(s[c]);
                }
                i && (this.faceVertexUvs[0] = i),
                  a && (this.faceVertexUvs[1] = a);
              },
              toJSON: function () {
                function t(t, e, n) {
                  return n ? t | (1 << e) : t & ~(1 << e);
                }
                function e(t) {
                  var e = t.x.toString() + t.y.toString() + t.z.toString();
                  return void 0 !== p[e]
                    ? p[e]
                    : ((p[e] = u.length / 3), u.push(t.x, t.y, t.z), p[e]);
                }
                function n(t) {
                  var e = t.r.toString() + t.g.toString() + t.b.toString();
                  return void 0 !== f[e]
                    ? f[e]
                    : ((f[e] = d.length), d.push(t.getHex()), f[e]);
                }
                function r(t) {
                  var e = t.x.toString() + t.y.toString();
                  return void 0 !== g[e]
                    ? g[e]
                    : ((g[e] = m.length / 2), m.push(t.x, t.y), g[e]);
                }
                var i = {
                  metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON",
                  },
                };
                if (
                  ((i.uuid = this.uuid),
                  (i.type = this.type),
                  "" !== this.name && (i.name = this.name),
                  void 0 !== this.parameters)
                ) {
                  var a = this.parameters;
                  for (var o in a) void 0 !== a[o] && (i[o] = a[o]);
                  return i;
                }
                for (var s = [], c = 0; c < this.vertices.length; c++) {
                  var h = this.vertices[c];
                  s.push(h.x, h.y, h.z);
                }
                for (
                  var l = [],
                    u = [],
                    p = {},
                    d = [],
                    f = {},
                    m = [],
                    g = {},
                    c = 0;
                  c < this.faces.length;
                  c++
                ) {
                  var v = this.faces[c],
                    y = void 0 !== this.faceVertexUvs[0][c],
                    x = v.normal.length() > 0,
                    b = v.vertexNormals.length > 0,
                    _ = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                    w = v.vertexColors.length > 0,
                    M = 0;
                  if (
                    ((M = t(M, 0, 0)),
                    (M = t(M, 1, !0)),
                    (M = t(M, 2, !1)),
                    (M = t(M, 3, y)),
                    (M = t(M, 4, x)),
                    (M = t(M, 5, b)),
                    (M = t(M, 6, _)),
                    (M = t(M, 7, w)),
                    l.push(M),
                    l.push(v.a, v.b, v.c),
                    l.push(v.materialIndex),
                    y)
                  ) {
                    var E = this.faceVertexUvs[0][c];
                    l.push(r(E[0]), r(E[1]), r(E[2]));
                  }
                  if ((x && l.push(e(v.normal)), b)) {
                    var T = v.vertexNormals;
                    l.push(e(T[0]), e(T[1]), e(T[2]));
                  }
                  if ((_ && l.push(n(v.color)), w)) {
                    var S = v.vertexColors;
                    l.push(n(S[0]), n(S[1]), n(S[2]));
                  }
                }
                return (
                  (i.data = {}),
                  (i.data.vertices = s),
                  (i.data.normals = u),
                  d.length > 0 && (i.data.colors = d),
                  m.length > 0 && (i.data.uvs = [m]),
                  (i.data.faces = l),
                  i
                );
              },
              clone: function () {
                return new T().copy(this);
              },
              copy: function (t) {
                var e, n, r, i, a, o;
                (this.vertices = []),
                  (this.colors = []),
                  (this.faces = []),
                  (this.faceVertexUvs = [[]]),
                  (this.morphTargets = []),
                  (this.morphNormals = []),
                  (this.skinWeights = []),
                  (this.skinIndices = []),
                  (this.lineDistances = []),
                  (this.boundingBox = null),
                  (this.boundingSphere = null),
                  (this.name = t.name);
                var s = t.vertices;
                for (e = 0, n = s.length; e < n; e++)
                  this.vertices.push(s[e].clone());
                var c = t.colors;
                for (e = 0, n = c.length; e < n; e++)
                  this.colors.push(c[e].clone());
                var h = t.faces;
                for (e = 0, n = h.length; e < n; e++)
                  this.faces.push(h[e].clone());
                for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                  var l = t.faceVertexUvs[e];
                  for (
                    void 0 === this.faceVertexUvs[e] &&
                      (this.faceVertexUvs[e] = []),
                      r = 0,
                      i = l.length;
                    r < i;
                    r++
                  ) {
                    var u = l[r],
                      p = [];
                    for (a = 0, o = u.length; a < o; a++) {
                      var d = u[a];
                      p.push(d.clone());
                    }
                    this.faceVertexUvs[e].push(p);
                  }
                }
                var f = t.morphTargets;
                for (e = 0, n = f.length; e < n; e++) {
                  var m = {};
                  if (((m.name = f[e].name), void 0 !== f[e].vertices))
                    for (
                      m.vertices = [], r = 0, i = f[e].vertices.length;
                      r < i;
                      r++
                    )
                      m.vertices.push(f[e].vertices[r].clone());
                  if (void 0 !== f[e].normals)
                    for (
                      m.normals = [], r = 0, i = f[e].normals.length;
                      r < i;
                      r++
                    )
                      m.normals.push(f[e].normals[r].clone());
                  this.morphTargets.push(m);
                }
                var g = t.morphNormals;
                for (e = 0, n = g.length; e < n; e++) {
                  var v = {};
                  if (void 0 !== g[e].vertexNormals)
                    for (
                      v.vertexNormals = [],
                        r = 0,
                        i = g[e].vertexNormals.length;
                      r < i;
                      r++
                    ) {
                      var y = g[e].vertexNormals[r],
                        x = {};
                      (x.a = y.a.clone()),
                        (x.b = y.b.clone()),
                        (x.c = y.c.clone()),
                        v.vertexNormals.push(x);
                    }
                  if (void 0 !== g[e].faceNormals)
                    for (
                      v.faceNormals = [], r = 0, i = g[e].faceNormals.length;
                      r < i;
                      r++
                    )
                      v.faceNormals.push(g[e].faceNormals[r].clone());
                  this.morphNormals.push(v);
                }
                var b = t.skinWeights;
                for (e = 0, n = b.length; e < n; e++)
                  this.skinWeights.push(b[e].clone());
                var _ = t.skinIndices;
                for (e = 0, n = _.length; e < n; e++)
                  this.skinIndices.push(_[e].clone());
                var w = t.lineDistances;
                for (e = 0, n = w.length; e < n; e++)
                  this.lineDistances.push(w[e]);
                var M = t.boundingBox;
                null !== M && (this.boundingBox = M.clone());
                var E = t.boundingSphere;
                return (
                  null !== E && (this.boundingSphere = E.clone()),
                  (this.elementsNeedUpdate = t.elementsNeedUpdate),
                  (this.verticesNeedUpdate = t.verticesNeedUpdate),
                  (this.uvsNeedUpdate = t.uvsNeedUpdate),
                  (this.normalsNeedUpdate = t.normalsNeedUpdate),
                  (this.colorsNeedUpdate = t.colorsNeedUpdate),
                  (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
                  (this.groupsNeedUpdate = t.groupsNeedUpdate),
                  this
                );
              },
              dispose: function () {
                this.dispatchEvent({ type: "dispose" });
              },
            })),
              Object.defineProperty(S.prototype, "needsUpdate", {
                set: function (t) {
                  !0 === t && this.version++;
                },
              }),
              Object.assign(S.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function () {},
                setArray: function (t) {
                  if (Array.isArray(t))
                    throw new TypeError(
                      "THREE.BufferAttribute: array should be a Typed Array."
                    );
                  return (
                    (this.count = void 0 !== t ? t.length / this.itemSize : 0),
                    (this.array = t),
                    this
                  );
                },
                setDynamic: function (t) {
                  return (this.dynamic = t), this;
                },
                copy: function (t) {
                  return (
                    (this.name = t.name),
                    (this.array = new t.array.constructor(t.array)),
                    (this.itemSize = t.itemSize),
                    (this.count = t.count),
                    (this.normalized = t.normalized),
                    (this.dynamic = t.dynamic),
                    this
                  );
                },
                copyAt: function (t, e, n) {
                  (t *= this.itemSize), (n *= e.itemSize);
                  for (var r = 0, i = this.itemSize; r < i; r++)
                    this.array[t + r] = e.array[n + r];
                  return this;
                },
                copyArray: function (t) {
                  return this.array.set(t), this;
                },
                copyColorsArray: function (t) {
                  for (
                    var e = this.array, n = 0, r = 0, i = t.length;
                    r < i;
                    r++
                  ) {
                    var a = t[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                        r
                      ),
                      (a = new g())),
                      (e[n++] = a.r),
                      (e[n++] = a.g),
                      (e[n++] = a.b);
                  }
                  return this;
                },
                copyVector2sArray: function (t) {
                  for (
                    var e = this.array, r = 0, i = 0, a = t.length;
                    i < a;
                    i++
                  ) {
                    var o = t[i];
                    void 0 === o &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                        i
                      ),
                      (o = new n())),
                      (e[r++] = o.x),
                      (e[r++] = o.y);
                  }
                  return this;
                },
                copyVector3sArray: function (t) {
                  for (
                    var e = this.array, n = 0, r = 0, i = t.length;
                    r < i;
                    r++
                  ) {
                    var o = t[r];
                    void 0 === o &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                        r
                      ),
                      (o = new a())),
                      (e[n++] = o.x),
                      (e[n++] = o.y),
                      (e[n++] = o.z);
                  }
                  return this;
                },
                copyVector4sArray: function (t) {
                  for (
                    var e = this.array, n = 0, r = 0, i = t.length;
                    r < i;
                    r++
                  ) {
                    var a = t[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                        r
                      ),
                      (a = new c())),
                      (e[n++] = a.x),
                      (e[n++] = a.y),
                      (e[n++] = a.z),
                      (e[n++] = a.w);
                  }
                  return this;
                },
                set: function (t, e) {
                  return void 0 === e && (e = 0), this.array.set(t, e), this;
                },
                getX: function (t) {
                  return this.array[t * this.itemSize];
                },
                setX: function (t, e) {
                  return (this.array[t * this.itemSize] = e), this;
                },
                getY: function (t) {
                  return this.array[t * this.itemSize + 1];
                },
                setY: function (t, e) {
                  return (this.array[t * this.itemSize + 1] = e), this;
                },
                getZ: function (t) {
                  return this.array[t * this.itemSize + 2];
                },
                setZ: function (t, e) {
                  return (this.array[t * this.itemSize + 2] = e), this;
                },
                getW: function (t) {
                  return this.array[t * this.itemSize + 3];
                },
                setW: function (t, e) {
                  return (this.array[t * this.itemSize + 3] = e), this;
                },
                setXY: function (t, e, n) {
                  return (
                    (t *= this.itemSize),
                    (this.array[t + 0] = e),
                    (this.array[t + 1] = n),
                    this
                  );
                },
                setXYZ: function (t, e, n, r) {
                  return (
                    (t *= this.itemSize),
                    (this.array[t + 0] = e),
                    (this.array[t + 1] = n),
                    (this.array[t + 2] = r),
                    this
                  );
                },
                setXYZW: function (t, e, n, r, i) {
                  return (
                    (t *= this.itemSize),
                    (this.array[t + 0] = e),
                    (this.array[t + 1] = n),
                    (this.array[t + 2] = r),
                    (this.array[t + 3] = i),
                    this
                  );
                },
                onUpload: function (t) {
                  return (this.onUploadCallback = t), this;
                },
                clone: function () {
                  return new this.constructor(this.array, this.itemSize).copy(
                    this
                  );
                },
              }),
              (A.prototype = Object.create(S.prototype)),
              (A.prototype.constructor = A),
              (L.prototype = Object.create(S.prototype)),
              (L.prototype.constructor = L),
              (R.prototype = Object.create(S.prototype)),
              (R.prototype.constructor = R),
              (C.prototype = Object.create(S.prototype)),
              (C.prototype.constructor = C),
              (P.prototype = Object.create(S.prototype)),
              (P.prototype.constructor = P),
              (O.prototype = Object.create(S.prototype)),
              (O.prototype.constructor = O),
              (I.prototype = Object.create(S.prototype)),
              (I.prototype.constructor = I),
              (N.prototype = Object.create(S.prototype)),
              (N.prototype.constructor = N),
              (D.prototype = Object.create(S.prototype)),
              (D.prototype.constructor = D),
              Object.assign(U.prototype, {
                computeGroups: function (t) {
                  for (
                    var e, n = [], r = void 0, i = t.faces, a = 0;
                    a < i.length;
                    a++
                  ) {
                    var o = i[a];
                    o.materialIndex !== r &&
                      ((r = o.materialIndex),
                      void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
                      (e = { start: 3 * a, materialIndex: r }));
                  }
                  void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
                    (this.groups = n);
                },
                fromGeometry: function (t) {
                  var e,
                    r = t.faces,
                    i = t.vertices,
                    a = t.faceVertexUvs,
                    o = a[0] && a[0].length > 0,
                    s = a[1] && a[1].length > 0,
                    c = t.morphTargets,
                    h = c.length;
                  if (h > 0) {
                    e = [];
                    for (var l = 0; l < h; l++) e[l] = [];
                    this.morphTargets.position = e;
                  }
                  var u,
                    p = t.morphNormals,
                    d = p.length;
                  if (d > 0) {
                    u = [];
                    for (var l = 0; l < d; l++) u[l] = [];
                    this.morphTargets.normal = u;
                  }
                  var f = t.skinIndices,
                    m = t.skinWeights,
                    g = f.length === i.length,
                    v = m.length === i.length;
                  i.length > 0 &&
                    0 === r.length &&
                    console.error(
                      "THREE.DirectGeometry: Faceless geometries are not supported."
                    );
                  for (var l = 0; l < r.length; l++) {
                    var y = r[l];
                    this.vertices.push(i[y.a], i[y.b], i[y.c]);
                    var x = y.vertexNormals;
                    if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
                    else {
                      var b = y.normal;
                      this.normals.push(b, b, b);
                    }
                    var _ = y.vertexColors;
                    if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                    else {
                      var w = y.color;
                      this.colors.push(w, w, w);
                    }
                    if (!0 === o) {
                      var M = a[0][l];
                      void 0 !== M
                        ? this.uvs.push(M[0], M[1], M[2])
                        : (console.warn(
                            "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                            l
                          ),
                          this.uvs.push(new n(), new n(), new n()));
                    }
                    if (!0 === s) {
                      var M = a[1][l];
                      void 0 !== M
                        ? this.uvs2.push(M[0], M[1], M[2])
                        : (console.warn(
                            "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                            l
                          ),
                          this.uvs2.push(new n(), new n(), new n()));
                    }
                    for (var E = 0; E < h; E++) {
                      var T = c[E].vertices;
                      e[E].push(T[y.a], T[y.b], T[y.c]);
                    }
                    for (var E = 0; E < d; E++) {
                      var S = p[E].vertexNormals[l];
                      u[E].push(S.a, S.b, S.c);
                    }
                    g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]),
                      v && this.skinWeights.push(m[y.a], m[y.b], m[y.c]);
                  }
                  return (
                    this.computeGroups(t),
                    (this.verticesNeedUpdate = t.verticesNeedUpdate),
                    (this.normalsNeedUpdate = t.normalsNeedUpdate),
                    (this.colorsNeedUpdate = t.colorsNeedUpdate),
                    (this.uvsNeedUpdate = t.uvsNeedUpdate),
                    (this.groupsNeedUpdate = t.groupsNeedUpdate),
                    this
                  );
                },
              });
            var Rc = 1;
            (F.prototype = Object.assign(Object.create(e.prototype), {
              constructor: F,
              isBufferGeometry: !0,
              getIndex: function () {
                return this.index;
              },
              setIndex: function (t) {
                Array.isArray(t)
                  ? (this.index = new (B(t) > 65535 ? I : P)(t, 1))
                  : (this.index = t);
              },
              addAttribute: function (t, e) {
                return (e && e.isBufferAttribute) ||
                  (e && e.isInterleavedBufferAttribute)
                  ? "index" === t
                    ? (console.warn(
                        "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                      ),
                      this.setIndex(e),
                      this)
                    : ((this.attributes[t] = e), this)
                  : (console.warn(
                      "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                    ),
                    this.addAttribute(t, new S(arguments[1], arguments[2])));
              },
              getAttribute: function (t) {
                return this.attributes[t];
              },
              removeAttribute: function (t) {
                return delete this.attributes[t], this;
              },
              addGroup: function (t, e, n) {
                this.groups.push({
                  start: t,
                  count: e,
                  materialIndex: void 0 !== n ? n : 0,
                });
              },
              clearGroups: function () {
                this.groups = [];
              },
              setDrawRange: function (t, e) {
                (this.drawRange.start = t), (this.drawRange.count = e);
              },
              applyMatrix: function (t) {
                var e = this.attributes.position;
                void 0 !== e &&
                  (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
                var n = this.attributes.normal;
                if (void 0 !== n) {
                  new o().getNormalMatrix(t).applyToBufferAttribute(n),
                    (n.needsUpdate = !0);
                }
                return (
                  null !== this.boundingBox && this.computeBoundingBox(),
                  null !== this.boundingSphere && this.computeBoundingSphere(),
                  this
                );
              },
              rotateX: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationX(e), this.applyMatrix(t), this;
                };
              })(),
              rotateY: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationY(e), this.applyMatrix(t), this;
                };
              })(),
              rotateZ: (function () {
                var t = new r();
                return function (e) {
                  return t.makeRotationZ(e), this.applyMatrix(t), this;
                };
              })(),
              translate: (function () {
                var t = new r();
                return function (e, n, r) {
                  return t.makeTranslation(e, n, r), this.applyMatrix(t), this;
                };
              })(),
              scale: (function () {
                var t = new r();
                return function (e, n, r) {
                  return t.makeScale(e, n, r), this.applyMatrix(t), this;
                };
              })(),
              lookAt: (function () {
                var t = new _();
                return function (e) {
                  t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
                };
              })(),
              center: (function () {
                var t = new a();
                return function () {
                  return (
                    this.computeBoundingBox(),
                    this.boundingBox.getCenter(t).negate(),
                    this.translate(t.x, t.y, t.z),
                    this
                  );
                };
              })(),
              setFromObject: function (t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                  var n = new N(3 * e.vertices.length, 3),
                    r = new N(3 * e.colors.length, 3);
                  if (
                    (this.addAttribute(
                      "position",
                      n.copyVector3sArray(e.vertices)
                    ),
                    this.addAttribute("color", r.copyColorsArray(e.colors)),
                    e.lineDistances &&
                      e.lineDistances.length === e.vertices.length)
                  ) {
                    var i = new N(e.lineDistances.length, 1);
                    this.addAttribute(
                      "lineDistance",
                      i.copyArray(e.lineDistances)
                    );
                  }
                  null !== e.boundingSphere &&
                    (this.boundingSphere = e.boundingSphere.clone()),
                    null !== e.boundingBox &&
                      (this.boundingBox = e.boundingBox.clone());
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this;
              },
              setFromPoints: function (t) {
                for (var e = [], n = 0, r = t.length; n < r; n++) {
                  var i = t[n];
                  e.push(i.x, i.y, i.z || 0);
                }
                return this.addAttribute("position", new N(e, 3)), this;
              },
              updateFromObject: function (t) {
                var e = t.geometry;
                if (t.isMesh) {
                  var n = e.__directGeometry;
                  if (
                    (!0 === e.elementsNeedUpdate &&
                      ((n = void 0), (e.elementsNeedUpdate = !1)),
                    void 0 === n)
                  )
                    return this.fromGeometry(e);
                  (n.verticesNeedUpdate = e.verticesNeedUpdate),
                    (n.normalsNeedUpdate = e.normalsNeedUpdate),
                    (n.colorsNeedUpdate = e.colorsNeedUpdate),
                    (n.uvsNeedUpdate = e.uvsNeedUpdate),
                    (n.groupsNeedUpdate = e.groupsNeedUpdate),
                    (e.verticesNeedUpdate = !1),
                    (e.normalsNeedUpdate = !1),
                    (e.colorsNeedUpdate = !1),
                    (e.uvsNeedUpdate = !1),
                    (e.groupsNeedUpdate = !1),
                    (e = n);
                }
                var r;
                return (
                  !0 === e.verticesNeedUpdate &&
                    ((r = this.attributes.position),
                    void 0 !== r &&
                      (r.copyVector3sArray(e.vertices), (r.needsUpdate = !0)),
                    (e.verticesNeedUpdate = !1)),
                  !0 === e.normalsNeedUpdate &&
                    ((r = this.attributes.normal),
                    void 0 !== r &&
                      (r.copyVector3sArray(e.normals), (r.needsUpdate = !0)),
                    (e.normalsNeedUpdate = !1)),
                  !0 === e.colorsNeedUpdate &&
                    ((r = this.attributes.color),
                    void 0 !== r &&
                      (r.copyColorsArray(e.colors), (r.needsUpdate = !0)),
                    (e.colorsNeedUpdate = !1)),
                  e.uvsNeedUpdate &&
                    ((r = this.attributes.uv),
                    void 0 !== r &&
                      (r.copyVector2sArray(e.uvs), (r.needsUpdate = !0)),
                    (e.uvsNeedUpdate = !1)),
                  e.lineDistancesNeedUpdate &&
                    ((r = this.attributes.lineDistance),
                    void 0 !== r &&
                      (r.copyArray(e.lineDistances), (r.needsUpdate = !0)),
                    (e.lineDistancesNeedUpdate = !1)),
                  e.groupsNeedUpdate &&
                    (e.computeGroups(t.geometry),
                    (this.groups = e.groups),
                    (e.groupsNeedUpdate = !1)),
                  this
                );
              },
              fromGeometry: function (t) {
                return (
                  (t.__directGeometry = new U().fromGeometry(t)),
                  this.fromDirectGeometry(t.__directGeometry)
                );
              },
              fromDirectGeometry: function (t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (
                  (this.addAttribute(
                    "position",
                    new S(e, 3).copyVector3sArray(t.vertices)
                  ),
                  t.normals.length > 0)
                ) {
                  var n = new Float32Array(3 * t.normals.length);
                  this.addAttribute(
                    "normal",
                    new S(n, 3).copyVector3sArray(t.normals)
                  );
                }
                if (t.colors.length > 0) {
                  var r = new Float32Array(3 * t.colors.length);
                  this.addAttribute(
                    "color",
                    new S(r, 3).copyColorsArray(t.colors)
                  );
                }
                if (t.uvs.length > 0) {
                  var i = new Float32Array(2 * t.uvs.length);
                  this.addAttribute("uv", new S(i, 2).copyVector2sArray(t.uvs));
                }
                if (t.uvs2.length > 0) {
                  var a = new Float32Array(2 * t.uvs2.length);
                  this.addAttribute(
                    "uv2",
                    new S(a, 2).copyVector2sArray(t.uvs2)
                  );
                }
                this.groups = t.groups;
                for (var o in t.morphTargets) {
                  for (
                    var s = [], c = t.morphTargets[o], h = 0, l = c.length;
                    h < l;
                    h++
                  ) {
                    var u = c[h],
                      p = new N(3 * u.length, 3);
                    s.push(p.copyVector3sArray(u));
                  }
                  this.morphAttributes[o] = s;
                }
                if (t.skinIndices.length > 0) {
                  var d = new N(4 * t.skinIndices.length, 4);
                  this.addAttribute(
                    "skinIndex",
                    d.copyVector4sArray(t.skinIndices)
                  );
                }
                if (t.skinWeights.length > 0) {
                  var f = new N(4 * t.skinWeights.length, 4);
                  this.addAttribute(
                    "skinWeight",
                    f.copyVector4sArray(t.skinWeights)
                  );
                }
                return (
                  null !== t.boundingSphere &&
                    (this.boundingSphere = t.boundingSphere.clone()),
                  null !== t.boundingBox &&
                    (this.boundingBox = t.boundingBox.clone()),
                  this
                );
              },
              computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new p());
                var t = this.attributes.position;
                void 0 !== t
                  ? this.boundingBox.setFromBufferAttribute(t)
                  : this.boundingBox.makeEmpty(),
                  (isNaN(this.boundingBox.min.x) ||
                    isNaN(this.boundingBox.min.y) ||
                    isNaN(this.boundingBox.min.z)) &&
                    console.error(
                      'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                      this
                    );
              },
              computeBoundingSphere: (function () {
                var t = new p(),
                  e = new a();
                return function () {
                  null === this.boundingSphere &&
                    (this.boundingSphere = new d());
                  var n = this.attributes.position;
                  if (n) {
                    var r = this.boundingSphere.center;
                    t.setFromBufferAttribute(n), t.getCenter(r);
                    for (var i = 0, a = 0, o = n.count; a < o; a++)
                      (e.x = n.getX(a)),
                        (e.y = n.getY(a)),
                        (e.z = n.getZ(a)),
                        (i = Math.max(i, r.distanceToSquared(e)));
                    (this.boundingSphere.radius = Math.sqrt(i)),
                      isNaN(this.boundingSphere.radius) &&
                        console.error(
                          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                          this
                        );
                  }
                };
              })(),
              computeFaceNormals: function () {},
              computeVertexNormals: function () {
                var t = this.index,
                  e = this.attributes,
                  n = this.groups;
                if (e.position) {
                  var r = e.position.array;
                  if (void 0 === e.normal)
                    this.addAttribute(
                      "normal",
                      new S(new Float32Array(r.length), 3)
                    );
                  else
                    for (
                      var i = e.normal.array, o = 0, s = i.length;
                      o < s;
                      o++
                    )
                      i[o] = 0;
                  var c,
                    h,
                    l,
                    u = e.normal.array,
                    p = new a(),
                    d = new a(),
                    f = new a(),
                    m = new a(),
                    g = new a();
                  if (t) {
                    var v = t.array;
                    0 === n.length && this.addGroup(0, v.length);
                    for (var y = 0, x = n.length; y < x; ++y)
                      for (
                        var b = n[y],
                          _ = b.start,
                          w = b.count,
                          o = _,
                          s = _ + w;
                        o < s;
                        o += 3
                      )
                        (c = 3 * v[o + 0]),
                          (h = 3 * v[o + 1]),
                          (l = 3 * v[o + 2]),
                          p.fromArray(r, c),
                          d.fromArray(r, h),
                          f.fromArray(r, l),
                          m.subVectors(f, d),
                          g.subVectors(p, d),
                          m.cross(g),
                          (u[c] += m.x),
                          (u[c + 1] += m.y),
                          (u[c + 2] += m.z),
                          (u[h] += m.x),
                          (u[h + 1] += m.y),
                          (u[h + 2] += m.z),
                          (u[l] += m.x),
                          (u[l + 1] += m.y),
                          (u[l + 2] += m.z);
                  } else
                    for (var o = 0, s = r.length; o < s; o += 9)
                      p.fromArray(r, o),
                        d.fromArray(r, o + 3),
                        f.fromArray(r, o + 6),
                        m.subVectors(f, d),
                        g.subVectors(p, d),
                        m.cross(g),
                        (u[o] = m.x),
                        (u[o + 1] = m.y),
                        (u[o + 2] = m.z),
                        (u[o + 3] = m.x),
                        (u[o + 4] = m.y),
                        (u[o + 5] = m.z),
                        (u[o + 6] = m.x),
                        (u[o + 7] = m.y),
                        (u[o + 8] = m.z);
                  this.normalizeNormals(), (e.normal.needsUpdate = !0);
                }
              },
              merge: function (t, e) {
                if (!t || !t.isBufferGeometry)
                  return void console.error(
                    "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                    t
                  );
                void 0 === e &&
                  ((e = 0),
                  console.warn(
                    "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                  ));
                var n = this.attributes;
                for (var r in n)
                  if (void 0 !== t.attributes[r])
                    for (
                      var i = n[r],
                        a = i.array,
                        o = t.attributes[r],
                        s = o.array,
                        c = o.itemSize,
                        h = 0,
                        l = c * e;
                      h < s.length;
                      h++, l++
                    )
                      a[l] = s[h];
                return this;
              },
              normalizeNormals: (function () {
                var t = new a();
                return function () {
                  for (
                    var e = this.attributes.normal, n = 0, r = e.count;
                    n < r;
                    n++
                  )
                    (t.x = e.getX(n)),
                      (t.y = e.getY(n)),
                      (t.z = e.getZ(n)),
                      t.normalize(),
                      e.setXYZ(n, t.x, t.y, t.z);
                };
              })(),
              toNonIndexed: function () {
                if (null === this.index)
                  return (
                    console.warn(
                      "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
                    ),
                    this
                  );
                var t = new F(),
                  e = this.index.array,
                  n = this.attributes;
                for (var r in n) {
                  for (
                    var i = n[r],
                      a = i.array,
                      o = i.itemSize,
                      s = new a.constructor(e.length * o),
                      c = 0,
                      h = 0,
                      l = 0,
                      u = e.length;
                    l < u;
                    l++
                  ) {
                    c = e[l] * o;
                    for (var p = 0; p < o; p++) s[h++] = a[c++];
                  }
                  t.addAttribute(r, new S(s, o));
                }
                for (var d = this.groups, l = 0, u = d.length; l < u; l++) {
                  var f = d[l];
                  t.addGroup(f.start, f.count, f.materialIndex);
                }
                return t;
              },
              toJSON: function () {
                var t = {
                  metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON",
                  },
                };
                if (
                  ((t.uuid = this.uuid),
                  (t.type = this.type),
                  "" !== this.name && (t.name = this.name),
                  Object.keys(this.userData).length > 0 &&
                    (t.userData = this.userData),
                  void 0 !== this.parameters)
                ) {
                  var e = this.parameters;
                  for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                  return t;
                }
                t.data = { attributes: {} };
                var r = this.index;
                if (null !== r) {
                  var i = Array.prototype.slice.call(r.array);
                  t.data.index = { type: r.array.constructor.name, array: i };
                }
                var a = this.attributes;
                for (var n in a) {
                  var o = a[n],
                    i = Array.prototype.slice.call(o.array);
                  t.data.attributes[n] = {
                    itemSize: o.itemSize,
                    type: o.array.constructor.name,
                    array: i,
                    normalized: o.normalized,
                  };
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                var c = this.boundingSphere;
                return (
                  null !== c &&
                    (t.data.boundingSphere = {
                      center: c.center.toArray(),
                      radius: c.radius,
                    }),
                  t
                );
              },
              clone: function () {
                return new F().copy(this);
              },
              copy: function (t) {
                var e, n, r;
                (this.index = null),
                  (this.attributes = {}),
                  (this.morphAttributes = {}),
                  (this.groups = []),
                  (this.boundingBox = null),
                  (this.boundingSphere = null),
                  (this.name = t.name);
                var i = t.index;
                null !== i && this.setIndex(i.clone());
                var a = t.attributes;
                for (e in a) {
                  var o = a[e];
                  this.addAttribute(e, o.clone());
                }
                var s = t.morphAttributes;
                for (e in s) {
                  var c = [],
                    h = s[e];
                  for (n = 0, r = h.length; n < r; n++) c.push(h[n].clone());
                  this.morphAttributes[e] = c;
                }
                var l = t.groups;
                for (n = 0, r = l.length; n < r; n++) {
                  var u = l[n];
                  this.addGroup(u.start, u.count, u.materialIndex);
                }
                var p = t.boundingBox;
                null !== p && (this.boundingBox = p.clone());
                var d = t.boundingSphere;
                return (
                  null !== d && (this.boundingSphere = d.clone()),
                  (this.drawRange.start = t.drawRange.start),
                  (this.drawRange.count = t.drawRange.count),
                  (this.userData = t.userData),
                  this
                );
              },
              dispose: function () {
                this.dispatchEvent({ type: "dispose" });
              },
            })),
              (z.prototype = Object.create(T.prototype)),
              (z.prototype.constructor = z),
              (G.prototype = Object.create(F.prototype)),
              (G.prototype.constructor = G),
              (H.prototype = Object.create(T.prototype)),
              (H.prototype.constructor = H),
              (V.prototype = Object.create(F.prototype)),
              (V.prototype.constructor = V);
            var Cc = 0;
            (k.prototype = Object.assign(Object.create(e.prototype), {
              constructor: k,
              isMaterial: !0,
              onBeforeCompile: function () {},
              setValues: function (t) {
                if (void 0 !== t)
                  for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                      if ("shading" !== e) {
                        var r = this[e];
                        void 0 !== r
                          ? r && r.isColor
                            ? r.set(n)
                            : r && r.isVector3 && n && n.isVector3
                            ? r.copy(n)
                            : (this[e] = "overdraw" === e ? Number(n) : n)
                          : console.warn(
                              "THREE." +
                                this.type +
                                ": '" +
                                e +
                                "' is not a property of this material."
                            );
                      } else
                        console.warn(
                          "THREE." +
                            this.type +
                            ": .shading has been removed. Use the boolean .flatShading instead."
                        ),
                          (this.flatShading = 1 === n);
                    else
                      console.warn(
                        "THREE.Material: '" + e + "' parameter is undefined."
                      );
                  }
              },
              toJSON: function (t) {
                function e(t) {
                  var e = [];
                  for (var n in t) {
                    var r = t[n];
                    delete r.metadata, e.push(r);
                  }
                  return e;
                }
                var n = void 0 === t || "string" == typeof t;
                n && (t = { textures: {}, images: {} });
                var r = {
                  metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON",
                  },
                };
                if (
                  ((r.uuid = this.uuid),
                  (r.type = this.type),
                  "" !== this.name && (r.name = this.name),
                  this.color &&
                    this.color.isColor &&
                    (r.color = this.color.getHex()),
                  void 0 !== this.roughness && (r.roughness = this.roughness),
                  void 0 !== this.metalness && (r.metalness = this.metalness),
                  this.emissive &&
                    this.emissive.isColor &&
                    (r.emissive = this.emissive.getHex()),
                  1 !== this.emissiveIntensity &&
                    (r.emissiveIntensity = this.emissiveIntensity),
                  this.specular &&
                    this.specular.isColor &&
                    (r.specular = this.specular.getHex()),
                  void 0 !== this.shininess && (r.shininess = this.shininess),
                  void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat),
                  void 0 !== this.clearCoatRoughness &&
                    (r.clearCoatRoughness = this.clearCoatRoughness),
                  this.map &&
                    this.map.isTexture &&
                    (r.map = this.map.toJSON(t).uuid),
                  this.alphaMap &&
                    this.alphaMap.isTexture &&
                    (r.alphaMap = this.alphaMap.toJSON(t).uuid),
                  this.lightMap &&
                    this.lightMap.isTexture &&
                    (r.lightMap = this.lightMap.toJSON(t).uuid),
                  this.aoMap &&
                    this.aoMap.isTexture &&
                    ((r.aoMap = this.aoMap.toJSON(t).uuid),
                    (r.aoMapIntensity = this.aoMapIntensity)),
                  this.bumpMap &&
                    this.bumpMap.isTexture &&
                    ((r.bumpMap = this.bumpMap.toJSON(t).uuid),
                    (r.bumpScale = this.bumpScale)),
                  this.normalMap &&
                    this.normalMap.isTexture &&
                    ((r.normalMap = this.normalMap.toJSON(t).uuid),
                    (r.normalMapType = this.normalMapType),
                    (r.normalScale = this.normalScale.toArray())),
                  this.displacementMap &&
                    this.displacementMap.isTexture &&
                    ((r.displacementMap = this.displacementMap.toJSON(t).uuid),
                    (r.displacementScale = this.displacementScale),
                    (r.displacementBias = this.displacementBias)),
                  this.roughnessMap &&
                    this.roughnessMap.isTexture &&
                    (r.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                  this.metalnessMap &&
                    this.metalnessMap.isTexture &&
                    (r.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                  this.emissiveMap &&
                    this.emissiveMap.isTexture &&
                    (r.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                  this.specularMap &&
                    this.specularMap.isTexture &&
                    (r.specularMap = this.specularMap.toJSON(t).uuid),
                  this.envMap &&
                    this.envMap.isTexture &&
                    ((r.envMap = this.envMap.toJSON(t).uuid),
                    (r.reflectivity = this.reflectivity)),
                  this.gradientMap &&
                    this.gradientMap.isTexture &&
                    (r.gradientMap = this.gradientMap.toJSON(t).uuid),
                  void 0 !== this.size && (r.size = this.size),
                  void 0 !== this.sizeAttenuation &&
                    (r.sizeAttenuation = this.sizeAttenuation),
                  this.blending !== mo && (r.blending = this.blending),
                  !0 === this.flatShading && (r.flatShading = this.flatShading),
                  this.side !== so && (r.side = this.side),
                  this.vertexColors !== lo &&
                    (r.vertexColors = this.vertexColors),
                  this.opacity < 1 && (r.opacity = this.opacity),
                  !0 === this.transparent && (r.transparent = this.transparent),
                  (r.depthFunc = this.depthFunc),
                  (r.depthTest = this.depthTest),
                  (r.depthWrite = this.depthWrite),
                  0 !== this.rotation && (r.rotation = this.rotation),
                  1 !== this.linewidth && (r.linewidth = this.linewidth),
                  void 0 !== this.dashSize && (r.dashSize = this.dashSize),
                  void 0 !== this.gapSize && (r.gapSize = this.gapSize),
                  void 0 !== this.scale && (r.scale = this.scale),
                  !0 === this.dithering && (r.dithering = !0),
                  this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
                  !0 === this.premultipliedAlpha &&
                    (r.premultipliedAlpha = this.premultipliedAlpha),
                  !0 === this.wireframe && (r.wireframe = this.wireframe),
                  this.wireframeLinewidth > 1 &&
                    (r.wireframeLinewidth = this.wireframeLinewidth),
                  "round" !== this.wireframeLinecap &&
                    (r.wireframeLinecap = this.wireframeLinecap),
                  "round" !== this.wireframeLinejoin &&
                    (r.wireframeLinejoin = this.wireframeLinejoin),
                  !0 === this.morphTargets && (r.morphTargets = !0),
                  !0 === this.skinning && (r.skinning = !0),
                  !1 === this.visible && (r.visible = !1),
                  "{}" !== JSON.stringify(this.userData) &&
                    (r.userData = this.userData),
                  n)
                ) {
                  var i = e(t.textures),
                    a = e(t.images);
                  i.length > 0 && (r.textures = i),
                    a.length > 0 && (r.images = a);
                }
                return r;
              },
              clone: function () {
                return new this.constructor().copy(this);
              },
              copy: function (t) {
                (this.name = t.name),
                  (this.fog = t.fog),
                  (this.lights = t.lights),
                  (this.blending = t.blending),
                  (this.side = t.side),
                  (this.flatShading = t.flatShading),
                  (this.vertexColors = t.vertexColors),
                  (this.opacity = t.opacity),
                  (this.transparent = t.transparent),
                  (this.blendSrc = t.blendSrc),
                  (this.blendDst = t.blendDst),
                  (this.blendEquation = t.blendEquation),
                  (this.blendSrcAlpha = t.blendSrcAlpha),
                  (this.blendDstAlpha = t.blendDstAlpha),
                  (this.blendEquationAlpha = t.blendEquationAlpha),
                  (this.depthFunc = t.depthFunc),
                  (this.depthTest = t.depthTest),
                  (this.depthWrite = t.depthWrite),
                  (this.colorWrite = t.colorWrite),
                  (this.precision = t.precision),
                  (this.polygonOffset = t.polygonOffset),
                  (this.polygonOffsetFactor = t.polygonOffsetFactor),
                  (this.polygonOffsetUnits = t.polygonOffsetUnits),
                  (this.dithering = t.dithering),
                  (this.alphaTest = t.alphaTest),
                  (this.premultipliedAlpha = t.premultipliedAlpha),
                  (this.overdraw = t.overdraw),
                  (this.visible = t.visible),
                  (this.userData = JSON.parse(JSON.stringify(t.userData))),
                  (this.clipShadows = t.clipShadows),
                  (this.clipIntersection = t.clipIntersection);
                var e = t.clippingPlanes,
                  n = null;
                if (null !== e) {
                  var r = e.length;
                  n = new Array(r);
                  for (var i = 0; i !== r; ++i) n[i] = e[i].clone();
                }
                return (
                  (this.clippingPlanes = n),
                  (this.shadowSide = t.shadowSide),
                  this
                );
              },
              dispose: function () {
                this.dispatchEvent({ type: "dispose" });
              },
            })),
              (j.prototype = Object.create(k.prototype)),
              (j.prototype.constructor = j),
              (j.prototype.isMeshBasicMaterial = !0),
              (j.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  (this.map = t.map),
                  (this.lightMap = t.lightMap),
                  (this.lightMapIntensity = t.lightMapIntensity),
                  (this.aoMap = t.aoMap),
                  (this.aoMapIntensity = t.aoMapIntensity),
                  (this.specularMap = t.specularMap),
                  (this.alphaMap = t.alphaMap),
                  (this.envMap = t.envMap),
                  (this.combine = t.combine),
                  (this.reflectivity = t.reflectivity),
                  (this.refractionRatio = t.refractionRatio),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.wireframeLinecap = t.wireframeLinecap),
                  (this.wireframeLinejoin = t.wireframeLinejoin),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  this
                );
              }),
              (W.prototype = Object.create(k.prototype)),
              (W.prototype.constructor = W),
              (W.prototype.isShaderMaterial = !0),
              (W.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  (this.fragmentShader = t.fragmentShader),
                  (this.vertexShader = t.vertexShader),
                  (this.uniforms = Mc.clone(t.uniforms)),
                  (this.defines = Object.assign({}, t.defines)),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.lights = t.lights),
                  (this.clipping = t.clipping),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.morphNormals = t.morphNormals),
                  (this.extensions = t.extensions),
                  this
                );
              }),
              (W.prototype.toJSON = function (t) {
                var e = k.prototype.toJSON.call(this, t);
                return (
                  (e.uniforms = this.uniforms),
                  (e.vertexShader = this.vertexShader),
                  (e.fragmentShader = this.fragmentShader),
                  e
                );
              }),
              Object.assign(X.prototype, {
                set: function (t, e) {
                  return this.origin.copy(t), this.direction.copy(e), this;
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    this.origin.copy(t.origin),
                    this.direction.copy(t.direction),
                    this
                  );
                },
                at: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn("THREE.Ray: .at() target is now required"),
                      (e = new a())),
                    e.copy(this.direction).multiplyScalar(t).add(this.origin)
                  );
                },
                lookAt: function (t) {
                  return (
                    this.direction.copy(t).sub(this.origin).normalize(), this
                  );
                },
                recast: (function () {
                  var t = new a();
                  return function (e) {
                    return this.origin.copy(this.at(e, t)), this;
                  };
                })(),
                closestPointToPoint: function (t, e) {
                  void 0 === e &&
                    (console.warn(
                      "THREE.Ray: .closestPointToPoint() target is now required"
                    ),
                    (e = new a())),
                    e.subVectors(t, this.origin);
                  var n = e.dot(this.direction);
                  return n < 0
                    ? e.copy(this.origin)
                    : e.copy(this.direction).multiplyScalar(n).add(this.origin);
                },
                distanceToPoint: function (t) {
                  return Math.sqrt(this.distanceSqToPoint(t));
                },
                distanceSqToPoint: (function () {
                  var t = new a();
                  return function (e) {
                    var n = t.subVectors(e, this.origin).dot(this.direction);
                    return n < 0
                      ? this.origin.distanceToSquared(e)
                      : (t
                          .copy(this.direction)
                          .multiplyScalar(n)
                          .add(this.origin),
                        t.distanceToSquared(e));
                  };
                })(),
                distanceSqToSegment: (function () {
                  var t = new a(),
                    e = new a(),
                    n = new a();
                  return function (r, i, a, o) {
                    t.copy(r).add(i).multiplyScalar(0.5),
                      e.copy(i).sub(r).normalize(),
                      n.copy(this.origin).sub(t);
                    var s,
                      c,
                      h,
                      l,
                      u = 0.5 * r.distanceTo(i),
                      p = -this.direction.dot(e),
                      d = n.dot(this.direction),
                      f = -n.dot(e),
                      m = n.lengthSq(),
                      g = Math.abs(1 - p * p);
                    if (g > 0)
                      if (
                        ((s = p * f - d), (c = p * d - f), (l = u * g), s >= 0)
                      )
                        if (c >= -l)
                          if (c <= l) {
                            var v = 1 / g;
                            (s *= v),
                              (c *= v),
                              (h =
                                s * (s + p * c + 2 * d) +
                                c * (p * s + c + 2 * f) +
                                m);
                          } else
                            (c = u),
                              (s = Math.max(0, -(p * c + d))),
                              (h = -s * s + c * (c + 2 * f) + m);
                        else
                          (c = -u),
                            (s = Math.max(0, -(p * c + d))),
                            (h = -s * s + c * (c + 2 * f) + m);
                      else
                        c <= -l
                          ? ((s = Math.max(0, -(-p * u + d))),
                            (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)),
                            (h = -s * s + c * (c + 2 * f) + m))
                          : c <= l
                          ? ((s = 0),
                            (c = Math.min(Math.max(-u, -f), u)),
                            (h = c * (c + 2 * f) + m))
                          : ((s = Math.max(0, -(p * u + d))),
                            (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)),
                            (h = -s * s + c * (c + 2 * f) + m));
                    else
                      (c = p > 0 ? -u : u),
                        (s = Math.max(0, -(p * c + d))),
                        (h = -s * s + c * (c + 2 * f) + m);
                    return (
                      a &&
                        a
                          .copy(this.direction)
                          .multiplyScalar(s)
                          .add(this.origin),
                      o && o.copy(e).multiplyScalar(c).add(t),
                      h
                    );
                  };
                })(),
                intersectSphere: (function () {
                  var t = new a();
                  return function (e, n) {
                    t.subVectors(e.center, this.origin);
                    var r = t.dot(this.direction),
                      i = t.dot(t) - r * r,
                      a = e.radius * e.radius;
                    if (i > a) return null;
                    var o = Math.sqrt(a - i),
                      s = r - o,
                      c = r + o;
                    return s < 0 && c < 0
                      ? null
                      : s < 0
                      ? this.at(c, n)
                      : this.at(s, n);
                  };
                })(),
                intersectsSphere: function (t) {
                  return this.distanceToPoint(t.center) <= t.radius;
                },
                distanceToPlane: function (t) {
                  var e = t.normal.dot(this.direction);
                  if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                  var n = -(this.origin.dot(t.normal) + t.constant) / e;
                  return n >= 0 ? n : null;
                },
                intersectPlane: function (t, e) {
                  var n = this.distanceToPlane(t);
                  return null === n ? null : this.at(n, e);
                },
                intersectsPlane: function (t) {
                  var e = t.distanceToPoint(this.origin);
                  return 0 === e || t.normal.dot(this.direction) * e < 0;
                },
                intersectBox: function (t, e) {
                  var n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c = 1 / this.direction.x,
                    h = 1 / this.direction.y,
                    l = 1 / this.direction.z,
                    u = this.origin;
                  return (
                    c >= 0
                      ? ((n = (t.min.x - u.x) * c), (r = (t.max.x - u.x) * c))
                      : ((n = (t.max.x - u.x) * c), (r = (t.min.x - u.x) * c)),
                    h >= 0
                      ? ((i = (t.min.y - u.y) * h), (a = (t.max.y - u.y) * h))
                      : ((i = (t.max.y - u.y) * h), (a = (t.min.y - u.y) * h)),
                    n > a || i > r
                      ? null
                      : ((i > n || n !== n) && (n = i),
                        (a < r || r !== r) && (r = a),
                        l >= 0
                          ? ((o = (t.min.z - u.z) * l),
                            (s = (t.max.z - u.z) * l))
                          : ((o = (t.max.z - u.z) * l),
                            (s = (t.min.z - u.z) * l)),
                        n > s || o > r
                          ? null
                          : ((o > n || n !== n) && (n = o),
                            (s < r || r !== r) && (r = s),
                            r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                  );
                },
                intersectsBox: (function () {
                  var t = new a();
                  return function (e) {
                    return null !== this.intersectBox(e, t);
                  };
                })(),
                intersectTriangle: (function () {
                  var t = new a(),
                    e = new a(),
                    n = new a(),
                    r = new a();
                  return function (i, a, o, s, c) {
                    e.subVectors(a, i),
                      n.subVectors(o, i),
                      r.crossVectors(e, n);
                    var h,
                      l = this.direction.dot(r);
                    if (l > 0) {
                      if (s) return null;
                      h = 1;
                    } else {
                      if (!(l < 0)) return null;
                      (h = -1), (l = -l);
                    }
                    t.subVectors(this.origin, i);
                    var u = h * this.direction.dot(n.crossVectors(t, n));
                    if (u < 0) return null;
                    var p = h * this.direction.dot(e.cross(t));
                    if (p < 0) return null;
                    if (u + p > l) return null;
                    var d = -h * t.dot(r);
                    return d < 0 ? null : this.at(d / l, c);
                  };
                })(),
                applyMatrix4: function (t) {
                  return (
                    this.origin.applyMatrix4(t),
                    this.direction.transformDirection(t),
                    this
                  );
                },
                equals: function (t) {
                  return (
                    t.origin.equals(this.origin) &&
                    t.direction.equals(this.direction)
                  );
                },
              }),
              Object.assign(q, {
                getNormal: (function () {
                  var t = new a();
                  return function (e, n, r, i) {
                    void 0 === i &&
                      (console.warn(
                        "THREE.Triangle: .getNormal() target is now required"
                      ),
                      (i = new a())),
                      i.subVectors(r, n),
                      t.subVectors(e, n),
                      i.cross(t);
                    var o = i.lengthSq();
                    return o > 0
                      ? i.multiplyScalar(1 / Math.sqrt(o))
                      : i.set(0, 0, 0);
                  };
                })(),
                getBarycoord: (function () {
                  var t = new a(),
                    e = new a(),
                    n = new a();
                  return function (r, i, o, s, c) {
                    t.subVectors(s, i), e.subVectors(o, i), n.subVectors(r, i);
                    var h = t.dot(t),
                      l = t.dot(e),
                      u = t.dot(n),
                      p = e.dot(e),
                      d = e.dot(n),
                      f = h * p - l * l;
                    if (
                      (void 0 === c &&
                        (console.warn(
                          "THREE.Triangle: .getBarycoord() target is now required"
                        ),
                        (c = new a())),
                      0 === f)
                    )
                      return c.set(-2, -1, -1);
                    var m = 1 / f,
                      g = (p * u - l * d) * m,
                      v = (h * d - l * u) * m;
                    return c.set(1 - g - v, v, g);
                  };
                })(),
                containsPoint: (function () {
                  var t = new a();
                  return function (e, n, r, i) {
                    return (
                      q.getBarycoord(e, n, r, i, t),
                      t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    );
                  };
                })(),
              }),
              Object.assign(q.prototype, {
                set: function (t, e, n) {
                  return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
                },
                setFromPointsAndIndices: function (t, e, n, r) {
                  return (
                    this.a.copy(t[e]),
                    this.b.copy(t[n]),
                    this.c.copy(t[r]),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                  );
                },
                getArea: (function () {
                  var t = new a(),
                    e = new a();
                  return function () {
                    return (
                      t.subVectors(this.c, this.b),
                      e.subVectors(this.a, this.b),
                      0.5 * t.cross(e).length()
                    );
                  };
                })(),
                getMidpoint: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Triangle: .getMidpoint() target is now required"
                      ),
                      (t = new a())),
                    t
                      .addVectors(this.a, this.b)
                      .add(this.c)
                      .multiplyScalar(1 / 3)
                  );
                },
                getNormal: function (t) {
                  return q.getNormal(this.a, this.b, this.c, t);
                },
                getPlane: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Triangle: .getPlane() target is now required"
                      ),
                      (t = new a())),
                    t.setFromCoplanarPoints(this.a, this.b, this.c)
                  );
                },
                getBarycoord: function (t, e) {
                  return q.getBarycoord(t, this.a, this.b, this.c, e);
                },
                containsPoint: function (t) {
                  return q.containsPoint(t, this.a, this.b, this.c);
                },
                intersectsBox: function (t) {
                  return t.intersectsTriangle(this);
                },
                closestPointToPoint: (function () {
                  var t = new a(),
                    e = new a(),
                    n = new a(),
                    r = new a(),
                    i = new a(),
                    o = new a();
                  return function (s, c) {
                    void 0 === c &&
                      (console.warn(
                        "THREE.Triangle: .closestPointToPoint() target is now required"
                      ),
                      (c = new a()));
                    var h,
                      l,
                      u = this.a,
                      p = this.b,
                      d = this.c;
                    t.subVectors(p, u), e.subVectors(d, u), r.subVectors(s, u);
                    var f = t.dot(r),
                      m = e.dot(r);
                    if (f <= 0 && m <= 0) return c.copy(u);
                    i.subVectors(s, p);
                    var g = t.dot(i),
                      v = e.dot(i);
                    if (g >= 0 && v <= g) return c.copy(p);
                    var y = f * v - g * m;
                    if (y <= 0 && f >= 0 && g <= 0)
                      return (h = f / (f - g)), c.copy(u).addScaledVector(t, h);
                    o.subVectors(s, d);
                    var x = t.dot(o),
                      b = e.dot(o);
                    if (b >= 0 && x <= b) return c.copy(d);
                    var _ = x * m - f * b;
                    if (_ <= 0 && m >= 0 && b <= 0)
                      return (l = m / (m - b)), c.copy(u).addScaledVector(e, l);
                    var w = g * b - x * v;
                    if (w <= 0 && v - g >= 0 && x - b >= 0)
                      return (
                        n.subVectors(d, p),
                        (l = (v - g) / (v - g + (x - b))),
                        c.copy(p).addScaledVector(n, l)
                      );
                    var M = 1 / (w + _ + y);
                    return (
                      (h = _ * M),
                      (l = y * M),
                      c.copy(u).addScaledVector(t, h).addScaledVector(e, l)
                    );
                  };
                })(),
                equals: function (t) {
                  return (
                    t.a.equals(this.a) &&
                    t.b.equals(this.b) &&
                    t.c.equals(this.c)
                  );
                },
              }),
              (Y.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Y,
                isMesh: !0,
                setDrawMode: function (t) {
                  this.drawMode = t;
                },
                copy: function (t) {
                  return (
                    _.prototype.copy.call(this, t),
                    (this.drawMode = t.drawMode),
                    void 0 !== t.morphTargetInfluences &&
                      (this.morphTargetInfluences =
                        t.morphTargetInfluences.slice()),
                    void 0 !== t.morphTargetDictionary &&
                      (this.morphTargetDictionary = Object.assign(
                        {},
                        t.morphTargetDictionary
                      )),
                    this
                  );
                },
                updateMorphTargets: function () {
                  var t,
                    e,
                    n,
                    r = this.geometry;
                  if (r.isBufferGeometry) {
                    var i = r.morphAttributes,
                      a = Object.keys(i);
                    if (a.length > 0) {
                      var o = i[a[0]];
                      if (void 0 !== o)
                        for (
                          this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {},
                            t = 0,
                            e = o.length;
                          t < e;
                          t++
                        )
                          (n = o[t].name || String(t)),
                            this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[n] = t);
                    }
                  } else {
                    var s = r.morphTargets;
                    if (void 0 !== s && s.length > 0)
                      for (
                        this.morphTargetInfluences = [],
                          this.morphTargetDictionary = {},
                          t = 0,
                          e = s.length;
                        t < e;
                        t++
                      )
                        (n = s[t].name || String(t)),
                          this.morphTargetInfluences.push(0),
                          (this.morphTargetDictionary[n] = t);
                  }
                },
                raycast: (function () {
                  function t(t, e, n, r, i, a, o) {
                    return (
                      q.getBarycoord(t, e, n, r, x),
                      i.multiplyScalar(x.x),
                      a.multiplyScalar(x.y),
                      o.multiplyScalar(x.z),
                      i.add(a).add(o),
                      i.clone()
                    );
                  }
                  function e(t, e, n, r, i, a, o, s) {
                    if (
                      null ===
                      (e.side === co
                        ? r.intersectTriangle(o, a, i, !0, s)
                        : r.intersectTriangle(i, a, o, e.side !== ho, s))
                    )
                      return null;
                    _.copy(s), _.applyMatrix4(t.matrixWorld);
                    var c = n.ray.origin.distanceTo(_);
                    return c < n.near || c > n.far
                      ? null
                      : { distance: c, point: _.clone(), object: t };
                  }
                  function i(n, r, i, a, o, s, c, p, d) {
                    h.fromBufferAttribute(o, c),
                      l.fromBufferAttribute(o, p),
                      u.fromBufferAttribute(o, d);
                    var f = e(n, r, i, a, h, l, u, b);
                    if (f) {
                      s &&
                        (g.fromBufferAttribute(s, c),
                        v.fromBufferAttribute(s, p),
                        y.fromBufferAttribute(s, d),
                        (f.uv = t(b, h, l, u, g, v, y)));
                      var m = new E(c, p, d);
                      q.getNormal(h, l, u, m.normal), (f.face = m);
                    }
                    return f;
                  }
                  var o = new r(),
                    s = new X(),
                    c = new d(),
                    h = new a(),
                    l = new a(),
                    u = new a(),
                    p = new a(),
                    f = new a(),
                    m = new a(),
                    g = new n(),
                    v = new n(),
                    y = new n(),
                    x = new a(),
                    b = new a(),
                    _ = new a();
                  return function (n, r) {
                    var a = this.geometry,
                      d = this.material,
                      x = this.matrixWorld;
                    if (
                      void 0 !== d &&
                      (null === a.boundingSphere && a.computeBoundingSphere(),
                      c.copy(a.boundingSphere),
                      c.applyMatrix4(x),
                      !1 !== n.ray.intersectsSphere(c) &&
                        (o.getInverse(x),
                        s.copy(n.ray).applyMatrix4(o),
                        null === a.boundingBox ||
                          !1 !== s.intersectsBox(a.boundingBox)))
                    ) {
                      var _;
                      if (a.isBufferGeometry) {
                        var w,
                          M,
                          E,
                          T,
                          S,
                          A,
                          L,
                          R,
                          C,
                          P,
                          O,
                          I = a.index,
                          N = a.attributes.position,
                          D = a.attributes.uv,
                          U = a.groups,
                          B = a.drawRange;
                        if (null !== I)
                          if (Array.isArray(d))
                            for (T = 0, A = U.length; T < A; T++)
                              for (
                                R = U[T],
                                  C = d[R.materialIndex],
                                  P = Math.max(R.start, B.start),
                                  O = Math.min(
                                    R.start + R.count,
                                    B.start + B.count
                                  ),
                                  S = P,
                                  L = O;
                                S < L;
                                S += 3
                              )
                                (w = I.getX(S)),
                                  (M = I.getX(S + 1)),
                                  (E = I.getX(S + 2)),
                                  (_ = i(this, C, n, s, N, D, w, M, E)) &&
                                    ((_.faceIndex = Math.floor(S / 3)),
                                    r.push(_));
                          else
                            for (
                              P = Math.max(0, B.start),
                                O = Math.min(I.count, B.start + B.count),
                                T = P,
                                A = O;
                              T < A;
                              T += 3
                            )
                              (w = I.getX(T)),
                                (M = I.getX(T + 1)),
                                (E = I.getX(T + 2)),
                                (_ = i(this, d, n, s, N, D, w, M, E)) &&
                                  ((_.faceIndex = Math.floor(T / 3)),
                                  r.push(_));
                        else if (void 0 !== N)
                          if (Array.isArray(d))
                            for (T = 0, A = U.length; T < A; T++)
                              for (
                                R = U[T],
                                  C = d[R.materialIndex],
                                  P = Math.max(R.start, B.start),
                                  O = Math.min(
                                    R.start + R.count,
                                    B.start + B.count
                                  ),
                                  S = P,
                                  L = O;
                                S < L;
                                S += 3
                              )
                                (w = S),
                                  (M = S + 1),
                                  (E = S + 2),
                                  (_ = i(this, C, n, s, N, D, w, M, E)) &&
                                    ((_.faceIndex = Math.floor(S / 3)),
                                    r.push(_));
                          else
                            for (
                              P = Math.max(0, B.start),
                                O = Math.min(N.count, B.start + B.count),
                                T = P,
                                A = O;
                              T < A;
                              T += 3
                            )
                              (w = T),
                                (M = T + 1),
                                (E = T + 2),
                                (_ = i(this, d, n, s, N, D, w, M, E)) &&
                                  ((_.faceIndex = Math.floor(T / 3)),
                                  r.push(_));
                      } else if (a.isGeometry) {
                        var F,
                          z,
                          G,
                          H,
                          V = Array.isArray(d),
                          k = a.vertices,
                          j = a.faces,
                          W = a.faceVertexUvs[0];
                        W.length > 0 && (H = W);
                        for (var X = 0, q = j.length; X < q; X++) {
                          var Y = j[X],
                            J = V ? d[Y.materialIndex] : d;
                          if (void 0 !== J) {
                            if (
                              ((F = k[Y.a]),
                              (z = k[Y.b]),
                              (G = k[Y.c]),
                              !0 === J.morphTargets)
                            ) {
                              var Z = a.morphTargets,
                                Q = this.morphTargetInfluences;
                              h.set(0, 0, 0), l.set(0, 0, 0), u.set(0, 0, 0);
                              for (var K = 0, $ = Z.length; K < $; K++) {
                                var tt = Q[K];
                                if (0 !== tt) {
                                  var et = Z[K].vertices;
                                  h.addScaledVector(
                                    p.subVectors(et[Y.a], F),
                                    tt
                                  ),
                                    l.addScaledVector(
                                      f.subVectors(et[Y.b], z),
                                      tt
                                    ),
                                    u.addScaledVector(
                                      m.subVectors(et[Y.c], G),
                                      tt
                                    );
                                }
                              }
                              h.add(F),
                                l.add(z),
                                u.add(G),
                                (F = h),
                                (z = l),
                                (G = u);
                            }
                            if ((_ = e(this, J, n, s, F, z, G, b))) {
                              if (H && H[X]) {
                                var nt = H[X];
                                g.copy(nt[0]),
                                  v.copy(nt[1]),
                                  y.copy(nt[2]),
                                  (_.uv = t(b, F, z, G, g, v, y));
                              }
                              (_.face = Y), (_.faceIndex = X), r.push(_);
                            }
                          }
                        }
                      }
                    }
                  };
                })(),
                clone: function () {
                  return new this.constructor(
                    this.geometry,
                    this.material
                  ).copy(this);
                },
              })),
              (ot.prototype = Object.create(s.prototype)),
              (ot.prototype.constructor = ot),
              (ot.prototype.isCubeTexture = !0),
              Object.defineProperty(ot.prototype, "images", {
                get: function () {
                  return this.image;
                },
                set: function (t) {
                  this.image = t;
                },
              });
            var Pc = new s(),
              Oc = new ot(),
              Ic = [],
              Nc = [],
              Dc = new Float32Array(16),
              Uc = new Float32Array(9),
              Bc = new Float32Array(4);
            (Ft.prototype.updateCache = function (t) {
              var e = this.cache;
              t instanceof Float32Array &&
                e.length !== t.length &&
                (this.cache = new Float32Array(t.length)),
                lt(e, t);
            }),
              (zt.prototype.setValue = function (t, e, n) {
                for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                  var o = r[i];
                  o.setValue(t, e[o.id], n);
                }
              });
            var Fc = /([\w\d_]+)(\])?(\[|\.)?/g;
            (Vt.prototype.setValue = function (t, e, n) {
              var r = this.map[e];
              void 0 !== r && r.setValue(t, n, this.renderer);
            }),
              (Vt.prototype.setOptional = function (t, e, n) {
                var r = e[n];
                void 0 !== r && this.setValue(t, n, r);
              }),
              (Vt.upload = function (t, e, n, r) {
                for (var i = 0, a = e.length; i !== a; ++i) {
                  var o = e[i],
                    s = n[o.id];
                  !1 !== s.needsUpdate && o.setValue(t, s.value, r);
                }
              }),
              (Vt.seqWithValue = function (t, e) {
                for (var n = [], r = 0, i = t.length; r !== i; ++r) {
                  var a = t[r];
                  a.id in e && n.push(a);
                }
                return n;
              });
            var zc = 0,
              Gc = 0;
            (fe.prototype = Object.create(k.prototype)),
              (fe.prototype.constructor = fe),
              (fe.prototype.isMeshDepthMaterial = !0),
              (fe.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  (this.depthPacking = t.depthPacking),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.map = t.map),
                  (this.alphaMap = t.alphaMap),
                  (this.displacementMap = t.displacementMap),
                  (this.displacementScale = t.displacementScale),
                  (this.displacementBias = t.displacementBias),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  this
                );
              }),
              (me.prototype = Object.create(k.prototype)),
              (me.prototype.constructor = me),
              (me.prototype.isMeshDistanceMaterial = !0),
              (me.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.referencePosition.copy(t.referencePosition),
                  (this.nearDistance = t.nearDistance),
                  (this.farDistance = t.farDistance),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.map = t.map),
                  (this.alphaMap = t.alphaMap),
                  (this.displacementMap = t.displacementMap),
                  (this.displacementScale = t.displacementScale),
                  (this.displacementBias = t.displacementBias),
                  this
                );
              }),
              (be.prototype = Object.assign(Object.create(_.prototype), {
                constructor: be,
                isGroup: !0,
              })),
              (_e.prototype = Object.assign(Object.create(w.prototype), {
                constructor: _e,
                isPerspectiveCamera: !0,
                copy: function (t, e) {
                  return (
                    w.prototype.copy.call(this, t, e),
                    (this.fov = t.fov),
                    (this.zoom = t.zoom),
                    (this.near = t.near),
                    (this.far = t.far),
                    (this.focus = t.focus),
                    (this.aspect = t.aspect),
                    (this.view =
                      null === t.view ? null : Object.assign({}, t.view)),
                    (this.filmGauge = t.filmGauge),
                    (this.filmOffset = t.filmOffset),
                    this
                  );
                },
                setFocalLength: function (t) {
                  var e = (0.5 * this.getFilmHeight()) / t;
                  (this.fov = 2 * xc.RAD2DEG * Math.atan(e)),
                    this.updateProjectionMatrix();
                },
                getFocalLength: function () {
                  var t = Math.tan(0.5 * xc.DEG2RAD * this.fov);
                  return (0.5 * this.getFilmHeight()) / t;
                },
                getEffectiveFOV: function () {
                  return (
                    2 *
                    xc.RAD2DEG *
                    Math.atan(Math.tan(0.5 * xc.DEG2RAD * this.fov) / this.zoom)
                  );
                },
                getFilmWidth: function () {
                  return this.filmGauge * Math.min(this.aspect, 1);
                },
                getFilmHeight: function () {
                  return this.filmGauge / Math.max(this.aspect, 1);
                },
                setViewOffset: function (t, e, n, r, i, a) {
                  (this.aspect = t / e),
                    null === this.view &&
                      (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1,
                      }),
                    (this.view.enabled = !0),
                    (this.view.fullWidth = t),
                    (this.view.fullHeight = e),
                    (this.view.offsetX = n),
                    (this.view.offsetY = r),
                    (this.view.width = i),
                    (this.view.height = a),
                    this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                  null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                  var t = this.near,
                    e = (t * Math.tan(0.5 * xc.DEG2RAD * this.fov)) / this.zoom,
                    n = 2 * e,
                    r = this.aspect * n,
                    i = -0.5 * r,
                    a = this.view;
                  if (null !== this.view && this.view.enabled) {
                    var o = a.fullWidth,
                      s = a.fullHeight;
                    (i += (a.offsetX * r) / o),
                      (e -= (a.offsetY * n) / s),
                      (r *= a.width / o),
                      (n *= a.height / s);
                  }
                  var c = this.filmOffset;
                  0 !== c && (i += (t * c) / this.getFilmWidth()),
                    this.projectionMatrix.makePerspective(
                      i,
                      i + r,
                      e,
                      e - n,
                      t,
                      this.far
                    );
                },
                toJSON: function (t) {
                  var e = _.prototype.toJSON.call(this, t);
                  return (
                    (e.object.fov = this.fov),
                    (e.object.zoom = this.zoom),
                    (e.object.near = this.near),
                    (e.object.far = this.far),
                    (e.object.focus = this.focus),
                    (e.object.aspect = this.aspect),
                    null !== this.view &&
                      (e.object.view = Object.assign({}, this.view)),
                    (e.object.filmGauge = this.filmGauge),
                    (e.object.filmOffset = this.filmOffset),
                    e
                  );
                },
              })),
              (we.prototype = Object.assign(Object.create(_e.prototype), {
                constructor: we,
                isArrayCamera: !0,
              })),
              (Se.prototype.isFogExp2 = !0),
              (Se.prototype.clone = function () {
                return new Se(this.color, this.density);
              }),
              (Se.prototype.toJSON = function () {
                return {
                  type: "FogExp2",
                  color: this.color.getHex(),
                  density: this.density,
                };
              }),
              (Ae.prototype.isFog = !0),
              (Ae.prototype.clone = function () {
                return new Ae(this.color, this.near, this.far);
              }),
              (Ae.prototype.toJSON = function () {
                return {
                  type: "Fog",
                  color: this.color.getHex(),
                  near: this.near,
                  far: this.far,
                };
              }),
              (Le.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Le,
                copy: function (t, e) {
                  return (
                    _.prototype.copy.call(this, t, e),
                    null !== t.background &&
                      (this.background = t.background.clone()),
                    null !== t.fog && (this.fog = t.fog.clone()),
                    null !== t.overrideMaterial &&
                      (this.overrideMaterial = t.overrideMaterial.clone()),
                    (this.autoUpdate = t.autoUpdate),
                    (this.matrixAutoUpdate = t.matrixAutoUpdate),
                    this
                  );
                },
                toJSON: function (t) {
                  var e = _.prototype.toJSON.call(this, t);
                  return (
                    null !== this.background &&
                      (e.object.background = this.background.toJSON(t)),
                    null !== this.fog && (e.object.fog = this.fog.toJSON()),
                    e
                  );
                },
              })),
              Object.defineProperty(Re.prototype, "needsUpdate", {
                set: function (t) {
                  !0 === t && this.version++;
                },
              }),
              Object.assign(Re.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function () {},
                setArray: function (t) {
                  if (Array.isArray(t))
                    throw new TypeError(
                      "THREE.BufferAttribute: array should be a Typed Array."
                    );
                  return (
                    (this.count = void 0 !== t ? t.length / this.stride : 0),
                    (this.array = t),
                    this
                  );
                },
                setDynamic: function (t) {
                  return (this.dynamic = t), this;
                },
                copy: function (t) {
                  return (
                    (this.array = new t.array.constructor(t.array)),
                    (this.count = t.count),
                    (this.stride = t.stride),
                    (this.dynamic = t.dynamic),
                    this
                  );
                },
                copyAt: function (t, e, n) {
                  (t *= this.stride), (n *= e.stride);
                  for (var r = 0, i = this.stride; r < i; r++)
                    this.array[t + r] = e.array[n + r];
                  return this;
                },
                set: function (t, e) {
                  return void 0 === e && (e = 0), this.array.set(t, e), this;
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                onUpload: function (t) {
                  return (this.onUploadCallback = t), this;
                },
              }),
              Object.defineProperties(Ce.prototype, {
                count: {
                  get: function () {
                    return this.data.count;
                  },
                },
                array: {
                  get: function () {
                    return this.data.array;
                  },
                },
              }),
              Object.assign(Ce.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function (t, e) {
                  return (
                    (this.data.array[t * this.data.stride + this.offset] = e),
                    this
                  );
                },
                setY: function (t, e) {
                  return (
                    (this.data.array[t * this.data.stride + this.offset + 1] =
                      e),
                    this
                  );
                },
                setZ: function (t, e) {
                  return (
                    (this.data.array[t * this.data.stride + this.offset + 2] =
                      e),
                    this
                  );
                },
                setW: function (t, e) {
                  return (
                    (this.data.array[t * this.data.stride + this.offset + 3] =
                      e),
                    this
                  );
                },
                getX: function (t) {
                  return this.data.array[t * this.data.stride + this.offset];
                },
                getY: function (t) {
                  return this.data.array[
                    t * this.data.stride + this.offset + 1
                  ];
                },
                getZ: function (t) {
                  return this.data.array[
                    t * this.data.stride + this.offset + 2
                  ];
                },
                getW: function (t) {
                  return this.data.array[
                    t * this.data.stride + this.offset + 3
                  ];
                },
                setXY: function (t, e, n) {
                  return (
                    (t = t * this.data.stride + this.offset),
                    (this.data.array[t + 0] = e),
                    (this.data.array[t + 1] = n),
                    this
                  );
                },
                setXYZ: function (t, e, n, r) {
                  return (
                    (t = t * this.data.stride + this.offset),
                    (this.data.array[t + 0] = e),
                    (this.data.array[t + 1] = n),
                    (this.data.array[t + 2] = r),
                    this
                  );
                },
                setXYZW: function (t, e, n, r, i) {
                  return (
                    (t = t * this.data.stride + this.offset),
                    (this.data.array[t + 0] = e),
                    (this.data.array[t + 1] = n),
                    (this.data.array[t + 2] = r),
                    (this.data.array[t + 3] = i),
                    this
                  );
                },
              }),
              (Pe.prototype = Object.create(k.prototype)),
              (Pe.prototype.constructor = Pe),
              (Pe.prototype.isSpriteMaterial = !0),
              (Pe.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  (this.map = t.map),
                  (this.rotation = t.rotation),
                  this
                );
              });
            var Hc;
            (Oe.prototype = Object.assign(Object.create(_.prototype), {
              constructor: Oe,
              isSprite: !0,
              raycast: (function () {
                function t(t, e, n, r, i, a) {
                  s.subVectors(t, n).addScalar(0.5).multiply(r),
                    void 0 !== i
                      ? ((c.x = a * s.x - i * s.y), (c.y = i * s.x + a * s.y))
                      : c.copy(s),
                    t.copy(e),
                    (t.x += c.x),
                    (t.y += c.y),
                    t.applyMatrix4(h);
                }
                var e = new a(),
                  i = new a(),
                  o = new a(),
                  s = new n(),
                  c = new n(),
                  h = new r(),
                  l = new a(),
                  u = new a(),
                  p = new a();
                return function (n, r) {
                  i.setFromMatrixScale(this.matrixWorld),
                    h
                      .getInverse(this.modelViewMatrix)
                      .premultiply(this.matrixWorld),
                    o.setFromMatrixPosition(this.modelViewMatrix);
                  var a,
                    s,
                    c = this.material.rotation;
                  0 !== c && ((s = Math.cos(c)), (a = Math.sin(c)));
                  var d = this.center;
                  t(l.set(-0.5, -0.5, 0), o, d, i, a, s),
                    t(u.set(0.5, -0.5, 0), o, d, i, a, s),
                    t(p.set(0.5, 0.5, 0), o, d, i, a, s);
                  var f = n.ray.intersectTriangle(l, u, p, !1, e);
                  if (
                    null !== f ||
                    (t(u.set(-0.5, 0.5, 0), o, d, i, a, s),
                    null !== (f = n.ray.intersectTriangle(l, p, u, !1, e)))
                  ) {
                    var m = n.ray.origin.distanceTo(e);
                    m < n.near ||
                      m > n.far ||
                      r.push({
                        distance: m,
                        point: e.clone(),
                        face: null,
                        object: this,
                      });
                  }
                };
              })(),
              clone: function () {
                return new this.constructor(this.material).copy(this);
              },
              copy: function (t) {
                return (
                  _.prototype.copy.call(this, t),
                  void 0 !== t.center && this.center.copy(t.center),
                  this
                );
              },
            })),
              (Ie.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Ie,
                copy: function (t) {
                  _.prototype.copy.call(this, t, !1);
                  for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    this.addLevel(i.object.clone(), i.distance);
                  }
                  return this;
                },
                addLevel: function (t, e) {
                  void 0 === e && (e = 0), (e = Math.abs(e));
                  for (
                    var n = this.levels, r = 0;
                    r < n.length && !(e < n[r].distance);
                    r++
                  );
                  n.splice(r, 0, { distance: e, object: t }), this.add(t);
                },
                getObjectForDistance: function (t) {
                  for (
                    var e = this.levels, n = 1, r = e.length;
                    n < r && !(t < e[n].distance);
                    n++
                  );
                  return e[n - 1].object;
                },
                raycast: (function () {
                  var t = new a();
                  return function (e, n) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var r = e.ray.origin.distanceTo(t);
                    this.getObjectForDistance(r).raycast(e, n);
                  };
                })(),
                update: (function () {
                  var t = new a(),
                    e = new a();
                  return function (n) {
                    var r = this.levels;
                    if (r.length > 1) {
                      t.setFromMatrixPosition(n.matrixWorld),
                        e.setFromMatrixPosition(this.matrixWorld);
                      var i = t.distanceTo(e);
                      r[0].object.visible = !0;
                      for (
                        var a = 1, o = r.length;
                        a < o && i >= r[a].distance;
                        a++
                      )
                        (r[a - 1].object.visible = !1),
                          (r[a].object.visible = !0);
                      for (; a < o; a++) r[a].object.visible = !1;
                    }
                  };
                })(),
                toJSON: function (t) {
                  var e = _.prototype.toJSON.call(this, t);
                  e.object.levels = [];
                  for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    e.object.levels.push({
                      object: a.object.uuid,
                      distance: a.distance,
                    });
                  }
                  return e;
                },
              })),
              Object.assign(Ne.prototype, {
                calculateInverses: function () {
                  this.boneInverses = [];
                  for (var t = 0, e = this.bones.length; t < e; t++) {
                    var n = new r();
                    this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                      this.boneInverses.push(n);
                  }
                },
                pose: function () {
                  var t, e, n;
                  for (e = 0, n = this.bones.length; e < n; e++)
                    (t = this.bones[e]) &&
                      t.matrixWorld.getInverse(this.boneInverses[e]);
                  for (e = 0, n = this.bones.length; e < n; e++)
                    (t = this.bones[e]) &&
                      (t.parent && t.parent.isBone
                        ? (t.matrix.getInverse(t.parent.matrixWorld),
                          t.matrix.multiply(t.matrixWorld))
                        : t.matrix.copy(t.matrixWorld),
                      t.matrix.decompose(t.position, t.quaternion, t.scale));
                },
                update: (function () {
                  var t = new r(),
                    e = new r();
                  return function () {
                    for (
                      var n = this.bones,
                        r = this.boneInverses,
                        i = this.boneMatrices,
                        a = this.boneTexture,
                        o = 0,
                        s = n.length;
                      o < s;
                      o++
                    ) {
                      var c = n[o] ? n[o].matrixWorld : e;
                      t.multiplyMatrices(c, r[o]), t.toArray(i, 16 * o);
                    }
                    void 0 !== a && (a.needsUpdate = !0);
                  };
                })(),
                clone: function () {
                  return new Ne(this.bones, this.boneInverses);
                },
                getBoneByName: function (t) {
                  for (var e = 0, n = this.bones.length; e < n; e++) {
                    var r = this.bones[e];
                    if (r.name === t) return r;
                  }
                },
              }),
              (De.prototype = Object.assign(Object.create(_.prototype), {
                constructor: De,
                isBone: !0,
              })),
              (Ue.prototype = Object.assign(Object.create(Y.prototype), {
                constructor: Ue,
                isSkinnedMesh: !0,
                initBones: function () {
                  var t,
                    e,
                    n,
                    r,
                    i = [];
                  if (this.geometry && void 0 !== this.geometry.bones) {
                    for (n = 0, r = this.geometry.bones.length; n < r; n++)
                      (e = this.geometry.bones[n]),
                        (t = new De()),
                        i.push(t),
                        (t.name = e.name),
                        t.position.fromArray(e.pos),
                        t.quaternion.fromArray(e.rotq),
                        void 0 !== e.scl && t.scale.fromArray(e.scl);
                    for (n = 0, r = this.geometry.bones.length; n < r; n++)
                      (e = this.geometry.bones[n]),
                        -1 !== e.parent &&
                        null !== e.parent &&
                        void 0 !== i[e.parent]
                          ? i[e.parent].add(i[n])
                          : this.add(i[n]);
                  }
                  return this.updateMatrixWorld(!0), i;
                },
                bind: function (t, e) {
                  (this.skeleton = t),
                    void 0 === e &&
                      (this.updateMatrixWorld(!0),
                      this.skeleton.calculateInverses(),
                      (e = this.matrixWorld)),
                    this.bindMatrix.copy(e),
                    this.bindMatrixInverse.getInverse(e);
                },
                pose: function () {
                  this.skeleton.pose();
                },
                normalizeSkinWeights: function () {
                  var t, e;
                  if (this.geometry && this.geometry.isGeometry)
                    for (e = 0; e < this.geometry.skinWeights.length; e++) {
                      var n = this.geometry.skinWeights[e];
                      (t = 1 / n.manhattanLength()),
                        t !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0);
                    }
                  else if (this.geometry && this.geometry.isBufferGeometry) {
                    var r = new c(),
                      i = this.geometry.attributes.skinWeight;
                    for (e = 0; e < i.count; e++)
                      (r.x = i.getX(e)),
                        (r.y = i.getY(e)),
                        (r.z = i.getZ(e)),
                        (r.w = i.getW(e)),
                        (t = 1 / r.manhattanLength()),
                        t !== 1 / 0 ? r.multiplyScalar(t) : r.set(1, 0, 0, 0),
                        i.setXYZW(e, r.x, r.y, r.z, r.w);
                  }
                },
                updateMatrixWorld: function (t) {
                  Y.prototype.updateMatrixWorld.call(this, t),
                    "attached" === this.bindMode
                      ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                      : "detached" === this.bindMode
                      ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                      : console.warn(
                          "THREE.SkinnedMesh: Unrecognized bindMode: " +
                            this.bindMode
                        );
                },
                clone: function () {
                  return new this.constructor(
                    this.geometry,
                    this.material
                  ).copy(this);
                },
              })),
              (Be.prototype = Object.create(k.prototype)),
              (Be.prototype.constructor = Be),
              (Be.prototype.isLineBasicMaterial = !0),
              (Be.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  (this.linewidth = t.linewidth),
                  (this.linecap = t.linecap),
                  (this.linejoin = t.linejoin),
                  this
                );
              }),
              (Fe.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Fe,
                isLine: !0,
                computeLineDistances: (function () {
                  var t = new a(),
                    e = new a();
                  return function () {
                    var n = this.geometry;
                    if (n.isBufferGeometry)
                      if (null === n.index) {
                        for (
                          var r = n.attributes.position,
                            i = [0],
                            a = 1,
                            o = r.count;
                          a < o;
                          a++
                        )
                          t.fromBufferAttribute(r, a - 1),
                            e.fromBufferAttribute(r, a),
                            (i[a] = i[a - 1]),
                            (i[a] += t.distanceTo(e));
                        n.addAttribute("lineDistance", new N(i, 1));
                      } else
                        console.warn(
                          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                        );
                    else if (n.isGeometry) {
                      var s = n.vertices,
                        i = n.lineDistances;
                      i[0] = 0;
                      for (var a = 1, o = s.length; a < o; a++)
                        (i[a] = i[a - 1]), (i[a] += s[a - 1].distanceTo(s[a]));
                    }
                    return this;
                  };
                })(),
                raycast: (function () {
                  var t = new r(),
                    e = new X(),
                    n = new d();
                  return function (r, i) {
                    var o = r.linePrecision,
                      s = o * o,
                      c = this.geometry,
                      h = this.matrixWorld;
                    if (
                      (null === c.boundingSphere && c.computeBoundingSphere(),
                      n.copy(c.boundingSphere),
                      n.applyMatrix4(h),
                      !1 !== r.ray.intersectsSphere(n))
                    ) {
                      t.getInverse(h), e.copy(r.ray).applyMatrix4(t);
                      var l = new a(),
                        u = new a(),
                        p = new a(),
                        d = new a(),
                        f = this && this.isLineSegments ? 2 : 1;
                      if (c.isBufferGeometry) {
                        var m = c.index,
                          g = c.attributes,
                          v = g.position.array;
                        if (null !== m)
                          for (
                            var y = m.array, x = 0, b = y.length - 1;
                            x < b;
                            x += f
                          ) {
                            var _ = y[x],
                              w = y[x + 1];
                            l.fromArray(v, 3 * _), u.fromArray(v, 3 * w);
                            var M = e.distanceSqToSegment(l, u, d, p);
                            if (!(M > s)) {
                              d.applyMatrix4(this.matrixWorld);
                              var E = r.ray.origin.distanceTo(d);
                              E < r.near ||
                                E > r.far ||
                                i.push({
                                  distance: E,
                                  point: p
                                    .clone()
                                    .applyMatrix4(this.matrixWorld),
                                  index: x,
                                  face: null,
                                  faceIndex: null,
                                  object: this,
                                });
                            }
                          }
                        else
                          for (var x = 0, b = v.length / 3 - 1; x < b; x += f) {
                            l.fromArray(v, 3 * x), u.fromArray(v, 3 * x + 3);
                            var M = e.distanceSqToSegment(l, u, d, p);
                            if (!(M > s)) {
                              d.applyMatrix4(this.matrixWorld);
                              var E = r.ray.origin.distanceTo(d);
                              E < r.near ||
                                E > r.far ||
                                i.push({
                                  distance: E,
                                  point: p
                                    .clone()
                                    .applyMatrix4(this.matrixWorld),
                                  index: x,
                                  face: null,
                                  faceIndex: null,
                                  object: this,
                                });
                            }
                          }
                      } else if (c.isGeometry)
                        for (
                          var T = c.vertices, S = T.length, x = 0;
                          x < S - 1;
                          x += f
                        ) {
                          var M = e.distanceSqToSegment(T[x], T[x + 1], d, p);
                          if (!(M > s)) {
                            d.applyMatrix4(this.matrixWorld);
                            var E = r.ray.origin.distanceTo(d);
                            E < r.near ||
                              E > r.far ||
                              i.push({
                                distance: E,
                                point: p.clone().applyMatrix4(this.matrixWorld),
                                index: x,
                                face: null,
                                faceIndex: null,
                                object: this,
                              });
                          }
                        }
                    }
                  };
                })(),
                clone: function () {
                  return new this.constructor(
                    this.geometry,
                    this.material
                  ).copy(this);
                },
              })),
              (ze.prototype = Object.assign(Object.create(Fe.prototype), {
                constructor: ze,
                isLineSegments: !0,
                computeLineDistances: (function () {
                  var t = new a(),
                    e = new a();
                  return function () {
                    var n = this.geometry;
                    if (n.isBufferGeometry)
                      if (null === n.index) {
                        for (
                          var r = n.attributes.position,
                            i = [],
                            a = 0,
                            o = r.count;
                          a < o;
                          a += 2
                        )
                          t.fromBufferAttribute(r, a),
                            e.fromBufferAttribute(r, a + 1),
                            (i[a] = 0 === a ? 0 : i[a - 1]),
                            (i[a + 1] = i[a] + t.distanceTo(e));
                        n.addAttribute("lineDistance", new N(i, 1));
                      } else
                        console.warn(
                          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                        );
                    else if (n.isGeometry)
                      for (
                        var s = n.vertices,
                          i = n.lineDistances,
                          a = 0,
                          o = s.length;
                        a < o;
                        a += 2
                      )
                        t.copy(s[a]),
                          e.copy(s[a + 1]),
                          (i[a] = 0 === a ? 0 : i[a - 1]),
                          (i[a + 1] = i[a] + t.distanceTo(e));
                    return this;
                  };
                })(),
              })),
              (Ge.prototype = Object.assign(Object.create(Fe.prototype), {
                constructor: Ge,
                isLineLoop: !0,
              })),
              (He.prototype = Object.create(k.prototype)),
              (He.prototype.constructor = He),
              (He.prototype.isPointsMaterial = !0),
              (He.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  (this.map = t.map),
                  (this.size = t.size),
                  (this.sizeAttenuation = t.sizeAttenuation),
                  (this.morphTargets = t.morphTargets),
                  this
                );
              }),
              (Ve.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Ve,
                isPoints: !0,
                raycast: (function () {
                  var t = new r(),
                    e = new X(),
                    n = new d();
                  return function (r, i) {
                    function o(t, n) {
                      var a = e.distanceSqToPoint(t);
                      if (a < p) {
                        e.closestPointToPoint(t, f), f.applyMatrix4(h);
                        var o = r.ray.origin.distanceTo(f);
                        if (o < r.near || o > r.far) return;
                        i.push({
                          distance: o,
                          distanceToRay: Math.sqrt(a),
                          point: f.clone(),
                          index: n,
                          face: null,
                          object: s,
                        });
                      }
                    }
                    var s = this,
                      c = this.geometry,
                      h = this.matrixWorld,
                      l = r.params.Points.threshold;
                    if (
                      (null === c.boundingSphere && c.computeBoundingSphere(),
                      n.copy(c.boundingSphere),
                      n.applyMatrix4(h),
                      (n.radius += l),
                      !1 !== r.ray.intersectsSphere(n))
                    ) {
                      t.getInverse(h), e.copy(r.ray).applyMatrix4(t);
                      var u =
                          l /
                          ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        p = u * u,
                        d = new a(),
                        f = new a();
                      if (c.isBufferGeometry) {
                        var m = c.index,
                          g = c.attributes,
                          v = g.position.array;
                        if (null !== m)
                          for (
                            var y = m.array, x = 0, b = y.length;
                            x < b;
                            x++
                          ) {
                            var _ = y[x];
                            d.fromArray(v, 3 * _), o(d, _);
                          }
                        else
                          for (var x = 0, w = v.length / 3; x < w; x++)
                            d.fromArray(v, 3 * x), o(d, x);
                      } else
                        for (
                          var M = c.vertices, x = 0, w = M.length;
                          x < w;
                          x++
                        )
                          o(M[x], x);
                    }
                  };
                })(),
                clone: function () {
                  return new this.constructor(
                    this.geometry,
                    this.material
                  ).copy(this);
                },
              })),
              (ke.prototype = Object.assign(Object.create(s.prototype), {
                constructor: ke,
                isVideoTexture: !0,
                update: function () {
                  var t = this.image;
                  t.readyState >= t.HAVE_CURRENT_DATA &&
                    (this.needsUpdate = !0);
                },
              })),
              (je.prototype = Object.create(s.prototype)),
              (je.prototype.constructor = je),
              (je.prototype.isCompressedTexture = !0),
              (We.prototype = Object.create(s.prototype)),
              (We.prototype.constructor = We),
              (We.prototype.isCanvasTexture = !0),
              (Xe.prototype = Object.create(s.prototype)),
              (Xe.prototype.constructor = Xe),
              (Xe.prototype.isDepthTexture = !0),
              (qe.prototype = Object.create(F.prototype)),
              (qe.prototype.constructor = qe),
              (Ye.prototype = Object.create(T.prototype)),
              (Ye.prototype.constructor = Ye),
              (Je.prototype = Object.create(F.prototype)),
              (Je.prototype.constructor = Je),
              (Ze.prototype = Object.create(T.prototype)),
              (Ze.prototype.constructor = Ze),
              (Qe.prototype = Object.create(F.prototype)),
              (Qe.prototype.constructor = Qe),
              (Ke.prototype = Object.create(T.prototype)),
              (Ke.prototype.constructor = Ke),
              ($e.prototype = Object.create(Qe.prototype)),
              ($e.prototype.constructor = $e),
              (tn.prototype = Object.create(T.prototype)),
              (tn.prototype.constructor = tn),
              (en.prototype = Object.create(Qe.prototype)),
              (en.prototype.constructor = en),
              (nn.prototype = Object.create(T.prototype)),
              (nn.prototype.constructor = nn),
              (rn.prototype = Object.create(Qe.prototype)),
              (rn.prototype.constructor = rn),
              (an.prototype = Object.create(T.prototype)),
              (an.prototype.constructor = an),
              (on.prototype = Object.create(Qe.prototype)),
              (on.prototype.constructor = on),
              (sn.prototype = Object.create(T.prototype)),
              (sn.prototype.constructor = sn),
              (cn.prototype = Object.create(F.prototype)),
              (cn.prototype.constructor = cn),
              (hn.prototype = Object.create(T.prototype)),
              (hn.prototype.constructor = hn),
              (ln.prototype = Object.create(F.prototype)),
              (ln.prototype.constructor = ln),
              (un.prototype = Object.create(T.prototype)),
              (un.prototype.constructor = un),
              (pn.prototype = Object.create(F.prototype)),
              (pn.prototype.constructor = pn);
            var Vc = {
                triangulate: function (t, e, n) {
                  n = n || 2;
                  var r = e && e.length,
                    i = r ? e[0] * n : t.length,
                    a = dn(t, 0, i, n, !0),
                    o = [];
                  if (!a) return o;
                  var s, c, h, l, u, p, d;
                  if ((r && (a = bn(t, e, a, n)), t.length > 80 * n)) {
                    (s = h = t[0]), (c = l = t[1]);
                    for (var f = n; f < i; f += n)
                      (u = t[f]),
                        (p = t[f + 1]),
                        u < s && (s = u),
                        p < c && (c = p),
                        u > h && (h = u),
                        p > l && (l = p);
                    (d = Math.max(h - s, l - c)), (d = 0 !== d ? 1 / d : 0);
                  }
                  return mn(a, o, n, s, c, d), o;
                },
              },
              kc = {
                area: function (t) {
                  for (
                    var e = t.length, n = 0, r = e - 1, i = 0;
                    i < e;
                    r = i++
                  )
                    n += t[r].x * t[i].y - t[i].x * t[r].y;
                  return 0.5 * n;
                },
                isClockWise: function (t) {
                  return kc.area(t) < 0;
                },
                triangulateShape: function (t, e) {
                  var n = [],
                    r = [],
                    i = [];
                  Hn(t), Vn(n, t);
                  var a = t.length;
                  e.forEach(Hn);
                  for (var o = 0; o < e.length; o++)
                    r.push(a), (a += e[o].length), Vn(n, e[o]);
                  for (
                    var s = Vc.triangulate(n, r), o = 0;
                    o < s.length;
                    o += 3
                  )
                    i.push(s.slice(o, o + 3));
                  return i;
                },
              };
            (kn.prototype = Object.create(T.prototype)),
              (kn.prototype.constructor = kn),
              (kn.prototype.toJSON = function () {
                var t = T.prototype.toJSON.call(this);
                return Wn(this.parameters.shapes, this.parameters.options, t);
              }),
              (jn.prototype = Object.create(F.prototype)),
              (jn.prototype.constructor = jn),
              (jn.prototype.toJSON = function () {
                var t = F.prototype.toJSON.call(this);
                return Wn(this.parameters.shapes, this.parameters.options, t);
              });
            var jc = {
              generateTopUV: function (t, e, r, i, a) {
                var o = e[3 * r],
                  s = e[3 * r + 1],
                  c = e[3 * i],
                  h = e[3 * i + 1],
                  l = e[3 * a],
                  u = e[3 * a + 1];
                return [new n(o, s), new n(c, h), new n(l, u)];
              },
              generateSideWallUV: function (t, e, r, i, a, o) {
                var s = e[3 * r],
                  c = e[3 * r + 1],
                  h = e[3 * r + 2],
                  l = e[3 * i],
                  u = e[3 * i + 1],
                  p = e[3 * i + 2],
                  d = e[3 * a],
                  f = e[3 * a + 1],
                  m = e[3 * a + 2],
                  g = e[3 * o],
                  v = e[3 * o + 1],
                  y = e[3 * o + 2];
                return Math.abs(c - u) < 0.01
                  ? [
                      new n(s, 1 - h),
                      new n(l, 1 - p),
                      new n(d, 1 - m),
                      new n(g, 1 - y),
                    ]
                  : [
                      new n(c, 1 - h),
                      new n(u, 1 - p),
                      new n(f, 1 - m),
                      new n(v, 1 - y),
                    ];
              },
            };
            (Xn.prototype = Object.create(T.prototype)),
              (Xn.prototype.constructor = Xn),
              (qn.prototype = Object.create(jn.prototype)),
              (qn.prototype.constructor = qn),
              (Yn.prototype = Object.create(T.prototype)),
              (Yn.prototype.constructor = Yn),
              (Jn.prototype = Object.create(F.prototype)),
              (Jn.prototype.constructor = Jn),
              (Zn.prototype = Object.create(T.prototype)),
              (Zn.prototype.constructor = Zn),
              (Qn.prototype = Object.create(F.prototype)),
              (Qn.prototype.constructor = Qn),
              (Kn.prototype = Object.create(T.prototype)),
              (Kn.prototype.constructor = Kn),
              ($n.prototype = Object.create(F.prototype)),
              ($n.prototype.constructor = $n),
              (tr.prototype = Object.create(T.prototype)),
              (tr.prototype.constructor = tr),
              (tr.prototype.toJSON = function () {
                var t = T.prototype.toJSON.call(this);
                return nr(this.parameters.shapes, t);
              }),
              (er.prototype = Object.create(F.prototype)),
              (er.prototype.constructor = er),
              (er.prototype.toJSON = function () {
                var t = F.prototype.toJSON.call(this);
                return nr(this.parameters.shapes, t);
              }),
              (rr.prototype = Object.create(F.prototype)),
              (rr.prototype.constructor = rr),
              (ir.prototype = Object.create(T.prototype)),
              (ir.prototype.constructor = ir),
              (ar.prototype = Object.create(F.prototype)),
              (ar.prototype.constructor = ar),
              (or.prototype = Object.create(ir.prototype)),
              (or.prototype.constructor = or),
              (sr.prototype = Object.create(ar.prototype)),
              (sr.prototype.constructor = sr),
              (cr.prototype = Object.create(T.prototype)),
              (cr.prototype.constructor = cr),
              (hr.prototype = Object.create(F.prototype)),
              (hr.prototype.constructor = hr);
            var Wc = Object.freeze({
              WireframeGeometry: qe,
              ParametricGeometry: Ye,
              ParametricBufferGeometry: Je,
              TetrahedronGeometry: Ke,
              TetrahedronBufferGeometry: $e,
              OctahedronGeometry: tn,
              OctahedronBufferGeometry: en,
              IcosahedronGeometry: nn,
              IcosahedronBufferGeometry: rn,
              DodecahedronGeometry: an,
              DodecahedronBufferGeometry: on,
              PolyhedronGeometry: Ze,
              PolyhedronBufferGeometry: Qe,
              TubeGeometry: sn,
              TubeBufferGeometry: cn,
              TorusKnotGeometry: hn,
              TorusKnotBufferGeometry: ln,
              TorusGeometry: un,
              TorusBufferGeometry: pn,
              TextGeometry: Xn,
              TextBufferGeometry: qn,
              SphereGeometry: Yn,
              SphereBufferGeometry: Jn,
              RingGeometry: Zn,
              RingBufferGeometry: Qn,
              PlaneGeometry: H,
              PlaneBufferGeometry: V,
              LatheGeometry: Kn,
              LatheBufferGeometry: $n,
              ShapeGeometry: tr,
              ShapeBufferGeometry: er,
              ExtrudeGeometry: kn,
              ExtrudeBufferGeometry: jn,
              EdgesGeometry: rr,
              ConeGeometry: or,
              ConeBufferGeometry: sr,
              CylinderGeometry: ir,
              CylinderBufferGeometry: ar,
              CircleGeometry: cr,
              CircleBufferGeometry: hr,
              BoxGeometry: z,
              BoxBufferGeometry: G,
            });
            (lr.prototype = Object.create(k.prototype)),
              (lr.prototype.constructor = lr),
              (lr.prototype.isShadowMaterial = !0),
              (lr.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t), this.color.copy(t.color), this
                );
              }),
              (ur.prototype = Object.create(W.prototype)),
              (ur.prototype.constructor = ur),
              (ur.prototype.isRawShaderMaterial = !0),
              (pr.prototype = Object.create(k.prototype)),
              (pr.prototype.constructor = pr),
              (pr.prototype.isMeshStandardMaterial = !0),
              (pr.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  (this.defines = { STANDARD: "" }),
                  this.color.copy(t.color),
                  (this.roughness = t.roughness),
                  (this.metalness = t.metalness),
                  (this.map = t.map),
                  (this.lightMap = t.lightMap),
                  (this.lightMapIntensity = t.lightMapIntensity),
                  (this.aoMap = t.aoMap),
                  (this.aoMapIntensity = t.aoMapIntensity),
                  this.emissive.copy(t.emissive),
                  (this.emissiveMap = t.emissiveMap),
                  (this.emissiveIntensity = t.emissiveIntensity),
                  (this.bumpMap = t.bumpMap),
                  (this.bumpScale = t.bumpScale),
                  (this.normalMap = t.normalMap),
                  (this.normalMapType = t.normalMapType),
                  this.normalScale.copy(t.normalScale),
                  (this.displacementMap = t.displacementMap),
                  (this.displacementScale = t.displacementScale),
                  (this.displacementBias = t.displacementBias),
                  (this.roughnessMap = t.roughnessMap),
                  (this.metalnessMap = t.metalnessMap),
                  (this.alphaMap = t.alphaMap),
                  (this.envMap = t.envMap),
                  (this.envMapIntensity = t.envMapIntensity),
                  (this.refractionRatio = t.refractionRatio),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.wireframeLinecap = t.wireframeLinecap),
                  (this.wireframeLinejoin = t.wireframeLinejoin),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.morphNormals = t.morphNormals),
                  this
                );
              }),
              (dr.prototype = Object.create(pr.prototype)),
              (dr.prototype.constructor = dr),
              (dr.prototype.isMeshPhysicalMaterial = !0),
              (dr.prototype.copy = function (t) {
                return (
                  pr.prototype.copy.call(this, t),
                  (this.defines = { PHYSICAL: "" }),
                  (this.reflectivity = t.reflectivity),
                  (this.clearCoat = t.clearCoat),
                  (this.clearCoatRoughness = t.clearCoatRoughness),
                  this
                );
              }),
              (fr.prototype = Object.create(k.prototype)),
              (fr.prototype.constructor = fr),
              (fr.prototype.isMeshPhongMaterial = !0),
              (fr.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  this.specular.copy(t.specular),
                  (this.shininess = t.shininess),
                  (this.map = t.map),
                  (this.lightMap = t.lightMap),
                  (this.lightMapIntensity = t.lightMapIntensity),
                  (this.aoMap = t.aoMap),
                  (this.aoMapIntensity = t.aoMapIntensity),
                  this.emissive.copy(t.emissive),
                  (this.emissiveMap = t.emissiveMap),
                  (this.emissiveIntensity = t.emissiveIntensity),
                  (this.bumpMap = t.bumpMap),
                  (this.bumpScale = t.bumpScale),
                  (this.normalMap = t.normalMap),
                  (this.normalMapType = t.normalMapType),
                  this.normalScale.copy(t.normalScale),
                  (this.displacementMap = t.displacementMap),
                  (this.displacementScale = t.displacementScale),
                  (this.displacementBias = t.displacementBias),
                  (this.specularMap = t.specularMap),
                  (this.alphaMap = t.alphaMap),
                  (this.envMap = t.envMap),
                  (this.combine = t.combine),
                  (this.reflectivity = t.reflectivity),
                  (this.refractionRatio = t.refractionRatio),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.wireframeLinecap = t.wireframeLinecap),
                  (this.wireframeLinejoin = t.wireframeLinejoin),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.morphNormals = t.morphNormals),
                  this
                );
              }),
              (mr.prototype = Object.create(fr.prototype)),
              (mr.prototype.constructor = mr),
              (mr.prototype.isMeshToonMaterial = !0),
              (mr.prototype.copy = function (t) {
                return (
                  fr.prototype.copy.call(this, t),
                  (this.gradientMap = t.gradientMap),
                  this
                );
              }),
              (gr.prototype = Object.create(k.prototype)),
              (gr.prototype.constructor = gr),
              (gr.prototype.isMeshNormalMaterial = !0),
              (gr.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  (this.bumpMap = t.bumpMap),
                  (this.bumpScale = t.bumpScale),
                  (this.normalMap = t.normalMap),
                  (this.normalMapType = t.normalMapType),
                  this.normalScale.copy(t.normalScale),
                  (this.displacementMap = t.displacementMap),
                  (this.displacementScale = t.displacementScale),
                  (this.displacementBias = t.displacementBias),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.morphNormals = t.morphNormals),
                  this
                );
              }),
              (vr.prototype = Object.create(k.prototype)),
              (vr.prototype.constructor = vr),
              (vr.prototype.isMeshLambertMaterial = !0),
              (vr.prototype.copy = function (t) {
                return (
                  k.prototype.copy.call(this, t),
                  this.color.copy(t.color),
                  (this.map = t.map),
                  (this.lightMap = t.lightMap),
                  (this.lightMapIntensity = t.lightMapIntensity),
                  (this.aoMap = t.aoMap),
                  (this.aoMapIntensity = t.aoMapIntensity),
                  this.emissive.copy(t.emissive),
                  (this.emissiveMap = t.emissiveMap),
                  (this.emissiveIntensity = t.emissiveIntensity),
                  (this.specularMap = t.specularMap),
                  (this.alphaMap = t.alphaMap),
                  (this.envMap = t.envMap),
                  (this.combine = t.combine),
                  (this.reflectivity = t.reflectivity),
                  (this.refractionRatio = t.refractionRatio),
                  (this.wireframe = t.wireframe),
                  (this.wireframeLinewidth = t.wireframeLinewidth),
                  (this.wireframeLinecap = t.wireframeLinecap),
                  (this.wireframeLinejoin = t.wireframeLinejoin),
                  (this.skinning = t.skinning),
                  (this.morphTargets = t.morphTargets),
                  (this.morphNormals = t.morphNormals),
                  this
                );
              }),
              (yr.prototype = Object.create(Be.prototype)),
              (yr.prototype.constructor = yr),
              (yr.prototype.isLineDashedMaterial = !0),
              (yr.prototype.copy = function (t) {
                return (
                  Be.prototype.copy.call(this, t),
                  (this.scale = t.scale),
                  (this.dashSize = t.dashSize),
                  (this.gapSize = t.gapSize),
                  this
                );
              });
            var Xc = Object.freeze({
                ShadowMaterial: lr,
                SpriteMaterial: Pe,
                RawShaderMaterial: ur,
                ShaderMaterial: W,
                PointsMaterial: He,
                MeshPhysicalMaterial: dr,
                MeshStandardMaterial: pr,
                MeshPhongMaterial: fr,
                MeshToonMaterial: mr,
                MeshNormalMaterial: gr,
                MeshLambertMaterial: vr,
                MeshDepthMaterial: fe,
                MeshDistanceMaterial: me,
                MeshBasicMaterial: j,
                LineDashedMaterial: yr,
                LineBasicMaterial: Be,
                Material: k,
              }),
              qc = {
                enabled: !1,
                files: {},
                add: function (t, e) {
                  !1 !== this.enabled && (this.files[t] = e);
                },
                get: function (t) {
                  if (!1 !== this.enabled) return this.files[t];
                },
                remove: function (t) {
                  delete this.files[t];
                },
                clear: function () {
                  this.files = {};
                },
              },
              Yc = new xr(),
              Jc = {};
            Object.assign(br.prototype, {
              load: function (t, e, n, r) {
                void 0 === t && (t = ""),
                  void 0 !== this.path && (t = this.path + t),
                  (t = this.manager.resolveURL(t));
                var i = this,
                  a = qc.get(t);
                if (void 0 !== a)
                  return (
                    i.manager.itemStart(t),
                    setTimeout(function () {
                      e && e(a), i.manager.itemEnd(t);
                    }, 0),
                    a
                  );
                if (void 0 !== Jc[t])
                  return void Jc[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r,
                  });
                var o = /^data:(.*?)(;base64)?,(.*)$/,
                  s = t.match(o);
                if (s) {
                  var c = s[1],
                    h = !!s[2],
                    l = s[3];
                  (l = window.decodeURIComponent(l)), h && (l = window.atob(l));
                  try {
                    var u,
                      p = (this.responseType || "").toLowerCase();
                    switch (p) {
                      case "arraybuffer":
                      case "blob":
                        for (
                          var d = new Uint8Array(l.length), f = 0;
                          f < l.length;
                          f++
                        )
                          d[f] = l.charCodeAt(f);
                        u =
                          "blob" === p
                            ? new Blob([d.buffer], { type: c })
                            : d.buffer;
                        break;
                      case "document":
                        var m = new DOMParser();
                        u = m.parseFromString(l, c);
                        break;
                      case "json":
                        u = JSON.parse(l);
                        break;
                      default:
                        u = l;
                    }
                    window.setTimeout(function () {
                      e && e(u), i.manager.itemEnd(t);
                    }, 0);
                  } catch (e) {
                    window.setTimeout(function () {
                      r && r(e), i.manager.itemEnd(t), i.manager.itemError(t);
                    }, 0);
                  }
                } else {
                  (Jc[t] = []),
                    Jc[t].push({ onLoad: e, onProgress: n, onError: r });
                  var g = new XMLHttpRequest();
                  g.open("GET", t, !0),
                    g.addEventListener(
                      "load",
                      function (e) {
                        var n = this.response;
                        qc.add(t, n);
                        var r = Jc[t];
                        if (
                          (delete Jc[t],
                          200 === this.status || 0 === this.status)
                        ) {
                          0 === this.status &&
                            console.warn(
                              "THREE.FileLoader: HTTP Status 0 received."
                            );
                          for (var a = 0, o = r.length; a < o; a++) {
                            var s = r[a];
                            s.onLoad && s.onLoad(n);
                          }
                          i.manager.itemEnd(t);
                        } else {
                          for (var a = 0, o = r.length; a < o; a++) {
                            var s = r[a];
                            s.onError && s.onError(e);
                          }
                          i.manager.itemEnd(t), i.manager.itemError(t);
                        }
                      },
                      !1
                    ),
                    g.addEventListener(
                      "progress",
                      function (e) {
                        for (var n = Jc[t], r = 0, i = n.length; r < i; r++) {
                          var a = n[r];
                          a.onProgress && a.onProgress(e);
                        }
                      },
                      !1
                    ),
                    g.addEventListener(
                      "error",
                      function (e) {
                        var n = Jc[t];
                        delete Jc[t];
                        for (var r = 0, a = n.length; r < a; r++) {
                          var o = n[r];
                          o.onError && o.onError(e);
                        }
                        i.manager.itemEnd(t), i.manager.itemError(t);
                      },
                      !1
                    ),
                    void 0 !== this.responseType &&
                      (g.responseType = this.responseType),
                    void 0 !== this.withCredentials &&
                      (g.withCredentials = this.withCredentials),
                    g.overrideMimeType &&
                      g.overrideMimeType(
                        void 0 !== this.mimeType ? this.mimeType : "text/plain"
                      );
                  for (var v in this.requestHeader)
                    g.setRequestHeader(v, this.requestHeader[v]);
                  g.send(null);
                }
                return i.manager.itemStart(t), g;
              },
              setPath: function (t) {
                return (this.path = t), this;
              },
              setResponseType: function (t) {
                return (this.responseType = t), this;
              },
              setWithCredentials: function (t) {
                return (this.withCredentials = t), this;
              },
              setMimeType: function (t) {
                return (this.mimeType = t), this;
              },
              setRequestHeader: function (t) {
                return (this.requestHeader = t), this;
              },
            }),
              Object.assign(_r.prototype, {
                load: function (t, e, n, r) {
                  var i = this,
                    a = [],
                    o = new je();
                  o.image = a;
                  var s = new br(this.manager);
                  if (
                    (s.setPath(this.path),
                    s.setResponseType("arraybuffer"),
                    Array.isArray(t))
                  )
                    for (var c = 0, h = 0, l = t.length; h < l; ++h)
                      !(function (h) {
                        s.load(
                          t[h],
                          function (t) {
                            var n = i._parser(t, !0);
                            (a[h] = {
                              width: n.width,
                              height: n.height,
                              format: n.format,
                              mipmaps: n.mipmaps,
                            }),
                              6 === (c += 1) &&
                                (1 === n.mipmapCount && (o.minFilter = us),
                                (o.format = n.format),
                                (o.needsUpdate = !0),
                                e && e(o));
                          },
                          n,
                          r
                        );
                      })(h);
                  else
                    s.load(
                      t,
                      function (t) {
                        var n = i._parser(t, !0);
                        if (n.isCubemap)
                          for (
                            var r = n.mipmaps.length / n.mipmapCount, s = 0;
                            s < r;
                            s++
                          ) {
                            a[s] = { mipmaps: [] };
                            for (var c = 0; c < n.mipmapCount; c++)
                              a[s].mipmaps.push(
                                n.mipmaps[s * n.mipmapCount + c]
                              ),
                                (a[s].format = n.format),
                                (a[s].width = n.width),
                                (a[s].height = n.height);
                          }
                        else
                          (o.image.width = n.width),
                            (o.image.height = n.height),
                            (o.mipmaps = n.mipmaps);
                        1 === n.mipmapCount && (o.minFilter = us),
                          (o.format = n.format),
                          (o.needsUpdate = !0),
                          e && e(o);
                      },
                      n,
                      r
                    );
                  return o;
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
              }),
              Object.assign(wr.prototype, {
                load: function (t, e, n, r) {
                  var i = this,
                    a = new u(),
                    o = new br(this.manager);
                  return (
                    o.setResponseType("arraybuffer"),
                    o.load(
                      t,
                      function (t) {
                        var n = i._parser(t);
                        n &&
                          (void 0 !== n.image
                            ? (a.image = n.image)
                            : void 0 !== n.data &&
                              ((a.image.width = n.width),
                              (a.image.height = n.height),
                              (a.image.data = n.data)),
                          (a.wrapS = void 0 !== n.wrapS ? n.wrapS : os),
                          (a.wrapT = void 0 !== n.wrapT ? n.wrapT : os),
                          (a.magFilter =
                            void 0 !== n.magFilter ? n.magFilter : us),
                          (a.minFilter =
                            void 0 !== n.minFilter ? n.minFilter : ds),
                          (a.anisotropy =
                            void 0 !== n.anisotropy ? n.anisotropy : 1),
                          void 0 !== n.format && (a.format = n.format),
                          void 0 !== n.type && (a.type = n.type),
                          void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps),
                          1 === n.mipmapCount && (a.minFilter = us),
                          (a.needsUpdate = !0),
                          e && e(a, n));
                      },
                      n,
                      r
                    ),
                    a
                  );
                },
              }),
              Object.assign(Mr.prototype, {
                crossOrigin: "anonymous",
                load: function (t, e, n, r) {
                  function i() {
                    c.removeEventListener("load", i, !1),
                      c.removeEventListener("error", a, !1),
                      qc.add(t, this),
                      e && e(this),
                      o.manager.itemEnd(t);
                  }
                  function a(e) {
                    c.removeEventListener("load", i, !1),
                      c.removeEventListener("error", a, !1),
                      r && r(e),
                      o.manager.itemEnd(t),
                      o.manager.itemError(t);
                  }
                  void 0 === t && (t = ""),
                    void 0 !== this.path && (t = this.path + t),
                    (t = this.manager.resolveURL(t));
                  var o = this,
                    s = qc.get(t);
                  if (void 0 !== s)
                    return (
                      o.manager.itemStart(t),
                      setTimeout(function () {
                        e && e(s), o.manager.itemEnd(t);
                      }, 0),
                      s
                    );
                  var c = document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "img"
                  );
                  return (
                    c.addEventListener("load", i, !1),
                    c.addEventListener("error", a, !1),
                    "data:" !== t.substr(0, 5) &&
                      void 0 !== this.crossOrigin &&
                      (c.crossOrigin = this.crossOrigin),
                    o.manager.itemStart(t),
                    (c.src = t),
                    c
                  );
                },
                setCrossOrigin: function (t) {
                  return (this.crossOrigin = t), this;
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
              }),
              Object.assign(Er.prototype, {
                crossOrigin: "anonymous",
                load: function (t, e, n, r) {
                  var i = new ot(),
                    a = new Mr(this.manager);
                  a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                  for (var o = 0, s = 0; s < t.length; ++s)
                    !(function (n) {
                      a.load(
                        t[n],
                        function (t) {
                          (i.images[n] = t),
                            6 == ++o && ((i.needsUpdate = !0), e && e(i));
                        },
                        void 0,
                        r
                      );
                    })(s);
                  return i;
                },
                setCrossOrigin: function (t) {
                  return (this.crossOrigin = t), this;
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
              }),
              Object.assign(Tr.prototype, {
                crossOrigin: "anonymous",
                load: function (t, e, n, r) {
                  var i = new s(),
                    a = new Mr(this.manager);
                  return (
                    a.setCrossOrigin(this.crossOrigin),
                    a.setPath(this.path),
                    a.load(
                      t,
                      function (n) {
                        i.image = n;
                        var r =
                          t.search(/\.(jpg|jpeg)$/) > 0 ||
                          0 === t.search(/^data\:image\/jpeg/);
                        (i.format = r ? As : Ls),
                          (i.needsUpdate = !0),
                          void 0 !== e && e(i);
                      },
                      n,
                      r
                    ),
                    i
                  );
                },
                setCrossOrigin: function (t) {
                  return (this.crossOrigin = t), this;
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
              }),
              Object.assign(Sr.prototype, {
                getPoint: function () {
                  return (
                    console.warn("THREE.Curve: .getPoint() not implemented."),
                    null
                  );
                },
                getPointAt: function (t, e) {
                  var n = this.getUtoTmapping(t);
                  return this.getPoint(n, e);
                },
                getPoints: function (t) {
                  void 0 === t && (t = 5);
                  for (var e = [], n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                  return e;
                },
                getSpacedPoints: function (t) {
                  void 0 === t && (t = 5);
                  for (var e = [], n = 0; n <= t; n++)
                    e.push(this.getPointAt(n / t));
                  return e;
                },
                getLength: function () {
                  var t = this.getLengths();
                  return t[t.length - 1];
                },
                getLengths: function (t) {
                  if (
                    (void 0 === t && (t = this.arcLengthDivisions),
                    this.cacheArcLengths &&
                      this.cacheArcLengths.length === t + 1 &&
                      !this.needsUpdate)
                  )
                    return this.cacheArcLengths;
                  this.needsUpdate = !1;
                  var e,
                    n,
                    r = [],
                    i = this.getPoint(0),
                    a = 0;
                  for (r.push(0), n = 1; n <= t; n++)
                    (e = this.getPoint(n / t)),
                      (a += e.distanceTo(i)),
                      r.push(a),
                      (i = e);
                  return (this.cacheArcLengths = r), r;
                },
                updateArcLengths: function () {
                  (this.needsUpdate = !0), this.getLengths();
                },
                getUtoTmapping: function (t, e) {
                  var n,
                    r = this.getLengths(),
                    i = 0,
                    a = r.length;
                  n = e || t * r[a - 1];
                  for (var o, s = 0, c = a - 1; s <= c; )
                    if (((i = Math.floor(s + (c - s) / 2)), (o = r[i] - n) < 0))
                      s = i + 1;
                    else {
                      if (!(o > 0)) {
                        c = i;
                        break;
                      }
                      c = i - 1;
                    }
                  if (((i = c), r[i] === n)) return i / (a - 1);
                  var h = r[i];
                  return (i + (n - h) / (r[i + 1] - h)) / (a - 1);
                },
                getTangent: function (t) {
                  var e = t - 1e-4,
                    n = t + 1e-4;
                  e < 0 && (e = 0), n > 1 && (n = 1);
                  var r = this.getPoint(e);
                  return this.getPoint(n).clone().sub(r).normalize();
                },
                getTangentAt: function (t) {
                  var e = this.getUtoTmapping(t);
                  return this.getTangent(e);
                },
                computeFrenetFrames: function (t, e) {
                  var n,
                    i,
                    o,
                    s = new a(),
                    c = [],
                    h = [],
                    l = [],
                    u = new a(),
                    p = new r();
                  for (n = 0; n <= t; n++)
                    (i = n / t),
                      (c[n] = this.getTangentAt(i)),
                      c[n].normalize();
                  (h[0] = new a()), (l[0] = new a());
                  var d = Number.MAX_VALUE,
                    f = Math.abs(c[0].x),
                    m = Math.abs(c[0].y),
                    g = Math.abs(c[0].z);
                  for (
                    f <= d && ((d = f), s.set(1, 0, 0)),
                      m <= d && ((d = m), s.set(0, 1, 0)),
                      g <= d && s.set(0, 0, 1),
                      u.crossVectors(c[0], s).normalize(),
                      h[0].crossVectors(c[0], u),
                      l[0].crossVectors(c[0], h[0]),
                      n = 1;
                    n <= t;
                    n++
                  )
                    (h[n] = h[n - 1].clone()),
                      (l[n] = l[n - 1].clone()),
                      u.crossVectors(c[n - 1], c[n]),
                      u.length() > Number.EPSILON &&
                        (u.normalize(),
                        (o = Math.acos(xc.clamp(c[n - 1].dot(c[n]), -1, 1))),
                        h[n].applyMatrix4(p.makeRotationAxis(u, o))),
                      l[n].crossVectors(c[n], h[n]);
                  if (!0 === e)
                    for (
                      o = Math.acos(xc.clamp(h[0].dot(h[t]), -1, 1)),
                        o /= t,
                        c[0].dot(u.crossVectors(h[0], h[t])) > 0 && (o = -o),
                        n = 1;
                      n <= t;
                      n++
                    )
                      h[n].applyMatrix4(p.makeRotationAxis(c[n], o * n)),
                        l[n].crossVectors(c[n], h[n]);
                  return { tangents: c, normals: h, binormals: l };
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                },
                toJSON: function () {
                  var t = {
                    metadata: {
                      version: 4.5,
                      type: "Curve",
                      generator: "Curve.toJSON",
                    },
                  };
                  return (
                    (t.arcLengthDivisions = this.arcLengthDivisions),
                    (t.type = this.type),
                    t
                  );
                },
                fromJSON: function (t) {
                  return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                },
              }),
              (Ar.prototype = Object.create(Sr.prototype)),
              (Ar.prototype.constructor = Ar),
              (Ar.prototype.isEllipseCurve = !0),
              (Ar.prototype.getPoint = function (t, e) {
                for (
                  var r = e || new n(),
                    i = 2 * Math.PI,
                    a = this.aEndAngle - this.aStartAngle,
                    o = Math.abs(a) < Number.EPSILON;
                  a < 0;

                )
                  a += i;
                for (; a > i; ) a -= i;
                a < Number.EPSILON && (a = o ? 0 : i),
                  !0 !== this.aClockwise ||
                    o ||
                    (a === i ? (a = -i) : (a -= i));
                var s = this.aStartAngle + t * a,
                  c = this.aX + this.xRadius * Math.cos(s),
                  h = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                  var l = Math.cos(this.aRotation),
                    u = Math.sin(this.aRotation),
                    p = c - this.aX,
                    d = h - this.aY;
                  (c = p * l - d * u + this.aX), (h = p * u + d * l + this.aY);
                }
                return r.set(c, h);
              }),
              (Ar.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  (this.aX = t.aX),
                  (this.aY = t.aY),
                  (this.xRadius = t.xRadius),
                  (this.yRadius = t.yRadius),
                  (this.aStartAngle = t.aStartAngle),
                  (this.aEndAngle = t.aEndAngle),
                  (this.aClockwise = t.aClockwise),
                  (this.aRotation = t.aRotation),
                  this
                );
              }),
              (Ar.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.aX = this.aX),
                  (t.aY = this.aY),
                  (t.xRadius = this.xRadius),
                  (t.yRadius = this.yRadius),
                  (t.aStartAngle = this.aStartAngle),
                  (t.aEndAngle = this.aEndAngle),
                  (t.aClockwise = this.aClockwise),
                  (t.aRotation = this.aRotation),
                  t
                );
              }),
              (Ar.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  (this.aX = t.aX),
                  (this.aY = t.aY),
                  (this.xRadius = t.xRadius),
                  (this.yRadius = t.yRadius),
                  (this.aStartAngle = t.aStartAngle),
                  (this.aEndAngle = t.aEndAngle),
                  (this.aClockwise = t.aClockwise),
                  (this.aRotation = t.aRotation),
                  this
                );
              }),
              (Lr.prototype = Object.create(Ar.prototype)),
              (Lr.prototype.constructor = Lr),
              (Lr.prototype.isArcCurve = !0);
            var Zc = new a(),
              Qc = new Rr(),
              Kc = new Rr(),
              $c = new Rr();
            (Cr.prototype = Object.create(Sr.prototype)),
              (Cr.prototype.constructor = Cr),
              (Cr.prototype.isCatmullRomCurve3 = !0),
              (Cr.prototype.getPoint = function (t, e) {
                var n = e || new a(),
                  r = this.points,
                  i = r.length,
                  o = (i - (this.closed ? 0 : 1)) * t,
                  s = Math.floor(o),
                  c = o - s;
                this.closed
                  ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / i) + 1) * i)
                  : 0 === c && s === i - 1 && ((s = i - 2), (c = 1));
                var h, l, u, p;
                if (
                  (this.closed || s > 0
                    ? (h = r[(s - 1) % i])
                    : (Zc.subVectors(r[0], r[1]).add(r[0]), (h = Zc)),
                  (l = r[s % i]),
                  (u = r[(s + 1) % i]),
                  this.closed || s + 2 < i
                    ? (p = r[(s + 2) % i])
                    : (Zc.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]),
                      (p = Zc)),
                  "centripetal" === this.curveType ||
                    "chordal" === this.curveType)
                ) {
                  var d = "chordal" === this.curveType ? 0.5 : 0.25,
                    f = Math.pow(h.distanceToSquared(l), d),
                    m = Math.pow(l.distanceToSquared(u), d),
                    g = Math.pow(u.distanceToSquared(p), d);
                  m < 1e-4 && (m = 1),
                    f < 1e-4 && (f = m),
                    g < 1e-4 && (g = m),
                    Qc.initNonuniformCatmullRom(h.x, l.x, u.x, p.x, f, m, g),
                    Kc.initNonuniformCatmullRom(h.y, l.y, u.y, p.y, f, m, g),
                    $c.initNonuniformCatmullRom(h.z, l.z, u.z, p.z, f, m, g);
                } else
                  "catmullrom" === this.curveType &&
                    (Qc.initCatmullRom(h.x, l.x, u.x, p.x, this.tension),
                    Kc.initCatmullRom(h.y, l.y, u.y, p.y, this.tension),
                    $c.initCatmullRom(h.z, l.z, u.z, p.z, this.tension));
                return n.set(Qc.calc(c), Kc.calc(c), $c.calc(c)), n;
              }),
              (Cr.prototype.copy = function (t) {
                Sr.prototype.copy.call(this, t), (this.points = []);
                for (var e = 0, n = t.points.length; e < n; e++) {
                  var r = t.points[e];
                  this.points.push(r.clone());
                }
                return (
                  (this.closed = t.closed),
                  (this.curveType = t.curveType),
                  (this.tension = t.tension),
                  this
                );
              }),
              (Cr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                  var r = this.points[e];
                  t.points.push(r.toArray());
                }
                return (
                  (t.closed = this.closed),
                  (t.curveType = this.curveType),
                  (t.tension = this.tension),
                  t
                );
              }),
              (Cr.prototype.fromJSON = function (t) {
                Sr.prototype.fromJSON.call(this, t), (this.points = []);
                for (var e = 0, n = t.points.length; e < n; e++) {
                  var r = t.points[e];
                  this.points.push(new a().fromArray(r));
                }
                return (
                  (this.closed = t.closed),
                  (this.curveType = t.curveType),
                  (this.tension = t.tension),
                  this
                );
              }),
              (Hr.prototype = Object.create(Sr.prototype)),
              (Hr.prototype.constructor = Hr),
              (Hr.prototype.isCubicBezierCurve = !0),
              (Hr.prototype.getPoint = function (t, e) {
                var r = e || new n(),
                  i = this.v0,
                  a = this.v1,
                  o = this.v2,
                  s = this.v3;
                return (
                  r.set(Gr(t, i.x, a.x, o.x, s.x), Gr(t, i.y, a.y, o.y, s.y)), r
                );
              }),
              (Hr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v0.copy(t.v0),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this.v3.copy(t.v3),
                  this
                );
              }),
              (Hr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v0 = this.v0.toArray()),
                  (t.v1 = this.v1.toArray()),
                  (t.v2 = this.v2.toArray()),
                  (t.v3 = this.v3.toArray()),
                  t
                );
              }),
              (Hr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v0.fromArray(t.v0),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this.v3.fromArray(t.v3),
                  this
                );
              }),
              (Vr.prototype = Object.create(Sr.prototype)),
              (Vr.prototype.constructor = Vr),
              (Vr.prototype.isCubicBezierCurve3 = !0),
              (Vr.prototype.getPoint = function (t, e) {
                var n = e || new a(),
                  r = this.v0,
                  i = this.v1,
                  o = this.v2,
                  s = this.v3;
                return (
                  n.set(
                    Gr(t, r.x, i.x, o.x, s.x),
                    Gr(t, r.y, i.y, o.y, s.y),
                    Gr(t, r.z, i.z, o.z, s.z)
                  ),
                  n
                );
              }),
              (Vr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v0.copy(t.v0),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this.v3.copy(t.v3),
                  this
                );
              }),
              (Vr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v0 = this.v0.toArray()),
                  (t.v1 = this.v1.toArray()),
                  (t.v2 = this.v2.toArray()),
                  (t.v3 = this.v3.toArray()),
                  t
                );
              }),
              (Vr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v0.fromArray(t.v0),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this.v3.fromArray(t.v3),
                  this
                );
              }),
              (kr.prototype = Object.create(Sr.prototype)),
              (kr.prototype.constructor = kr),
              (kr.prototype.isLineCurve = !0),
              (kr.prototype.getPoint = function (t, e) {
                var r = e || new n();
                return (
                  1 === t
                    ? r.copy(this.v2)
                    : (r.copy(this.v2).sub(this.v1),
                      r.multiplyScalar(t).add(this.v1)),
                  r
                );
              }),
              (kr.prototype.getPointAt = function (t, e) {
                return this.getPoint(t, e);
              }),
              (kr.prototype.getTangent = function () {
                return this.v2.clone().sub(this.v1).normalize();
              }),
              (kr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this
                );
              }),
              (kr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                );
              }),
              (kr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this
                );
              }),
              (jr.prototype = Object.create(Sr.prototype)),
              (jr.prototype.constructor = jr),
              (jr.prototype.isLineCurve3 = !0),
              (jr.prototype.getPoint = function (t, e) {
                var n = e || new a();
                return (
                  1 === t
                    ? n.copy(this.v2)
                    : (n.copy(this.v2).sub(this.v1),
                      n.multiplyScalar(t).add(this.v1)),
                  n
                );
              }),
              (jr.prototype.getPointAt = function (t, e) {
                return this.getPoint(t, e);
              }),
              (jr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this
                );
              }),
              (jr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                );
              }),
              (jr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this
                );
              }),
              (Wr.prototype = Object.create(Sr.prototype)),
              (Wr.prototype.constructor = Wr),
              (Wr.prototype.isQuadraticBezierCurve = !0),
              (Wr.prototype.getPoint = function (t, e) {
                var r = e || new n(),
                  i = this.v0,
                  a = this.v1,
                  o = this.v2;
                return r.set(Dr(t, i.x, a.x, o.x), Dr(t, i.y, a.y, o.y)), r;
              }),
              (Wr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v0.copy(t.v0),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this
                );
              }),
              (Wr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v0 = this.v0.toArray()),
                  (t.v1 = this.v1.toArray()),
                  (t.v2 = this.v2.toArray()),
                  t
                );
              }),
              (Wr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v0.fromArray(t.v0),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this
                );
              }),
              (Xr.prototype = Object.create(Sr.prototype)),
              (Xr.prototype.constructor = Xr),
              (Xr.prototype.isQuadraticBezierCurve3 = !0),
              (Xr.prototype.getPoint = function (t, e) {
                var n = e || new a(),
                  r = this.v0,
                  i = this.v1,
                  o = this.v2;
                return (
                  n.set(
                    Dr(t, r.x, i.x, o.x),
                    Dr(t, r.y, i.y, o.y),
                    Dr(t, r.z, i.z, o.z)
                  ),
                  n
                );
              }),
              (Xr.prototype.copy = function (t) {
                return (
                  Sr.prototype.copy.call(this, t),
                  this.v0.copy(t.v0),
                  this.v1.copy(t.v1),
                  this.v2.copy(t.v2),
                  this
                );
              }),
              (Xr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                return (
                  (t.v0 = this.v0.toArray()),
                  (t.v1 = this.v1.toArray()),
                  (t.v2 = this.v2.toArray()),
                  t
                );
              }),
              (Xr.prototype.fromJSON = function (t) {
                return (
                  Sr.prototype.fromJSON.call(this, t),
                  this.v0.fromArray(t.v0),
                  this.v1.fromArray(t.v1),
                  this.v2.fromArray(t.v2),
                  this
                );
              }),
              (qr.prototype = Object.create(Sr.prototype)),
              (qr.prototype.constructor = qr),
              (qr.prototype.isSplineCurve = !0),
              (qr.prototype.getPoint = function (t, e) {
                var r = e || new n(),
                  i = this.points,
                  a = (i.length - 1) * t,
                  o = Math.floor(a),
                  s = a - o,
                  c = i[0 === o ? o : o - 1],
                  h = i[o],
                  l = i[o > i.length - 2 ? i.length - 1 : o + 1],
                  u = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return (
                  r.set(Pr(s, c.x, h.x, l.x, u.x), Pr(s, c.y, h.y, l.y, u.y)), r
                );
              }),
              (qr.prototype.copy = function (t) {
                Sr.prototype.copy.call(this, t), (this.points = []);
                for (var e = 0, n = t.points.length; e < n; e++) {
                  var r = t.points[e];
                  this.points.push(r.clone());
                }
                return this;
              }),
              (qr.prototype.toJSON = function () {
                var t = Sr.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                  var r = this.points[e];
                  t.points.push(r.toArray());
                }
                return t;
              }),
              (qr.prototype.fromJSON = function (t) {
                Sr.prototype.fromJSON.call(this, t), (this.points = []);
                for (var e = 0, r = t.points.length; e < r; e++) {
                  var i = t.points[e];
                  this.points.push(new n().fromArray(i));
                }
                return this;
              });
            var th = Object.freeze({
              ArcCurve: Lr,
              CatmullRomCurve3: Cr,
              CubicBezierCurve: Hr,
              CubicBezierCurve3: Vr,
              EllipseCurve: Ar,
              LineCurve: kr,
              LineCurve3: jr,
              QuadraticBezierCurve: Wr,
              QuadraticBezierCurve3: Xr,
              SplineCurve: qr,
            });
            (Yr.prototype = Object.assign(Object.create(Sr.prototype), {
              constructor: Yr,
              add: function (t) {
                this.curves.push(t);
              },
              closePath: function () {
                var t = this.curves[0].getPoint(0),
                  e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new kr(e, t));
              },
              getPoint: function (t) {
                for (
                  var e = t * this.getLength(),
                    n = this.getCurveLengths(),
                    r = 0;
                  r < n.length;

                ) {
                  if (n[r] >= e) {
                    var i = n[r] - e,
                      a = this.curves[r],
                      o = a.getLength(),
                      s = 0 === o ? 0 : 1 - i / o;
                    return a.getPointAt(s);
                  }
                  r++;
                }
                return null;
              },
              getLength: function () {
                var t = this.getCurveLengths();
                return t[t.length - 1];
              },
              updateArcLengths: function () {
                (this.needsUpdate = !0),
                  (this.cacheLengths = null),
                  this.getCurveLengths();
              },
              getCurveLengths: function () {
                if (
                  this.cacheLengths &&
                  this.cacheLengths.length === this.curves.length
                )
                  return this.cacheLengths;
                for (
                  var t = [], e = 0, n = 0, r = this.curves.length;
                  n < r;
                  n++
                )
                  (e += this.curves[n].getLength()), t.push(e);
                return (this.cacheLengths = t), t;
              },
              getSpacedPoints: function (t) {
                void 0 === t && (t = 40);
                for (var e = [], n = 0; n <= t; n++)
                  e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]), e;
              },
              getPoints: function (t) {
                t = t || 12;
                for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                  for (
                    var a = i[r],
                      o =
                        a && a.isEllipseCurve
                          ? 2 * t
                          : a && (a.isLineCurve || a.isLineCurve3)
                          ? 1
                          : a && a.isSplineCurve
                          ? t * a.points.length
                          : t,
                      s = a.getPoints(o),
                      c = 0;
                    c < s.length;
                    c++
                  ) {
                    var h = s[c];
                    (e && e.equals(h)) || (n.push(h), (e = h));
                  }
                return (
                  this.autoClose &&
                    n.length > 1 &&
                    !n[n.length - 1].equals(n[0]) &&
                    n.push(n[0]),
                  n
                );
              },
              copy: function (t) {
                Sr.prototype.copy.call(this, t), (this.curves = []);
                for (var e = 0, n = t.curves.length; e < n; e++) {
                  var r = t.curves[e];
                  this.curves.push(r.clone());
                }
                return (this.autoClose = t.autoClose), this;
              },
              toJSON: function () {
                var t = Sr.prototype.toJSON.call(this);
                (t.autoClose = this.autoClose), (t.curves = []);
                for (var e = 0, n = this.curves.length; e < n; e++) {
                  var r = this.curves[e];
                  t.curves.push(r.toJSON());
                }
                return t;
              },
              fromJSON: function (t) {
                Sr.prototype.fromJSON.call(this, t),
                  (this.autoClose = t.autoClose),
                  (this.curves = []);
                for (var e = 0, n = t.curves.length; e < n; e++) {
                  var r = t.curves[e];
                  this.curves.push(new th[r.type]().fromJSON(r));
                }
                return this;
              },
            })),
              (Jr.prototype = Object.assign(Object.create(Yr.prototype), {
                constructor: Jr,
                setFromPoints: function (t) {
                  this.moveTo(t[0].x, t[0].y);
                  for (var e = 1, n = t.length; e < n; e++)
                    this.lineTo(t[e].x, t[e].y);
                },
                moveTo: function (t, e) {
                  this.currentPoint.set(t, e);
                },
                lineTo: function (t, e) {
                  var r = new kr(this.currentPoint.clone(), new n(t, e));
                  this.curves.push(r), this.currentPoint.set(t, e);
                },
                quadraticCurveTo: function (t, e, r, i) {
                  var a = new Wr(
                    this.currentPoint.clone(),
                    new n(t, e),
                    new n(r, i)
                  );
                  this.curves.push(a), this.currentPoint.set(r, i);
                },
                bezierCurveTo: function (t, e, r, i, a, o) {
                  var s = new Hr(
                    this.currentPoint.clone(),
                    new n(t, e),
                    new n(r, i),
                    new n(a, o)
                  );
                  this.curves.push(s), this.currentPoint.set(a, o);
                },
                splineThru: function (t) {
                  var e = [this.currentPoint.clone()].concat(t),
                    n = new qr(e);
                  this.curves.push(n), this.currentPoint.copy(t[t.length - 1]);
                },
                arc: function (t, e, n, r, i, a) {
                  var o = this.currentPoint.x,
                    s = this.currentPoint.y;
                  this.absarc(t + o, e + s, n, r, i, a);
                },
                absarc: function (t, e, n, r, i, a) {
                  this.absellipse(t, e, n, n, r, i, a);
                },
                ellipse: function (t, e, n, r, i, a, o, s) {
                  var c = this.currentPoint.x,
                    h = this.currentPoint.y;
                  this.absellipse(t + c, e + h, n, r, i, a, o, s);
                },
                absellipse: function (t, e, n, r, i, a, o, s) {
                  var c = new Ar(t, e, n, r, i, a, o, s);
                  if (this.curves.length > 0) {
                    var h = c.getPoint(0);
                    h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
                  }
                  this.curves.push(c);
                  var l = c.getPoint(1);
                  this.currentPoint.copy(l);
                },
                copy: function (t) {
                  return (
                    Yr.prototype.copy.call(this, t),
                    this.currentPoint.copy(t.currentPoint),
                    this
                  );
                },
                toJSON: function () {
                  var t = Yr.prototype.toJSON.call(this);
                  return (t.currentPoint = this.currentPoint.toArray()), t;
                },
                fromJSON: function (t) {
                  return (
                    Yr.prototype.fromJSON.call(this, t),
                    this.currentPoint.fromArray(t.currentPoint),
                    this
                  );
                },
              })),
              (Zr.prototype = Object.assign(Object.create(Jr.prototype), {
                constructor: Zr,
                getPointsHoles: function (t) {
                  for (var e = [], n = 0, r = this.holes.length; n < r; n++)
                    e[n] = this.holes[n].getPoints(t);
                  return e;
                },
                extractPoints: function (t) {
                  return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t),
                  };
                },
                copy: function (t) {
                  Jr.prototype.copy.call(this, t), (this.holes = []);
                  for (var e = 0, n = t.holes.length; e < n; e++) {
                    var r = t.holes[e];
                    this.holes.push(r.clone());
                  }
                  return this;
                },
                toJSON: function () {
                  var t = Jr.prototype.toJSON.call(this);
                  (t.uuid = this.uuid), (t.holes = []);
                  for (var e = 0, n = this.holes.length; e < n; e++) {
                    var r = this.holes[e];
                    t.holes.push(r.toJSON());
                  }
                  return t;
                },
                fromJSON: function (t) {
                  Jr.prototype.fromJSON.call(this, t),
                    (this.uuid = t.uuid),
                    (this.holes = []);
                  for (var e = 0, n = t.holes.length; e < n; e++) {
                    var r = t.holes[e];
                    this.holes.push(new Jr().fromJSON(r));
                  }
                  return this;
                },
              })),
              (Qr.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Qr,
                isLight: !0,
                copy: function (t) {
                  return (
                    _.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.intensity = t.intensity),
                    this
                  );
                },
                toJSON: function (t) {
                  var e = _.prototype.toJSON.call(this, t);
                  return (
                    (e.object.color = this.color.getHex()),
                    (e.object.intensity = this.intensity),
                    void 0 !== this.groundColor &&
                      (e.object.groundColor = this.groundColor.getHex()),
                    void 0 !== this.distance &&
                      (e.object.distance = this.distance),
                    void 0 !== this.angle && (e.object.angle = this.angle),
                    void 0 !== this.decay && (e.object.decay = this.decay),
                    void 0 !== this.penumbra &&
                      (e.object.penumbra = this.penumbra),
                    void 0 !== this.shadow &&
                      (e.object.shadow = this.shadow.toJSON()),
                    e
                  );
                },
              })),
              (Kr.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: Kr,
                isHemisphereLight: !0,
                copy: function (t) {
                  return (
                    Qr.prototype.copy.call(this, t),
                    this.groundColor.copy(t.groundColor),
                    this
                  );
                },
              })),
              Object.assign($r.prototype, {
                copy: function (t) {
                  return (
                    (this.camera = t.camera.clone()),
                    (this.bias = t.bias),
                    (this.radius = t.radius),
                    this.mapSize.copy(t.mapSize),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                toJSON: function () {
                  var t = {};
                  return (
                    0 !== this.bias && (t.bias = this.bias),
                    1 !== this.radius && (t.radius = this.radius),
                    (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                      (t.mapSize = this.mapSize.toArray()),
                    (t.camera = this.camera.toJSON(!1).object),
                    delete t.camera.matrix,
                    t
                  );
                },
              }),
              (ti.prototype = Object.assign(Object.create($r.prototype), {
                constructor: ti,
                isSpotLightShadow: !0,
                update: function (t) {
                  var e = this.camera,
                    n = 2 * xc.RAD2DEG * t.angle,
                    r = this.mapSize.width / this.mapSize.height,
                    i = t.distance || e.far;
                  (n === e.fov && r === e.aspect && i === e.far) ||
                    ((e.fov = n),
                    (e.aspect = r),
                    (e.far = i),
                    e.updateProjectionMatrix());
                },
              })),
              (ei.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: ei,
                isSpotLight: !0,
                copy: function (t) {
                  return (
                    Qr.prototype.copy.call(this, t),
                    (this.distance = t.distance),
                    (this.angle = t.angle),
                    (this.penumbra = t.penumbra),
                    (this.decay = t.decay),
                    (this.target = t.target.clone()),
                    (this.shadow = t.shadow.clone()),
                    this
                  );
                },
              })),
              (ni.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: ni,
                isPointLight: !0,
                copy: function (t) {
                  return (
                    Qr.prototype.copy.call(this, t),
                    (this.distance = t.distance),
                    (this.decay = t.decay),
                    (this.shadow = t.shadow.clone()),
                    this
                  );
                },
              })),
              (ri.prototype = Object.assign(Object.create($r.prototype), {
                constructor: ri,
              })),
              (ii.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: ii,
                isDirectionalLight: !0,
                copy: function (t) {
                  return (
                    Qr.prototype.copy.call(this, t),
                    (this.target = t.target.clone()),
                    (this.shadow = t.shadow.clone()),
                    this
                  );
                },
              })),
              (ai.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: ai,
                isAmbientLight: !0,
              })),
              (oi.prototype = Object.assign(Object.create(Qr.prototype), {
                constructor: oi,
                isRectAreaLight: !0,
                copy: function (t) {
                  return (
                    Qr.prototype.copy.call(this, t),
                    (this.width = t.width),
                    (this.height = t.height),
                    this
                  );
                },
                toJSON: function (t) {
                  var e = Qr.prototype.toJSON.call(this, t);
                  return (
                    (e.object.width = this.width),
                    (e.object.height = this.height),
                    e
                  );
                },
              }));
            var eh = {
              arraySlice: function (t, e, n) {
                return eh.isTypedArray(t)
                  ? new t.constructor(
                      t.subarray(e, void 0 !== n ? n : t.length)
                    )
                  : t.slice(e, n);
              },
              convertArray: function (t, e, n) {
                return !t || (!n && t.constructor === e)
                  ? t
                  : "number" == typeof e.BYTES_PER_ELEMENT
                  ? new e(t)
                  : Array.prototype.slice.call(t);
              },
              isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView);
              },
              getKeyframeOrder: function (t) {
                function e(e, n) {
                  return t[e] - t[n];
                }
                for (var n = t.length, r = new Array(n), i = 0; i !== n; ++i)
                  r[i] = i;
                return r.sort(e), r;
              },
              sortedArray: function (t, e, n) {
                for (
                  var r = t.length, i = new t.constructor(r), a = 0, o = 0;
                  o !== r;
                  ++a
                )
                  for (var s = n[a] * e, c = 0; c !== e; ++c) i[o++] = t[s + c];
                return i;
              },
              flattenJSON: function (t, e, n, r) {
                for (var i = 1, a = t[0]; void 0 !== a && void 0 === a[r]; )
                  a = t[i++];
                if (void 0 !== a) {
                  var o = a[r];
                  if (void 0 !== o)
                    if (Array.isArray(o))
                      do {
                        (o = a[r]),
                          void 0 !== o && (e.push(a.time), n.push.apply(n, o)),
                          (a = t[i++]);
                      } while (void 0 !== a);
                    else if (void 0 !== o.toArray)
                      do {
                        (o = a[r]),
                          void 0 !== o &&
                            (e.push(a.time), o.toArray(n, n.length)),
                          (a = t[i++]);
                      } while (void 0 !== a);
                    else
                      do {
                        (o = a[r]),
                          void 0 !== o && (e.push(a.time), n.push(o)),
                          (a = t[i++]);
                      } while (void 0 !== a);
                }
              },
            };
            Object.assign(si.prototype, {
              evaluate: function (t) {
                var e = this.parameterPositions,
                  n = this._cachedIndex,
                  r = e[n],
                  i = e[n - 1];
                t: {
                  e: {
                    var a;
                    n: {
                      r: if (!(t < r)) {
                        for (var o = n + 2; ; ) {
                          if (void 0 === r) {
                            if (t < i) break r;
                            return (
                              (n = e.length),
                              (this._cachedIndex = n),
                              this.afterEnd_(n - 1, t, i)
                            );
                          }
                          if (n === o) break;
                          if (((i = r), (r = e[++n]), t < r)) break e;
                        }
                        a = e.length;
                        break n;
                      }
                      {
                        if (t >= i) break t;
                        var s = e[1];
                        t < s && ((n = 2), (i = s));
                        for (var o = n - 2; ; ) {
                          if (void 0 === i)
                            return (
                              (this._cachedIndex = 0),
                              this.beforeStart_(0, t, r)
                            );
                          if (n === o) break;
                          if (((r = i), (i = e[--n - 1]), t >= i)) break e;
                        }
                        (a = n), (n = 0);
                      }
                    }
                    for (; n < a; ) {
                      var c = (n + a) >>> 1;
                      t < e[c] ? (a = c) : (n = c + 1);
                    }
                    if (((r = e[n]), void 0 === (i = e[n - 1])))
                      return (
                        (this._cachedIndex = 0), this.beforeStart_(0, t, r)
                      );
                    if (void 0 === r)
                      return (
                        (n = e.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, i, t)
                      );
                  }
                  (this._cachedIndex = n), this.intervalChanged_(n, i, r);
                }
                return this.interpolate_(n, i, t, r);
              },
              settings: null,
              DefaultSettings_: {},
              getSettings_: function () {
                return this.settings || this.DefaultSettings_;
              },
              copySampleValue_: function (t) {
                for (
                  var e = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = t * r,
                    a = 0;
                  a !== r;
                  ++a
                )
                  e[a] = n[i + a];
                return e;
              },
              interpolate_: function () {
                throw new Error("call to abstract method");
              },
              intervalChanged_: function () {},
            }),
              Object.assign(si.prototype, {
                beforeStart_: si.prototype.copySampleValue_,
                afterEnd_: si.prototype.copySampleValue_,
              }),
              (ci.prototype = Object.assign(Object.create(si.prototype), {
                constructor: ci,
                DefaultSettings_: { endingStart: ic, endingEnd: ic },
                intervalChanged_: function (t, e, n) {
                  var r = this.parameterPositions,
                    i = t - 2,
                    a = t + 1,
                    o = r[i],
                    s = r[a];
                  if (void 0 === o)
                    switch (this.getSettings_().endingStart) {
                      case 2401:
                        (i = t), (o = 2 * e - n);
                        break;
                      case 2402:
                        (i = r.length - 2), (o = e + r[i] - r[i + 1]);
                        break;
                      default:
                        (i = t), (o = n);
                    }
                  if (void 0 === s)
                    switch (this.getSettings_().endingEnd) {
                      case 2401:
                        (a = t), (s = 2 * n - e);
                        break;
                      case 2402:
                        (a = 1), (s = n + r[1] - r[0]);
                        break;
                      default:
                        (a = t - 1), (s = e);
                    }
                  var c = 0.5 * (n - e),
                    h = this.valueSize;
                  (this._weightPrev = c / (e - o)),
                    (this._weightNext = c / (s - n)),
                    (this._offsetPrev = i * h),
                    (this._offsetNext = a * h);
                },
                interpolate_: function (t, e, n, r) {
                  for (
                    var i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = t * o,
                      c = s - o,
                      h = this._offsetPrev,
                      l = this._offsetNext,
                      u = this._weightPrev,
                      p = this._weightNext,
                      d = (n - e) / (r - e),
                      f = d * d,
                      m = f * d,
                      g = -u * m + 2 * u * f - u * d,
                      v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
                      y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
                      x = p * m - p * f,
                      b = 0;
                    b !== o;
                    ++b
                  )
                    i[b] =
                      g * a[h + b] + v * a[c + b] + y * a[s + b] + x * a[l + b];
                  return i;
                },
              })),
              (hi.prototype = Object.assign(Object.create(si.prototype), {
                constructor: hi,
                interpolate_: function (t, e, n, r) {
                  for (
                    var i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = t * o,
                      c = s - o,
                      h = (n - e) / (r - e),
                      l = 1 - h,
                      u = 0;
                    u !== o;
                    ++u
                  )
                    i[u] = a[c + u] * l + a[s + u] * h;
                  return i;
                },
              })),
              (li.prototype = Object.assign(Object.create(si.prototype), {
                constructor: li,
                interpolate_: function (t) {
                  return this.copySampleValue_(t - 1);
                },
              })),
              Object.assign(ui, {
                toJSON: function (t) {
                  var e,
                    n = t.constructor;
                  if (void 0 !== n.toJSON) e = n.toJSON(t);
                  else {
                    e = {
                      name: t.name,
                      times: eh.convertArray(t.times, Array),
                      values: eh.convertArray(t.values, Array),
                    };
                    var r = t.getInterpolation();
                    r !== t.DefaultInterpolation && (e.interpolation = r);
                  }
                  return (e.type = t.ValueTypeName), e;
                },
              }),
              Object.assign(ui.prototype, {
                constructor: ui,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function (t) {
                  return new li(
                    this.times,
                    this.values,
                    this.getValueSize(),
                    t
                  );
                },
                InterpolantFactoryMethodLinear: function (t) {
                  return new hi(
                    this.times,
                    this.values,
                    this.getValueSize(),
                    t
                  );
                },
                InterpolantFactoryMethodSmooth: function (t) {
                  return new ci(
                    this.times,
                    this.values,
                    this.getValueSize(),
                    t
                  );
                },
                setInterpolation: function (t) {
                  var e;
                  switch (t) {
                    case 2300:
                      e = this.InterpolantFactoryMethodDiscrete;
                      break;
                    case 2301:
                      e = this.InterpolantFactoryMethodLinear;
                      break;
                    case 2302:
                      e = this.InterpolantFactoryMethodSmooth;
                  }
                  if (void 0 === e) {
                    var n =
                      "unsupported interpolation for " +
                      this.ValueTypeName +
                      " keyframe track named " +
                      this.name;
                    if (void 0 === this.createInterpolant) {
                      if (t === this.DefaultInterpolation) throw new Error(n);
                      this.setInterpolation(this.DefaultInterpolation);
                    }
                    return console.warn("THREE.KeyframeTrack:", n), this;
                  }
                  return (this.createInterpolant = e), this;
                },
                getInterpolation: function () {
                  switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                      return 2300;
                    case this.InterpolantFactoryMethodLinear:
                      return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                      return 2302;
                  }
                },
                getValueSize: function () {
                  return this.values.length / this.times.length;
                },
                shift: function (t) {
                  if (0 !== t)
                    for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
                      e[n] += t;
                  return this;
                },
                scale: function (t) {
                  if (1 !== t)
                    for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
                      e[n] *= t;
                  return this;
                },
                trim: function (t, e) {
                  for (
                    var n = this.times, r = n.length, i = 0, a = r - 1;
                    i !== r && n[i] < t;

                  )
                    ++i;
                  for (; -1 !== a && n[a] > e; ) --a;
                  if ((++a, 0 !== i || a !== r)) {
                    i >= a && ((a = Math.max(a, 1)), (i = a - 1));
                    var o = this.getValueSize();
                    (this.times = eh.arraySlice(n, i, a)),
                      (this.values = eh.arraySlice(this.values, i * o, a * o));
                  }
                  return this;
                },
                validate: function () {
                  var t = !0,
                    e = this.getValueSize();
                  e - Math.floor(e) != 0 &&
                    (console.error(
                      "THREE.KeyframeTrack: Invalid value size in track.",
                      this
                    ),
                    (t = !1));
                  var n = this.times,
                    r = this.values,
                    i = n.length;
                  0 === i &&
                    (console.error(
                      "THREE.KeyframeTrack: Track is empty.",
                      this
                    ),
                    (t = !1));
                  for (var a = null, o = 0; o !== i; o++) {
                    var s = n[o];
                    if ("number" == typeof s && isNaN(s)) {
                      console.error(
                        "THREE.KeyframeTrack: Time is not a valid number.",
                        this,
                        o,
                        s
                      ),
                        (t = !1);
                      break;
                    }
                    if (null !== a && a > s) {
                      console.error(
                        "THREE.KeyframeTrack: Out of order keys.",
                        this,
                        o,
                        s,
                        a
                      ),
                        (t = !1);
                      break;
                    }
                    a = s;
                  }
                  if (void 0 !== r && eh.isTypedArray(r))
                    for (var o = 0, c = r.length; o !== c; ++o) {
                      var h = r[o];
                      if (isNaN(h)) {
                        console.error(
                          "THREE.KeyframeTrack: Value is not a valid number.",
                          this,
                          o,
                          h
                        ),
                          (t = !1);
                        break;
                      }
                    }
                  return t;
                },
                optimize: function () {
                  for (
                    var t = this.times,
                      e = this.values,
                      n = this.getValueSize(),
                      r = 2302 === this.getInterpolation(),
                      i = 1,
                      a = t.length - 1,
                      o = 1;
                    o < a;
                    ++o
                  ) {
                    var s = !1,
                      c = t[o];
                    if (c !== t[o + 1] && (1 !== o || c !== c[0]))
                      if (r) s = !0;
                      else
                        for (
                          var h = o * n, l = h - n, u = h + n, p = 0;
                          p !== n;
                          ++p
                        ) {
                          var d = e[h + p];
                          if (d !== e[l + p] || d !== e[u + p]) {
                            s = !0;
                            break;
                          }
                        }
                    if (s) {
                      if (o !== i) {
                        t[i] = t[o];
                        for (var f = o * n, m = i * n, p = 0; p !== n; ++p)
                          e[m + p] = e[f + p];
                      }
                      ++i;
                    }
                  }
                  if (a > 0) {
                    t[i] = t[a];
                    for (var f = a * n, m = i * n, p = 0; p !== n; ++p)
                      e[m + p] = e[f + p];
                    ++i;
                  }
                  return (
                    i !== t.length &&
                      ((this.times = eh.arraySlice(t, 0, i)),
                      (this.values = eh.arraySlice(e, 0, i * n))),
                    this
                  );
                },
              }),
              (pi.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: pi,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0,
              })),
              (di.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: di,
                ValueTypeName: "color",
              })),
              (fi.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: fi,
                ValueTypeName: "number",
              })),
              (mi.prototype = Object.assign(Object.create(si.prototype), {
                constructor: mi,
                interpolate_: function (t, e, n, r) {
                  for (
                    var a = this.resultBuffer,
                      o = this.sampleValues,
                      s = this.valueSize,
                      c = t * s,
                      h = (n - e) / (r - e),
                      l = c + s;
                    c !== l;
                    c += 4
                  )
                    i.slerpFlat(a, 0, o, c - s, o, c, h);
                  return a;
                },
              })),
              (gi.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: gi,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function (t) {
                  return new mi(
                    this.times,
                    this.values,
                    this.getValueSize(),
                    t
                  );
                },
                InterpolantFactoryMethodSmooth: void 0,
              })),
              (vi.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: vi,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0,
              })),
              (yi.prototype = Object.assign(Object.create(ui.prototype), {
                constructor: yi,
                ValueTypeName: "vector",
              })),
              Object.assign(xi, {
                parse: function (t) {
                  for (
                    var e = [],
                      n = t.tracks,
                      r = 1 / (t.fps || 1),
                      i = 0,
                      a = n.length;
                    i !== a;
                    ++i
                  )
                    e.push(_i(n[i]).scale(r));
                  return new xi(t.name, t.duration, e);
                },
                toJSON: function (t) {
                  for (
                    var e = [],
                      n = t.tracks,
                      r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                      },
                      i = 0,
                      a = n.length;
                    i !== a;
                    ++i
                  )
                    e.push(ui.toJSON(n[i]));
                  return r;
                },
                CreateFromMorphTargetSequence: function (t, e, n, r) {
                  for (var i = e.length, a = [], o = 0; o < i; o++) {
                    var s = [],
                      c = [];
                    s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);
                    var h = eh.getKeyframeOrder(s);
                    (s = eh.sortedArray(s, 1, h)),
                      (c = eh.sortedArray(c, 1, h)),
                      r || 0 !== s[0] || (s.push(i), c.push(c[0])),
                      a.push(
                        new fi(
                          ".morphTargetInfluences[" + e[o].name + "]",
                          s,
                          c
                        ).scale(1 / n)
                      );
                  }
                  return new xi(t, -1, a);
                },
                findByName: function (t, e) {
                  var n = t;
                  if (!Array.isArray(t)) {
                    var r = t;
                    n = (r.geometry && r.geometry.animations) || r.animations;
                  }
                  for (var i = 0; i < n.length; i++)
                    if (n[i].name === e) return n[i];
                  return null;
                },
                CreateClipsFromMorphTargetSequences: function (t, e, n) {
                  for (
                    var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length;
                    a < o;
                    a++
                  ) {
                    var s = t[a],
                      c = s.name.match(i);
                    if (c && c.length > 1) {
                      var h = c[1],
                        l = r[h];
                      l || (r[h] = l = []), l.push(s);
                    }
                  }
                  var u = [];
                  for (var h in r)
                    u.push(xi.CreateFromMorphTargetSequence(h, r[h], e, n));
                  return u;
                },
                parseAnimation: function (t, e) {
                  if (!t)
                    return (
                      console.error(
                        "THREE.AnimationClip: No animation in JSONLoader data."
                      ),
                      null
                    );
                  for (
                    var n = function (t, e, n, r, i) {
                        if (0 !== n.length) {
                          var a = [],
                            o = [];
                          eh.flattenJSON(n, a, o, r),
                            0 !== a.length && i.push(new t(e, a, o));
                        }
                      },
                      r = [],
                      i = t.name || "default",
                      a = t.length || -1,
                      o = t.fps || 30,
                      s = t.hierarchy || [],
                      c = 0;
                    c < s.length;
                    c++
                  ) {
                    var h = s[c].keys;
                    if (h && 0 !== h.length)
                      if (h[0].morphTargets) {
                        for (var l = {}, u = 0; u < h.length; u++)
                          if (h[u].morphTargets)
                            for (var p = 0; p < h[u].morphTargets.length; p++)
                              l[h[u].morphTargets[p]] = -1;
                        for (var d in l) {
                          for (
                            var f = [], m = [], p = 0;
                            p !== h[u].morphTargets.length;
                            ++p
                          ) {
                            var g = h[u];
                            f.push(g.time), m.push(g.morphTarget === d ? 1 : 0);
                          }
                          r.push(
                            new fi(".morphTargetInfluence[" + d + "]", f, m)
                          );
                        }
                        a = l.length * (o || 1);
                      } else {
                        var v = ".bones[" + e[c].name + "]";
                        n(yi, v + ".position", h, "pos", r),
                          n(gi, v + ".quaternion", h, "rot", r),
                          n(yi, v + ".scale", h, "scl", r);
                      }
                  }
                  return 0 === r.length ? null : new xi(i, a, r);
                },
              }),
              Object.assign(xi.prototype, {
                resetDuration: function () {
                  for (
                    var t = this.tracks, e = 0, n = 0, r = t.length;
                    n !== r;
                    ++n
                  ) {
                    var i = this.tracks[n];
                    e = Math.max(e, i.times[i.times.length - 1]);
                  }
                  return (this.duration = e), this;
                },
                trim: function () {
                  for (var t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                  return this;
                },
                validate: function () {
                  for (var t = !0, e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                  return t;
                },
                optimize: function () {
                  for (var t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                  return this;
                },
              }),
              Object.assign(wi.prototype, {
                load: function (t, e, n, r) {
                  var i = this;
                  new br(i.manager).load(
                    t,
                    function (t) {
                      e(i.parse(JSON.parse(t)));
                    },
                    n,
                    r
                  );
                },
                setTextures: function (t) {
                  this.textures = t;
                },
                parse: function (t) {
                  function e(t) {
                    return (
                      void 0 === r[t] &&
                        console.warn(
                          "THREE.MaterialLoader: Undefined texture",
                          t
                        ),
                      r[t]
                    );
                  }
                  var r = this.textures,
                    i = new Xc[t.type]();
                  if (
                    (void 0 !== t.uuid && (i.uuid = t.uuid),
                    void 0 !== t.name && (i.name = t.name),
                    void 0 !== t.color && i.color.setHex(t.color),
                    void 0 !== t.roughness && (i.roughness = t.roughness),
                    void 0 !== t.metalness && (i.metalness = t.metalness),
                    void 0 !== t.emissive && i.emissive.setHex(t.emissive),
                    void 0 !== t.specular && i.specular.setHex(t.specular),
                    void 0 !== t.shininess && (i.shininess = t.shininess),
                    void 0 !== t.clearCoat && (i.clearCoat = t.clearCoat),
                    void 0 !== t.clearCoatRoughness &&
                      (i.clearCoatRoughness = t.clearCoatRoughness),
                    void 0 !== t.uniforms && (i.uniforms = t.uniforms),
                    void 0 !== t.vertexShader &&
                      (i.vertexShader = t.vertexShader),
                    void 0 !== t.fragmentShader &&
                      (i.fragmentShader = t.fragmentShader),
                    void 0 !== t.vertexColors &&
                      (i.vertexColors = t.vertexColors),
                    void 0 !== t.fog && (i.fog = t.fog),
                    void 0 !== t.flatShading && (i.flatShading = t.flatShading),
                    void 0 !== t.blending && (i.blending = t.blending),
                    void 0 !== t.side && (i.side = t.side),
                    void 0 !== t.opacity && (i.opacity = t.opacity),
                    void 0 !== t.transparent && (i.transparent = t.transparent),
                    void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
                    void 0 !== t.depthTest && (i.depthTest = t.depthTest),
                    void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
                    void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
                    void 0 !== t.wireframe && (i.wireframe = t.wireframe),
                    void 0 !== t.wireframeLinewidth &&
                      (i.wireframeLinewidth = t.wireframeLinewidth),
                    void 0 !== t.wireframeLinecap &&
                      (i.wireframeLinecap = t.wireframeLinecap),
                    void 0 !== t.wireframeLinejoin &&
                      (i.wireframeLinejoin = t.wireframeLinejoin),
                    void 0 !== t.rotation && (i.rotation = t.rotation),
                    1 !== t.linewidth && (i.linewidth = t.linewidth),
                    void 0 !== t.dashSize && (i.dashSize = t.dashSize),
                    void 0 !== t.gapSize && (i.gapSize = t.gapSize),
                    void 0 !== t.scale && (i.scale = t.scale),
                    void 0 !== t.polygonOffset &&
                      (i.polygonOffset = t.polygonOffset),
                    void 0 !== t.polygonOffsetFactor &&
                      (i.polygonOffsetFactor = t.polygonOffsetFactor),
                    void 0 !== t.polygonOffsetUnits &&
                      (i.polygonOffsetUnits = t.polygonOffsetUnits),
                    void 0 !== t.skinning && (i.skinning = t.skinning),
                    void 0 !== t.morphTargets &&
                      (i.morphTargets = t.morphTargets),
                    void 0 !== t.dithering && (i.dithering = t.dithering),
                    void 0 !== t.visible && (i.visible = t.visible),
                    void 0 !== t.userData && (i.userData = t.userData),
                    void 0 !== t.shading && (i.flatShading = 1 === t.shading),
                    void 0 !== t.size && (i.size = t.size),
                    void 0 !== t.sizeAttenuation &&
                      (i.sizeAttenuation = t.sizeAttenuation),
                    void 0 !== t.map && (i.map = e(t.map)),
                    void 0 !== t.alphaMap &&
                      ((i.alphaMap = e(t.alphaMap)), (i.transparent = !0)),
                    void 0 !== t.bumpMap && (i.bumpMap = e(t.bumpMap)),
                    void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
                    void 0 !== t.normalMap && (i.normalMap = e(t.normalMap)),
                    void 0 !== t.normalMapType &&
                      (i.normalMapType = t.normalMapType),
                    void 0 !== t.normalScale)
                  ) {
                    var a = t.normalScale;
                    !1 === Array.isArray(a) && (a = [a, a]),
                      (i.normalScale = new n().fromArray(a));
                  }
                  return (
                    void 0 !== t.displacementMap &&
                      (i.displacementMap = e(t.displacementMap)),
                    void 0 !== t.displacementScale &&
                      (i.displacementScale = t.displacementScale),
                    void 0 !== t.displacementBias &&
                      (i.displacementBias = t.displacementBias),
                    void 0 !== t.roughnessMap &&
                      (i.roughnessMap = e(t.roughnessMap)),
                    void 0 !== t.metalnessMap &&
                      (i.metalnessMap = e(t.metalnessMap)),
                    void 0 !== t.emissiveMap &&
                      (i.emissiveMap = e(t.emissiveMap)),
                    void 0 !== t.emissiveIntensity &&
                      (i.emissiveIntensity = t.emissiveIntensity),
                    void 0 !== t.specularMap &&
                      (i.specularMap = e(t.specularMap)),
                    void 0 !== t.envMap && (i.envMap = e(t.envMap)),
                    void 0 !== t.reflectivity &&
                      (i.reflectivity = t.reflectivity),
                    void 0 !== t.lightMap && (i.lightMap = e(t.lightMap)),
                    void 0 !== t.lightMapIntensity &&
                      (i.lightMapIntensity = t.lightMapIntensity),
                    void 0 !== t.aoMap && (i.aoMap = e(t.aoMap)),
                    void 0 !== t.aoMapIntensity &&
                      (i.aoMapIntensity = t.aoMapIntensity),
                    void 0 !== t.gradientMap &&
                      (i.gradientMap = e(t.gradientMap)),
                    i
                  );
                },
              }),
              Object.assign(Mi.prototype, {
                load: function (t, e, n, r) {
                  var i = this;
                  new br(i.manager).load(
                    t,
                    function (t) {
                      e(i.parse(JSON.parse(t)));
                    },
                    n,
                    r
                  );
                },
                parse: function (t) {
                  var e = new F(),
                    n = t.data.index;
                  if (void 0 !== n) {
                    var r = new nh[n.type](n.array);
                    e.setIndex(new S(r, 1));
                  }
                  var i = t.data.attributes;
                  for (var o in i) {
                    var s = i[o],
                      r = new nh[s.type](s.array);
                    e.addAttribute(o, new S(r, s.itemSize, s.normalized));
                  }
                  var c = t.data.groups || t.data.drawcalls || t.data.offsets;
                  if (void 0 !== c)
                    for (var h = 0, l = c.length; h !== l; ++h) {
                      var u = c[h];
                      e.addGroup(u.start, u.count, u.materialIndex);
                    }
                  var p = t.data.boundingSphere;
                  if (void 0 !== p) {
                    var f = new a();
                    void 0 !== p.center && f.fromArray(p.center),
                      (e.boundingSphere = new d(f, p.radius));
                  }
                  return e;
                },
              });
            var nh = {
              Int8Array: Int8Array,
              Uint8Array: Uint8Array,
              Uint8ClampedArray:
                "undefined" != typeof Uint8ClampedArray
                  ? Uint8ClampedArray
                  : Uint8Array,
              Int16Array: Int16Array,
              Uint16Array: Uint16Array,
              Int32Array: Int32Array,
              Uint32Array: Uint32Array,
              Float32Array: Float32Array,
              Float64Array: Float64Array,
            };
            (Ei.Handlers = {
              handlers: [],
              add: function (t, e) {
                this.handlers.push(t, e);
              },
              get: function (t) {
                for (
                  var e = this.handlers, n = 0, r = e.length;
                  n < r;
                  n += 2
                ) {
                  var i = e[n],
                    a = e[n + 1];
                  if (i.test(t)) return a;
                }
                return null;
              },
            }),
              Object.assign(Ei.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function () {},
                onLoadProgress: function () {},
                onLoadComplete: function () {},
                initMaterials: function (t, e, n) {
                  for (var r = [], i = 0; i < t.length; ++i)
                    r[i] = this.createMaterial(t[i], e, n);
                  return r;
                },
                createMaterial: (function () {
                  var t = {
                      NoBlending: fo,
                      NormalBlending: mo,
                      AdditiveBlending: go,
                      SubtractiveBlending: vo,
                      MultiplyBlending: yo,
                      CustomBlending: xo,
                    },
                    e = new g(),
                    n = new Tr(),
                    r = new wi();
                  return function (i, a, o) {
                    function s(t, e, r, i, s) {
                      var h,
                        l = a + t,
                        u = Ei.Handlers.get(l);
                      null !== u
                        ? (h = u.load(l))
                        : (n.setCrossOrigin(o), (h = n.load(l))),
                        void 0 !== e &&
                          (h.repeat.fromArray(e),
                          1 !== e[0] && (h.wrapS = as),
                          1 !== e[1] && (h.wrapT = as)),
                        void 0 !== r && h.offset.fromArray(r),
                        void 0 !== i &&
                          ("repeat" === i[0] && (h.wrapS = as),
                          "mirror" === i[0] && (h.wrapS = ss),
                          "repeat" === i[1] && (h.wrapT = as),
                          "mirror" === i[1] && (h.wrapT = ss)),
                        void 0 !== s && (h.anisotropy = s);
                      var p = xc.generateUUID();
                      return (c[p] = h), p;
                    }
                    var c = {},
                      h = {
                        uuid: xc.generateUUID(),
                        type: "MeshLambertMaterial",
                      };
                    for (var l in i) {
                      var u = i[l];
                      switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                          break;
                        case "DbgName":
                          h.name = u;
                          break;
                        case "blending":
                          h.blending = t[u];
                          break;
                        case "colorAmbient":
                        case "mapAmbient":
                          console.warn(
                            "THREE.Loader.createMaterial:",
                            l,
                            "is no longer supported."
                          );
                          break;
                        case "colorDiffuse":
                          h.color = e.fromArray(u).getHex();
                          break;
                        case "colorSpecular":
                          h.specular = e.fromArray(u).getHex();
                          break;
                        case "colorEmissive":
                          h.emissive = e.fromArray(u).getHex();
                          break;
                        case "specularCoef":
                          h.shininess = u;
                          break;
                        case "shading":
                          "basic" === u.toLowerCase() &&
                            (h.type = "MeshBasicMaterial"),
                            "phong" === u.toLowerCase() &&
                              (h.type = "MeshPhongMaterial"),
                            "standard" === u.toLowerCase() &&
                              (h.type = "MeshStandardMaterial");
                          break;
                        case "mapDiffuse":
                          h.map = s(
                            u,
                            i.mapDiffuseRepeat,
                            i.mapDiffuseOffset,
                            i.mapDiffuseWrap,
                            i.mapDiffuseAnisotropy
                          );
                          break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                          break;
                        case "mapEmissive":
                          h.emissiveMap = s(
                            u,
                            i.mapEmissiveRepeat,
                            i.mapEmissiveOffset,
                            i.mapEmissiveWrap,
                            i.mapEmissiveAnisotropy
                          );
                          break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                          break;
                        case "mapLight":
                          h.lightMap = s(
                            u,
                            i.mapLightRepeat,
                            i.mapLightOffset,
                            i.mapLightWrap,
                            i.mapLightAnisotropy
                          );
                          break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                          break;
                        case "mapAO":
                          h.aoMap = s(
                            u,
                            i.mapAORepeat,
                            i.mapAOOffset,
                            i.mapAOWrap,
                            i.mapAOAnisotropy
                          );
                          break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                          break;
                        case "mapBump":
                          h.bumpMap = s(
                            u,
                            i.mapBumpRepeat,
                            i.mapBumpOffset,
                            i.mapBumpWrap,
                            i.mapBumpAnisotropy
                          );
                          break;
                        case "mapBumpScale":
                          h.bumpScale = u;
                          break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                          break;
                        case "mapNormal":
                          h.normalMap = s(
                            u,
                            i.mapNormalRepeat,
                            i.mapNormalOffset,
                            i.mapNormalWrap,
                            i.mapNormalAnisotropy
                          );
                          break;
                        case "mapNormalFactor":
                          h.normalScale = u;
                          break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                          break;
                        case "mapSpecular":
                          h.specularMap = s(
                            u,
                            i.mapSpecularRepeat,
                            i.mapSpecularOffset,
                            i.mapSpecularWrap,
                            i.mapSpecularAnisotropy
                          );
                          break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                          break;
                        case "mapMetalness":
                          h.metalnessMap = s(
                            u,
                            i.mapMetalnessRepeat,
                            i.mapMetalnessOffset,
                            i.mapMetalnessWrap,
                            i.mapMetalnessAnisotropy
                          );
                          break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                          break;
                        case "mapRoughness":
                          h.roughnessMap = s(
                            u,
                            i.mapRoughnessRepeat,
                            i.mapRoughnessOffset,
                            i.mapRoughnessWrap,
                            i.mapRoughnessAnisotropy
                          );
                          break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                          break;
                        case "mapAlpha":
                          h.alphaMap = s(
                            u,
                            i.mapAlphaRepeat,
                            i.mapAlphaOffset,
                            i.mapAlphaWrap,
                            i.mapAlphaAnisotropy
                          );
                          break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                          break;
                        case "flipSided":
                          h.side = co;
                          break;
                        case "doubleSided":
                          h.side = ho;
                          break;
                        case "transparency":
                          console.warn(
                            "THREE.Loader.createMaterial: transparency has been renamed to opacity"
                          ),
                            (h.opacity = u);
                          break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                          h[l] = u;
                          break;
                        case "vertexColors":
                          !0 === u && (h.vertexColors = po),
                            "face" === u && (h.vertexColors = uo);
                          break;
                        default:
                          console.error(
                            "THREE.Loader.createMaterial: Unsupported",
                            l,
                            u
                          );
                      }
                    }
                    return (
                      "MeshBasicMaterial" === h.type && delete h.emissive,
                      "MeshPhongMaterial" !== h.type && delete h.specular,
                      h.opacity < 1 && (h.transparent = !0),
                      r.setTextures(c),
                      r.parse(h)
                    );
                  };
                })(),
              });
            var rh = {
              decodeText: function (t) {
                if ("undefined" != typeof TextDecoder)
                  return new TextDecoder().decode(t);
                for (var e = "", n = 0, r = t.length; n < r; n++)
                  e += String.fromCharCode(t[n]);
                return decodeURIComponent(escape(e));
              },
              extractUrlBase: function (t) {
                var e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1);
              },
            };
            Object.assign(Ti.prototype, {
              crossOrigin: "anonymous",
              load: function (t, e, n, r) {
                var i = this,
                  a =
                    this.texturePath && "string" == typeof this.texturePath
                      ? this.texturePath
                      : rh.extractUrlBase(t),
                  o = new br(this.manager);
                o.setWithCredentials(this.withCredentials),
                  o.load(
                    t,
                    function (n) {
                      var r = JSON.parse(n),
                        o = r.metadata;
                      if (void 0 !== o) {
                        var s = o.type;
                        if (void 0 !== s && "object" === s.toLowerCase())
                          return void console.error(
                            "THREE.JSONLoader: " +
                              t +
                              " should be loaded with THREE.ObjectLoader instead."
                          );
                      }
                      var c = i.parse(r, a);
                      e(c.geometry, c.materials);
                    },
                    n,
                    r
                  );
              },
              setCrossOrigin: function (t) {
                return (this.crossOrigin = t), this;
              },
              setTexturePath: function (t) {
                return (this.texturePath = t), this;
              },
              parse: (function () {
                function t(t, e) {
                  function r(t, e) {
                    return t & (1 << e);
                  }
                  var i,
                    o,
                    s,
                    c,
                    h,
                    l,
                    u,
                    p,
                    d,
                    f,
                    m,
                    v,
                    y,
                    x,
                    b,
                    _,
                    w,
                    M,
                    T,
                    S,
                    A,
                    L,
                    R,
                    C,
                    P,
                    O,
                    I,
                    N = t.faces,
                    D = t.vertices,
                    U = t.normals,
                    B = t.colors,
                    F = t.scale,
                    z = 0;
                  if (void 0 !== t.uvs) {
                    for (i = 0; i < t.uvs.length; i++) t.uvs[i].length && z++;
                    for (i = 0; i < z; i++) e.faceVertexUvs[i] = [];
                  }
                  for (c = 0, h = D.length; c < h; )
                    (M = new a()),
                      (M.x = D[c++] * F),
                      (M.y = D[c++] * F),
                      (M.z = D[c++] * F),
                      e.vertices.push(M);
                  for (c = 0, h = N.length; c < h; )
                    if (
                      ((f = N[c++]),
                      (m = r(f, 0)),
                      (v = r(f, 1)),
                      (y = r(f, 3)),
                      (x = r(f, 4)),
                      (b = r(f, 5)),
                      (_ = r(f, 6)),
                      (w = r(f, 7)),
                      m)
                    ) {
                      if (
                        ((S = new E()),
                        (S.a = N[c]),
                        (S.b = N[c + 1]),
                        (S.c = N[c + 3]),
                        (A = new E()),
                        (A.a = N[c + 1]),
                        (A.b = N[c + 2]),
                        (A.c = N[c + 3]),
                        (c += 4),
                        v &&
                          ((d = N[c++]),
                          (S.materialIndex = d),
                          (A.materialIndex = d)),
                        (s = e.faces.length),
                        y)
                      )
                        for (i = 0; i < z; i++)
                          for (
                            C = t.uvs[i],
                              e.faceVertexUvs[i][s] = [],
                              e.faceVertexUvs[i][s + 1] = [],
                              o = 0;
                            o < 4;
                            o++
                          )
                            (p = N[c++]),
                              (O = C[2 * p]),
                              (I = C[2 * p + 1]),
                              (P = new n(O, I)),
                              2 !== o && e.faceVertexUvs[i][s].push(P),
                              0 !== o && e.faceVertexUvs[i][s + 1].push(P);
                      if (
                        (x &&
                          ((u = 3 * N[c++]),
                          S.normal.set(U[u++], U[u++], U[u]),
                          A.normal.copy(S.normal)),
                        b)
                      )
                        for (i = 0; i < 4; i++)
                          (u = 3 * N[c++]),
                            (R = new a(U[u++], U[u++], U[u])),
                            2 !== i && S.vertexNormals.push(R),
                            0 !== i && A.vertexNormals.push(R);
                      if (
                        (_ &&
                          ((l = N[c++]),
                          (L = B[l]),
                          S.color.setHex(L),
                          A.color.setHex(L)),
                        w)
                      )
                        for (i = 0; i < 4; i++)
                          (l = N[c++]),
                            (L = B[l]),
                            2 !== i && S.vertexColors.push(new g(L)),
                            0 !== i && A.vertexColors.push(new g(L));
                      e.faces.push(S), e.faces.push(A);
                    } else {
                      if (
                        ((T = new E()),
                        (T.a = N[c++]),
                        (T.b = N[c++]),
                        (T.c = N[c++]),
                        v && ((d = N[c++]), (T.materialIndex = d)),
                        (s = e.faces.length),
                        y)
                      )
                        for (i = 0; i < z; i++)
                          for (
                            C = t.uvs[i], e.faceVertexUvs[i][s] = [], o = 0;
                            o < 3;
                            o++
                          )
                            (p = N[c++]),
                              (O = C[2 * p]),
                              (I = C[2 * p + 1]),
                              (P = new n(O, I)),
                              e.faceVertexUvs[i][s].push(P);
                      if (
                        (x &&
                          ((u = 3 * N[c++]),
                          T.normal.set(U[u++], U[u++], U[u])),
                        b)
                      )
                        for (i = 0; i < 3; i++)
                          (u = 3 * N[c++]),
                            (R = new a(U[u++], U[u++], U[u])),
                            T.vertexNormals.push(R);
                      if ((_ && ((l = N[c++]), T.color.setHex(B[l])), w))
                        for (i = 0; i < 3; i++)
                          (l = N[c++]), T.vertexColors.push(new g(B[l]));
                      e.faces.push(T);
                    }
                }
                function e(t, e) {
                  var n =
                    void 0 !== t.influencesPerVertex
                      ? t.influencesPerVertex
                      : 2;
                  if (t.skinWeights)
                    for (var r = 0, i = t.skinWeights.length; r < i; r += n) {
                      var a = t.skinWeights[r],
                        o = n > 1 ? t.skinWeights[r + 1] : 0,
                        s = n > 2 ? t.skinWeights[r + 2] : 0,
                        h = n > 3 ? t.skinWeights[r + 3] : 0;
                      e.skinWeights.push(new c(a, o, s, h));
                    }
                  if (t.skinIndices)
                    for (var r = 0, i = t.skinIndices.length; r < i; r += n) {
                      var l = t.skinIndices[r],
                        u = n > 1 ? t.skinIndices[r + 1] : 0,
                        p = n > 2 ? t.skinIndices[r + 2] : 0,
                        d = n > 3 ? t.skinIndices[r + 3] : 0;
                      e.skinIndices.push(new c(l, u, p, d));
                    }
                  (e.bones = t.bones),
                    e.bones &&
                      e.bones.length > 0 &&
                      (e.skinWeights.length !== e.skinIndices.length ||
                        e.skinIndices.length !== e.vertices.length) &&
                      console.warn(
                        "When skinning, number of vertices (" +
                          e.vertices.length +
                          "), skinIndices (" +
                          e.skinIndices.length +
                          "), and skinWeights (" +
                          e.skinWeights.length +
                          ") should match."
                      );
                }
                function r(t, e) {
                  var n = t.scale;
                  if (void 0 !== t.morphTargets)
                    for (var r = 0, i = t.morphTargets.length; r < i; r++) {
                      (e.morphTargets[r] = {}),
                        (e.morphTargets[r].name = t.morphTargets[r].name),
                        (e.morphTargets[r].vertices = []);
                      for (
                        var o = e.morphTargets[r].vertices,
                          s = t.morphTargets[r].vertices,
                          c = 0,
                          h = s.length;
                        c < h;
                        c += 3
                      ) {
                        var l = new a();
                        (l.x = s[c] * n),
                          (l.y = s[c + 1] * n),
                          (l.z = s[c + 2] * n),
                          o.push(l);
                      }
                    }
                  if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                    console.warn(
                      'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
                    );
                    for (
                      var u = e.faces,
                        p = t.morphColors[0].colors,
                        r = 0,
                        i = u.length;
                      r < i;
                      r++
                    )
                      u[r].color.fromArray(p, 3 * r);
                  }
                }
                function i(t, e) {
                  var n = [],
                    r = [];
                  void 0 !== t.animation && r.push(t.animation),
                    void 0 !== t.animations &&
                      (t.animations.length
                        ? (r = r.concat(t.animations))
                        : r.push(t.animations));
                  for (var i = 0; i < r.length; i++) {
                    var a = xi.parseAnimation(r[i], e.bones);
                    a && n.push(a);
                  }
                  if (e.morphTargets) {
                    var o = xi.CreateClipsFromMorphTargetSequences(
                      e.morphTargets,
                      10
                    );
                    n = n.concat(o);
                  }
                  n.length > 0 && (e.animations = n);
                }
                return function (n, a) {
                  void 0 !== n.data && (n = n.data),
                    void 0 !== n.scale
                      ? (n.scale = 1 / n.scale)
                      : (n.scale = 1);
                  var o = new T();
                  return (
                    t(n, o),
                    e(n, o),
                    r(n, o),
                    i(n, o),
                    o.computeFaceNormals(),
                    o.computeBoundingSphere(),
                    void 0 === n.materials || 0 === n.materials.length
                      ? { geometry: o }
                      : {
                          geometry: o,
                          materials: Ei.prototype.initMaterials(
                            n.materials,
                            a,
                            this.crossOrigin
                          ),
                        }
                  );
                };
              })(),
            }),
              Object.assign(Si.prototype, {
                crossOrigin: "anonymous",
                load: function (t, e, n, r) {
                  "" === this.texturePath &&
                    (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                  var i = this;
                  new br(i.manager).load(
                    t,
                    function (n) {
                      var a = null;
                      try {
                        a = JSON.parse(n);
                      } catch (e) {
                        return (
                          void 0 !== r && r(e),
                          void console.error(
                            "THREE:ObjectLoader: Can't parse " + t + ".",
                            e.message
                          )
                        );
                      }
                      var o = a.metadata;
                      if (
                        void 0 === o ||
                        void 0 === o.type ||
                        "geometry" === o.type.toLowerCase()
                      )
                        return void console.error(
                          "THREE.ObjectLoader: Can't load " +
                            t +
                            ". Use THREE.JSONLoader instead."
                        );
                      i.parse(a, e);
                    },
                    n,
                    r
                  );
                },
                setTexturePath: function (t) {
                  return (this.texturePath = t), this;
                },
                setCrossOrigin: function (t) {
                  return (this.crossOrigin = t), this;
                },
                parse: function (t, e) {
                  var n = this.parseShape(t.shapes),
                    r = this.parseGeometries(t.geometries, n),
                    i = this.parseImages(t.images, function () {
                      void 0 !== e && e(s);
                    }),
                    a = this.parseTextures(t.textures, i),
                    o = this.parseMaterials(t.materials, a),
                    s = this.parseObject(t.object, r, o);
                  return (
                    t.animations &&
                      (s.animations = this.parseAnimations(t.animations)),
                    (void 0 !== t.images && 0 !== t.images.length) ||
                      (void 0 !== e && e(s)),
                    s
                  );
                },
                parseShape: function (t) {
                  var e = {};
                  if (void 0 !== t)
                    for (var n = 0, r = t.length; n < r; n++) {
                      var i = new Zr().fromJSON(t[n]);
                      e[i.uuid] = i;
                    }
                  return e;
                },
                parseGeometries: function (t, e) {
                  var n = {};
                  if (void 0 !== t)
                    for (
                      var r = new Ti(), i = new Mi(), a = 0, o = t.length;
                      a < o;
                      a++
                    ) {
                      var s,
                        c = t[a];
                      switch (c.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                          s = new Wc[c.type](
                            c.width,
                            c.height,
                            c.widthSegments,
                            c.heightSegments
                          );
                          break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                          s = new Wc[c.type](
                            c.width,
                            c.height,
                            c.depth,
                            c.widthSegments,
                            c.heightSegments,
                            c.depthSegments
                          );
                          break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                          s = new Wc[c.type](
                            c.radius,
                            c.segments,
                            c.thetaStart,
                            c.thetaLength
                          );
                          break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                          s = new Wc[c.type](
                            c.radiusTop,
                            c.radiusBottom,
                            c.height,
                            c.radialSegments,
                            c.heightSegments,
                            c.openEnded,
                            c.thetaStart,
                            c.thetaLength
                          );
                          break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                          s = new Wc[c.type](
                            c.radius,
                            c.height,
                            c.radialSegments,
                            c.heightSegments,
                            c.openEnded,
                            c.thetaStart,
                            c.thetaLength
                          );
                          break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                          s = new Wc[c.type](
                            c.radius,
                            c.widthSegments,
                            c.heightSegments,
                            c.phiStart,
                            c.phiLength,
                            c.thetaStart,
                            c.thetaLength
                          );
                          break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                          s = new Wc[c.type](c.radius, c.detail);
                          break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                          s = new Wc[c.type](
                            c.innerRadius,
                            c.outerRadius,
                            c.thetaSegments,
                            c.phiSegments,
                            c.thetaStart,
                            c.thetaLength
                          );
                          break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                          s = new Wc[c.type](
                            c.radius,
                            c.tube,
                            c.radialSegments,
                            c.tubularSegments,
                            c.arc
                          );
                          break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                          s = new Wc[c.type](
                            c.radius,
                            c.tube,
                            c.tubularSegments,
                            c.radialSegments,
                            c.p,
                            c.q
                          );
                          break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                          s = new Wc[c.type](
                            c.points,
                            c.segments,
                            c.phiStart,
                            c.phiLength
                          );
                          break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                          s = new Wc[c.type](
                            c.vertices,
                            c.indices,
                            c.radius,
                            c.details
                          );
                          break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                          for (
                            var h = [], l = 0, u = c.shapes.length;
                            l < u;
                            l++
                          ) {
                            var p = e[c.shapes[l]];
                            h.push(p);
                          }
                          s = new Wc[c.type](h, c.curveSegments);
                          break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                          for (
                            var h = [], l = 0, u = c.shapes.length;
                            l < u;
                            l++
                          ) {
                            var p = e[c.shapes[l]];
                            h.push(p);
                          }
                          var d = c.options.extrudePath;
                          void 0 !== d &&
                            (c.options.extrudePath = new th[d.type]().fromJSON(
                              d
                            )),
                            (s = new Wc[c.type](h, c.options));
                          break;
                        case "BufferGeometry":
                          s = i.parse(c);
                          break;
                        case "Geometry":
                          s = r.parse(c, this.texturePath).geometry;
                          break;
                        default:
                          console.warn(
                            'THREE.ObjectLoader: Unsupported geometry type "' +
                              c.type +
                              '"'
                          );
                          continue;
                      }
                      (s.uuid = c.uuid),
                        void 0 !== c.name && (s.name = c.name),
                        !0 === s.isBufferGeometry &&
                          void 0 !== c.userData &&
                          (s.userData = c.userData),
                        (n[c.uuid] = s);
                    }
                  return n;
                },
                parseMaterials: function (t, e) {
                  var n = {};
                  if (void 0 !== t) {
                    var r = new wi();
                    r.setTextures(e);
                    for (var i = 0, a = t.length; i < a; i++) {
                      var o = t[i];
                      if ("MultiMaterial" === o.type) {
                        for (var s = [], c = 0; c < o.materials.length; c++)
                          s.push(r.parse(o.materials[c]));
                        n[o.uuid] = s;
                      } else n[o.uuid] = r.parse(o);
                    }
                  }
                  return n;
                },
                parseAnimations: function (t) {
                  for (var e = [], n = 0; n < t.length; n++) {
                    var r = t[n],
                      i = xi.parse(r);
                    void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i);
                  }
                  return e;
                },
                parseImages: function (t, e) {
                  function n(t) {
                    return (
                      r.manager.itemStart(t),
                      o.load(
                        t,
                        function () {
                          r.manager.itemEnd(t);
                        },
                        void 0,
                        function () {
                          r.manager.itemEnd(t), r.manager.itemError(t);
                        }
                      )
                    );
                  }
                  var r = this,
                    i = {};
                  if (void 0 !== t && t.length > 0) {
                    var a = new xr(e),
                      o = new Mr(a);
                    o.setCrossOrigin(this.crossOrigin);
                    for (var s = 0, c = t.length; s < c; s++) {
                      var h = t[s],
                        l = h.url;
                      if (Array.isArray(l)) {
                        i[h.uuid] = [];
                        for (var u = 0, p = l.length; u < p; u++) {
                          var d = l[u],
                            f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)
                              ? d
                              : r.texturePath + d;
                          i[h.uuid].push(n(f));
                        }
                      } else {
                        var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url)
                          ? h.url
                          : r.texturePath + h.url;
                        i[h.uuid] = n(f);
                      }
                    }
                  }
                  return i;
                },
                parseTextures: function (t, e) {
                  function n(t, e) {
                    return "number" == typeof t
                      ? t
                      : (console.warn(
                          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                          t
                        ),
                        e[t]);
                  }
                  var r = {};
                  if (void 0 !== t)
                    for (var i = 0, a = t.length; i < a; i++) {
                      var o = t[i];
                      void 0 === o.image &&
                        console.warn(
                          'THREE.ObjectLoader: No "image" specified for',
                          o.uuid
                        ),
                        void 0 === e[o.image] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined image",
                            o.image
                          );
                      var c;
                      (c = Array.isArray(e[o.image])
                        ? new ot(e[o.image])
                        : new s(e[o.image])),
                        (c.needsUpdate = !0),
                        (c.uuid = o.uuid),
                        void 0 !== o.name && (c.name = o.name),
                        void 0 !== o.mapping && (c.mapping = n(o.mapping, ih)),
                        void 0 !== o.offset && c.offset.fromArray(o.offset),
                        void 0 !== o.repeat && c.repeat.fromArray(o.repeat),
                        void 0 !== o.center && c.center.fromArray(o.center),
                        void 0 !== o.rotation && (c.rotation = o.rotation),
                        void 0 !== o.wrap &&
                          ((c.wrapS = n(o.wrap[0], ah)),
                          (c.wrapT = n(o.wrap[1], ah))),
                        void 0 !== o.format && (c.format = o.format),
                        void 0 !== o.minFilter &&
                          (c.minFilter = n(o.minFilter, oh)),
                        void 0 !== o.magFilter &&
                          (c.magFilter = n(o.magFilter, oh)),
                        void 0 !== o.anisotropy &&
                          (c.anisotropy = o.anisotropy),
                        void 0 !== o.flipY && (c.flipY = o.flipY),
                        (r[o.uuid] = c);
                    }
                  return r;
                },
                parseObject: function (t, e, n) {
                  function r(t) {
                    return (
                      void 0 === e[t] &&
                        console.warn(
                          "THREE.ObjectLoader: Undefined geometry",
                          t
                        ),
                      e[t]
                    );
                  }
                  function i(t) {
                    if (void 0 !== t) {
                      if (Array.isArray(t)) {
                        for (var e = [], r = 0, i = t.length; r < i; r++) {
                          var a = t[r];
                          void 0 === n[a] &&
                            console.warn(
                              "THREE.ObjectLoader: Undefined material",
                              a
                            ),
                            e.push(n[a]);
                        }
                        return e;
                      }
                      return (
                        void 0 === n[t] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined material",
                            t
                          ),
                        n[t]
                      );
                    }
                  }
                  var a;
                  switch (t.type) {
                    case "Scene":
                      (a = new Le()),
                        void 0 !== t.background &&
                          Number.isInteger(t.background) &&
                          (a.background = new g(t.background)),
                        void 0 !== t.fog &&
                          ("Fog" === t.fog.type
                            ? (a.fog = new Ae(
                                t.fog.color,
                                t.fog.near,
                                t.fog.far
                              ))
                            : "FogExp2" === t.fog.type &&
                              (a.fog = new Se(t.fog.color, t.fog.density)));
                      break;
                    case "PerspectiveCamera":
                      (a = new _e(t.fov, t.aspect, t.near, t.far)),
                        void 0 !== t.focus && (a.focus = t.focus),
                        void 0 !== t.zoom && (a.zoom = t.zoom),
                        void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge),
                        void 0 !== t.filmOffset &&
                          (a.filmOffset = t.filmOffset),
                        void 0 !== t.view &&
                          (a.view = Object.assign({}, t.view));
                      break;
                    case "OrthographicCamera":
                      (a = new M(
                        t.left,
                        t.right,
                        t.top,
                        t.bottom,
                        t.near,
                        t.far
                      )),
                        void 0 !== t.zoom && (a.zoom = t.zoom),
                        void 0 !== t.view &&
                          (a.view = Object.assign({}, t.view));
                      break;
                    case "AmbientLight":
                      a = new ai(t.color, t.intensity);
                      break;
                    case "DirectionalLight":
                      a = new ii(t.color, t.intensity);
                      break;
                    case "PointLight":
                      a = new ni(t.color, t.intensity, t.distance, t.decay);
                      break;
                    case "RectAreaLight":
                      a = new oi(t.color, t.intensity, t.width, t.height);
                      break;
                    case "SpotLight":
                      a = new ei(
                        t.color,
                        t.intensity,
                        t.distance,
                        t.angle,
                        t.penumbra,
                        t.decay
                      );
                      break;
                    case "HemisphereLight":
                      a = new Kr(t.color, t.groundColor, t.intensity);
                      break;
                    case "SkinnedMesh":
                      console.warn(
                        "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
                      );
                    case "Mesh":
                      var o = r(t.geometry),
                        s = i(t.material);
                      a =
                        o.bones && o.bones.length > 0
                          ? new Ue(o, s)
                          : new Y(o, s);
                      break;
                    case "LOD":
                      a = new Ie();
                      break;
                    case "Line":
                      a = new Fe(r(t.geometry), i(t.material), t.mode);
                      break;
                    case "LineLoop":
                      a = new Ge(r(t.geometry), i(t.material));
                      break;
                    case "LineSegments":
                      a = new ze(r(t.geometry), i(t.material));
                      break;
                    case "PointCloud":
                    case "Points":
                      a = new Ve(r(t.geometry), i(t.material));
                      break;
                    case "Sprite":
                      a = new Oe(i(t.material));
                      break;
                    case "Group":
                      a = new be();
                      break;
                    default:
                      a = new _();
                  }
                  if (
                    ((a.uuid = t.uuid),
                    void 0 !== t.name && (a.name = t.name),
                    void 0 !== t.matrix
                      ? (a.matrix.fromArray(t.matrix),
                        void 0 !== t.matrixAutoUpdate &&
                          (a.matrixAutoUpdate = t.matrixAutoUpdate),
                        a.matrixAutoUpdate &&
                          a.matrix.decompose(a.position, a.quaternion, a.scale))
                      : (void 0 !== t.position &&
                          a.position.fromArray(t.position),
                        void 0 !== t.rotation &&
                          a.rotation.fromArray(t.rotation),
                        void 0 !== t.quaternion &&
                          a.quaternion.fromArray(t.quaternion),
                        void 0 !== t.scale && a.scale.fromArray(t.scale)),
                    void 0 !== t.castShadow && (a.castShadow = t.castShadow),
                    void 0 !== t.receiveShadow &&
                      (a.receiveShadow = t.receiveShadow),
                    t.shadow &&
                      (void 0 !== t.shadow.bias &&
                        (a.shadow.bias = t.shadow.bias),
                      void 0 !== t.shadow.radius &&
                        (a.shadow.radius = t.shadow.radius),
                      void 0 !== t.shadow.mapSize &&
                        a.shadow.mapSize.fromArray(t.shadow.mapSize),
                      void 0 !== t.shadow.camera &&
                        (a.shadow.camera = this.parseObject(t.shadow.camera))),
                    void 0 !== t.visible && (a.visible = t.visible),
                    void 0 !== t.frustumCulled &&
                      (a.frustumCulled = t.frustumCulled),
                    void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder),
                    void 0 !== t.userData && (a.userData = t.userData),
                    void 0 !== t.layers && (a.layers.mask = t.layers),
                    void 0 !== t.children)
                  )
                    for (var c = t.children, h = 0; h < c.length; h++)
                      a.add(this.parseObject(c[h], e, n));
                  if ("LOD" === t.type)
                    for (var l = t.levels, u = 0; u < l.length; u++) {
                      var p = l[u],
                        d = a.getObjectByProperty("uuid", p.object);
                      void 0 !== d && a.addLevel(d, p.distance);
                    }
                  return a;
                },
              });
            var ih = {
                UVMapping: 300,
                CubeReflectionMapping: Ko,
                CubeRefractionMapping: $o,
                EquirectangularReflectionMapping: ts,
                EquirectangularRefractionMapping: es,
                SphericalReflectionMapping: ns,
                CubeUVReflectionMapping: rs,
                CubeUVRefractionMapping: is,
              },
              ah = {
                RepeatWrapping: as,
                ClampToEdgeWrapping: os,
                MirroredRepeatWrapping: ss,
              },
              oh = {
                NearestFilter: cs,
                NearestMipMapNearestFilter: hs,
                NearestMipMapLinearFilter: ls,
                LinearFilter: us,
                LinearMipMapNearestFilter: ps,
                LinearMipMapLinearFilter: ds,
              };
            (Ai.prototype = {
              constructor: Ai,
              setOptions: function (t) {
                return (this.options = t), this;
              },
              load: function (t, e, n, r) {
                void 0 === t && (t = ""),
                  void 0 !== this.path && (t = this.path + t),
                  (t = this.manager.resolveURL(t));
                var i = this,
                  a = qc.get(t);
                if (void 0 !== a)
                  return (
                    i.manager.itemStart(t),
                    setTimeout(function () {
                      e && e(a), i.manager.itemEnd(t);
                    }, 0),
                    a
                  );
                fetch(t)
                  .then(function (t) {
                    return t.blob();
                  })
                  .then(function (t) {
                    return createImageBitmap(t, i.options);
                  })
                  .then(function (n) {
                    qc.add(t, n), e && e(n), i.manager.itemEnd(t);
                  })
                  .catch(function (e) {
                    r && r(e), i.manager.itemEnd(t), i.manager.itemError(t);
                  });
              },
              setCrossOrigin: function () {
                return this;
              },
              setPath: function (t) {
                return (this.path = t), this;
              },
            }),
              Object.assign(Li.prototype, {
                moveTo: function (t, e) {
                  (this.currentPath = new Jr()),
                    this.subPaths.push(this.currentPath),
                    this.currentPath.moveTo(t, e);
                },
                lineTo: function (t, e) {
                  this.currentPath.lineTo(t, e);
                },
                quadraticCurveTo: function (t, e, n, r) {
                  this.currentPath.quadraticCurveTo(t, e, n, r);
                },
                bezierCurveTo: function (t, e, n, r, i, a) {
                  this.currentPath.bezierCurveTo(t, e, n, r, i, a);
                },
                splineThru: function (t) {
                  this.currentPath.splineThru(t);
                },
                toShapes: function (t, e) {
                  function n(t) {
                    for (var e = [], n = 0, r = t.length; n < r; n++) {
                      var i = t[n],
                        a = new Zr();
                      (a.curves = i.curves), e.push(a);
                    }
                    return e;
                  }
                  var r = kc.isClockWise,
                    i = this.subPaths;
                  if (0 === i.length) return [];
                  if (!0 === e) return n(i);
                  var a,
                    o,
                    s,
                    c = [];
                  if (1 === i.length)
                    return (
                      (o = i[0]),
                      (s = new Zr()),
                      (s.curves = o.curves),
                      c.push(s),
                      c
                    );
                  var h = !r(i[0].getPoints());
                  h = t ? !h : h;
                  var l,
                    u = [],
                    p = [],
                    d = [],
                    f = 0;
                  (p[f] = void 0), (d[f] = []);
                  for (var m = 0, g = i.length; m < g; m++)
                    (o = i[m]),
                      (l = o.getPoints()),
                      (a = r(l)),
                      (a = t ? !a : a),
                      a
                        ? (!h && p[f] && f++,
                          (p[f] = { s: new Zr(), p: l }),
                          (p[f].s.curves = o.curves),
                          h && f++,
                          (d[f] = []))
                        : d[f].push({ h: o, p: l[0] });
                  if (!p[0]) return n(i);
                  if (p.length > 1) {
                    for (var v = !1, y = [], x = 0, b = p.length; x < b; x++)
                      u[x] = [];
                    for (var x = 0, b = p.length; x < b; x++)
                      for (var _ = d[x], w = 0; w < _.length; w++) {
                        for (var M = _[w], E = !0, T = 0; T < p.length; T++)
                          (function (t, e) {
                            for (
                              var n = e.length, r = !1, i = n - 1, a = 0;
                              a < n;
                              i = a++
                            ) {
                              var o = e[i],
                                s = e[a],
                                c = s.x - o.x,
                                h = s.y - o.y;
                              if (Math.abs(h) > Number.EPSILON) {
                                if (
                                  (h < 0 &&
                                    ((o = e[a]),
                                    (c = -c),
                                    (s = e[i]),
                                    (h = -h)),
                                  t.y < o.y || t.y > s.y)
                                )
                                  continue;
                                if (t.y === o.y) {
                                  if (t.x === o.x) return !0;
                                } else {
                                  var l = h * (t.x - o.x) - c * (t.y - o.y);
                                  if (0 === l) return !0;
                                  if (l < 0) continue;
                                  r = !r;
                                }
                              } else {
                                if (t.y !== o.y) continue;
                                if (
                                  (s.x <= t.x && t.x <= o.x) ||
                                  (o.x <= t.x && t.x <= s.x)
                                )
                                  return !0;
                              }
                            }
                            return r;
                          })(M.p, p[T].p) &&
                            (x !== T && y.push({ froms: x, tos: T, hole: w }),
                            E ? ((E = !1), u[T].push(M)) : (v = !0));
                        E && u[x].push(M);
                      }
                    y.length > 0 && (v || (d = u));
                  }
                  for (var S, m = 0, A = p.length; m < A; m++) {
                    (s = p[m].s), c.push(s), (S = d[m]);
                    for (var L = 0, R = S.length; L < R; L++)
                      s.holes.push(S[L].h);
                  }
                  return c;
                },
              }),
              Object.assign(Ri.prototype, {
                isFont: !0,
                generateShapes: function (t, e) {
                  void 0 === e && (e = 100);
                  for (
                    var n = [], r = Ci(t, e, this.data), i = 0, a = r.length;
                    i < a;
                    i++
                  )
                    Array.prototype.push.apply(n, r[i].toShapes());
                  return n;
                },
              }),
              Object.assign(Oi.prototype, {
                load: function (t, e, n, r) {
                  var i = this,
                    a = new br(this.manager);
                  a.setPath(this.path),
                    a.load(
                      t,
                      function (t) {
                        var n;
                        try {
                          n = JSON.parse(t);
                        } catch (e) {
                          console.warn(
                            "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                          ),
                            (n = JSON.parse(t.substring(65, t.length - 2)));
                        }
                        var r = i.parse(n);
                        e && e(r);
                      },
                      n,
                      r
                    );
                },
                parse: function (t) {
                  return new Ri(t);
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
              });
            var sh,
              ch = {
                getContext: function () {
                  return (
                    void 0 === sh &&
                      (sh = new (window.AudioContext ||
                        window.webkitAudioContext)()),
                    sh
                  );
                },
                setContext: function (t) {
                  sh = t;
                },
              };
            Object.assign(Ii.prototype, {
              load: function (t, e, n, r) {
                var i = new br(this.manager);
                i.setResponseType("arraybuffer"),
                  i.load(
                    t,
                    function (t) {
                      var n = t.slice(0);
                      ch.getContext().decodeAudioData(n, function (t) {
                        e(t);
                      });
                    },
                    n,
                    r
                  );
              },
            }),
              Object.assign(Ni.prototype, {
                update: (function () {
                  var t,
                    e,
                    n,
                    i,
                    a,
                    o,
                    s,
                    c,
                    h = new r(),
                    l = new r();
                  return function (r) {
                    if (
                      t !== this ||
                      e !== r.focus ||
                      n !== r.fov ||
                      i !== r.aspect * this.aspect ||
                      a !== r.near ||
                      o !== r.far ||
                      s !== r.zoom ||
                      c !== this.eyeSep
                    ) {
                      (t = this),
                        (e = r.focus),
                        (n = r.fov),
                        (i = r.aspect * this.aspect),
                        (a = r.near),
                        (o = r.far),
                        (s = r.zoom);
                      var u = r.projectionMatrix.clone();
                      c = this.eyeSep / 2;
                      var p,
                        d,
                        f = (c * a) / e,
                        m = (a * Math.tan(xc.DEG2RAD * n * 0.5)) / s;
                      (l.elements[12] = -c),
                        (h.elements[12] = c),
                        (p = -m * i + f),
                        (d = m * i + f),
                        (u.elements[0] = (2 * a) / (d - p)),
                        (u.elements[8] = (d + p) / (d - p)),
                        this.cameraL.projectionMatrix.copy(u),
                        (p = -m * i - f),
                        (d = m * i - f),
                        (u.elements[0] = (2 * a) / (d - p)),
                        (u.elements[8] = (d + p) / (d - p)),
                        this.cameraR.projectionMatrix.copy(u);
                    }
                    this.cameraL.matrixWorld.copy(r.matrixWorld).multiply(l),
                      this.cameraR.matrixWorld.copy(r.matrixWorld).multiply(h);
                  };
                })(),
              }),
              (Di.prototype = Object.create(_.prototype)),
              (Di.prototype.constructor = Di),
              (Ui.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Ui,
                getInput: function () {
                  return this.gain;
                },
                removeFilter: function () {
                  return (
                    null !== this.filter &&
                      (this.gain.disconnect(this.filter),
                      this.filter.disconnect(this.context.destination),
                      this.gain.connect(this.context.destination),
                      (this.filter = null)),
                    this
                  );
                },
                getFilter: function () {
                  return this.filter;
                },
                setFilter: function (t) {
                  return (
                    null !== this.filter
                      ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination))
                      : this.gain.disconnect(this.context.destination),
                    (this.filter = t),
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination),
                    this
                  );
                },
                getMasterVolume: function () {
                  return this.gain.gain.value;
                },
                setMasterVolume: function (t) {
                  return (
                    this.gain.gain.setTargetAtTime(
                      t,
                      this.context.currentTime,
                      0.01
                    ),
                    this
                  );
                },
                updateMatrixWorld: (function () {
                  var t = new a(),
                    e = new i(),
                    n = new a(),
                    r = new a();
                  return function (i) {
                    _.prototype.updateMatrixWorld.call(this, i);
                    var a = this.context.listener,
                      o = this.up;
                    this.matrixWorld.decompose(t, e, n),
                      r.set(0, 0, -1).applyQuaternion(e),
                      a.positionX
                        ? (a.positionX.setValueAtTime(
                            t.x,
                            this.context.currentTime
                          ),
                          a.positionY.setValueAtTime(
                            t.y,
                            this.context.currentTime
                          ),
                          a.positionZ.setValueAtTime(
                            t.z,
                            this.context.currentTime
                          ),
                          a.forwardX.setValueAtTime(
                            r.x,
                            this.context.currentTime
                          ),
                          a.forwardY.setValueAtTime(
                            r.y,
                            this.context.currentTime
                          ),
                          a.forwardZ.setValueAtTime(
                            r.z,
                            this.context.currentTime
                          ),
                          a.upX.setValueAtTime(o.x, this.context.currentTime),
                          a.upY.setValueAtTime(o.y, this.context.currentTime),
                          a.upZ.setValueAtTime(o.z, this.context.currentTime))
                        : (a.setPosition(t.x, t.y, t.z),
                          a.setOrientation(r.x, r.y, r.z, o.x, o.y, o.z));
                  };
                })(),
              })),
              (Bi.prototype = Object.assign(Object.create(_.prototype), {
                constructor: Bi,
                getOutput: function () {
                  return this.gain;
                },
                setNodeSource: function (t) {
                  return (
                    (this.hasPlaybackControl = !1),
                    (this.sourceType = "audioNode"),
                    (this.source = t),
                    this.connect(),
                    this
                  );
                },
                setMediaElementSource: function (t) {
                  return (
                    (this.hasPlaybackControl = !1),
                    (this.sourceType = "mediaNode"),
                    (this.source = this.context.createMediaElementSource(t)),
                    this.connect(),
                    this
                  );
                },
                setBuffer: function (t) {
                  return (
                    (this.buffer = t),
                    (this.sourceType = "buffer"),
                    this.autoplay && this.play(),
                    this
                  );
                },
                play: function () {
                  if (!0 === this.isPlaying)
                    return void console.warn(
                      "THREE.Audio: Audio is already playing."
                    );
                  if (!1 === this.hasPlaybackControl)
                    return void console.warn(
                      "THREE.Audio: this Audio has no playback control."
                    );
                  var t = this.context.createBufferSource();
                  return (
                    (t.buffer = this.buffer),
                    (t.loop = this.loop),
                    (t.onended = this.onEnded.bind(this)),
                    t.playbackRate.setValueAtTime(
                      this.playbackRate,
                      this.startTime
                    ),
                    (this.startTime = this.context.currentTime),
                    t.start(this.startTime, this.offset),
                    (this.isPlaying = !0),
                    (this.source = t),
                    this.connect()
                  );
                },
                pause: function () {
                  return !1 === this.hasPlaybackControl
                    ? void console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      )
                    : (!0 === this.isPlaying &&
                        (this.source.stop(),
                        (this.source.onended = null),
                        (this.offset +=
                          (this.context.currentTime - this.startTime) *
                          this.playbackRate),
                        (this.isPlaying = !1)),
                      this);
                },
                stop: function () {
                  return !1 === this.hasPlaybackControl
                    ? void console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      )
                    : (this.source.stop(),
                      (this.source.onended = null),
                      (this.offset = 0),
                      (this.isPlaying = !1),
                      this);
                },
                connect: function () {
                  if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++)
                      this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(
                      this.getOutput()
                    );
                  } else this.source.connect(this.getOutput());
                  return this;
                },
                disconnect: function () {
                  if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++)
                      this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(
                      this.getOutput()
                    );
                  } else this.source.disconnect(this.getOutput());
                  return this;
                },
                getFilters: function () {
                  return this.filters;
                },
                setFilters: function (t) {
                  return (
                    t || (t = []),
                    !0 === this.isPlaying
                      ? (this.disconnect(), (this.filters = t), this.connect())
                      : (this.filters = t),
                    this
                  );
                },
                getFilter: function () {
                  return this.getFilters()[0];
                },
                setFilter: function (t) {
                  return this.setFilters(t ? [t] : []);
                },
                setPlaybackRate: function (t) {
                  return !1 === this.hasPlaybackControl
                    ? void console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      )
                    : ((this.playbackRate = t),
                      !0 === this.isPlaying &&
                        this.source.playbackRate.setValueAtTime(
                          this.playbackRate,
                          this.context.currentTime
                        ),
                      this);
                },
                getPlaybackRate: function () {
                  return this.playbackRate;
                },
                onEnded: function () {
                  this.isPlaying = !1;
                },
                getLoop: function () {
                  return !1 === this.hasPlaybackControl
                    ? (console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      ),
                      !1)
                    : this.loop;
                },
                setLoop: function (t) {
                  return !1 === this.hasPlaybackControl
                    ? void console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      )
                    : ((this.loop = t),
                      !0 === this.isPlaying && (this.source.loop = this.loop),
                      this);
                },
                getVolume: function () {
                  return this.gain.gain.value;
                },
                setVolume: function (t) {
                  return (
                    this.gain.gain.setTargetAtTime(
                      t,
                      this.context.currentTime,
                      0.01
                    ),
                    this
                  );
                },
              })),
              (Fi.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Fi,
                getOutput: function () {
                  return this.panner;
                },
                getRefDistance: function () {
                  return this.panner.refDistance;
                },
                setRefDistance: function (t) {
                  return (this.panner.refDistance = t), this;
                },
                getRolloffFactor: function () {
                  return this.panner.rolloffFactor;
                },
                setRolloffFactor: function (t) {
                  return (this.panner.rolloffFactor = t), this;
                },
                getDistanceModel: function () {
                  return this.panner.distanceModel;
                },
                setDistanceModel: function (t) {
                  return (this.panner.distanceModel = t), this;
                },
                getMaxDistance: function () {
                  return this.panner.maxDistance;
                },
                setMaxDistance: function (t) {
                  return (this.panner.maxDistance = t), this;
                },
                setDirectionalCone: function (t, e, n) {
                  return (
                    (this.panner.coneInnerAngle = t),
                    (this.panner.coneOuterAngle = e),
                    (this.panner.coneOuterGain = n),
                    this
                  );
                },
                updateMatrixWorld: (function () {
                  var t = new a(),
                    e = new i(),
                    n = new a(),
                    r = new a();
                  return function (i) {
                    _.prototype.updateMatrixWorld.call(this, i);
                    var a = this.panner;
                    this.matrixWorld.decompose(t, e, n),
                      r.set(0, 0, 1).applyQuaternion(e),
                      a.setPosition(t.x, t.y, t.z),
                      a.setOrientation(r.x, r.y, r.z);
                  };
                })(),
              })),
              Object.assign(zi.prototype, {
                getFrequencyData: function () {
                  return (
                    this.analyser.getByteFrequencyData(this.data), this.data
                  );
                },
                getAverageFrequency: function () {
                  for (
                    var t = 0, e = this.getFrequencyData(), n = 0;
                    n < e.length;
                    n++
                  )
                    t += e[n];
                  return t / e.length;
                },
              }),
              Object.assign(Gi.prototype, {
                accumulate: function (t, e) {
                  var n = this.buffer,
                    r = this.valueSize,
                    i = t * r + r,
                    a = this.cumulativeWeight;
                  if (0 === a) {
                    for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                    a = e;
                  } else {
                    a += e;
                    var s = e / a;
                    this._mixBufferRegion(n, i, 0, s, r);
                  }
                  this.cumulativeWeight = a;
                },
                apply: function (t) {
                  var e = this.valueSize,
                    n = this.buffer,
                    r = t * e + e,
                    i = this.cumulativeWeight,
                    a = this.binding;
                  if (((this.cumulativeWeight = 0), i < 1)) {
                    var o = 3 * e;
                    this._mixBufferRegion(n, r, o, 1 - i, e);
                  }
                  for (var s = e, c = e + e; s !== c; ++s)
                    if (n[s] !== n[s + e]) {
                      a.setValue(n, r);
                      break;
                    }
                },
                saveOriginalState: function () {
                  var t = this.binding,
                    e = this.buffer,
                    n = this.valueSize,
                    r = 3 * n;
                  t.getValue(e, r);
                  for (var i = n, a = r; i !== a; ++i) e[i] = e[r + (i % n)];
                  this.cumulativeWeight = 0;
                },
                restoreOriginalState: function () {
                  var t = 3 * this.valueSize;
                  this.binding.setValue(this.buffer, t);
                },
                _select: function (t, e, n, r, i) {
                  if (r >= 0.5)
                    for (var a = 0; a !== i; ++a) t[e + a] = t[n + a];
                },
                _slerp: function (t, e, n, r) {
                  i.slerpFlat(t, e, t, e, t, n, r);
                },
                _lerp: function (t, e, n, r, i) {
                  for (var a = 1 - r, o = 0; o !== i; ++o) {
                    var s = e + o;
                    t[s] = t[s] * a + t[n + o] * r;
                  }
                },
              });
            var hh = "\\[\\]\\.:\\/";
            Object.assign(Hi.prototype, {
              getValue: function (t, e) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                  r = this._bindings[n];
                void 0 !== r && r.getValue(t, e);
              },
              setValue: function (t, e) {
                for (
                  var n = this._bindings,
                    r = this._targetGroup.nCachedObjects_,
                    i = n.length;
                  r !== i;
                  ++r
                )
                  n[r].setValue(t, e);
              },
              bind: function () {
                for (
                  var t = this._bindings,
                    e = this._targetGroup.nCachedObjects_,
                    n = t.length;
                  e !== n;
                  ++e
                )
                  t[e].bind();
              },
              unbind: function () {
                for (
                  var t = this._bindings,
                    e = this._targetGroup.nCachedObjects_,
                    n = t.length;
                  e !== n;
                  ++e
                )
                  t[e].unbind();
              },
            }),
              Object.assign(Vi, {
                Composite: Hi,
                create: function (t, e, n) {
                  return t && t.isAnimationObjectGroup
                    ? new Vi.Composite(t, e, n)
                    : new Vi(t, e, n);
                },
                sanitizeNodeName: (function () {
                  var t = new RegExp("[" + hh + "]", "g");
                  return function (e) {
                    return e.replace(/\s/g, "_").replace(t, "");
                  };
                })(),
                parseTrackName: (function () {
                  var t = "[^" + hh + "]",
                    e = "[^" + hh.replace("\\.", "") + "]",
                    n = /((?:WC+[\/:])*)/.source.replace("WC", t),
                    r = /(WCOD+)?/.source.replace("WCOD", e),
                    i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                    a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                    o = new RegExp("^" + n + r + i + a + "$"),
                    s = ["material", "materials", "bones"];
                  return function (t) {
                    var e = o.exec(t);
                    if (!e)
                      throw new Error(
                        "PropertyBinding: Cannot parse trackName: " + t
                      );
                    var n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6],
                      },
                      r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                      var i = n.nodeName.substring(r + 1);
                      -1 !== s.indexOf(i) &&
                        ((n.nodeName = n.nodeName.substring(0, r)),
                        (n.objectName = i));
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                      throw new Error(
                        "PropertyBinding: can not parse propertyName from trackName: " +
                          t
                      );
                    return n;
                  };
                })(),
                findNode: function (t, e) {
                  if (
                    !e ||
                    "" === e ||
                    "root" === e ||
                    "." === e ||
                    -1 === e ||
                    e === t.name ||
                    e === t.uuid
                  )
                    return t;
                  if (t.skeleton) {
                    var n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n;
                  }
                  if (t.children) {
                    var r = function (t) {
                        for (var n = 0; n < t.length; n++) {
                          var i = t[n];
                          if (i.name === e || i.uuid === e) return i;
                          var a = r(i.children);
                          if (a) return a;
                        }
                        return null;
                      },
                      i = r(t.children);
                    if (i) return i;
                  }
                  return null;
                },
              }),
              Object.assign(Vi.prototype, {
                _getValue_unavailable: function () {},
                _setValue_unavailable: function () {},
                BindingType: {
                  Direct: 0,
                  EntireArray: 1,
                  ArrayElement: 2,
                  HasFromToArray: 3,
                },
                Versioning: {
                  None: 0,
                  NeedsUpdate: 1,
                  MatrixWorldNeedsUpdate: 2,
                },
                GetterByBindingType: [
                  function (t, e) {
                    t[e] = this.node[this.propertyName];
                  },
                  function (t, e) {
                    for (
                      var n = this.resolvedProperty, r = 0, i = n.length;
                      r !== i;
                      ++r
                    )
                      t[e++] = n[r];
                  },
                  function (t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex];
                  },
                  function (t, e) {
                    this.resolvedProperty.toArray(t, e);
                  },
                ],
                SetterByBindingTypeAndVersioning: [
                  [
                    function (t, e) {
                      this.targetObject[this.propertyName] = t[e];
                    },
                    function (t, e) {
                      (this.targetObject[this.propertyName] = t[e]),
                        (this.targetObject.needsUpdate = !0);
                    },
                    function (t, e) {
                      (this.targetObject[this.propertyName] = t[e]),
                        (this.targetObject.matrixWorldNeedsUpdate = !0);
                    },
                  ],
                  [
                    function (t, e) {
                      for (
                        var n = this.resolvedProperty, r = 0, i = n.length;
                        r !== i;
                        ++r
                      )
                        n[r] = t[e++];
                    },
                    function (t, e) {
                      for (
                        var n = this.resolvedProperty, r = 0, i = n.length;
                        r !== i;
                        ++r
                      )
                        n[r] = t[e++];
                      this.targetObject.needsUpdate = !0;
                    },
                    function (t, e) {
                      for (
                        var n = this.resolvedProperty, r = 0, i = n.length;
                        r !== i;
                        ++r
                      )
                        n[r] = t[e++];
                      this.targetObject.matrixWorldNeedsUpdate = !0;
                    },
                  ],
                  [
                    function (t, e) {
                      this.resolvedProperty[this.propertyIndex] = t[e];
                    },
                    function (t, e) {
                      (this.resolvedProperty[this.propertyIndex] = t[e]),
                        (this.targetObject.needsUpdate = !0);
                    },
                    function (t, e) {
                      (this.resolvedProperty[this.propertyIndex] = t[e]),
                        (this.targetObject.matrixWorldNeedsUpdate = !0);
                    },
                  ],
                  [
                    function (t, e) {
                      this.resolvedProperty.fromArray(t, e);
                    },
                    function (t, e) {
                      this.resolvedProperty.fromArray(t, e),
                        (this.targetObject.needsUpdate = !0);
                    },
                    function (t, e) {
                      this.resolvedProperty.fromArray(t, e),
                        (this.targetObject.matrixWorldNeedsUpdate = !0);
                    },
                  ],
                ],
                getValue: function (t, e) {
                  this.bind(), this.getValue(t, e);
                },
                setValue: function (t, e) {
                  this.bind(), this.setValue(t, e);
                },
                bind: function () {
                  var t = this.node,
                    e = this.parsedPath,
                    n = e.objectName,
                    r = e.propertyName,
                    i = e.propertyIndex;
                  if (
                    (t ||
                      ((t =
                        Vi.findNode(this.rootNode, e.nodeName) ||
                        this.rootNode),
                      (this.node = t)),
                    (this.getValue = this._getValue_unavailable),
                    (this.setValue = this._setValue_unavailable),
                    !t)
                  )
                    return void console.error(
                      "THREE.PropertyBinding: Trying to update node for track: " +
                        this.path +
                        " but it wasn't found."
                    );
                  if (n) {
                    var a = e.objectIndex;
                    switch (n) {
                      case "materials":
                        if (!t.material)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                            this
                          );
                        if (!t.material.materials)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                            this
                          );
                        t = t.material.materials;
                        break;
                      case "bones":
                        if (!t.skeleton)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                            this
                          );
                        t = t.skeleton.bones;
                        for (var o = 0; o < t.length; o++)
                          if (t[o].name === a) {
                            a = o;
                            break;
                          }
                        break;
                      default:
                        if (void 0 === t[n])
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                            this
                          );
                        t = t[n];
                    }
                    if (void 0 !== a) {
                      if (void 0 === t[a])
                        return void console.error(
                          "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                          this,
                          t
                        );
                      t = t[a];
                    }
                  }
                  var s = t[r];
                  if (void 0 === s) {
                    var c = e.nodeName;
                    return void console.error(
                      "THREE.PropertyBinding: Trying to update property for track: " +
                        c +
                        "." +
                        r +
                        " but it wasn't found.",
                      t
                    );
                  }
                  var h = this.Versioning.None;
                  void 0 !== t.needsUpdate
                    ? ((h = this.Versioning.NeedsUpdate),
                      (this.targetObject = t))
                    : void 0 !== t.matrixWorldNeedsUpdate &&
                      ((h = this.Versioning.MatrixWorldNeedsUpdate),
                      (this.targetObject = t));
                  var l = this.BindingType.Direct;
                  if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                      if (!t.geometry)
                        return void console.error(
                          "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                          this
                        );
                      if (t.geometry.isBufferGeometry) {
                        if (!t.geometry.morphAttributes)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                            this
                          );
                        for (
                          var o = 0;
                          o <
                          this.node.geometry.morphAttributes.position.length;
                          o++
                        )
                          if (
                            t.geometry.morphAttributes.position[o].name === i
                          ) {
                            i = o;
                            break;
                          }
                      } else {
                        if (!t.geometry.morphTargets)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                            this
                          );
                        for (
                          var o = 0;
                          o < this.node.geometry.morphTargets.length;
                          o++
                        )
                          if (t.geometry.morphTargets[o].name === i) {
                            i = o;
                            break;
                          }
                      }
                    }
                    (l = this.BindingType.ArrayElement),
                      (this.resolvedProperty = s),
                      (this.propertyIndex = i);
                  } else
                    void 0 !== s.fromArray && void 0 !== s.toArray
                      ? ((l = this.BindingType.HasFromToArray),
                        (this.resolvedProperty = s))
                      : Array.isArray(s)
                      ? ((l = this.BindingType.EntireArray),
                        (this.resolvedProperty = s))
                      : (this.propertyName = r);
                  (this.getValue = this.GetterByBindingType[l]),
                    (this.setValue =
                      this.SetterByBindingTypeAndVersioning[l][h]);
                },
                unbind: function () {
                  (this.node = null),
                    (this.getValue = this._getValue_unbound),
                    (this.setValue = this._setValue_unbound);
                },
              }),
              Object.assign(Vi.prototype, {
                _getValue_unbound: Vi.prototype.getValue,
                _setValue_unbound: Vi.prototype.setValue,
              }),
              Object.assign(ki.prototype, {
                isAnimationObjectGroup: !0,
                add: function () {
                  for (
                    var t = this._objects,
                      e = t.length,
                      n = this.nCachedObjects_,
                      r = this._indicesByUUID,
                      i = this._paths,
                      a = this._parsedPaths,
                      o = this._bindings,
                      s = o.length,
                      c = void 0,
                      h = 0,
                      l = arguments.length;
                    h !== l;
                    ++h
                  ) {
                    var u = arguments[h],
                      p = u.uuid,
                      d = r[p];
                    if (void 0 === d) {
                      (d = e++), (r[p] = d), t.push(u);
                      for (var f = 0, m = s; f !== m; ++f)
                        o[f].push(new Vi(u, i[f], a[f]));
                    } else if (d < n) {
                      c = t[d];
                      var g = --n,
                        v = t[g];
                      (r[v.uuid] = d), (t[d] = v), (r[p] = g), (t[g] = u);
                      for (var f = 0, m = s; f !== m; ++f) {
                        var y = o[f],
                          x = y[g],
                          b = y[d];
                        (y[d] = x),
                          void 0 === b && (b = new Vi(u, i[f], a[f])),
                          (y[g] = b);
                      }
                    } else
                      t[d] !== c &&
                        console.error(
                          "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                        );
                  }
                  this.nCachedObjects_ = n;
                },
                remove: function () {
                  for (
                    var t = this._objects,
                      e = this.nCachedObjects_,
                      n = this._indicesByUUID,
                      r = this._bindings,
                      i = r.length,
                      a = 0,
                      o = arguments.length;
                    a !== o;
                    ++a
                  ) {
                    var s = arguments[a],
                      c = s.uuid,
                      h = n[c];
                    if (void 0 !== h && h >= e) {
                      var l = e++,
                        u = t[l];
                      (n[u.uuid] = h), (t[h] = u), (n[c] = l), (t[l] = s);
                      for (var p = 0, d = i; p !== d; ++p) {
                        var f = r[p],
                          m = f[l],
                          g = f[h];
                        (f[h] = m), (f[l] = g);
                      }
                    }
                  }
                  this.nCachedObjects_ = e;
                },
                uncache: function () {
                  for (
                    var t = this._objects,
                      e = t.length,
                      n = this.nCachedObjects_,
                      r = this._indicesByUUID,
                      i = this._bindings,
                      a = i.length,
                      o = 0,
                      s = arguments.length;
                    o !== s;
                    ++o
                  ) {
                    var c = arguments[o],
                      h = c.uuid,
                      l = r[h];
                    if (void 0 !== l)
                      if ((delete r[h], l < n)) {
                        var u = --n,
                          p = t[u],
                          d = --e,
                          f = t[d];
                        (r[p.uuid] = l),
                          (t[l] = p),
                          (r[f.uuid] = u),
                          (t[u] = f),
                          t.pop();
                        for (var m = 0, g = a; m !== g; ++m) {
                          var v = i[m],
                            y = v[u],
                            x = v[d];
                          (v[l] = y), (v[u] = x), v.pop();
                        }
                      } else {
                        var d = --e,
                          f = t[d];
                        (r[f.uuid] = l), (t[l] = f), t.pop();
                        for (var m = 0, g = a; m !== g; ++m) {
                          var v = i[m];
                          (v[l] = v[d]), v.pop();
                        }
                      }
                  }
                  this.nCachedObjects_ = n;
                },
                subscribe_: function (t, e) {
                  var n = this._bindingsIndicesByPath,
                    r = n[t],
                    i = this._bindings;
                  if (void 0 !== r) return i[r];
                  var a = this._paths,
                    o = this._parsedPaths,
                    s = this._objects,
                    c = s.length,
                    h = this.nCachedObjects_,
                    l = new Array(c);
                  (r = i.length), (n[t] = r), a.push(t), o.push(e), i.push(l);
                  for (var u = h, p = s.length; u !== p; ++u) {
                    var d = s[u];
                    l[u] = new Vi(d, t, e);
                  }
                  return l;
                },
                unsubscribe_: function (t) {
                  var e = this._bindingsIndicesByPath,
                    n = e[t];
                  if (void 0 !== n) {
                    var r = this._paths,
                      i = this._parsedPaths,
                      a = this._bindings,
                      o = a.length - 1,
                      s = a[o];
                    (e[t[o]] = n),
                      (a[n] = s),
                      a.pop(),
                      (i[n] = i[o]),
                      i.pop(),
                      (r[n] = r[o]),
                      r.pop();
                  }
                },
              }),
              Object.assign(ji.prototype, {
                play: function () {
                  return this._mixer._activateAction(this), this;
                },
                stop: function () {
                  return this._mixer._deactivateAction(this), this.reset();
                },
                reset: function () {
                  return (
                    (this.paused = !1),
                    (this.enabled = !0),
                    (this.time = 0),
                    (this._loopCount = -1),
                    (this._startTime = null),
                    this.stopFading().stopWarping()
                  );
                },
                isRunning: function () {
                  return (
                    this.enabled &&
                    !this.paused &&
                    0 !== this.timeScale &&
                    null === this._startTime &&
                    this._mixer._isActiveAction(this)
                  );
                },
                isScheduled: function () {
                  return this._mixer._isActiveAction(this);
                },
                startAt: function (t) {
                  return (this._startTime = t), this;
                },
                setLoop: function (t, e) {
                  return (this.loop = t), (this.repetitions = e), this;
                },
                setEffectiveWeight: function (t) {
                  return (
                    (this.weight = t),
                    (this._effectiveWeight = this.enabled ? t : 0),
                    this.stopFading()
                  );
                },
                getEffectiveWeight: function () {
                  return this._effectiveWeight;
                },
                fadeIn: function (t) {
                  return this._scheduleFading(t, 0, 1);
                },
                fadeOut: function (t) {
                  return this._scheduleFading(t, 1, 0);
                },
                crossFadeFrom: function (t, e, n) {
                  if ((t.fadeOut(e), this.fadeIn(e), n)) {
                    var r = this._clip.duration,
                      i = t._clip.duration,
                      a = i / r,
                      o = r / i;
                    t.warp(1, a, e), this.warp(o, 1, e);
                  }
                  return this;
                },
                crossFadeTo: function (t, e, n) {
                  return t.crossFadeFrom(this, e, n);
                },
                stopFading: function () {
                  var t = this._weightInterpolant;
                  return (
                    null !== t &&
                      ((this._weightInterpolant = null),
                      this._mixer._takeBackControlInterpolant(t)),
                    this
                  );
                },
                setEffectiveTimeScale: function (t) {
                  return (
                    (this.timeScale = t),
                    (this._effectiveTimeScale = this.paused ? 0 : t),
                    this.stopWarping()
                  );
                },
                getEffectiveTimeScale: function () {
                  return this._effectiveTimeScale;
                },
                setDuration: function (t) {
                  return (
                    (this.timeScale = this._clip.duration / t),
                    this.stopWarping()
                  );
                },
                syncWith: function (t) {
                  return (
                    (this.time = t.time),
                    (this.timeScale = t.timeScale),
                    this.stopWarping()
                  );
                },
                halt: function (t) {
                  return this.warp(this._effectiveTimeScale, 0, t);
                },
                warp: function (t, e, n) {
                  var r = this._mixer,
                    i = r.time,
                    a = this._timeScaleInterpolant,
                    o = this.timeScale;
                  null === a &&
                    ((a = r._lendControlInterpolant()),
                    (this._timeScaleInterpolant = a));
                  var s = a.parameterPositions,
                    c = a.sampleValues;
                  return (
                    (s[0] = i),
                    (s[1] = i + n),
                    (c[0] = t / o),
                    (c[1] = e / o),
                    this
                  );
                },
                stopWarping: function () {
                  var t = this._timeScaleInterpolant;
                  return (
                    null !== t &&
                      ((this._timeScaleInterpolant = null),
                      this._mixer._takeBackControlInterpolant(t)),
                    this
                  );
                },
                getMixer: function () {
                  return this._mixer;
                },
                getClip: function () {
                  return this._clip;
                },
                getRoot: function () {
                  return this._localRoot || this._mixer._root;
                },
                _update: function (t, e, n, r) {
                  if (!this.enabled) return void this._updateWeight(t);
                  var i = this._startTime;
                  if (null !== i) {
                    var a = (t - i) * n;
                    if (a < 0 || 0 === n) return;
                    (this._startTime = null), (e = n * a);
                  }
                  e *= this._updateTimeScale(t);
                  var o = this._updateTime(e),
                    s = this._updateWeight(t);
                  if (s > 0)
                    for (
                      var c = this._interpolants,
                        h = this._propertyBindings,
                        l = 0,
                        u = c.length;
                      l !== u;
                      ++l
                    )
                      c[l].evaluate(o), h[l].accumulate(r, s);
                },
                _updateWeight: function (t) {
                  var e = 0;
                  if (this.enabled) {
                    e = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                      var r = n.evaluate(t)[0];
                      (e *= r),
                        t > n.parameterPositions[1] &&
                          (this.stopFading(), 0 === r && (this.enabled = !1));
                    }
                  }
                  return (this._effectiveWeight = e), e;
                },
                _updateTimeScale: function (t) {
                  var e = 0;
                  if (!this.paused) {
                    e = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) {
                      (e *= n.evaluate(t)[0]),
                        t > n.parameterPositions[1] &&
                          (this.stopWarping(),
                          0 === e ? (this.paused = !0) : (this.timeScale = e));
                    }
                  }
                  return (this._effectiveTimeScale = e), e;
                },
                _updateTime: function (t) {
                  var e = this.time + t,
                    n = this._clip.duration,
                    r = this.loop,
                    i = this._loopCount,
                    a = 2202 === r;
                  if (0 === t)
                    return -1 === i ? e : a && 1 == (1 & i) ? n - e : e;
                  if (2200 === r) {
                    -1 === i &&
                      ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                    t: {
                      if (e >= n) e = n;
                      else {
                        if (!(e < 0)) break t;
                        e = 0;
                      }
                      this.clampWhenFinished
                        ? (this.paused = !0)
                        : (this.enabled = !1),
                        this._mixer.dispatchEvent({
                          type: "finished",
                          action: this,
                          direction: t < 0 ? -1 : 1,
                        });
                    }
                  } else {
                    if (
                      (-1 === i &&
                        (t >= 0
                          ? ((i = 0),
                            this._setEndings(!0, 0 === this.repetitions, a))
                          : this._setEndings(0 === this.repetitions, !0, a)),
                      e >= n || e < 0)
                    ) {
                      var o = Math.floor(e / n);
                      (e -= n * o), (i += Math.abs(o));
                      var s = this.repetitions - i;
                      if (s <= 0)
                        this.clampWhenFinished
                          ? (this.paused = !0)
                          : (this.enabled = !1),
                          (e = t > 0 ? n : 0),
                          this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1,
                          });
                      else {
                        if (1 === s) {
                          var c = t < 0;
                          this._setEndings(c, !c, a);
                        } else this._setEndings(!1, !1, a);
                        (this._loopCount = i),
                          this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o,
                          });
                      }
                    }
                    if (a && 1 == (1 & i)) return (this.time = e), n - e;
                  }
                  return (this.time = e), e;
                },
                _setEndings: function (t, e, n) {
                  var r = this._interpolantSettings;
                  n
                    ? ((r.endingStart = 2401), (r.endingEnd = 2401))
                    : ((r.endingStart = t
                        ? this.zeroSlopeAtStart
                          ? 2401
                          : ic
                        : 2402),
                      (r.endingEnd = e
                        ? this.zeroSlopeAtEnd
                          ? 2401
                          : ic
                        : 2402));
                },
                _scheduleFading: function (t, e, n) {
                  var r = this._mixer,
                    i = r.time,
                    a = this._weightInterpolant;
                  null === a &&
                    ((a = r._lendControlInterpolant()),
                    (this._weightInterpolant = a));
                  var o = a.parameterPositions,
                    s = a.sampleValues;
                  return (
                    (o[0] = i), (s[0] = e), (o[1] = i + t), (s[1] = n), this
                  );
                },
              }),
              (Wi.prototype = Object.assign(Object.create(e.prototype), {
                constructor: Wi,
                _bindAction: function (t, e) {
                  var n = t._localRoot || this._root,
                    r = t._clip.tracks,
                    i = r.length,
                    a = t._propertyBindings,
                    o = t._interpolants,
                    s = n.uuid,
                    c = this._bindingsByRootAndName,
                    h = c[s];
                  void 0 === h && ((h = {}), (c[s] = h));
                  for (var l = 0; l !== i; ++l) {
                    var u = r[l],
                      p = u.name,
                      d = h[p];
                    if (void 0 !== d) a[l] = d;
                    else {
                      if (void 0 !== (d = a[l])) {
                        null === d._cacheIndex &&
                          (++d.referenceCount,
                          this._addInactiveBinding(d, s, p));
                        continue;
                      }
                      var f = e && e._propertyBindings[l].binding.parsedPath;
                      (d = new Gi(
                        Vi.create(n, p, f),
                        u.ValueTypeName,
                        u.getValueSize()
                      )),
                        ++d.referenceCount,
                        this._addInactiveBinding(d, s, p),
                        (a[l] = d);
                    }
                    o[l].resultBuffer = d.buffer;
                  }
                },
                _activateAction: function (t) {
                  if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                      var e = (t._localRoot || this._root).uuid,
                        n = t._clip.uuid,
                        r = this._actionsByClip[n];
                      this._bindAction(t, r && r.knownActions[0]),
                        this._addInactiveAction(t, n, e);
                    }
                    for (
                      var i = t._propertyBindings, a = 0, o = i.length;
                      a !== o;
                      ++a
                    ) {
                      var s = i[a];
                      0 == s.useCount++ &&
                        (this._lendBinding(s), s.saveOriginalState());
                    }
                    this._lendAction(t);
                  }
                },
                _deactivateAction: function (t) {
                  if (this._isActiveAction(t)) {
                    for (
                      var e = t._propertyBindings, n = 0, r = e.length;
                      n !== r;
                      ++n
                    ) {
                      var i = e[n];
                      0 == --i.useCount &&
                        (i.restoreOriginalState(), this._takeBackBinding(i));
                    }
                    this._takeBackAction(t);
                  }
                },
                _initMemoryManager: function () {
                  (this._actions = []),
                    (this._nActiveActions = 0),
                    (this._actionsByClip = {}),
                    (this._bindings = []),
                    (this._nActiveBindings = 0),
                    (this._bindingsByRootAndName = {}),
                    (this._controlInterpolants = []),
                    (this._nActiveControlInterpolants = 0);
                  var t = this;
                  this.stats = {
                    actions: {
                      get total() {
                        return t._actions.length;
                      },
                      get inUse() {
                        return t._nActiveActions;
                      },
                    },
                    bindings: {
                      get total() {
                        return t._bindings.length;
                      },
                      get inUse() {
                        return t._nActiveBindings;
                      },
                    },
                    controlInterpolants: {
                      get total() {
                        return t._controlInterpolants.length;
                      },
                      get inUse() {
                        return t._nActiveControlInterpolants;
                      },
                    },
                  };
                },
                _isActiveAction: function (t) {
                  var e = t._cacheIndex;
                  return null !== e && e < this._nActiveActions;
                },
                _addInactiveAction: function (t, e, n) {
                  var r = this._actions,
                    i = this._actionsByClip,
                    a = i[e];
                  if (void 0 === a)
                    (a = { knownActions: [t], actionByRoot: {} }),
                      (t._byClipCacheIndex = 0),
                      (i[e] = a);
                  else {
                    var o = a.knownActions;
                    (t._byClipCacheIndex = o.length), o.push(t);
                  }
                  (t._cacheIndex = r.length),
                    r.push(t),
                    (a.actionByRoot[n] = t);
                },
                _removeInactiveAction: function (t) {
                  var e = this._actions,
                    n = e[e.length - 1],
                    r = t._cacheIndex;
                  (n._cacheIndex = r),
                    (e[r] = n),
                    e.pop(),
                    (t._cacheIndex = null);
                  var i = t._clip.uuid,
                    a = this._actionsByClip,
                    o = a[i],
                    s = o.knownActions,
                    c = s[s.length - 1],
                    h = t._byClipCacheIndex;
                  (c._byClipCacheIndex = h),
                    (s[h] = c),
                    s.pop(),
                    (t._byClipCacheIndex = null),
                    delete o.actionByRoot[(t._localRoot || this._root).uuid],
                    0 === s.length && delete a[i],
                    this._removeInactiveBindingsForAction(t);
                },
                _removeInactiveBindingsForAction: function (t) {
                  for (
                    var e = t._propertyBindings, n = 0, r = e.length;
                    n !== r;
                    ++n
                  ) {
                    var i = e[n];
                    0 == --i.referenceCount && this._removeInactiveBinding(i);
                  }
                },
                _lendAction: function (t) {
                  var e = this._actions,
                    n = t._cacheIndex,
                    r = this._nActiveActions++,
                    i = e[r];
                  (t._cacheIndex = r),
                    (e[r] = t),
                    (i._cacheIndex = n),
                    (e[n] = i);
                },
                _takeBackAction: function (t) {
                  var e = this._actions,
                    n = t._cacheIndex,
                    r = --this._nActiveActions,
                    i = e[r];
                  (t._cacheIndex = r),
                    (e[r] = t),
                    (i._cacheIndex = n),
                    (e[n] = i);
                },
                _addInactiveBinding: function (t, e, n) {
                  var r = this._bindingsByRootAndName,
                    i = r[e],
                    a = this._bindings;
                  void 0 === i && ((i = {}), (r[e] = i)),
                    (i[n] = t),
                    (t._cacheIndex = a.length),
                    a.push(t);
                },
                _removeInactiveBinding: function (t) {
                  var e = this._bindings,
                    n = t.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    a = this._bindingsByRootAndName,
                    o = a[r],
                    s = e[e.length - 1],
                    c = t._cacheIndex;
                  (s._cacheIndex = c), (e[c] = s), e.pop(), delete o[i];
                  t: {
                    for (var h in o) break t;
                    delete a[r];
                  }
                },
                _lendBinding: function (t) {
                  var e = this._bindings,
                    n = t._cacheIndex,
                    r = this._nActiveBindings++,
                    i = e[r];
                  (t._cacheIndex = r),
                    (e[r] = t),
                    (i._cacheIndex = n),
                    (e[n] = i);
                },
                _takeBackBinding: function (t) {
                  var e = this._bindings,
                    n = t._cacheIndex,
                    r = --this._nActiveBindings,
                    i = e[r];
                  (t._cacheIndex = r),
                    (e[r] = t),
                    (i._cacheIndex = n),
                    (e[n] = i);
                },
                _lendControlInterpolant: function () {
                  var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    n = t[e];
                  return (
                    void 0 === n &&
                      ((n = new hi(
                        new Float32Array(2),
                        new Float32Array(2),
                        1,
                        this._controlInterpolantsResultBuffer
                      )),
                      (n.__cacheIndex = e),
                      (t[e] = n)),
                    n
                  );
                },
                _takeBackControlInterpolant: function (t) {
                  var e = this._controlInterpolants,
                    n = t.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = e[r];
                  (t.__cacheIndex = r),
                    (e[r] = t),
                    (i.__cacheIndex = n),
                    (e[n] = i);
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function (t, e) {
                  var n = e || this._root,
                    r = n.uuid,
                    i = "string" == typeof t ? xi.findByName(n, t) : t,
                    a = null !== i ? i.uuid : t,
                    o = this._actionsByClip[a],
                    s = null;
                  if (void 0 !== o) {
                    var c = o.actionByRoot[r];
                    if (void 0 !== c) return c;
                    (s = o.knownActions[0]), null === i && (i = s._clip);
                  }
                  if (null === i) return null;
                  var h = new ji(this, i, e);
                  return (
                    this._bindAction(h, s), this._addInactiveAction(h, a, r), h
                  );
                },
                existingAction: function (t, e) {
                  var n = e || this._root,
                    r = n.uuid,
                    i = "string" == typeof t ? xi.findByName(n, t) : t,
                    a = i ? i.uuid : t,
                    o = this._actionsByClip[a];
                  return void 0 !== o ? o.actionByRoot[r] || null : null;
                },
                stopAllAction: function () {
                  var t = this._actions,
                    e = this._nActiveActions,
                    n = this._bindings,
                    r = this._nActiveBindings;
                  (this._nActiveActions = 0), (this._nActiveBindings = 0);
                  for (var i = 0; i !== e; ++i) t[i].reset();
                  for (var i = 0; i !== r; ++i) n[i].useCount = 0;
                  return this;
                },
                update: function (t) {
                  t *= this.timeScale;
                  for (
                    var e = this._actions,
                      n = this._nActiveActions,
                      r = (this.time += t),
                      i = Math.sign(t),
                      a = (this._accuIndex ^= 1),
                      o = 0;
                    o !== n;
                    ++o
                  ) {
                    e[o]._update(r, t, i, a);
                  }
                  for (
                    var s = this._bindings, c = this._nActiveBindings, o = 0;
                    o !== c;
                    ++o
                  )
                    s[o].apply(a);
                  return this;
                },
                getRoot: function () {
                  return this._root;
                },
                uncacheClip: function (t) {
                  var e = this._actions,
                    n = t.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                  if (void 0 !== i) {
                    for (
                      var a = i.knownActions, o = 0, s = a.length;
                      o !== s;
                      ++o
                    ) {
                      var c = a[o];
                      this._deactivateAction(c);
                      var h = c._cacheIndex,
                        l = e[e.length - 1];
                      (c._cacheIndex = null),
                        (c._byClipCacheIndex = null),
                        (l._cacheIndex = h),
                        (e[h] = l),
                        e.pop(),
                        this._removeInactiveBindingsForAction(c);
                    }
                    delete r[n];
                  }
                },
                uncacheRoot: function (t) {
                  var e = t.uuid,
                    n = this._actionsByClip;
                  for (var r in n) {
                    var i = n[r].actionByRoot,
                      a = i[e];
                    void 0 !== a &&
                      (this._deactivateAction(a),
                      this._removeInactiveAction(a));
                  }
                  var o = this._bindingsByRootAndName,
                    s = o[e];
                  if (void 0 !== s)
                    for (var c in s) {
                      var h = s[c];
                      h.restoreOriginalState(), this._removeInactiveBinding(h);
                    }
                },
                uncacheAction: function (t, e) {
                  var n = this.existingAction(t, e);
                  null !== n &&
                    (this._deactivateAction(n), this._removeInactiveAction(n));
                },
              })),
              (Xi.prototype.clone = function () {
                return new Xi(
                  void 0 === this.value.clone ? this.value : this.value.clone()
                );
              }),
              (qi.prototype = Object.assign(Object.create(F.prototype), {
                constructor: qi,
                isInstancedBufferGeometry: !0,
                copy: function (t) {
                  return (
                    F.prototype.copy.call(this, t),
                    (this.maxInstancedCount = t.maxInstancedCount),
                    this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
              })),
              (Yi.prototype = Object.assign(Object.create(Re.prototype), {
                constructor: Yi,
                isInstancedInterleavedBuffer: !0,
                copy: function (t) {
                  return (
                    Re.prototype.copy.call(this, t),
                    (this.meshPerAttribute = t.meshPerAttribute),
                    this
                  );
                },
              })),
              (Ji.prototype = Object.assign(Object.create(S.prototype), {
                constructor: Ji,
                isInstancedBufferAttribute: !0,
                copy: function (t) {
                  return (
                    S.prototype.copy.call(this, t),
                    (this.meshPerAttribute = t.meshPerAttribute),
                    this
                  );
                },
              })),
              Object.assign(Zi.prototype, {
                linePrecision: 1,
                set: function (t, e) {
                  this.ray.set(t, e);
                },
                setFromCamera: function (t, e) {
                  e && e.isPerspectiveCamera
                    ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                      this.ray.direction
                        .set(t.x, t.y, 0.5)
                        .unproject(e)
                        .sub(this.ray.origin)
                        .normalize())
                    : e && e.isOrthographicCamera
                    ? (this.ray.origin
                        .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                        .unproject(e),
                      this.ray.direction
                        .set(0, 0, -1)
                        .transformDirection(e.matrixWorld))
                    : console.error(
                        "THREE.Raycaster: Unsupported camera type."
                      );
                },
                intersectObject: function (t, e, n) {
                  var r = n || [];
                  return Ki(t, this, r, e), r.sort(Qi), r;
                },
                intersectObjects: function (t, e, n) {
                  var r = n || [];
                  if (!1 === Array.isArray(t))
                    return (
                      console.warn(
                        "THREE.Raycaster.intersectObjects: objects is not an Array."
                      ),
                      r
                    );
                  for (var i = 0, a = t.length; i < a; i++)
                    Ki(t[i], this, r, e);
                  return r.sort(Qi), r;
                },
              }),
              Object.assign($i.prototype, {
                start: function () {
                  (this.startTime = (
                    "undefined" == typeof performance ? Date : performance
                  ).now()),
                    (this.oldTime = this.startTime),
                    (this.elapsedTime = 0),
                    (this.running = !0);
                },
                stop: function () {
                  this.getElapsedTime(),
                    (this.running = !1),
                    (this.autoStart = !1);
                },
                getElapsedTime: function () {
                  return this.getDelta(), this.elapsedTime;
                },
                getDelta: function () {
                  var t = 0;
                  if (this.autoStart && !this.running) return this.start(), 0;
                  if (this.running) {
                    var e = (
                      "undefined" == typeof performance ? Date : performance
                    ).now();
                    (t = (e - this.oldTime) / 1e3),
                      (this.oldTime = e),
                      (this.elapsedTime += t);
                  }
                  return t;
                },
              }),
              Object.assign(ta.prototype, {
                set: function (t, e, n) {
                  return (
                    (this.radius = t), (this.phi = e), (this.theta = n), this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    (this.radius = t.radius),
                    (this.phi = t.phi),
                    (this.theta = t.theta),
                    this
                  );
                },
                makeSafe: function () {
                  return (
                    (this.phi = Math.max(
                      1e-6,
                      Math.min(Math.PI - 1e-6, this.phi)
                    )),
                    this
                  );
                },
                setFromVector3: function (t) {
                  return (
                    (this.radius = t.length()),
                    0 === this.radius
                      ? ((this.theta = 0), (this.phi = 0))
                      : ((this.theta = Math.atan2(t.x, t.z)),
                        (this.phi = Math.acos(
                          xc.clamp(t.y / this.radius, -1, 1)
                        ))),
                    this
                  );
                },
              }),
              Object.assign(ea.prototype, {
                set: function (t, e, n) {
                  return (
                    (this.radius = t), (this.theta = e), (this.y = n), this
                  );
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return (
                    (this.radius = t.radius),
                    (this.theta = t.theta),
                    (this.y = t.y),
                    this
                  );
                },
                setFromVector3: function (t) {
                  return (
                    (this.radius = Math.sqrt(t.x * t.x + t.z * t.z)),
                    (this.theta = Math.atan2(t.x, t.z)),
                    (this.y = t.y),
                    this
                  );
                },
              }),
              Object.assign(na.prototype, {
                set: function (t, e) {
                  return this.min.copy(t), this.max.copy(e), this;
                },
                setFromPoints: function (t) {
                  this.makeEmpty();
                  for (var e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                  return this;
                },
                setFromCenterAndSize: (function () {
                  var t = new n();
                  return function (e, n) {
                    var r = t.copy(n).multiplyScalar(0.5);
                    return (
                      this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                    );
                  };
                })(),
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return this.min.copy(t.min), this.max.copy(t.max), this;
                },
                makeEmpty: function () {
                  return (
                    (this.min.x = this.min.y = 1 / 0),
                    (this.max.x = this.max.y = -1 / 0),
                    this
                  );
                },
                isEmpty: function () {
                  return this.max.x < this.min.x || this.max.y < this.min.y;
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Box2: .getCenter() target is now required"
                      ),
                      (t = new n())),
                    this.isEmpty()
                      ? t.set(0, 0)
                      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
                  );
                },
                getSize: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Box2: .getSize() target is now required"
                      ),
                      (t = new n())),
                    this.isEmpty()
                      ? t.set(0, 0)
                      : t.subVectors(this.max, this.min)
                  );
                },
                expandByPoint: function (t) {
                  return this.min.min(t), this.max.max(t), this;
                },
                expandByVector: function (t) {
                  return this.min.sub(t), this.max.add(t), this;
                },
                expandByScalar: function (t) {
                  return this.min.addScalar(-t), this.max.addScalar(t), this;
                },
                containsPoint: function (t) {
                  return !(
                    t.x < this.min.x ||
                    t.x > this.max.x ||
                    t.y < this.min.y ||
                    t.y > this.max.y
                  );
                },
                containsBox: function (t) {
                  return (
                    this.min.x <= t.min.x &&
                    t.max.x <= this.max.x &&
                    this.min.y <= t.min.y &&
                    t.max.y <= this.max.y
                  );
                },
                getParameter: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Box2: .getParameter() target is now required"
                      ),
                      (e = new n())),
                    e.set(
                      (t.x - this.min.x) / (this.max.x - this.min.x),
                      (t.y - this.min.y) / (this.max.y - this.min.y)
                    )
                  );
                },
                intersectsBox: function (t) {
                  return !(
                    t.max.x < this.min.x ||
                    t.min.x > this.max.x ||
                    t.max.y < this.min.y ||
                    t.min.y > this.max.y
                  );
                },
                clampPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Box2: .clampPoint() target is now required"
                      ),
                      (e = new n())),
                    e.copy(t).clamp(this.min, this.max)
                  );
                },
                distanceToPoint: (function () {
                  var t = new n();
                  return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length();
                  };
                })(),
                intersect: function (t) {
                  return this.min.max(t.min), this.max.min(t.max), this;
                },
                union: function (t) {
                  return this.min.min(t.min), this.max.max(t.max), this;
                },
                translate: function (t) {
                  return this.min.add(t), this.max.add(t), this;
                },
                equals: function (t) {
                  return t.min.equals(this.min) && t.max.equals(this.max);
                },
              }),
              Object.assign(ra.prototype, {
                set: function (t, e) {
                  return this.start.copy(t), this.end.copy(e), this;
                },
                clone: function () {
                  return new this.constructor().copy(this);
                },
                copy: function (t) {
                  return this.start.copy(t.start), this.end.copy(t.end), this;
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Line3: .getCenter() target is now required"
                      ),
                      (t = new a())),
                    t.addVectors(this.start, this.end).multiplyScalar(0.5)
                  );
                },
                delta: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        "THREE.Line3: .delta() target is now required"
                      ),
                      (t = new a())),
                    t.subVectors(this.end, this.start)
                  );
                },
                distanceSq: function () {
                  return this.start.distanceToSquared(this.end);
                },
                distance: function () {
                  return this.start.distanceTo(this.end);
                },
                at: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        "THREE.Line3: .at() target is now required"
                      ),
                      (e = new a())),
                    this.delta(e).multiplyScalar(t).add(this.start)
                  );
                },
                closestPointToPointParameter: (function () {
                  var t = new a(),
                    e = new a();
                  return function (n, r) {
                    t.subVectors(n, this.start),
                      e.subVectors(this.end, this.start);
                    var i = e.dot(e),
                      a = e.dot(t),
                      o = a / i;
                    return r && (o = xc.clamp(o, 0, 1)), o;
                  };
                })(),
                closestPointToPoint: function (t, e, n) {
                  var r = this.closestPointToPointParameter(t, e);
                  return (
                    void 0 === n &&
                      (console.warn(
                        "THREE.Line3: .closestPointToPoint() target is now required"
                      ),
                      (n = new a())),
                    this.delta(n).multiplyScalar(r).add(this.start)
                  );
                },
                applyMatrix4: function (t) {
                  return (
                    this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                  );
                },
                equals: function (t) {
                  return t.start.equals(this.start) && t.end.equals(this.end);
                },
              }),
              (ia.prototype = Object.create(_.prototype)),
              (ia.prototype.constructor = ia),
              (ia.prototype.isImmediateRenderObject = !0),
              (aa.prototype = Object.create(ze.prototype)),
              (aa.prototype.constructor = aa),
              (aa.prototype.update = (function () {
                var t = new a(),
                  e = new a(),
                  n = new o();
                return function () {
                  var r = ["a", "b", "c"];
                  this.object.updateMatrixWorld(!0),
                    n.getNormalMatrix(this.object.matrixWorld);
                  var i = this.object.matrixWorld,
                    a = this.geometry.attributes.position,
                    o = this.object.geometry;
                  if (o && o.isGeometry)
                    for (
                      var s = o.vertices,
                        c = o.faces,
                        h = 0,
                        l = 0,
                        u = c.length;
                      l < u;
                      l++
                    )
                      for (
                        var p = c[l], d = 0, f = p.vertexNormals.length;
                        d < f;
                        d++
                      ) {
                        var m = s[p[r[d]]],
                          g = p.vertexNormals[d];
                        t.copy(m).applyMatrix4(i),
                          e
                            .copy(g)
                            .applyMatrix3(n)
                            .normalize()
                            .multiplyScalar(this.size)
                            .add(t),
                          a.setXYZ(h, t.x, t.y, t.z),
                          (h += 1),
                          a.setXYZ(h, e.x, e.y, e.z),
                          (h += 1);
                      }
                  else if (o && o.isBufferGeometry)
                    for (
                      var v = o.attributes.position,
                        y = o.attributes.normal,
                        h = 0,
                        d = 0,
                        f = v.count;
                      d < f;
                      d++
                    )
                      t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(i),
                        e.set(y.getX(d), y.getY(d), y.getZ(d)),
                        e
                          .applyMatrix3(n)
                          .normalize()
                          .multiplyScalar(this.size)
                          .add(t),
                        a.setXYZ(h, t.x, t.y, t.z),
                        (h += 1),
                        a.setXYZ(h, e.x, e.y, e.z),
                        (h += 1);
                  a.needsUpdate = !0;
                };
              })()),
              (oa.prototype = Object.create(_.prototype)),
              (oa.prototype.constructor = oa),
              (oa.prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose();
              }),
              (oa.prototype.update = (function () {
                var t = new a(),
                  e = new a();
                return function () {
                  this.light.updateMatrixWorld();
                  var n = this.light.distance ? this.light.distance : 1e3,
                    r = n * Math.tan(this.light.angle);
                  this.cone.scale.set(r, r, n),
                    t.setFromMatrixPosition(this.light.matrixWorld),
                    e.setFromMatrixPosition(this.light.target.matrixWorld),
                    this.cone.lookAt(e.sub(t)),
                    void 0 !== this.color
                      ? this.cone.material.color.set(this.color)
                      : this.cone.material.color.copy(this.light.color);
                };
              })()),
              (ca.prototype = Object.create(ze.prototype)),
              (ca.prototype.constructor = ca),
              (ca.prototype.updateMatrixWorld = (function () {
                var t = new a(),
                  e = new r(),
                  n = new r();
                return function (r) {
                  var i = this.bones,
                    a = this.geometry,
                    o = a.getAttribute("position");
                  n.getInverse(this.root.matrixWorld);
                  for (var s = 0, c = 0; s < i.length; s++) {
                    var h = i[s];
                    h.parent &&
                      h.parent.isBone &&
                      (e.multiplyMatrices(n, h.matrixWorld),
                      t.setFromMatrixPosition(e),
                      o.setXYZ(c, t.x, t.y, t.z),
                      e.multiplyMatrices(n, h.parent.matrixWorld),
                      t.setFromMatrixPosition(e),
                      o.setXYZ(c + 1, t.x, t.y, t.z),
                      (c += 2));
                  }
                  (a.getAttribute("position").needsUpdate = !0),
                    _.prototype.updateMatrixWorld.call(this, r);
                };
              })()),
              (ha.prototype = Object.create(Y.prototype)),
              (ha.prototype.constructor = ha),
              (ha.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose();
              }),
              (ha.prototype.update = function () {
                void 0 !== this.color
                  ? this.material.color.set(this.color)
                  : this.material.color.copy(this.light.color);
              }),
              (la.prototype = Object.create(_.prototype)),
              (la.prototype.constructor = la),
              (la.prototype.dispose = function () {
                this.children[0].geometry.dispose(),
                  this.children[0].material.dispose();
              }),
              (la.prototype.update = function () {
                var t = 0.5 * this.light.width,
                  e = 0.5 * this.light.height,
                  n = this.line.geometry.attributes.position,
                  r = n.array;
                (r[0] = t),
                  (r[1] = -e),
                  (r[2] = 0),
                  (r[3] = t),
                  (r[4] = e),
                  (r[5] = 0),
                  (r[6] = -t),
                  (r[7] = e),
                  (r[8] = 0),
                  (r[9] = -t),
                  (r[10] = -e),
                  (r[11] = 0),
                  (r[12] = t),
                  (r[13] = -e),
                  (r[14] = 0),
                  (n.needsUpdate = !0),
                  void 0 !== this.color
                    ? this.line.material.color.set(this.color)
                    : this.line.material.color.copy(this.light.color);
              }),
              (ua.prototype = Object.create(_.prototype)),
              (ua.prototype.constructor = ua),
              (ua.prototype.dispose = function () {
                this.children[0].geometry.dispose(),
                  this.children[0].material.dispose();
              }),
              (ua.prototype.update = (function () {
                var t = new a(),
                  e = new g(),
                  n = new g();
                return function () {
                  var r = this.children[0];
                  if (void 0 !== this.color)
                    this.material.color.set(this.color);
                  else {
                    var i = r.geometry.getAttribute("color");
                    e.copy(this.light.color), n.copy(this.light.groundColor);
                    for (var a = 0, o = i.count; a < o; a++) {
                      var s = a < o / 2 ? e : n;
                      i.setXYZ(a, s.r, s.g, s.b);
                    }
                    i.needsUpdate = !0;
                  }
                  r.lookAt(
                    t.setFromMatrixPosition(this.light.matrixWorld).negate()
                  );
                };
              })()),
              (pa.prototype = Object.create(ze.prototype)),
              (pa.prototype.constructor = pa),
              (da.prototype = Object.create(ze.prototype)),
              (da.prototype.constructor = da),
              (fa.prototype = Object.create(ze.prototype)),
              (fa.prototype.constructor = fa),
              (fa.prototype.update = (function () {
                var t = new a(),
                  e = new a(),
                  n = new o();
                return function () {
                  this.object.updateMatrixWorld(!0),
                    n.getNormalMatrix(this.object.matrixWorld);
                  for (
                    var r = this.object.matrixWorld,
                      i = this.geometry.attributes.position,
                      a = this.object.geometry,
                      o = a.vertices,
                      s = a.faces,
                      c = 0,
                      h = 0,
                      l = s.length;
                    h < l;
                    h++
                  ) {
                    var u = s[h],
                      p = u.normal;
                    t
                      .copy(o[u.a])
                      .add(o[u.b])
                      .add(o[u.c])
                      .divideScalar(3)
                      .applyMatrix4(r),
                      e
                        .copy(p)
                        .applyMatrix3(n)
                        .normalize()
                        .multiplyScalar(this.size)
                        .add(t),
                      i.setXYZ(c, t.x, t.y, t.z),
                      (c += 1),
                      i.setXYZ(c, e.x, e.y, e.z),
                      (c += 1);
                  }
                  i.needsUpdate = !0;
                };
              })()),
              (ma.prototype = Object.create(_.prototype)),
              (ma.prototype.constructor = ma),
              (ma.prototype.dispose = function () {
                this.lightPlane.geometry.dispose(),
                  this.lightPlane.material.dispose(),
                  this.targetLine.geometry.dispose(),
                  this.targetLine.material.dispose();
              }),
              (ma.prototype.update = (function () {
                var t = new a(),
                  e = new a(),
                  n = new a();
                return function () {
                  t.setFromMatrixPosition(this.light.matrixWorld),
                    e.setFromMatrixPosition(this.light.target.matrixWorld),
                    n.subVectors(e, t),
                    this.lightPlane.lookAt(n),
                    void 0 !== this.color
                      ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color))
                      : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                    this.targetLine.lookAt(n),
                    (this.targetLine.scale.z = n.length());
                };
              })()),
              (ga.prototype = Object.create(ze.prototype)),
              (ga.prototype.constructor = ga),
              (ga.prototype.update = (function () {
                function t(t, a, o, s) {
                  r.set(a, o, s).unproject(i);
                  var c = n[t];
                  if (void 0 !== c)
                    for (
                      var h = e.getAttribute("position"), l = 0, u = c.length;
                      l < u;
                      l++
                    )
                      h.setXYZ(c[l], r.x, r.y, r.z);
                }
                var e,
                  n,
                  r = new a(),
                  i = new w();
                return function () {
                  (e = this.geometry), (n = this.pointMap);
                  i.projectionMatrix.copy(this.camera.projectionMatrix),
                    t("c", 0, 0, -1),
                    t("t", 0, 0, 1),
                    t("n1", -1, -1, -1),
                    t("n2", 1, -1, -1),
                    t("n3", -1, 1, -1),
                    t("n4", 1, 1, -1),
                    t("f1", -1, -1, 1),
                    t("f2", 1, -1, 1),
                    t("f3", -1, 1, 1),
                    t("f4", 1, 1, 1),
                    t("u1", 0.7, 1.1, -1),
                    t("u2", -0.7, 1.1, -1),
                    t("u3", 0, 2, -1),
                    t("cf1", -1, 0, 1),
                    t("cf2", 1, 0, 1),
                    t("cf3", 0, -1, 1),
                    t("cf4", 0, 1, 1),
                    t("cn1", -1, 0, -1),
                    t("cn2", 1, 0, -1),
                    t("cn3", 0, -1, -1),
                    t("cn4", 0, 1, -1),
                    (e.getAttribute("position").needsUpdate = !0);
                };
              })()),
              (va.prototype = Object.create(ze.prototype)),
              (va.prototype.constructor = va),
              (va.prototype.update = (function () {
                var t = new p();
                return function (e) {
                  if (
                    (void 0 !== e &&
                      console.warn(
                        "THREE.BoxHelper: .update() has no longer arguments."
                      ),
                    void 0 !== this.object && t.setFromObject(this.object),
                    !t.isEmpty())
                  ) {
                    var n = t.min,
                      r = t.max,
                      i = this.geometry.attributes.position,
                      a = i.array;
                    (a[0] = r.x),
                      (a[1] = r.y),
                      (a[2] = r.z),
                      (a[3] = n.x),
                      (a[4] = r.y),
                      (a[5] = r.z),
                      (a[6] = n.x),
                      (a[7] = n.y),
                      (a[8] = r.z),
                      (a[9] = r.x),
                      (a[10] = n.y),
                      (a[11] = r.z),
                      (a[12] = r.x),
                      (a[13] = r.y),
                      (a[14] = n.z),
                      (a[15] = n.x),
                      (a[16] = r.y),
                      (a[17] = n.z),
                      (a[18] = n.x),
                      (a[19] = n.y),
                      (a[20] = n.z),
                      (a[21] = r.x),
                      (a[22] = n.y),
                      (a[23] = n.z),
                      (i.needsUpdate = !0),
                      this.geometry.computeBoundingSphere();
                  }
                };
              })()),
              (va.prototype.setFromObject = function (t) {
                return (this.object = t), this.update(), this;
              }),
              (ya.prototype = Object.create(ze.prototype)),
              (ya.prototype.constructor = ya),
              (ya.prototype.updateMatrixWorld = function (t) {
                var e = this.box;
                e.isEmpty() ||
                  (e.getCenter(this.position),
                  e.getSize(this.scale),
                  this.scale.multiplyScalar(0.5),
                  _.prototype.updateMatrixWorld.call(this, t));
              }),
              (xa.prototype = Object.create(Fe.prototype)),
              (xa.prototype.constructor = xa),
              (xa.prototype.updateMatrixWorld = function (t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8),
                  this.scale.set(0.5 * this.size, 0.5 * this.size, e),
                  (this.children[0].material.side = e < 0 ? co : so),
                  this.lookAt(this.plane.normal),
                  _.prototype.updateMatrixWorld.call(this, t);
              });
            var lh, uh;
            (ba.prototype = Object.create(_.prototype)),
              (ba.prototype.constructor = ba),
              (ba.prototype.setDirection = (function () {
                var t,
                  e = new a();
                return function (n) {
                  n.y > 0.99999
                    ? this.quaternion.set(0, 0, 0, 1)
                    : n.y < -0.99999
                    ? this.quaternion.set(1, 0, 0, 0)
                    : (e.set(n.z, 0, -n.x).normalize(),
                      (t = Math.acos(n.y)),
                      this.quaternion.setFromAxisAngle(e, t));
                };
              })()),
              (ba.prototype.setLength = function (t, e, n) {
                void 0 === e && (e = 0.2 * t),
                  void 0 === n && (n = 0.2 * e),
                  this.line.scale.set(1, Math.max(0, t - e), 1),
                  this.line.updateMatrix(),
                  this.cone.scale.set(n, e, n),
                  (this.cone.position.y = t),
                  this.cone.updateMatrix();
              }),
              (ba.prototype.setColor = function (t) {
                this.line.material.color.copy(t),
                  this.cone.material.color.copy(t);
              }),
              (_a.prototype = Object.create(ze.prototype)),
              (_a.prototype.constructor = _a);
            (Sr.create = function (t, e) {
              return (
                console.log("THREE.Curve.create() has been deprecated"),
                (t.prototype = Object.create(Sr.prototype)),
                (t.prototype.constructor = t),
                (t.prototype.getPoint = e),
                t
              );
            }),
              Object.assign(Yr.prototype, {
                createPointsGeometry: function (t) {
                  console.warn(
                    "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
                  );
                  var e = this.getPoints(t);
                  return this.createGeometry(e);
                },
                createSpacedPointsGeometry: function (t) {
                  console.warn(
                    "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
                  );
                  var e = this.getSpacedPoints(t);
                  return this.createGeometry(e);
                },
                createGeometry: function (t) {
                  console.warn(
                    "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
                  );
                  for (var e = new T(), n = 0, r = t.length; n < r; n++) {
                    var i = t[n];
                    e.vertices.push(new a(i.x, i.y, i.z || 0));
                  }
                  return e;
                },
              }),
              Object.assign(Jr.prototype, {
                fromPoints: function (t) {
                  console.warn(
                    "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
                  ),
                    this.setFromPoints(t);
                },
              }),
              (Va.prototype = Object.create(Cr.prototype)),
              (ka.prototype = Object.create(Cr.prototype)),
              (ja.prototype = Object.create(Cr.prototype)),
              Object.assign(ja.prototype, {
                initFromArray: function () {
                  console.error(
                    "THREE.Spline: .initFromArray() has been removed."
                  );
                },
                getControlPointsArray: function () {
                  console.error(
                    "THREE.Spline: .getControlPointsArray() has been removed."
                  );
                },
                reparametrizeByArcLength: function () {
                  console.error(
                    "THREE.Spline: .reparametrizeByArcLength() has been removed."
                  );
                },
              }),
              (pa.prototype.setColors = function () {
                console.error(
                  "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
                );
              }),
              (ca.prototype.update = function () {
                console.error(
                  "THREE.SkeletonHelper: update() no longer needs to be called."
                );
              }),
              Object.assign(Ei.prototype, {
                extractUrlBase: function (t) {
                  return (
                    console.warn(
                      "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
                    ),
                    rh.extractUrlBase(t)
                  );
                },
              }),
              Object.assign(na.prototype, {
                center: function (t) {
                  return (
                    console.warn(
                      "THREE.Box2: .center() has been renamed to .getCenter()."
                    ),
                    this.getCenter(t)
                  );
                },
                empty: function () {
                  return (
                    console.warn(
                      "THREE.Box2: .empty() has been renamed to .isEmpty()."
                    ),
                    this.isEmpty()
                  );
                },
                isIntersectionBox: function (t) {
                  return (
                    console.warn(
                      "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
                    ),
                    this.intersectsBox(t)
                  );
                },
                size: function (t) {
                  return (
                    console.warn(
                      "THREE.Box2: .size() has been renamed to .getSize()."
                    ),
                    this.getSize(t)
                  );
                },
              }),
              Object.assign(p.prototype, {
                center: function (t) {
                  return (
                    console.warn(
                      "THREE.Box3: .center() has been renamed to .getCenter()."
                    ),
                    this.getCenter(t)
                  );
                },
                empty: function () {
                  return (
                    console.warn(
                      "THREE.Box3: .empty() has been renamed to .isEmpty()."
                    ),
                    this.isEmpty()
                  );
                },
                isIntersectionBox: function (t) {
                  return (
                    console.warn(
                      "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
                    ),
                    this.intersectsBox(t)
                  );
                },
                isIntersectionSphere: function (t) {
                  return (
                    console.warn(
                      "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
                    ),
                    this.intersectsSphere(t)
                  );
                },
                size: function (t) {
                  return (
                    console.warn(
                      "THREE.Box3: .size() has been renamed to .getSize()."
                    ),
                    this.getSize(t)
                  );
                },
              }),
              (ra.prototype.center = function (t) {
                return (
                  console.warn(
                    "THREE.Line3: .center() has been renamed to .getCenter()."
                  ),
                  this.getCenter(t)
                );
              }),
              Object.assign(xc, {
                random16: function () {
                  return (
                    console.warn(
                      "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
                    ),
                    Math.random()
                  );
                },
                nearestPowerOfTwo: function (t) {
                  return (
                    console.warn(
                      "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
                    ),
                    xc.floorPowerOfTwo(t)
                  );
                },
                nextPowerOfTwo: function (t) {
                  return (
                    console.warn(
                      "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
                    ),
                    xc.ceilPowerOfTwo(t)
                  );
                },
              }),
              Object.assign(o.prototype, {
                flattenToArrayOffset: function (t, e) {
                  return (
                    console.warn(
                      "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
                    ),
                    this.toArray(t, e)
                  );
                },
                multiplyVector3: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
                    ),
                    t.applyMatrix3(this)
                  );
                },
                multiplyVector3Array: function () {
                  console.error(
                    "THREE.Matrix3: .multiplyVector3Array() has been removed."
                  );
                },
                applyToBuffer: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
                    ),
                    this.applyToBufferAttribute(t)
                  );
                },
                applyToVector3Array: function () {
                  console.error(
                    "THREE.Matrix3: .applyToVector3Array() has been removed."
                  );
                },
              }),
              Object.assign(r.prototype, {
                extractPosition: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
                    ),
                    this.copyPosition(t)
                  );
                },
                flattenToArrayOffset: function (t, e) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
                    ),
                    this.toArray(t, e)
                  );
                },
                getPosition: (function () {
                  var t;
                  return function () {
                    return (
                      void 0 === t && (t = new a()),
                      console.warn(
                        "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
                      ),
                      t.setFromMatrixColumn(this, 3)
                    );
                  };
                })(),
                setRotationFromQuaternion: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
                    ),
                    this.makeRotationFromQuaternion(t)
                  );
                },
                multiplyToArray: function () {
                  console.warn(
                    "THREE.Matrix4: .multiplyToArray() has been removed."
                  );
                },
                multiplyVector3: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
                    ),
                    t.applyMatrix4(this)
                  );
                },
                multiplyVector4: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
                    ),
                    t.applyMatrix4(this)
                  );
                },
                multiplyVector3Array: function () {
                  console.error(
                    "THREE.Matrix4: .multiplyVector3Array() has been removed."
                  );
                },
                rotateAxis: function (t) {
                  console.warn(
                    "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
                  ),
                    t.transformDirection(this);
                },
                crossVector: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
                    ),
                    t.applyMatrix4(this)
                  );
                },
                translate: function () {
                  console.error(
                    "THREE.Matrix4: .translate() has been removed."
                  );
                },
                rotateX: function () {
                  console.error("THREE.Matrix4: .rotateX() has been removed.");
                },
                rotateY: function () {
                  console.error("THREE.Matrix4: .rotateY() has been removed.");
                },
                rotateZ: function () {
                  console.error("THREE.Matrix4: .rotateZ() has been removed.");
                },
                rotateByAxis: function () {
                  console.error(
                    "THREE.Matrix4: .rotateByAxis() has been removed."
                  );
                },
                applyToBuffer: function (t) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
                    ),
                    this.applyToBufferAttribute(t)
                  );
                },
                applyToVector3Array: function () {
                  console.error(
                    "THREE.Matrix4: .applyToVector3Array() has been removed."
                  );
                },
                makeFrustum: function (t, e, n, r, i, a) {
                  return (
                    console.warn(
                      "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
                    ),
                    this.makePerspective(t, e, r, n, i, a)
                  );
                },
              }),
              (f.prototype.isIntersectionLine = function (t) {
                return (
                  console.warn(
                    "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
                  ),
                  this.intersectsLine(t)
                );
              }),
              (i.prototype.multiplyVector3 = function (t) {
                return (
                  console.warn(
                    "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
                  ),
                  t.applyQuaternion(this)
                );
              }),
              Object.assign(X.prototype, {
                isIntersectionBox: function (t) {
                  return (
                    console.warn(
                      "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
                    ),
                    this.intersectsBox(t)
                  );
                },
                isIntersectionPlane: function (t) {
                  return (
                    console.warn(
                      "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
                    ),
                    this.intersectsPlane(t)
                  );
                },
                isIntersectionSphere: function (t) {
                  return (
                    console.warn(
                      "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
                    ),
                    this.intersectsSphere(t)
                  );
                },
              }),
              Object.assign(q.prototype, {
                area: function () {
                  return (
                    console.warn(
                      "THREE.Triangle: .area() has been renamed to .getArea()."
                    ),
                    this.getArea()
                  );
                },
                barycoordFromPoint: function (t, e) {
                  return (
                    console.warn(
                      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
                    ),
                    this.getBarycoord(t, e)
                  );
                },
                midpoint: function (t) {
                  return (
                    console.warn(
                      "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
                    ),
                    this.getMidpoint(t)
                  );
                },
                normal: function (t) {
                  return (
                    console.warn(
                      "THREE.Triangle: .normal() has been renamed to .getNormal()."
                    ),
                    this.getNormal(t)
                  );
                },
                plane: function (t) {
                  return (
                    console.warn(
                      "THREE.Triangle: .plane() has been renamed to .getPlane()."
                    ),
                    this.getPlane(t)
                  );
                },
              }),
              Object.assign(q, {
                barycoordFromPoint: function (t, e, n, r, i) {
                  return (
                    console.warn(
                      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
                    ),
                    q.getBarycoord(t, e, n, r, i)
                  );
                },
                normal: function (t, e, n, r) {
                  return (
                    console.warn(
                      "THREE.Triangle: .normal() has been renamed to .getNormal()."
                    ),
                    q.getNormal(t, e, n, r)
                  );
                },
              }),
              Object.assign(Zr.prototype, {
                extractAllPoints: function (t) {
                  return (
                    console.warn(
                      "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
                    ),
                    this.extractPoints(t)
                  );
                },
                extrude: function (t) {
                  return (
                    console.warn(
                      "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
                    ),
                    new kn(this, t)
                  );
                },
                makeGeometry: function (t) {
                  return (
                    console.warn(
                      "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
                    ),
                    new tr(this, t)
                  );
                },
              }),
              Object.assign(n.prototype, {
                fromAttribute: function (t, e, n) {
                  return (
                    console.warn(
                      "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
                    ),
                    this.fromBufferAttribute(t, e, n)
                  );
                },
                distanceToManhattan: function (t) {
                  return (
                    console.warn(
                      "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
                    ),
                    this.manhattanDistanceTo(t)
                  );
                },
                lengthManhattan: function () {
                  return (
                    console.warn(
                      "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
                    ),
                    this.manhattanLength()
                  );
                },
              }),
              Object.assign(a.prototype, {
                setEulerFromRotationMatrix: function () {
                  console.error(
                    "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
                  );
                },
                setEulerFromQuaternion: function () {
                  console.error(
                    "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
                  );
                },
                getPositionFromMatrix: function (t) {
                  return (
                    console.warn(
                      "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
                    ),
                    this.setFromMatrixPosition(t)
                  );
                },
                getScaleFromMatrix: function (t) {
                  return (
                    console.warn(
                      "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
                    ),
                    this.setFromMatrixScale(t)
                  );
                },
                getColumnFromMatrix: function (t, e) {
                  return (
                    console.warn(
                      "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
                    ),
                    this.setFromMatrixColumn(e, t)
                  );
                },
                applyProjection: function (t) {
                  return (
                    console.warn(
                      "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
                    ),
                    this.applyMatrix4(t)
                  );
                },
                fromAttribute: function (t, e, n) {
                  return (
                    console.warn(
                      "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
                    ),
                    this.fromBufferAttribute(t, e, n)
                  );
                },
                distanceToManhattan: function (t) {
                  return (
                    console.warn(
                      "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
                    ),
                    this.manhattanDistanceTo(t)
                  );
                },
                lengthManhattan: function () {
                  return (
                    console.warn(
                      "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
                    ),
                    this.manhattanLength()
                  );
                },
              }),
              Object.assign(c.prototype, {
                fromAttribute: function (t, e, n) {
                  return (
                    console.warn(
                      "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
                    ),
                    this.fromBufferAttribute(t, e, n)
                  );
                },
                lengthManhattan: function () {
                  return (
                    console.warn(
                      "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
                    ),
                    this.manhattanLength()
                  );
                },
              }),
              Object.assign(T.prototype, {
                computeTangents: function () {
                  console.error(
                    "THREE.Geometry: .computeTangents() has been removed."
                  );
                },
                computeLineDistances: function () {
                  console.error(
                    "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
                  );
                },
              }),
              Object.assign(_.prototype, {
                getChildByName: function (t) {
                  return (
                    console.warn(
                      "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
                    ),
                    this.getObjectByName(t)
                  );
                },
                renderDepth: function () {
                  console.warn(
                    "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
                  );
                },
                translate: function (t, e) {
                  return (
                    console.warn(
                      "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
                    ),
                    this.translateOnAxis(e, t)
                  );
                },
                getWorldRotation: function () {
                  console.error(
                    "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
                  );
                },
              }),
              Object.defineProperties(_.prototype, {
                eulerOrder: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.Object3D: .eulerOrder is now .rotation.order."
                      ),
                      this.rotation.order
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.Object3D: .eulerOrder is now .rotation.order."
                    ),
                      (this.rotation.order = t);
                  },
                },
                useQuaternion: {
                  get: function () {
                    console.warn(
                      "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                    );
                  },
                },
              }),
              Object.defineProperties(Ie.prototype, {
                objects: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.LOD: .objects has been renamed to .levels."
                      ),
                      this.levels
                    );
                  },
                },
              }),
              Object.defineProperty(Ne.prototype, "useVertexTexture", {
                get: function () {
                  console.warn(
                    "THREE.Skeleton: useVertexTexture has been removed."
                  );
                },
                set: function () {
                  console.warn(
                    "THREE.Skeleton: useVertexTexture has been removed."
                  );
                },
              }),
              Object.defineProperty(Sr.prototype, "__arcLengthDivisions", {
                get: function () {
                  return (
                    console.warn(
                      "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
                    ),
                    this.arcLengthDivisions
                  );
                },
                set: function (t) {
                  console.warn(
                    "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
                  ),
                    (this.arcLengthDivisions = t);
                },
              }),
              (_e.prototype.setLens = function (t, e) {
                console.warn(
                  "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
                ),
                  void 0 !== e && (this.filmGauge = e),
                  this.setFocalLength(t);
              }),
              Object.defineProperties(Qr.prototype, {
                onlyShadow: {
                  set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.");
                  },
                },
                shadowCameraFov: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
                    ),
                      (this.shadow.camera.fov = t);
                  },
                },
                shadowCameraLeft: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
                    ),
                      (this.shadow.camera.left = t);
                  },
                },
                shadowCameraRight: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
                    ),
                      (this.shadow.camera.right = t);
                  },
                },
                shadowCameraTop: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
                    ),
                      (this.shadow.camera.top = t);
                  },
                },
                shadowCameraBottom: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
                    ),
                      (this.shadow.camera.bottom = t);
                  },
                },
                shadowCameraNear: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
                    ),
                      (this.shadow.camera.near = t);
                  },
                },
                shadowCameraFar: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
                    ),
                      (this.shadow.camera.far = t);
                  },
                },
                shadowCameraVisible: {
                  set: function () {
                    console.warn(
                      "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
                    );
                  },
                },
                shadowBias: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowBias is now .shadow.bias."
                    ),
                      (this.shadow.bias = t);
                  },
                },
                shadowDarkness: {
                  set: function () {
                    console.warn(
                      "THREE.Light: .shadowDarkness has been removed."
                    );
                  },
                },
                shadowMapWidth: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
                    ),
                      (this.shadow.mapSize.width = t);
                  },
                },
                shadowMapHeight: {
                  set: function (t) {
                    console.warn(
                      "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
                    ),
                      (this.shadow.mapSize.height = t);
                  },
                },
              }),
              Object.defineProperties(S.prototype, {
                length: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                      ),
                      this.array.length
                    );
                  },
                },
                copyIndicesArray: function () {
                  console.error(
                    "THREE.BufferAttribute: .copyIndicesArray() has been removed."
                  );
                },
              }),
              Object.assign(F.prototype, {
                addIndex: function (t) {
                  console.warn(
                    "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
                  ),
                    this.setIndex(t);
                },
                addDrawCall: function (t, e, n) {
                  void 0 !== n &&
                    console.warn(
                      "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
                    ),
                    console.warn(
                      "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
                    ),
                    this.addGroup(t, e);
                },
                clearDrawCalls: function () {
                  console.warn(
                    "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
                  ),
                    this.clearGroups();
                },
                computeTangents: function () {
                  console.warn(
                    "THREE.BufferGeometry: .computeTangents() has been removed."
                  );
                },
                computeOffsets: function () {
                  console.warn(
                    "THREE.BufferGeometry: .computeOffsets() has been removed."
                  );
                },
              }),
              Object.defineProperties(F.prototype, {
                drawcalls: {
                  get: function () {
                    return (
                      console.error(
                        "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                      ),
                      this.groups
                    );
                  },
                },
                offsets: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.BufferGeometry: .offsets has been renamed to .groups."
                      ),
                      this.groups
                    );
                  },
                },
              }),
              Object.assign(jn.prototype, {
                getArrays: function () {
                  console.error(
                    "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
                  );
                },
                addShapeList: function () {
                  console.error(
                    "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
                  );
                },
                addShape: function () {
                  console.error(
                    "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
                  );
                },
              }),
              Object.defineProperties(Xi.prototype, {
                dynamic: {
                  set: function () {
                    console.warn(
                      "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
                    );
                  },
                },
                onUpdate: {
                  value: function () {
                    return (
                      console.warn(
                        "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
                      ),
                      this
                    );
                  },
                },
              }),
              Object.defineProperties(k.prototype, {
                wrapAround: {
                  get: function () {
                    console.warn(
                      "THREE.Material: .wrapAround has been removed."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.Material: .wrapAround has been removed."
                    );
                  },
                },
                wrapRGB: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.Material: .wrapRGB has been removed."
                      ),
                      new g()
                    );
                  },
                },
                shading: {
                  get: function () {
                    console.error(
                      "THREE." +
                        this.type +
                        ": .shading has been removed. Use the boolean .flatShading instead."
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE." +
                        this.type +
                        ": .shading has been removed. Use the boolean .flatShading instead."
                    ),
                      (this.flatShading = 1 === t);
                  },
                },
              }),
              Object.defineProperties(fr.prototype, {
                metal: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
                      ),
                      !1
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
                    );
                  },
                },
              }),
              Object.defineProperties(W.prototype, {
                derivatives: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                      ),
                      this.extensions.derivatives
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                    ),
                      (this.extensions.derivatives = t);
                  },
                },
              }),
              Object.assign(Te.prototype, {
                animate: function (t) {
                  console.warn(
                    "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
                  ),
                    this.setAnimationLoop(t);
                },
                getCurrentRenderTarget: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
                    ),
                    this.getRenderTarget()
                  );
                },
                getMaxAnisotropy: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
                    ),
                    this.capabilities.getMaxAnisotropy()
                  );
                },
                getPrecision: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
                    ),
                    this.capabilities.precision
                  );
                },
                resetGLState: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
                    ),
                    this.state.reset()
                  );
                },
                supportsFloatTextures: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
                    ),
                    this.extensions.get("OES_texture_float")
                  );
                },
                supportsHalfFloatTextures: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
                    ),
                    this.extensions.get("OES_texture_half_float")
                  );
                },
                supportsStandardDerivatives: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
                    ),
                    this.extensions.get("OES_standard_derivatives")
                  );
                },
                supportsCompressedTextureS3TC: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
                    ),
                    this.extensions.get("WEBGL_compressed_texture_s3tc")
                  );
                },
                supportsCompressedTexturePVRTC: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
                    ),
                    this.extensions.get("WEBGL_compressed_texture_pvrtc")
                  );
                },
                supportsBlendMinMax: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
                    ),
                    this.extensions.get("EXT_blend_minmax")
                  );
                },
                supportsVertexTextures: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
                    ),
                    this.capabilities.vertexTextures
                  );
                },
                supportsInstancedArrays: function () {
                  return (
                    console.warn(
                      "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
                    ),
                    this.extensions.get("ANGLE_instanced_arrays")
                  );
                },
                enableScissorTest: function (t) {
                  console.warn(
                    "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
                  ),
                    this.setScissorTest(t);
                },
                initMaterial: function () {
                  console.warn(
                    "THREE.WebGLRenderer: .initMaterial() has been removed."
                  );
                },
                addPrePlugin: function () {
                  console.warn(
                    "THREE.WebGLRenderer: .addPrePlugin() has been removed."
                  );
                },
                addPostPlugin: function () {
                  console.warn(
                    "THREE.WebGLRenderer: .addPostPlugin() has been removed."
                  );
                },
                updateShadowMap: function () {
                  console.warn(
                    "THREE.WebGLRenderer: .updateShadowMap() has been removed."
                  );
                },
                setFaceCulling: function () {
                  console.warn(
                    "THREE.WebGLRenderer: .setFaceCulling() has been removed."
                  );
                },
              }),
              Object.defineProperties(Te.prototype, {
                shadowMapEnabled: {
                  get: function () {
                    return this.shadowMap.enabled;
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
                    ),
                      (this.shadowMap.enabled = t);
                  },
                },
                shadowMapType: {
                  get: function () {
                    return this.shadowMap.type;
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
                    ),
                      (this.shadowMap.type = t);
                  },
                },
                shadowMapCullFace: {
                  get: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                    );
                  },
                },
              }),
              Object.defineProperties(ge.prototype, {
                cullFace: {
                  get: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                    );
                  },
                },
                renderReverseSided: {
                  get: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                    );
                  },
                },
                renderSingleSided: {
                  get: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                    );
                  },
                  set: function () {
                    console.warn(
                      "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                    );
                  },
                },
              }),
              Object.defineProperties(h.prototype, {
                wrapS: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                      ),
                      this.texture.wrapS
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                    ),
                      (this.texture.wrapS = t);
                  },
                },
                wrapT: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                      ),
                      this.texture.wrapT
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                    ),
                      (this.texture.wrapT = t);
                  },
                },
                magFilter: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                      ),
                      this.texture.magFilter
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                    ),
                      (this.texture.magFilter = t);
                  },
                },
                minFilter: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                      ),
                      this.texture.minFilter
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                    ),
                      (this.texture.minFilter = t);
                  },
                },
                anisotropy: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                      ),
                      this.texture.anisotropy
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                    ),
                      (this.texture.anisotropy = t);
                  },
                },
                offset: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                      ),
                      this.texture.offset
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                    ),
                      (this.texture.offset = t);
                  },
                },
                repeat: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                      ),
                      this.texture.repeat
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                    ),
                      (this.texture.repeat = t);
                  },
                },
                format: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .format is now .texture.format."
                      ),
                      this.texture.format
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .format is now .texture.format."
                    ),
                      (this.texture.format = t);
                  },
                },
                type: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .type is now .texture.type."
                      ),
                      this.texture.type
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .type is now .texture.type."
                    ),
                      (this.texture.type = t);
                  },
                },
                generateMipmaps: {
                  get: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                      ),
                      this.texture.generateMipmaps
                    );
                  },
                  set: function (t) {
                    console.warn(
                      "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                    ),
                      (this.texture.generateMipmaps = t);
                  },
                },
              }),
              Object.defineProperties(Me.prototype, {
                standing: {
                  set: function () {
                    console.warn(
                      "THREE.WebVRManager: .standing has been removed."
                    );
                  },
                },
              }),
              (Bi.prototype.load = function (t) {
                console.warn(
                  "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
                );
                var e = this;
                return (
                  new Ii().load(t, function (t) {
                    e.setBuffer(t);
                  }),
                  this
                );
              }),
              (zi.prototype.getData = function () {
                return (
                  console.warn(
                    "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
                  ),
                  this.getFrequencyData()
                );
              }),
              (Di.prototype.updateCubeMap = function (t, e) {
                return (
                  console.warn(
                    "THREE.CubeCamera: .updateCubeMap() is now .update()."
                  ),
                  this.update(t, e)
                );
              });
            var ph = {
              merge: function (t, e, n) {
                console.warn(
                  "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
                );
                var r;
                e.isMesh &&
                  (e.matrixAutoUpdate && e.updateMatrix(),
                  (r = e.matrix),
                  (e = e.geometry)),
                  t.merge(e, r, n);
              },
              center: function (t) {
                return (
                  console.warn(
                    "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
                  ),
                  t.center()
                );
              },
            };
            (bc.crossOrigin = void 0),
              (bc.loadTexture = function (t, e, n, r) {
                console.warn(
                  "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
                );
                var i = new Tr();
                i.setCrossOrigin(this.crossOrigin);
                var a = i.load(t, n, void 0, r);
                return e && (a.mapping = e), a;
              }),
              (bc.loadTextureCube = function (t, e, n, r) {
                console.warn(
                  "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
                );
                var i = new Er();
                i.setCrossOrigin(this.crossOrigin);
                var a = i.load(t, n, void 0, r);
                return e && (a.mapping = e), a;
              }),
              (bc.loadCompressedTexture = function () {
                console.error(
                  "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
                );
              }),
              (bc.loadCompressedTextureCube = function () {
                console.error(
                  "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
                );
              });
            var dh = {
              createMultiMaterialObject: function () {
                console.error(
                  "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
                );
              },
              detach: function () {
                console.error(
                  "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
                );
              },
              attach: function () {
                console.error(
                  "THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"
                );
              },
            };
            (t.WebGLRenderTargetCube = l),
              (t.WebGLRenderTarget = h),
              (t.WebGLRenderer = Te),
              (t.ShaderLib = Sc),
              (t.UniformsLib = Tc),
              (t.UniformsUtils = Mc),
              (t.ShaderChunk = wc),
              (t.FogExp2 = Se),
              (t.Fog = Ae),
              (t.Scene = Le),
              (t.Sprite = Oe),
              (t.LOD = Ie),
              (t.SkinnedMesh = Ue),
              (t.Skeleton = Ne),
              (t.Bone = De),
              (t.Mesh = Y),
              (t.LineSegments = ze),
              (t.LineLoop = Ge),
              (t.Line = Fe),
              (t.Points = Ve),
              (t.Group = be),
              (t.VideoTexture = ke),
              (t.DataTexture = u),
              (t.CompressedTexture = je),
              (t.CubeTexture = ot),
              (t.CanvasTexture = We),
              (t.DepthTexture = Xe),
              (t.Texture = s),
              (t.CompressedTextureLoader = _r),
              (t.DataTextureLoader = wr),
              (t.CubeTextureLoader = Er),
              (t.TextureLoader = Tr),
              (t.ObjectLoader = Si),
              (t.MaterialLoader = wi),
              (t.BufferGeometryLoader = Mi),
              (t.DefaultLoadingManager = Yc),
              (t.LoadingManager = xr),
              (t.JSONLoader = Ti),
              (t.ImageLoader = Mr),
              (t.ImageBitmapLoader = Ai),
              (t.FontLoader = Oi),
              (t.FileLoader = br),
              (t.Loader = Ei),
              (t.LoaderUtils = rh),
              (t.Cache = qc),
              (t.AudioLoader = Ii),
              (t.SpotLightShadow = ti),
              (t.SpotLight = ei),
              (t.PointLight = ni),
              (t.RectAreaLight = oi),
              (t.HemisphereLight = Kr),
              (t.DirectionalLightShadow = ri),
              (t.DirectionalLight = ii),
              (t.AmbientLight = ai),
              (t.LightShadow = $r),
              (t.Light = Qr),
              (t.StereoCamera = Ni),
              (t.PerspectiveCamera = _e),
              (t.OrthographicCamera = M),
              (t.CubeCamera = Di),
              (t.ArrayCamera = we),
              (t.Camera = w),
              (t.AudioListener = Ui),
              (t.PositionalAudio = Fi),
              (t.AudioContext = ch),
              (t.AudioAnalyser = zi),
              (t.Audio = Bi),
              (t.VectorKeyframeTrack = yi),
              (t.StringKeyframeTrack = vi),
              (t.QuaternionKeyframeTrack = gi),
              (t.NumberKeyframeTrack = fi),
              (t.ColorKeyframeTrack = di),
              (t.BooleanKeyframeTrack = pi),
              (t.PropertyMixer = Gi),
              (t.PropertyBinding = Vi),
              (t.KeyframeTrack = ui),
              (t.AnimationUtils = eh),
              (t.AnimationObjectGroup = ki),
              (t.AnimationMixer = Wi),
              (t.AnimationClip = xi),
              (t.Uniform = Xi),
              (t.InstancedBufferGeometry = qi),
              (t.BufferGeometry = F),
              (t.Geometry = T),
              (t.InterleavedBufferAttribute = Ce),
              (t.InstancedInterleavedBuffer = Yi),
              (t.InterleavedBuffer = Re),
              (t.InstancedBufferAttribute = Ji),
              (t.Face3 = E),
              (t.Object3D = _),
              (t.Raycaster = Zi),
              (t.Layers = b),
              (t.EventDispatcher = e),
              (t.Clock = $i),
              (t.QuaternionLinearInterpolant = mi),
              (t.LinearInterpolant = hi),
              (t.DiscreteInterpolant = li),
              (t.CubicInterpolant = ci),
              (t.Interpolant = si),
              (t.Triangle = q),
              (t.Math = xc),
              (t.Spherical = ta),
              (t.Cylindrical = ea),
              (t.Plane = f),
              (t.Frustum = m),
              (t.Sphere = d),
              (t.Ray = X),
              (t.Matrix4 = r),
              (t.Matrix3 = o),
              (t.Box3 = p),
              (t.Box2 = na),
              (t.Line3 = ra),
              (t.Euler = x),
              (t.Vector4 = c),
              (t.Vector3 = a),
              (t.Vector2 = n),
              (t.Quaternion = i),
              (t.Color = g),
              (t.ImmediateRenderObject = ia),
              (t.VertexNormalsHelper = aa),
              (t.SpotLightHelper = oa),
              (t.SkeletonHelper = ca),
              (t.PointLightHelper = ha),
              (t.RectAreaLightHelper = la),
              (t.HemisphereLightHelper = ua),
              (t.GridHelper = pa),
              (t.PolarGridHelper = da),
              (t.FaceNormalsHelper = fa),
              (t.DirectionalLightHelper = ma),
              (t.CameraHelper = ga),
              (t.BoxHelper = va),
              (t.Box3Helper = ya),
              (t.PlaneHelper = xa),
              (t.ArrowHelper = ba),
              (t.AxesHelper = _a),
              (t.Shape = Zr),
              (t.Path = Jr),
              (t.ShapePath = Li),
              (t.Font = Ri),
              (t.CurvePath = Yr),
              (t.Curve = Sr),
              (t.ImageUtils = bc),
              (t.ShapeUtils = kc),
              (t.WebGLUtils = xe),
              (t.WireframeGeometry = qe),
              (t.ParametricGeometry = Ye),
              (t.ParametricBufferGeometry = Je),
              (t.TetrahedronGeometry = Ke),
              (t.TetrahedronBufferGeometry = $e),
              (t.OctahedronGeometry = tn),
              (t.OctahedronBufferGeometry = en),
              (t.IcosahedronGeometry = nn),
              (t.IcosahedronBufferGeometry = rn),
              (t.DodecahedronGeometry = an),
              (t.DodecahedronBufferGeometry = on),
              (t.PolyhedronGeometry = Ze),
              (t.PolyhedronBufferGeometry = Qe),
              (t.TubeGeometry = sn),
              (t.TubeBufferGeometry = cn),
              (t.TorusKnotGeometry = hn),
              (t.TorusKnotBufferGeometry = ln),
              (t.TorusGeometry = un),
              (t.TorusBufferGeometry = pn),
              (t.TextGeometry = Xn),
              (t.TextBufferGeometry = qn),
              (t.SphereGeometry = Yn),
              (t.SphereBufferGeometry = Jn),
              (t.RingGeometry = Zn),
              (t.RingBufferGeometry = Qn),
              (t.PlaneGeometry = H),
              (t.PlaneBufferGeometry = V),
              (t.LatheGeometry = Kn),
              (t.LatheBufferGeometry = $n),
              (t.ShapeGeometry = tr),
              (t.ShapeBufferGeometry = er),
              (t.ExtrudeGeometry = kn),
              (t.ExtrudeBufferGeometry = jn),
              (t.EdgesGeometry = rr),
              (t.ConeGeometry = or),
              (t.ConeBufferGeometry = sr),
              (t.CylinderGeometry = ir),
              (t.CylinderBufferGeometry = ar),
              (t.CircleGeometry = cr),
              (t.CircleBufferGeometry = hr),
              (t.BoxGeometry = z),
              (t.BoxBufferGeometry = G),
              (t.ShadowMaterial = lr),
              (t.SpriteMaterial = Pe),
              (t.RawShaderMaterial = ur),
              (t.ShaderMaterial = W),
              (t.PointsMaterial = He),
              (t.MeshPhysicalMaterial = dr),
              (t.MeshStandardMaterial = pr),
              (t.MeshPhongMaterial = fr),
              (t.MeshToonMaterial = mr),
              (t.MeshNormalMaterial = gr),
              (t.MeshLambertMaterial = vr),
              (t.MeshDepthMaterial = fe),
              (t.MeshDistanceMaterial = me),
              (t.MeshBasicMaterial = j);
            (t.LineDashedMaterial = yr),
              (t.LineBasicMaterial = Be),
              (t.Material = k),
              (t.Float64BufferAttribute = D),
              (t.Float32BufferAttribute = N),
              (t.Uint32BufferAttribute = I),
              (t.Int32BufferAttribute = O),
              (t.Uint16BufferAttribute = P),
              (t.Int16BufferAttribute = C),
              (t.Uint8ClampedBufferAttribute = R),
              (t.Uint8BufferAttribute = L),
              (t.Int8BufferAttribute = A),
              (t.BufferAttribute = S),
              (t.ArcCurve = Lr),
              (t.CatmullRomCurve3 = Cr),
              (t.CubicBezierCurve = Hr),
              (t.CubicBezierCurve3 = Vr),
              (t.EllipseCurve = Ar),
              (t.LineCurve = kr),
              (t.LineCurve3 = jr),
              (t.QuadraticBezierCurve = Wr),
              (t.QuadraticBezierCurve3 = Xr),
              (t.SplineCurve = qr),
              (t.REVISION = to),
              (t.MOUSE = eo),
              (t.CullFaceNone = no),
              (t.CullFaceBack = ro),
              (t.CullFaceFront = io),
              (t.CullFaceFrontBack = 3),
              (t.FrontFaceDirectionCW = 0),
              (t.FrontFaceDirectionCCW = 1),
              (t.BasicShadowMap = 0),
              (t.PCFShadowMap = ao),
              (t.PCFSoftShadowMap = oo),
              (t.FrontSide = so),
              (t.BackSide = co),
              (t.DoubleSide = ho),
              (t.FlatShading = 1),
              (t.SmoothShading = 2),
              (t.NoColors = lo),
              (t.FaceColors = uo),
              (t.VertexColors = po),
              (t.NoBlending = fo),
              (t.NormalBlending = mo),
              (t.AdditiveBlending = go),
              (t.SubtractiveBlending = vo),
              (t.MultiplyBlending = yo),
              (t.CustomBlending = xo),
              (t.AddEquation = bo),
              (t.SubtractEquation = _o),
              (t.ReverseSubtractEquation = wo),
              (t.MinEquation = Mo),
              (t.MaxEquation = Eo),
              (t.ZeroFactor = To),
              (t.OneFactor = So),
              (t.SrcColorFactor = Ao),
              (t.OneMinusSrcColorFactor = Lo),
              (t.SrcAlphaFactor = Ro),
              (t.OneMinusSrcAlphaFactor = Co),
              (t.DstAlphaFactor = Po),
              (t.OneMinusDstAlphaFactor = Oo),
              (t.DstColorFactor = Io),
              (t.OneMinusDstColorFactor = No),
              (t.SrcAlphaSaturateFactor = Do),
              (t.NeverDepth = Uo),
              (t.AlwaysDepth = Bo),
              (t.LessDepth = Fo),
              (t.LessEqualDepth = zo),
              (t.EqualDepth = Go),
              (t.GreaterEqualDepth = Ho),
              (t.GreaterDepth = Vo),
              (t.NotEqualDepth = ko),
              (t.MultiplyOperation = jo),
              (t.MixOperation = Wo),
              (t.AddOperation = Xo),
              (t.NoToneMapping = qo),
              (t.LinearToneMapping = Yo),
              (t.ReinhardToneMapping = Jo),
              (t.Uncharted2ToneMapping = Zo),
              (t.CineonToneMapping = Qo),
              (t.UVMapping = 300),
              (t.CubeReflectionMapping = Ko),
              (t.CubeRefractionMapping = $o),
              (t.EquirectangularReflectionMapping = ts),
              (t.EquirectangularRefractionMapping = es),
              (t.SphericalReflectionMapping = ns),
              (t.CubeUVReflectionMapping = rs),
              (t.CubeUVRefractionMapping = is),
              (t.RepeatWrapping = as),
              (t.ClampToEdgeWrapping = os),
              (t.MirroredRepeatWrapping = ss),
              (t.NearestFilter = cs),
              (t.NearestMipMapNearestFilter = hs),
              (t.NearestMipMapLinearFilter = ls),
              (t.LinearFilter = us),
              (t.LinearMipMapNearestFilter = ps),
              (t.LinearMipMapLinearFilter = ds),
              (t.UnsignedByteType = fs),
              (t.ByteType = ms),
              (t.ShortType = gs),
              (t.UnsignedShortType = vs),
              (t.IntType = ys),
              (t.UnsignedIntType = xs),
              (t.FloatType = bs),
              (t.HalfFloatType = _s),
              (t.UnsignedShort4444Type = ws),
              (t.UnsignedShort5551Type = Ms),
              (t.UnsignedShort565Type = Es),
              (t.UnsignedInt248Type = Ts),
              (t.AlphaFormat = Ss),
              (t.RGBFormat = As),
              (t.RGBAFormat = Ls),
              (t.LuminanceFormat = Rs),
              (t.LuminanceAlphaFormat = Cs),
              (t.RGBEFormat = Ps),
              (t.DepthFormat = Os),
              (t.DepthStencilFormat = Is),
              (t.RGB_S3TC_DXT1_Format = Ns),
              (t.RGBA_S3TC_DXT1_Format = Ds),
              (t.RGBA_S3TC_DXT3_Format = Us),
              (t.RGBA_S3TC_DXT5_Format = Bs),
              (t.RGB_PVRTC_4BPPV1_Format = Fs),
              (t.RGB_PVRTC_2BPPV1_Format = zs),
              (t.RGBA_PVRTC_4BPPV1_Format = Gs),
              (t.RGBA_PVRTC_2BPPV1_Format = Hs),
              (t.RGB_ETC1_Format = Vs),
              (t.RGBA_ASTC_4x4_Format = ks),
              (t.RGBA_ASTC_5x4_Format = js),
              (t.RGBA_ASTC_5x5_Format = Ws),
              (t.RGBA_ASTC_6x5_Format = Xs),
              (t.RGBA_ASTC_6x6_Format = qs),
              (t.RGBA_ASTC_8x5_Format = Ys),
              (t.RGBA_ASTC_8x6_Format = Js),
              (t.RGBA_ASTC_8x8_Format = Zs),
              (t.RGBA_ASTC_10x5_Format = Qs),
              (t.RGBA_ASTC_10x6_Format = Ks),
              (t.RGBA_ASTC_10x8_Format = $s),
              (t.RGBA_ASTC_10x10_Format = tc),
              (t.RGBA_ASTC_12x10_Format = ec),
              (t.RGBA_ASTC_12x12_Format = nc),
              (t.LoopOnce = 2200),
              (t.LoopRepeat = rc),
              (t.LoopPingPong = 2202),
              (t.InterpolateDiscrete = 2300),
              (t.InterpolateLinear = 2301),
              (t.InterpolateSmooth = 2302),
              (t.ZeroCurvatureEnding = ic),
              (t.ZeroSlopeEnding = 2401),
              (t.WrapAroundEnding = 2402),
              (t.TrianglesDrawMode = ac),
              (t.TriangleStripDrawMode = oc),
              (t.TriangleFanDrawMode = sc),
              (t.LinearEncoding = cc),
              (t.sRGBEncoding = hc),
              (t.GammaEncoding = lc),
              (t.RGBEEncoding = uc),
              (t.LogLuvEncoding = 3003),
              (t.RGBM7Encoding = pc),
              (t.RGBM16Encoding = dc),
              (t.RGBDEncoding = fc),
              (t.BasicDepthPacking = mc),
              (t.RGBADepthPacking = gc),
              (t.TangentSpaceNormalMap = vc),
              (t.ObjectSpaceNormalMap = yc),
              (t.CubeGeometry = z),
              (t.Face4 = wa),
              (t.LineStrip = 0),
              (t.LinePieces = 1),
              (t.MeshFaceMaterial = Ma),
              (t.MultiMaterial = Ea),
              (t.PointCloud = Ta),
              (t.Particle = Sa),
              (t.ParticleSystem = Aa),
              (t.PointCloudMaterial = La),
              (t.ParticleBasicMaterial = Ra),
              (t.ParticleSystemMaterial = Ca),
              (t.Vertex = Pa),
              (t.DynamicBufferAttribute = Oa),
              (t.Int8Attribute = Ia),
              (t.Uint8Attribute = Na),
              (t.Uint8ClampedAttribute = Da),
              (t.Int16Attribute = Ua),
              (t.Uint16Attribute = Ba),
              (t.Int32Attribute = Fa),
              (t.Uint32Attribute = za),
              (t.Float32Attribute = Ga),
              (t.Float64Attribute = Ha),
              (t.ClosedSplineCurve3 = Va),
              (t.SplineCurve3 = ka),
              (t.Spline = ja),
              (t.AxisHelper = Wa),
              (t.BoundingBoxHelper = Xa),
              (t.EdgesHelper = qa),
              (t.WireframeHelper = Ya),
              (t.XHRLoader = Ja),
              (t.BinaryTextureLoader = Za),
              (t.GeometryUtils = ph),
              (t.Projector = Qa),
              (t.CanvasRenderer = Ka),
              (t.SceneUtils = dh);
            (t.LensFlare = $a),
              Object.defineProperty(t, "__esModule", { value: !0 });
          });
        },
        {},
      ],
      39: [
        function (_dereq_, module, exports) {
          (THREE.ColladaLoader = function (e) {
            this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager;
          }),
            (THREE.ColladaLoader.prototype = {
              constructor: THREE.ColladaLoader,
              crossOrigin: "anonymous",
              load: function (e, t, r, a) {
                var n = this,
                  i =
                    void 0 === n.path
                      ? THREE.LoaderUtils.extractUrlBase(e)
                      : n.path;
                new THREE.FileLoader(n.manager).load(
                  e,
                  function (e) {
                    t(n.parse(e, i));
                  },
                  r,
                  a
                );
              },
              setPath: function (e) {
                return (this.path = e), this;
              },
              options: {
                set convertUpAxis(e) {
                  console.warn(
                    "THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically."
                  );
                },
              },
              setCrossOrigin: function (e) {
                return (this.crossOrigin = e), this;
              },
              parse: function (e, t) {
                function r(e, t) {
                  for (
                    var r = [], a = e.childNodes, n = 0, i = a.length;
                    n < i;
                    n++
                  ) {
                    var s = a[n];
                    s.nodeName === t && r.push(s);
                  }
                  return r;
                }
                function a(e) {
                  if (0 === e.length) return [];
                  for (
                    var t = e.trim().split(/\s+/),
                      r = new Array(t.length),
                      a = 0,
                      n = t.length;
                    a < n;
                    a++
                  )
                    r[a] = t[a];
                  return r;
                }
                function n(e) {
                  if (0 === e.length) return [];
                  for (
                    var t = e.trim().split(/\s+/),
                      r = new Array(t.length),
                      a = 0,
                      n = t.length;
                    a < n;
                    a++
                  )
                    r[a] = parseFloat(t[a]);
                  return r;
                }
                function i(e) {
                  if (0 === e.length) return [];
                  for (
                    var t = e.trim().split(/\s+/),
                      r = new Array(t.length),
                      a = 0,
                      n = t.length;
                    a < n;
                    a++
                  )
                    r[a] = parseInt(t[a]);
                  return r;
                }
                function s(e) {
                  return e.substring(1);
                }
                function o() {
                  return "three_default_" + gt++;
                }
                function c(e) {
                  return 0 === Object.keys(e).length;
                }
                function l(e) {
                  return void 0 !== e && !0 === e.hasAttribute("meter")
                    ? parseFloat(e.getAttribute("meter"))
                    : 1;
                }
                function d(e) {
                  return void 0 !== e ? e.textContent : "Y_UP";
                }
                function u(e, t, a, n) {
                  var i = r(e, t)[0];
                  if (void 0 !== i)
                    for (var s = r(i, a), o = 0; o < s.length; o++) n(s[o]);
                }
                function f(e, t) {
                  for (var r in e) {
                    e[r].build = t(e[r]);
                  }
                }
                function h(e, t) {
                  return void 0 !== e.build
                    ? e.build
                    : ((e.build = t(e)), e.build);
                }
                function m(e) {
                  for (
                    var t = { sources: {}, samplers: {}, channels: {} },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType) {
                      var i;
                      switch (n.nodeName) {
                        case "source":
                          (i = n.getAttribute("id")), (t.sources[i] = ge(n));
                          break;
                        case "sampler":
                          (i = n.getAttribute("id")), (t.samplers[i] = p(n));
                          break;
                        case "channel":
                          (i = n.getAttribute("target")),
                            (t.channels[i] = v(n));
                          break;
                        default:
                          console.log(n);
                      }
                    }
                  }
                  bt.animations[e.getAttribute("id")] = t;
                }
                function p(e) {
                  for (
                    var t = { inputs: {} }, r = 0, a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "input":
                          var i = s(n.getAttribute("source")),
                            o = n.getAttribute("semantic");
                          t.inputs[o] = i;
                      }
                  }
                  return t;
                }
                function v(e) {
                  var t = {},
                    r = e.getAttribute("target"),
                    a = r.split("/"),
                    n = a.shift(),
                    i = a.shift(),
                    o = -1 !== i.indexOf("("),
                    c = -1 !== i.indexOf(".");
                  if (c)
                    (a = i.split(".")), (i = a.shift()), (t.member = a.shift());
                  else if (o) {
                    var l = i.split("(");
                    i = l.shift();
                    for (var d = 0; d < l.length; d++)
                      l[d] = parseInt(l[d].replace(/\)/, ""));
                    t.indices = l;
                  }
                  return (
                    (t.id = n),
                    (t.sid = i),
                    (t.arraySyntax = o),
                    (t.memberSyntax = c),
                    (t.sampler = s(e.getAttribute("source"))),
                    t
                  );
                }
                function g(e) {
                  var t = [],
                    r = e.channels,
                    a = e.samplers,
                    n = e.sources;
                  for (var i in r)
                    if (r.hasOwnProperty(i)) {
                      var s = r[i],
                        o = a[s.sampler],
                        c = o.inputs.INPUT,
                        l = o.inputs.OUTPUT,
                        d = n[c],
                        u = n[l],
                        f = y(s, d, u);
                      N(f, t);
                    }
                  return t;
                }
                function b(e) {
                  return h(bt.animations[e], g);
                }
                function y(e, t, r) {
                  var a,
                    n,
                    i,
                    s,
                    o,
                    c,
                    l = bt.nodes[e.id],
                    d = Ye(l.id),
                    u = l.transforms[e.sid],
                    f = l.matrix.clone().transpose(),
                    h = {};
                  switch (u) {
                    case "matrix":
                      for (i = 0, s = t.array.length; i < s; i++)
                        if (
                          ((a = t.array[i]),
                          (n = i * r.stride),
                          void 0 === h[a] && (h[a] = {}),
                          !0 === e.arraySyntax)
                        ) {
                          var m = r.array[n],
                            p = e.indices[0] + 4 * e.indices[1];
                          h[a][p] = m;
                        } else
                          for (o = 0, c = r.stride; o < c; o++)
                            h[a][o] = r.array[n + o];
                      break;
                    case "translate":
                    case "rotate":
                    case "scale":
                      console.warn(
                        'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',
                        u
                      );
                  }
                  var v = E(h, f);
                  return { name: d.uuid, keyframes: v };
                }
                function E(e, t) {
                  function r(e, t) {
                    return e.time - t.time;
                  }
                  var a = [];
                  for (var n in e) a.push({ time: parseFloat(n), value: e[n] });
                  a.sort(r);
                  for (var i = 0; i < 16; i++) T(a, i, t.elements[i]);
                  return a;
                }
                function N(e, t) {
                  for (
                    var r = e.keyframes,
                      a = e.name,
                      n = [],
                      i = [],
                      s = [],
                      o = [],
                      c = 0,
                      l = r.length;
                    c < l;
                    c++
                  ) {
                    var d = r[c],
                      u = d.time,
                      f = d.value;
                    st.fromArray(f).transpose(),
                      st.decompose(at, it, nt),
                      n.push(u),
                      i.push(at.x, at.y, at.z),
                      s.push(it.x, it.y, it.z, it.w),
                      o.push(nt.x, nt.y, nt.z);
                  }
                  return (
                    i.length > 0 &&
                      t.push(
                        new THREE.VectorKeyframeTrack(a + ".position", n, i)
                      ),
                    s.length > 0 &&
                      t.push(
                        new THREE.QuaternionKeyframeTrack(
                          a + ".quaternion",
                          n,
                          s
                        )
                      ),
                    o.length > 0 &&
                      t.push(new THREE.VectorKeyframeTrack(a + ".scale", n, o)),
                    t
                  );
                }
                function T(e, t, r) {
                  var a,
                    n,
                    i,
                    s = !0;
                  for (n = 0, i = e.length; n < i; n++)
                    (a = e[n]),
                      void 0 === a.value[t] ? (a.value[t] = null) : (s = !1);
                  if (!0 === s)
                    for (n = 0, i = e.length; n < i; n++)
                      (a = e[n]), (a.value[t] = r);
                  else w(e, t);
                }
                function w(e, t) {
                  for (var r, a, n = 0, i = e.length; n < i; n++) {
                    var s = e[n];
                    if (null === s.value[t]) {
                      if (((r = x(e, n, t)), (a = k(e, n, t)), null === r)) {
                        s.value[t] = a.value[t];
                        continue;
                      }
                      if (null === a) {
                        s.value[t] = r.value[t];
                        continue;
                      }
                      A(s, r, a, t);
                    }
                  }
                }
                function x(e, t, r) {
                  for (; t >= 0; ) {
                    var a = e[t];
                    if (null !== a.value[r]) return a;
                    t--;
                  }
                  return null;
                }
                function k(e, t, r) {
                  for (; t < e.length; ) {
                    var a = e[t];
                    if (null !== a.value[r]) return a;
                    t++;
                  }
                  return null;
                }
                function A(e, t, r, a) {
                  if (r.time - t.time == 0)
                    return void (e.value[a] = t.value[a]);
                  e.value[a] =
                    ((e.time - t.time) * (r.value[a] - t.value[a])) /
                      (r.time - t.time) +
                    t.value[a];
                }
                function R(e) {
                  for (
                    var t = {
                        name: e.getAttribute("id") || "default",
                        start: parseFloat(e.getAttribute("start") || 0),
                        end: parseFloat(e.getAttribute("end") || 0),
                        animations: [],
                      },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "instance_animation":
                          t.animations.push(s(n.getAttribute("url")));
                      }
                  }
                  bt.clips[e.getAttribute("id")] = t;
                }
                function H(e) {
                  for (
                    var t = [],
                      r = e.name,
                      a = e.end - e.start || -1,
                      n = e.animations,
                      i = 0,
                      s = n.length;
                    i < s;
                    i++
                  )
                    for (var o = b(n[i]), c = 0, l = o.length; c < l; c++)
                      t.push(o[c]);
                  return new THREE.AnimationClip(r, a, t);
                }
                function C(e) {
                  return h(bt.clips[e], H);
                }
                function _(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "skin":
                          (t.id = s(n.getAttribute("source"))), (t.skin = M(n));
                          break;
                        case "morph":
                          (t.id = s(n.getAttribute("source"))),
                            console.warn(
                              "THREE.ColladaLoader: Morph target animation not supported yet."
                            );
                      }
                  }
                  bt.controllers[e.getAttribute("id")] = t;
                }
                function M(e) {
                  for (
                    var t = { sources: {} }, r = 0, a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var i = e.childNodes[r];
                    if (1 === i.nodeType)
                      switch (i.nodeName) {
                        case "bind_shape_matrix":
                          t.bindShapeMatrix = n(i.textContent);
                          break;
                        case "source":
                          var s = i.getAttribute("id");
                          t.sources[s] = ge(i);
                          break;
                        case "joints":
                          t.joints = L(i);
                          break;
                        case "vertex_weights":
                          t.vertexWeights = O(i);
                      }
                  }
                  return t;
                }
                function L(e) {
                  for (
                    var t = { inputs: {} }, r = 0, a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "input":
                          var i = n.getAttribute("semantic"),
                            o = s(n.getAttribute("source"));
                          t.inputs[i] = o;
                      }
                  }
                  return t;
                }
                function O(e) {
                  for (
                    var t = { inputs: {} }, r = 0, a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "input":
                          var o = n.getAttribute("semantic"),
                            c = s(n.getAttribute("source")),
                            l = parseInt(n.getAttribute("offset"));
                          t.inputs[o] = { id: c, offset: l };
                          break;
                        case "vcount":
                          t.vcount = i(n.textContent);
                          break;
                        case "v":
                          t.v = i(n.textContent);
                      }
                  }
                  return t;
                }
                function j(e) {
                  var t = { id: e.id },
                    r = bt.geometries[t.id];
                  return (
                    void 0 !== e.skin &&
                      ((t.skin = I(e.skin)),
                      (r.sources.skinIndices = t.skin.indices),
                      (r.sources.skinWeights = t.skin.weights)),
                    t
                  );
                }
                function I(e) {
                  function t(e, t) {
                    return t.weight - e.weight;
                  }
                  var r,
                    a,
                    n,
                    i = {
                      joints: [],
                      indices: { array: [], stride: 4 },
                      weights: { array: [], stride: 4 },
                    },
                    s = e.sources,
                    o = e.vertexWeights,
                    c = o.vcount,
                    l = o.v,
                    d = o.inputs.JOINT.offset,
                    u = o.inputs.WEIGHT.offset,
                    f = e.sources[e.joints.inputs.JOINT],
                    h = e.sources[e.joints.inputs.INV_BIND_MATRIX],
                    m = s[o.inputs.WEIGHT.id].array,
                    p = 0;
                  for (r = 0, n = c.length; r < n; r++) {
                    var v = c[r],
                      g = [];
                    for (a = 0; a < v; a++) {
                      var b = l[p + d],
                        y = l[p + u],
                        E = m[y];
                      g.push({ index: b, weight: E }), (p += 2);
                    }
                    for (g.sort(t), a = 0; a < 4; a++) {
                      var N = g[a];
                      void 0 !== N
                        ? (i.indices.array.push(N.index),
                          i.weights.array.push(N.weight))
                        : (i.indices.array.push(0), i.weights.array.push(0));
                    }
                  }
                  for (
                    e.bindShapeMatrix
                      ? (i.bindMatrix = new THREE.Matrix4()
                          .fromArray(e.bindShapeMatrix)
                          .transpose())
                      : (i.bindMatrix = new THREE.Matrix4().identity()),
                      r = 0,
                      n = f.array.length;
                    r < n;
                    r++
                  ) {
                    var T = f.array[r],
                      w = new THREE.Matrix4()
                        .fromArray(h.array, r * h.stride)
                        .transpose();
                    i.joints.push({ name: T, boneInverse: w });
                  }
                  return i;
                }
                function q(e) {
                  return h(bt.controllers[e], j);
                }
                function S(e) {
                  var t = { init_from: r(e, "init_from")[0].textContent };
                  bt.images[e.getAttribute("id")] = t;
                }
                function U(e) {
                  return void 0 !== e.build ? e.build : e.init_from;
                }
                function F(e) {
                  var t = bt.images[e];
                  return void 0 !== t
                    ? h(t, U)
                    : (console.warn(
                        "THREE.ColladaLoader: Couldn't find image with ID:",
                        e
                      ),
                      null);
                }
                function B(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "profile_COMMON":
                          t.profile = V(n);
                      }
                  }
                  bt.effects[e.getAttribute("id")] = t;
                }
                function V(e) {
                  for (
                    var t = { surfaces: {}, samplers: {} },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "newparam":
                          P(n, t);
                          break;
                        case "technique":
                          t.technique = W(n);
                          break;
                        case "extra":
                          t.extra = Q(n);
                      }
                  }
                  return t;
                }
                function P(e, t) {
                  for (
                    var r = e.getAttribute("sid"),
                      a = 0,
                      n = e.childNodes.length;
                    a < n;
                    a++
                  ) {
                    var i = e.childNodes[a];
                    if (1 === i.nodeType)
                      switch (i.nodeName) {
                        case "surface":
                          t.surfaces[r] = D(i);
                          break;
                        case "sampler2D":
                          t.samplers[r] = z(i);
                      }
                  }
                }
                function D(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "init_from":
                          t.init_from = n.textContent;
                      }
                  }
                  return t;
                }
                function z(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "source":
                          t.source = n.textContent;
                      }
                  }
                  return t;
                }
                function W(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "constant":
                        case "lambert":
                        case "blinn":
                        case "phong":
                          (t.type = n.nodeName), (t.parameters = G(n));
                      }
                  }
                  return t;
                }
                function G(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "emission":
                        case "diffuse":
                        case "specular":
                        case "shininess":
                        case "transparency":
                          t[n.nodeName] = J(n);
                          break;
                        case "transparent":
                          t[n.nodeName] = {
                            opaque: n.getAttribute("opaque"),
                            data: J(n),
                          };
                      }
                  }
                  return t;
                }
                function J(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var i = e.childNodes[r];
                    if (1 === i.nodeType)
                      switch (i.nodeName) {
                        case "color":
                          t[i.nodeName] = n(i.textContent);
                          break;
                        case "float":
                          t[i.nodeName] = parseFloat(i.textContent);
                          break;
                        case "texture":
                          t[i.nodeName] = {
                            id: i.getAttribute("texture"),
                            extra: K(i),
                          };
                      }
                  }
                  return t;
                }
                function K(e) {
                  for (
                    var t = { technique: {} }, r = 0, a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "extra":
                          X(n, t);
                      }
                  }
                  return t;
                }
                function X(e, t) {
                  for (var r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "technique":
                          Z(n, t);
                      }
                  }
                }
                function Z(e, t) {
                  for (var r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "repeatU":
                        case "repeatV":
                        case "offsetU":
                        case "offsetV":
                          t.technique[n.nodeName] = parseFloat(n.textContent);
                          break;
                        case "wrapU":
                        case "wrapV":
                          "TRUE" === n.textContent.toUpperCase()
                            ? (t.technique[n.nodeName] = 1)
                            : "FALSE" === n.textContent.toUpperCase()
                            ? (t.technique[n.nodeName] = 0)
                            : (t.technique[n.nodeName] = parseInt(
                                n.textContent
                              ));
                      }
                  }
                }
                function Q(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "technique":
                          t.technique = Y(n);
                      }
                  }
                  return t;
                }
                function Y(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "double_sided":
                          t[n.nodeName] = parseInt(n.textContent);
                      }
                  }
                  return t;
                }
                function $(e) {
                  return e;
                }
                function ee(e) {
                  return h(bt.effects[e], $);
                }
                function te(e) {
                  for (
                    var t = { name: e.getAttribute("name") },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "instance_effect":
                          t.url = s(n.getAttribute("url"));
                      }
                  }
                  bt.materials[e.getAttribute("id")] = t;
                }
                function re(e) {
                  var t,
                    r = e.slice(2 + ((e.lastIndexOf(".") - 1) >>> 0));
                  switch ((r = r.toLowerCase())) {
                    case "tga":
                      t = mt;
                      break;
                    default:
                      t = ht;
                  }
                  return t;
                }
                function ae(e) {
                  function t(e) {
                    var t = a.profile.samplers[e.id],
                      r = null;
                    if (void 0 !== t) {
                      r = F(a.profile.surfaces[t.source].init_from);
                    } else
                      console.warn(
                        "THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."
                      ),
                        (r = F(e.id));
                    if (null !== r) {
                      var n = re(r);
                      if (void 0 !== n) {
                        var i = n.load(r),
                          s = e.extra;
                        if (
                          void 0 !== s &&
                          void 0 !== s.technique &&
                          !1 === c(s.technique)
                        ) {
                          var o = s.technique;
                          (i.wrapS = o.wrapU
                            ? THREE.RepeatWrapping
                            : THREE.ClampToEdgeWrapping),
                            (i.wrapT = o.wrapV
                              ? THREE.RepeatWrapping
                              : THREE.ClampToEdgeWrapping),
                            i.offset.set(o.offsetU || 0, o.offsetV || 0),
                            i.repeat.set(o.repeatU || 1, o.repeatV || 1);
                        } else
                          (i.wrapS = THREE.RepeatWrapping),
                            (i.wrapT = THREE.RepeatWrapping);
                        return i;
                      }
                      return (
                        console.warn(
                          "THREE.ColladaLoader: Loader for texture %s not found.",
                          r
                        ),
                        null
                      );
                    }
                    return (
                      console.warn(
                        "THREE.ColladaLoader: Couldn't create texture with ID:",
                        e.id
                      ),
                      null
                    );
                  }
                  var r,
                    a = ee(e.url),
                    n = a.profile.technique,
                    i = a.profile.extra;
                  switch (n.type) {
                    case "phong":
                    case "blinn":
                      r = new THREE.MeshPhongMaterial();
                      break;
                    case "lambert":
                      r = new THREE.MeshLambertMaterial();
                      break;
                    default:
                      r = new THREE.MeshBasicMaterial();
                  }
                  r.name = e.name;
                  var s = n.parameters;
                  for (var o in s) {
                    var l = s[o];
                    switch (o) {
                      case "diffuse":
                        l.color && r.color.fromArray(l.color),
                          l.texture && (r.map = t(l.texture));
                        break;
                      case "specular":
                        l.color && r.specular && r.specular.fromArray(l.color),
                          l.texture && (r.specularMap = t(l.texture));
                        break;
                      case "shininess":
                        l.float && r.shininess && (r.shininess = l.float);
                        break;
                      case "emission":
                        l.color && r.emissive && r.emissive.fromArray(l.color),
                          l.texture && (r.emissiveMap = t(l.texture));
                    }
                  }
                  var d = s.transparent,
                    u = s.transparency;
                  if (
                    (void 0 === u && d && (u = { float: 1 }),
                    void 0 === d &&
                      u &&
                      (d = { opaque: "A_ONE", data: { color: [1, 1, 1, 1] } }),
                    d && u)
                  )
                    if (d.data.texture) r.transparent = !0;
                    else {
                      var f = d.data.color;
                      switch (d.opaque) {
                        case "A_ONE":
                          r.opacity = f[3] * u.float;
                          break;
                        case "RGB_ZERO":
                          r.opacity = 1 - f[0] * u.float;
                          break;
                        case "A_ZERO":
                          r.opacity = 1 - f[3] * u.float;
                          break;
                        case "RGB_ONE":
                          r.opacity = f[0] * u.float;
                          break;
                        default:
                          console.warn(
                            'THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',
                            d.opaque
                          );
                      }
                      r.opacity < 1 && (r.transparent = !0);
                    }
                  return (
                    void 0 !== i &&
                      void 0 !== i.technique &&
                      1 === i.technique.double_sided &&
                      (r.side = THREE.DoubleSide),
                    r
                  );
                }
                function ne(e) {
                  return h(bt.materials[e], ae);
                }
                function ie(e) {
                  for (
                    var t = { name: e.getAttribute("name") },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "optics":
                          t.optics = se(n);
                      }
                  }
                  bt.cameras[e.getAttribute("id")] = t;
                }
                function se(e) {
                  for (var t = 0; t < e.childNodes.length; t++) {
                    var r = e.childNodes[t];
                    switch (r.nodeName) {
                      case "technique_common":
                        return oe(r);
                    }
                  }
                  return {};
                }
                function oe(e) {
                  for (var t = {}, r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    switch (a.nodeName) {
                      case "perspective":
                      case "orthographic":
                        (t.technique = a.nodeName), (t.parameters = ce(a));
                    }
                  }
                  return t;
                }
                function ce(e) {
                  for (var t = {}, r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    switch (a.nodeName) {
                      case "xfov":
                      case "yfov":
                      case "xmag":
                      case "ymag":
                      case "znear":
                      case "zfar":
                      case "aspect_ratio":
                        t[a.nodeName] = parseFloat(a.textContent);
                    }
                  }
                  return t;
                }
                function le(e) {
                  var t;
                  switch (e.optics.technique) {
                    case "perspective":
                      t = new THREE.PerspectiveCamera(
                        e.optics.parameters.yfov,
                        e.optics.parameters.aspect_ratio,
                        e.optics.parameters.znear,
                        e.optics.parameters.zfar
                      );
                      break;
                    case "orthographic":
                      var r = e.optics.parameters.ymag,
                        a = e.optics.parameters.xmag,
                        n = e.optics.parameters.aspect_ratio;
                      (a = void 0 === a ? r * n : a),
                        (r = void 0 === r ? a / n : r),
                        (a *= 0.5),
                        (r *= 0.5),
                        (t = new THREE.OrthographicCamera(
                          -a,
                          a,
                          r,
                          -r,
                          e.optics.parameters.znear,
                          e.optics.parameters.zfar
                        ));
                      break;
                    default:
                      t = new THREE.PerspectiveCamera();
                  }
                  return (t.name = e.name), t;
                }
                function de(e) {
                  var t = bt.cameras[e];
                  return void 0 !== t
                    ? h(t, le)
                    : (console.warn(
                        "THREE.ColladaLoader: Couldn't find camera with ID:",
                        e
                      ),
                      null);
                }
                function ue(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "technique_common":
                          t = fe(n);
                      }
                  }
                  bt.lights[e.getAttribute("id")] = t;
                }
                function fe(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "directional":
                        case "point":
                        case "spot":
                        case "ambient":
                          (t.technique = n.nodeName), (t.parameters = he(n));
                      }
                  }
                  return t;
                }
                function he(e) {
                  for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) {
                    var i = e.childNodes[r];
                    if (1 === i.nodeType)
                      switch (i.nodeName) {
                        case "color":
                          var s = n(i.textContent);
                          t.color = new THREE.Color().fromArray(s);
                          break;
                        case "falloff_angle":
                          t.falloffAngle = parseFloat(i.textContent);
                          break;
                        case "quadratic_attenuation":
                          var o = parseFloat(i.textContent);
                          t.distance = o ? Math.sqrt(1 / o) : 0;
                      }
                  }
                  return t;
                }
                function me(e) {
                  var t;
                  switch (e.technique) {
                    case "directional":
                      t = new THREE.DirectionalLight();
                      break;
                    case "point":
                      t = new THREE.PointLight();
                      break;
                    case "spot":
                      t = new THREE.SpotLight();
                      break;
                    case "ambient":
                      t = new THREE.AmbientLight();
                  }
                  return (
                    e.parameters.color && t.color.copy(e.parameters.color),
                    e.parameters.distance &&
                      (t.distance = e.parameters.distance),
                    t
                  );
                }
                function pe(e) {
                  var t = bt.lights[e];
                  return void 0 !== t
                    ? h(t, me)
                    : (console.warn(
                        "THREE.ColladaLoader: Couldn't find light with ID:",
                        e
                      ),
                      null);
                }
                function ve(e) {
                  var t = {
                      name: e.getAttribute("name"),
                      sources: {},
                      vertices: {},
                      primitives: [],
                    },
                    a = r(e, "mesh")[0];
                  if (void 0 !== a) {
                    for (var n = 0; n < a.childNodes.length; n++) {
                      var i = a.childNodes[n];
                      if (1 === i.nodeType) {
                        var s = i.getAttribute("id");
                        switch (i.nodeName) {
                          case "source":
                            t.sources[s] = ge(i);
                            break;
                          case "vertices":
                            t.vertices = be(i);
                            break;
                          case "polygons":
                            console.warn(
                              "THREE.ColladaLoader: Unsupported primitive type: ",
                              i.nodeName
                            );
                            break;
                          case "lines":
                          case "linestrips":
                          case "polylist":
                          case "triangles":
                            t.primitives.push(ye(i));
                            break;
                          default:
                            console.log(i);
                        }
                      }
                    }
                    bt.geometries[e.getAttribute("id")] = t;
                  }
                }
                function ge(e) {
                  for (
                    var t = { array: [], stride: 3 }, i = 0;
                    i < e.childNodes.length;
                    i++
                  ) {
                    var s = e.childNodes[i];
                    if (1 === s.nodeType)
                      switch (s.nodeName) {
                        case "float_array":
                          t.array = n(s.textContent);
                          break;
                        case "Name_array":
                          t.array = a(s.textContent);
                          break;
                        case "technique_common":
                          var o = r(s, "accessor")[0];
                          void 0 !== o &&
                            (t.stride = parseInt(o.getAttribute("stride")));
                      }
                  }
                  return t;
                }
                function be(e) {
                  for (var t = {}, r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    1 === a.nodeType &&
                      (t[a.getAttribute("semantic")] = s(
                        a.getAttribute("source")
                      ));
                  }
                  return t;
                }
                function ye(e) {
                  for (
                    var t = {
                        type: e.nodeName,
                        material: e.getAttribute("material"),
                        count: parseInt(e.getAttribute("count")),
                        inputs: {},
                        stride: 0,
                        hasUV: !1,
                      },
                      r = 0,
                      a = e.childNodes.length;
                    r < a;
                    r++
                  ) {
                    var n = e.childNodes[r];
                    if (1 === n.nodeType)
                      switch (n.nodeName) {
                        case "input":
                          var o = s(n.getAttribute("source")),
                            c = n.getAttribute("semantic"),
                            l = parseInt(n.getAttribute("offset"));
                          (t.inputs[c] = { id: o, offset: l }),
                            (t.stride = Math.max(t.stride, l + 1)),
                            "TEXCOORD" === c && (t.hasUV = !0);
                          break;
                        case "vcount":
                          t.vcount = i(n.textContent);
                          break;
                        case "p":
                          t.p = i(n.textContent);
                      }
                  }
                  return t;
                }
                function Ee(e) {
                  for (var t = {}, r = 0; r < e.length; r++) {
                    var a = e[r];
                    void 0 === t[a.type] && (t[a.type] = []), t[a.type].push(a);
                  }
                  return t;
                }
                function Ne(e) {
                  for (var t = 0, r = 0, a = e.length; r < a; r++) {
                    !0 === e[r].hasUV && t++;
                  }
                  t > 0 && t < e.length && (e.uvsNeedsFix = !0);
                }
                function Te(e) {
                  var t = {},
                    r = e.sources,
                    a = e.vertices,
                    n = e.primitives;
                  if (0 === n.length) return {};
                  var i = Ee(n);
                  for (var s in i) {
                    var o = i[s];
                    Ne(o), (t[s] = we(o, r, a));
                  }
                  return t;
                }
                function we(e, t, r) {
                  for (
                    var a = {},
                      n = { array: [], stride: 0 },
                      i = { array: [], stride: 0 },
                      s = { array: [], stride: 0 },
                      o = { array: [], stride: 0 },
                      c = { array: [], stride: 4 },
                      l = { array: [], stride: 4 },
                      d = new THREE.BufferGeometry(),
                      u = [],
                      f = 0,
                      h = 0;
                    h < e.length;
                    h++
                  ) {
                    var m = e[h],
                      p = m.inputs,
                      v = 0;
                    switch (m.type) {
                      case "lines":
                      case "linestrips":
                        v = 2 * m.count;
                        break;
                      case "triangles":
                        v = 3 * m.count;
                        break;
                      case "polylist":
                        for (var g = 0; g < m.count; g++) {
                          var b = m.vcount[g];
                          switch (b) {
                            case 3:
                              v += 3;
                              break;
                            case 4:
                              v += 6;
                              break;
                            default:
                              v += 3 * (b - 2);
                          }
                        }
                        break;
                      default:
                        console.warn(
                          "THREE.ColladaLoader: Unknow primitive type:",
                          m.type
                        );
                    }
                    d.addGroup(f, v, h),
                      (f += v),
                      m.material && u.push(m.material);
                    for (var y in p) {
                      var E = p[y];
                      switch (y) {
                        case "VERTEX":
                          for (var N in r) {
                            var T = r[N];
                            switch (N) {
                              case "POSITION":
                                var w = n.array.length;
                                if (
                                  (xe(m, t[T], E.offset, n.array),
                                  (n.stride = t[T].stride),
                                  t.skinWeights &&
                                    t.skinIndices &&
                                    (xe(m, t.skinIndices, E.offset, c.array),
                                    xe(m, t.skinWeights, E.offset, l.array)),
                                  !1 === m.hasUV && !0 === e.uvsNeedsFix)
                                )
                                  for (
                                    var v = (n.array.length - w) / n.stride,
                                      x = 0;
                                    x < v;
                                    x++
                                  )
                                    s.array.push(0, 0);
                                break;
                              case "NORMAL":
                                xe(m, t[T], E.offset, i.array),
                                  (i.stride = t[T].stride);
                                break;
                              case "COLOR":
                                xe(m, t[T], E.offset, o.array),
                                  (o.stride = t[T].stride);
                                break;
                              case "TEXCOORD":
                                xe(m, t[T], E.offset, s.array),
                                  (s.stride = t[T].stride);
                                break;
                              default:
                                console.warn(
                                  'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',
                                  N
                                );
                            }
                          }
                          break;
                        case "NORMAL":
                          xe(m, t[E.id], E.offset, i.array),
                            (i.stride = t[E.id].stride);
                          break;
                        case "COLOR":
                          xe(m, t[E.id], E.offset, o.array),
                            (o.stride = t[E.id].stride);
                          break;
                        case "TEXCOORD":
                          xe(m, t[E.id], E.offset, s.array),
                            (s.stride = t[E.id].stride);
                      }
                    }
                  }
                  return (
                    n.array.length > 0 &&
                      d.addAttribute(
                        "position",
                        new THREE.Float32BufferAttribute(n.array, n.stride)
                      ),
                    i.array.length > 0 &&
                      d.addAttribute(
                        "normal",
                        new THREE.Float32BufferAttribute(i.array, i.stride)
                      ),
                    o.array.length > 0 &&
                      d.addAttribute(
                        "color",
                        new THREE.Float32BufferAttribute(o.array, o.stride)
                      ),
                    s.array.length > 0 &&
                      d.addAttribute(
                        "uv",
                        new THREE.Float32BufferAttribute(s.array, s.stride)
                      ),
                    c.array.length > 0 &&
                      d.addAttribute(
                        "skinIndex",
                        new THREE.Float32BufferAttribute(c.array, c.stride)
                      ),
                    l.array.length > 0 &&
                      d.addAttribute(
                        "skinWeight",
                        new THREE.Float32BufferAttribute(l.array, l.stride)
                      ),
                    (a.data = d),
                    (a.type = e[0].type),
                    (a.materialKeys = u),
                    a
                  );
                }
                function xe(e, t, r, a) {
                  function n(e) {
                    for (var t = i[e + r] * l, n = t + l; t < n; t++)
                      a.push(c[t]);
                  }
                  var i = e.p,
                    s = e.stride,
                    o = e.vcount,
                    c = t.array,
                    l = t.stride;
                  if (void 0 !== e.vcount)
                    for (var d = 0, u = 0, f = o.length; u < f; u++) {
                      var h = o[u];
                      if (4 === h) {
                        var m = d + 0 * s,
                          p = d + 1 * s,
                          v = d + 2 * s,
                          g = d + 3 * s;
                        n(m), n(p), n(g), n(p), n(v), n(g);
                      } else if (3 === h) {
                        var m = d + 0 * s,
                          p = d + 1 * s,
                          v = d + 2 * s;
                        n(m), n(p), n(v);
                      } else if (h > 4)
                        for (var b = 1, y = h - 2; b <= y; b++) {
                          var m = d + 0 * s,
                            p = d + s * b,
                            v = d + s * (b + 1);
                          n(m), n(p), n(v);
                        }
                      d += s * h;
                    }
                  else for (var u = 0, f = i.length; u < f; u += s) n(u);
                }
                function ke(e) {
                  return h(bt.geometries[e], Te);
                }
                function Ae(e) {
                  for (
                    var t = {
                        name: e.getAttribute("name") || "",
                        joints: {},
                        links: [],
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "technique_common":
                          Ce(a, t);
                      }
                  }
                  bt.kinematicsModels[e.getAttribute("id")] = t;
                }
                function Re(e) {
                  return void 0 !== e.build ? e.build : e;
                }
                function He(e) {
                  return h(bt.kinematicsModels[e], Re);
                }
                function Ce(e, t) {
                  for (var r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "joint":
                          t.joints[a.getAttribute("sid")] = _e(a);
                          break;
                        case "link":
                          t.links.push(Le(a));
                      }
                  }
                }
                function _e(e) {
                  for (var t, r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "prismatic":
                        case "revolute":
                          t = Me(a);
                      }
                  }
                  return t;
                }
                function Me(e, t) {
                  for (
                    var t = {
                        sid: e.getAttribute("sid"),
                        name: e.getAttribute("name") || "",
                        axis: new THREE.Vector3(),
                        limits: { min: 0, max: 0 },
                        type: e.nodeName,
                        static: !1,
                        zeroPosition: 0,
                        middlePosition: 0,
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "axis":
                          var i = n(a.textContent);
                          t.axis.fromArray(i);
                          break;
                        case "limits":
                          var s = a.getElementsByTagName("max")[0],
                            o = a.getElementsByTagName("min")[0];
                          (t.limits.max = parseFloat(s.textContent)),
                            (t.limits.min = parseFloat(o.textContent));
                      }
                  }
                  return (
                    t.limits.min >= t.limits.max && (t.static = !0),
                    (t.middlePosition = (t.limits.min + t.limits.max) / 2),
                    t
                  );
                }
                function Le(e) {
                  for (
                    var t = {
                        sid: e.getAttribute("sid"),
                        name: e.getAttribute("name") || "",
                        attachments: [],
                        transforms: [],
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "attachment_full":
                          t.attachments.push(Oe(a));
                          break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                          t.transforms.push(je(a));
                      }
                  }
                  return t;
                }
                function Oe(e) {
                  for (
                    var t = {
                        joint: e.getAttribute("joint").split("/").pop(),
                        transforms: [],
                        links: [],
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "link":
                          t.links.push(Le(a));
                          break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                          t.transforms.push(je(a));
                      }
                  }
                  return t;
                }
                function je(e) {
                  var t = { type: e.nodeName },
                    r = n(e.textContent);
                  switch (t.type) {
                    case "matrix":
                      (t.obj = new THREE.Matrix4()),
                        t.obj.fromArray(r).transpose();
                      break;
                    case "translate":
                      (t.obj = new THREE.Vector3()), t.obj.fromArray(r);
                      break;
                    case "rotate":
                      (t.obj = new THREE.Vector3()),
                        t.obj.fromArray(r),
                        (t.angle = THREE.Math.degToRad(r[3]));
                  }
                  return t;
                }
                function Ie(e) {
                  for (
                    var t = {
                        name: e.getAttribute("name") || "",
                        rigidBodies: {},
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "rigid_body":
                          (t.rigidBodies[a.getAttribute("name")] = {}),
                            qe(a, t.rigidBodies[a.getAttribute("name")]);
                      }
                  }
                  bt.physicsModels[e.getAttribute("id")] = t;
                }
                function qe(e, t) {
                  for (var r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "technique_common":
                          Se(a, t);
                      }
                  }
                }
                function Se(e, t) {
                  for (var r = 0; r < e.childNodes.length; r++) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "inertia":
                          t.inertia = n(a.textContent);
                          break;
                        case "mass":
                          t.mass = n(a.textContent)[0];
                      }
                  }
                }
                function Ue(e) {
                  for (
                    var t = { bindJointAxis: [] }, r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "bind_joint_axis":
                          t.bindJointAxis.push(Fe(a));
                      }
                  }
                  bt.kinematicsScenes[s(e.getAttribute("url"))] = t;
                }
                function Fe(e) {
                  for (
                    var t = {
                        target: e.getAttribute("target").split("/").pop(),
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "axis":
                          var n = a.getElementsByTagName("param")[0];
                          t.axis = n.textContent;
                          var i = t.axis.split("inst_").pop().split("axis")[0];
                          t.jointIndex = i.substr(0, i.length - 1);
                      }
                  }
                  return t;
                }
                function Be(e) {
                  return void 0 !== e.build ? e.build : e;
                }
                function Ve(e) {
                  return h(bt.kinematicsScenes[e], Be);
                }
                function Pe(e) {
                  for (
                    var t = [],
                      r = dt.querySelector('[id="' + e.id + '"]'),
                      a = 0;
                    a < r.childNodes.length;
                    a++
                  ) {
                    var i = r.childNodes[a];
                    if (1 === i.nodeType)
                      switch (i.nodeName) {
                        case "matrix":
                          var s = n(i.textContent),
                            o = new THREE.Matrix4().fromArray(s).transpose();
                          t.push({
                            sid: i.getAttribute("sid"),
                            type: i.nodeName,
                            obj: o,
                          });
                          break;
                        case "translate":
                        case "scale":
                          var s = n(i.textContent),
                            c = new THREE.Vector3().fromArray(s);
                          t.push({
                            sid: i.getAttribute("sid"),
                            type: i.nodeName,
                            obj: c,
                          });
                          break;
                        case "rotate":
                          var s = n(i.textContent),
                            c = new THREE.Vector3().fromArray(s),
                            l = THREE.Math.degToRad(s[3]);
                          t.push({
                            sid: i.getAttribute("sid"),
                            type: i.nodeName,
                            obj: c,
                            angle: l,
                          });
                      }
                  }
                  return t;
                }
                function De(e) {
                  for (
                    var t = e.getElementsByTagName("node"), r = 0;
                    r < t.length;
                    r++
                  ) {
                    var a = t[r];
                    !1 === a.hasAttribute("id") && a.setAttribute("id", o());
                  }
                }
                function ze(e) {
                  for (
                    var t = {
                        name: e.getAttribute("name") || "",
                        type: e.getAttribute("type"),
                        id: e.getAttribute("id"),
                        sid: e.getAttribute("sid"),
                        matrix: new THREE.Matrix4(),
                        nodes: [],
                        instanceCameras: [],
                        instanceControllers: [],
                        instanceLights: [],
                        instanceGeometries: [],
                        instanceNodes: [],
                        transforms: {},
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    if (1 === a.nodeType)
                      switch (a.nodeName) {
                        case "node":
                          t.nodes.push(a.getAttribute("id")), ze(a);
                          break;
                        case "instance_camera":
                          t.instanceCameras.push(s(a.getAttribute("url")));
                          break;
                        case "instance_controller":
                          t.instanceControllers.push(We(a));
                          break;
                        case "instance_light":
                          t.instanceLights.push(s(a.getAttribute("url")));
                          break;
                        case "instance_geometry":
                          t.instanceGeometries.push(We(a));
                          break;
                        case "instance_node":
                          t.instanceNodes.push(s(a.getAttribute("url")));
                          break;
                        case "matrix":
                          var i = n(a.textContent);
                          t.matrix.multiply(st.fromArray(i).transpose()),
                            (t.transforms[a.getAttribute("sid")] = a.nodeName);
                          break;
                        case "translate":
                          var i = n(a.textContent);
                          ot.fromArray(i),
                            t.matrix.multiply(
                              st.makeTranslation(ot.x, ot.y, ot.z)
                            ),
                            (t.transforms[a.getAttribute("sid")] = a.nodeName);
                          break;
                        case "rotate":
                          var i = n(a.textContent),
                            o = THREE.Math.degToRad(i[3]);
                          t.matrix.multiply(
                            st.makeRotationAxis(ot.fromArray(i), o)
                          ),
                            (t.transforms[a.getAttribute("sid")] = a.nodeName);
                          break;
                        case "scale":
                          var i = n(a.textContent);
                          t.matrix.scale(ot.fromArray(i)),
                            (t.transforms[a.getAttribute("sid")] = a.nodeName);
                          break;
                        case "extra":
                          break;
                        default:
                          console.log(a);
                      }
                  }
                  return (
                    Qe(t.id)
                      ? console.warn(
                          "THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",
                          t.id
                        )
                      : (bt.nodes[t.id] = t),
                    t
                  );
                }
                function We(e) {
                  for (
                    var t = {
                        id: s(e.getAttribute("url")),
                        materials: {},
                        skeletons: [],
                      },
                      r = 0;
                    r < e.childNodes.length;
                    r++
                  ) {
                    var a = e.childNodes[r];
                    switch (a.nodeName) {
                      case "bind_material":
                        for (
                          var n = a.getElementsByTagName("instance_material"),
                            i = 0;
                          i < n.length;
                          i++
                        ) {
                          var o = n[i],
                            c = o.getAttribute("symbol"),
                            l = o.getAttribute("target");
                          t.materials[c] = s(l);
                        }
                        break;
                      case "skeleton":
                        t.skeletons.push(s(a.textContent));
                    }
                  }
                  return t;
                }
                function Ge(e, t) {
                  var r,
                    a,
                    n,
                    i = [],
                    s = [];
                  for (r = 0; r < e.length; r++) {
                    var o,
                      c = e[r];
                    if (Qe(c)) (o = Ye(c)), Je(o, t, i);
                    else if (tt(c))
                      for (
                        var l = bt.visualScenes[c], d = l.children, a = 0;
                        a < d.length;
                        a++
                      ) {
                        var u = d[a];
                        if ("JOINT" === u.type) {
                          var o = Ye(u.id);
                          Je(o, t, i);
                        }
                      }
                    else
                      console.error(
                        "THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",
                        c
                      );
                  }
                  for (r = 0; r < t.length; r++)
                    for (a = 0; a < i.length; a++)
                      if (((n = i[a]), n.bone.name === t[r].name)) {
                        (s[r] = n), (n.processed = !0);
                        break;
                      }
                  for (r = 0; r < i.length; r++)
                    (n = i[r]),
                      !1 === n.processed && (s.push(n), (n.processed = !0));
                  var f = [],
                    h = [];
                  for (r = 0; r < s.length; r++)
                    (n = s[r]), f.push(n.bone), h.push(n.boneInverse);
                  return new THREE.Skeleton(f, h);
                }
                function Je(e, t, r) {
                  e.traverse(function (e) {
                    if (!0 === e.isBone) {
                      for (var a, n = 0; n < t.length; n++) {
                        var i = t[n];
                        if (i.name === e.name) {
                          a = i.boneInverse;
                          break;
                        }
                      }
                      void 0 === a && (a = new THREE.Matrix4()),
                        r.push({ bone: e, boneInverse: a, processed: !1 });
                    }
                  });
                }
                function Ke(e) {
                  for (
                    var t = [],
                      r = e.matrix,
                      a = e.nodes,
                      n = e.type,
                      i = e.instanceCameras,
                      s = e.instanceControllers,
                      o = e.instanceLights,
                      c = e.instanceGeometries,
                      l = e.instanceNodes,
                      d = 0,
                      u = a.length;
                    d < u;
                    d++
                  )
                    t.push(Ye(a[d]));
                  for (var d = 0, u = i.length; d < u; d++) {
                    var f = de(i[d]);
                    null !== f && t.push(f.clone());
                  }
                  for (var d = 0, u = s.length; d < u; d++)
                    for (
                      var h = s[d],
                        m = q(h.id),
                        p = ke(m.id),
                        v = Ze(p, h.materials),
                        g = h.skeletons,
                        b = m.skin.joints,
                        y = Ge(g, b),
                        E = 0,
                        N = v.length;
                      E < N;
                      E++
                    ) {
                      var T = v[E];
                      T.isSkinnedMesh &&
                        (T.bind(y, m.skin.bindMatrix),
                        T.normalizeSkinWeights()),
                        t.push(T);
                    }
                  for (var d = 0, u = o.length; d < u; d++) {
                    var w = pe(o[d]);
                    null !== w && t.push(w.clone());
                  }
                  for (var d = 0, u = c.length; d < u; d++)
                    for (
                      var h = c[d],
                        p = ke(h.id),
                        v = Ze(p, h.materials),
                        E = 0,
                        N = v.length;
                      E < N;
                      E++
                    )
                      t.push(v[E]);
                  for (var d = 0, u = l.length; d < u; d++)
                    t.push(Ye(l[d]).clone());
                  var T;
                  if (0 === a.length && 1 === t.length) T = t[0];
                  else {
                    T = "JOINT" === n ? new THREE.Bone() : new THREE.Group();
                    for (var d = 0; d < t.length; d++) T.add(t[d]);
                  }
                  return (
                    "" === T.name && (T.name = "JOINT" === n ? e.sid : e.name),
                    T.matrix.copy(r),
                    T.matrix.decompose(T.position, T.quaternion, T.scale),
                    T
                  );
                }
                function Xe(e, t) {
                  for (var r = [], a = 0, n = e.length; a < n; a++) {
                    var i = t[e[a]];
                    void 0 === i
                      ? (console.warn(
                          "THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",
                          e[a]
                        ),
                        r.push(ct))
                      : r.push(ne(i));
                  }
                  return r;
                }
                function Ze(e, t) {
                  var r = [];
                  for (var a in e) {
                    var n = e[a],
                      i = Xe(n.materialKeys, t);
                    0 === i.length &&
                      ("lines" === a || "linestrips" === a
                        ? i.push(new THREE.LineBasicMaterial())
                        : i.push(new THREE.MeshPhongMaterial()));
                    var s = void 0 !== n.data.attributes.skinIndex;
                    if (s)
                      for (var o = 0, c = i.length; o < c; o++)
                        i[o].skinning = !0;
                    var l,
                      d = 1 === i.length ? i[0] : i;
                    switch (a) {
                      case "lines":
                        l = new THREE.LineSegments(n.data, d);
                        break;
                      case "linestrips":
                        l = new THREE.Line(n.data, d);
                        break;
                      case "triangles":
                      case "polylist":
                        l = s
                          ? new THREE.SkinnedMesh(n.data, d)
                          : new THREE.Mesh(n.data, d);
                    }
                    r.push(l);
                  }
                  return r;
                }
                function Qe(e) {
                  return void 0 !== bt.nodes[e];
                }
                function Ye(e) {
                  return h(bt.nodes[e], Ke);
                }
                function $e(e) {
                  var t = { name: e.getAttribute("name"), children: [] };
                  De(e);
                  for (var a = r(e, "node"), n = 0; n < a.length; n++)
                    t.children.push(ze(a[n]));
                  bt.visualScenes[e.getAttribute("id")] = t;
                }
                function et(e) {
                  var t = new THREE.Group();
                  t.name = e.name;
                  for (var r = e.children, a = 0; a < r.length; a++) {
                    var n = r[a];
                    t.add(Ye(n.id));
                  }
                  return t;
                }
                function tt(e) {
                  return void 0 !== bt.visualScenes[e];
                }
                function rt(e) {
                  return h(bt.visualScenes[e], et);
                }
                var at = new THREE.Vector3(),
                  nt = new THREE.Vector3(),
                  it = new THREE.Quaternion(),
                  st = new THREE.Matrix4(),
                  ot = new THREE.Vector3(),
                  ct = new THREE.MeshBasicMaterial({ color: 16711935 });
                if (0 === e.length) return { scene: new THREE.Scene() };
                var lt = new DOMParser().parseFromString(e, "application/xml"),
                  dt = r(lt, "COLLADA")[0],
                  ut = dt.getAttribute("version");
                console.log("THREE.ColladaLoader: File version", ut);
                var ft = (function (e) {
                    return {
                      unit: l(r(e, "unit")[0]),
                      upAxis: d(r(e, "up_axis")[0]),
                    };
                  })(r(dt, "asset")[0]),
                  ht = new THREE.TextureLoader(this.manager);
                ht.setPath(t).setCrossOrigin(this.crossOrigin);
                var mt;
                THREE.TGALoader &&
                  ((mt = new THREE.TGALoader(this.manager)), mt.setPath(t));
                var pt = [],
                  vt = {},
                  gt = 0,
                  bt = {
                    animations: {},
                    clips: {},
                    controllers: {},
                    images: {},
                    effects: {},
                    materials: {},
                    cameras: {},
                    lights: {},
                    geometries: {},
                    nodes: {},
                    visualScenes: {},
                    kinematicsModels: {},
                    physicsModels: {},
                    kinematicsScenes: {},
                  };
                u(dt, "library_animations", "animation", m),
                  u(dt, "library_animation_clips", "animation_clip", R),
                  u(dt, "library_controllers", "controller", _),
                  u(dt, "library_images", "image", S),
                  u(dt, "library_effects", "effect", B),
                  u(dt, "library_materials", "material", te),
                  u(dt, "library_cameras", "camera", ie),
                  u(dt, "library_lights", "light", ue),
                  u(dt, "library_geometries", "geometry", ve),
                  u(dt, "library_nodes", "node", ze),
                  u(dt, "library_visual_scenes", "visual_scene", $e),
                  u(dt, "library_kinematics_models", "kinematics_model", Ae),
                  u(dt, "library_physics_models", "physics_model", Ie),
                  u(dt, "scene", "instance_kinematics_scene", Ue),
                  f(bt.animations, g),
                  f(bt.clips, H),
                  f(bt.controllers, j),
                  f(bt.images, U),
                  f(bt.effects, $),
                  f(bt.materials, ae),
                  f(bt.cameras, le),
                  f(bt.lights, me),
                  f(bt.geometries, Te),
                  f(bt.visualScenes, et),
                  (function () {
                    var e = bt.clips;
                    if (!0 === c(e)) {
                      if (!1 === c(bt.animations)) {
                        var t = [];
                        for (var r in bt.animations)
                          for (var a = b(r), n = 0, i = a.length; n < i; n++)
                            t.push(a[n]);
                        pt.push(new THREE.AnimationClip("default", -1, t));
                      }
                    } else for (var r in e) pt.push(C(r));
                  })(),
                  (function () {
                    var e = Object.keys(bt.kinematicsModels)[0],
                      t = Object.keys(bt.kinematicsScenes)[0],
                      r = Object.keys(bt.visualScenes)[0];
                    if (void 0 !== e && void 0 !== t) {
                      for (
                        var a = He(e),
                          n = Ve(t),
                          i = rt(r),
                          s = n.bindJointAxis,
                          o = {},
                          c = 0,
                          l = s.length;
                        c < l;
                        c++
                      ) {
                        var d = s[c],
                          u = dt.querySelector('[sid="' + d.target + '"]');
                        if (u) {
                          var f = u.parentElement;
                          !(function (e, t) {
                            var r = t.getAttribute("name"),
                              n = a.joints[e];
                            i.traverse(function (a) {
                              a.name === r &&
                                (o[e] = {
                                  object: a,
                                  transforms: Pe(t),
                                  joint: n,
                                  position: n.zeroPosition,
                                });
                            });
                          })(d.jointIndex, f);
                        }
                      }
                      var h = new THREE.Matrix4();
                      vt = {
                        joints: a && a.joints,
                        getJointValue: function (e) {
                          var t = o[e];
                          if (t) return t.position;
                          console.warn(
                            "THREE.ColladaLoader: Joint " +
                              e +
                              " doesn't exist."
                          );
                        },
                        setJointValue: function (e, t) {
                          var r = o[e];
                          if (r) {
                            var a = r.joint;
                            if (t > a.limits.max || t < a.limits.min)
                              console.warn(
                                "THREE.ColladaLoader: Joint " +
                                  e +
                                  " value " +
                                  t +
                                  " outside of limits (min: " +
                                  a.limits.min +
                                  ", max: " +
                                  a.limits.max +
                                  ")."
                              );
                            else if (a.static)
                              console.warn(
                                "THREE.ColladaLoader: Joint " +
                                  e +
                                  " is static."
                              );
                            else {
                              var n = r.object,
                                i = a.axis,
                                s = r.transforms;
                              st.identity();
                              for (var c = 0; c < s.length; c++) {
                                var l = s[c];
                                if (l.sid && -1 !== l.sid.indexOf(e))
                                  switch (a.type) {
                                    case "revolute":
                                      st.multiply(
                                        h.makeRotationAxis(
                                          i,
                                          THREE.Math.degToRad(t)
                                        )
                                      );
                                      break;
                                    case "prismatic":
                                      st.multiply(
                                        h.makeTranslation(
                                          i.x * t,
                                          i.y * t,
                                          i.z * t
                                        )
                                      );
                                      break;
                                    default:
                                      console.warn(
                                        "THREE.ColladaLoader: Unknown joint type: " +
                                          a.type
                                      );
                                  }
                                else
                                  switch (l.type) {
                                    case "matrix":
                                      st.multiply(l.obj);
                                      break;
                                    case "translate":
                                      st.multiply(
                                        h.makeTranslation(
                                          l.obj.x,
                                          l.obj.y,
                                          l.obj.z
                                        )
                                      );
                                      break;
                                    case "scale":
                                      st.scale(l.obj);
                                      break;
                                    case "rotate":
                                      st.multiply(
                                        h.makeRotationAxis(l.obj, l.angle)
                                      );
                                  }
                              }
                              n.matrix.copy(st),
                                n.matrix.decompose(
                                  n.position,
                                  n.quaternion,
                                  n.scale
                                ),
                                (o[e].position = t);
                            }
                          } else
                            console.log(
                              "THREE.ColladaLoader: " + e + " does not exist."
                            );
                        },
                      };
                    }
                  })();
                var yt = (function (e) {
                  return rt(
                    s(r(e, "instance_visual_scene")[0].getAttribute("url"))
                  );
                })(r(dt, "scene")[0]);
                return (
                  "Z_UP" === ft.upAxis &&
                    yt.quaternion.setFromEuler(
                      new THREE.Euler(-Math.PI / 2, 0, 0)
                    ),
                  yt.scale.multiplyScalar(ft.unit),
                  { animations: pt, kinematics: vt, library: bt, scene: yt }
                );
              },
            });
        },
        {},
      ],
      40: [
        function (_dereq_, module, exports) {
          "use strict";
          (THREE.DRACOLoader = function (e) {
            (this.timeLoaded = 0),
              (this.manager = e || THREE.DefaultLoadingManager),
              (this.materials = null),
              (this.verbosity = 0),
              (this.attributeOptions = {}),
              (this.drawMode = THREE.TrianglesDrawMode),
              (this.nativeAttributeMap = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD",
              });
          }),
            (THREE.DRACOLoader.prototype = {
              constructor: THREE.DRACOLoader,
              load: function (e, t, r, o) {
                var i = this,
                  n = new THREE.FileLoader(i.manager);
                n.setPath(this.path),
                  n.setResponseType("arraybuffer"),
                  n.load(
                    e,
                    function (e) {
                      i.decodeDracoFile(e, t);
                    },
                    r,
                    o
                  );
              },
              setPath: function (e) {
                return (this.path = e), this;
              },
              setVerbosity: function (e) {
                return (this.verbosity = e), this;
              },
              setDrawMode: function (e) {
                return (this.drawMode = e), this;
              },
              setSkipDequantization: function (e, t) {
                var r = !0;
                return (
                  void 0 !== t && (r = t),
                  (this.getAttributeOptions(e).skipDequantization = r),
                  this
                );
              },
              decodeDracoFile: function (e, t, r, o) {
                var i = this;
                THREE.DRACOLoader.getDecoderModule().then(function (n) {
                  i.decodeDracoFileInternal(e, n.decoder, t, r || {}, o || {});
                });
              },
              decodeDracoFileInternal: function (e, t, r, o, i) {
                var n = new t.DecoderBuffer();
                n.Init(new Int8Array(e), e.byteLength);
                var a = new t.Decoder(),
                  d = a.GetEncodedGeometryType(n);
                if (d == t.TRIANGULAR_MESH)
                  this.verbosity > 0 && console.log("Loaded a mesh.");
                else {
                  if (d != t.POINT_CLOUD) {
                    var s = "THREE.DRACOLoader: Unknown geometry type.";
                    throw (console.error(s), new Error(s));
                  }
                  this.verbosity > 0 && console.log("Loaded a point cloud.");
                }
                r(this.convertDracoGeometryTo3JS(t, a, d, n, o, i));
              },
              addAttributeToGeometry: function (e, t, r, o, i, n, a, d) {
                if (0 === n.ptr) {
                  var s = "THREE.DRACOLoader: No attribute " + o;
                  throw (console.error(s), new Error(s));
                }
                var u,
                  c,
                  l = n.num_components(),
                  A = r.num_points(),
                  E = A * l;
                switch (i) {
                  case Float32Array:
                    (u = new e.DracoFloat32Array()),
                      t.GetAttributeFloatForAllPoints(r, n, u),
                      (d[o] = new Float32Array(E)),
                      (c = THREE.Float32BufferAttribute);
                    break;
                  case Int8Array:
                    (u = new e.DracoInt8Array()),
                      t.GetAttributeInt8ForAllPoints(r, n, u),
                      (d[o] = new Int8Array(E)),
                      (c = THREE.Int8BufferAttribute);
                    break;
                  case Int16Array:
                    (u = new e.DracoInt16Array()),
                      t.GetAttributeInt16ForAllPoints(r, n, u),
                      (d[o] = new Int16Array(E)),
                      (c = THREE.Int16BufferAttribute);
                    break;
                  case Int32Array:
                    (u = new e.DracoInt32Array()),
                      t.GetAttributeInt32ForAllPoints(r, n, u),
                      (d[o] = new Int32Array(E)),
                      (c = THREE.Int32BufferAttribute);
                    break;
                  case Uint8Array:
                    (u = new e.DracoUInt8Array()),
                      t.GetAttributeUInt8ForAllPoints(r, n, u),
                      (d[o] = new Uint8Array(E)),
                      (c = THREE.Uint8BufferAttribute);
                    break;
                  case Uint16Array:
                    (u = new e.DracoUInt16Array()),
                      t.GetAttributeUInt16ForAllPoints(r, n, u),
                      (d[o] = new Uint16Array(E)),
                      (c = THREE.Uint16BufferAttribute);
                    break;
                  case Uint32Array:
                    (u = new e.DracoUInt32Array()),
                      t.GetAttributeUInt32ForAllPoints(r, n, u),
                      (d[o] = new Uint32Array(E)),
                      (c = THREE.Uint32BufferAttribute);
                    break;
                  default:
                    var s = "THREE.DRACOLoader: Unexpected attribute type.";
                    throw (console.error(s), new Error(s));
                }
                for (var f = 0; f < E; f++) d[o][f] = u.GetValue(f);
                a.addAttribute(o, new c(d[o], l)), e.destroy(u);
              },
              convertDracoGeometryTo3JS: function (e, t, r, o, i, n) {
                !0 ===
                  this.getAttributeOptions("position").skipDequantization &&
                  t.SkipAttributeTransform(e.POSITION);
                var a, d;
                const s = performance.now();
                if (
                  (r === e.TRIANGULAR_MESH
                    ? ((a = new e.Mesh()), (d = t.DecodeBufferToMesh(o, a)))
                    : ((a = new e.PointCloud()),
                      (d = t.DecodeBufferToPointCloud(o, a))),
                  !d.ok() || 0 == a.ptr)
                ) {
                  var u = "THREE.DRACOLoader: Decoding failed: ";
                  throw (
                    ((u += d.error_msg()),
                    console.error(u),
                    e.destroy(t),
                    e.destroy(a),
                    new Error(u))
                  );
                }
                var c = performance.now();
                e.destroy(o);
                var l;
                r == e.TRIANGULAR_MESH
                  ? ((l = a.num_faces()),
                    this.verbosity > 0 &&
                      console.log("Number of faces loaded: " + l.toString()))
                  : (l = 0);
                var A = a.num_points(),
                  E = a.num_attributes();
                this.verbosity > 0 &&
                  (console.log("Number of points loaded: " + A.toString()),
                  console.log("Number of attributes loaded: " + E.toString()));
                var f = t.GetAttributeId(a, e.POSITION);
                if (-1 == f) {
                  var u = "THREE.DRACOLoader: No position attribute found.";
                  throw (
                    (console.error(u), e.destroy(t), e.destroy(a), new Error(u))
                  );
                }
                var R = t.GetAttribute(a, f),
                  y = {},
                  b = new THREE.BufferGeometry();
                for (var D in this.nativeAttributeMap)
                  if (void 0 === i[D]) {
                    var T = t.GetAttributeId(a, e[this.nativeAttributeMap[D]]);
                    if (-1 !== T) {
                      this.verbosity > 0 &&
                        console.log("Loaded " + D + " attribute.");
                      var m = t.GetAttribute(a, T);
                      this.addAttributeToGeometry(
                        e,
                        t,
                        a,
                        D,
                        Float32Array,
                        m,
                        b,
                        y
                      );
                    }
                  }
                for (var D in i) {
                  var p = n[D] || Float32Array,
                    h = i[D],
                    m = t.GetAttributeByUniqueId(a, h);
                  this.addAttributeToGeometry(e, t, a, D, p, m, b, y);
                }
                if (r == e.TRIANGULAR_MESH)
                  if (this.drawMode === THREE.TriangleStripDrawMode) {
                    var w = new e.DracoInt32Array();
                    t.GetTriangleStripsFromMesh(a, w);
                    y.indices = new Uint32Array(w.size());
                    for (var v = 0; v < w.size(); ++v)
                      y.indices[v] = w.GetValue(v);
                    e.destroy(w);
                  } else {
                    var H = 3 * l;
                    y.indices = new Uint32Array(H);
                    for (var O = new e.DracoInt32Array(), v = 0; v < l; ++v) {
                      t.GetFaceFromMesh(a, v, O);
                      var L = 3 * v;
                      (y.indices[L] = O.GetValue(0)),
                        (y.indices[L + 1] = O.GetValue(1)),
                        (y.indices[L + 2] = O.GetValue(2));
                    }
                    e.destroy(O);
                  }
                (b.drawMode = this.drawMode),
                  r == e.TRIANGULAR_MESH &&
                    b.setIndex(
                      new (y.indices.length > 65535
                        ? THREE.Uint32BufferAttribute
                        : THREE.Uint16BufferAttribute)(y.indices, 1)
                    );
                var I = new e.AttributeQuantizationTransform();
                if (I.InitFromAttribute(R)) {
                  (b.attributes.position.isQuantized = !0),
                    (b.attributes.position.maxRange = I.range()),
                    (b.attributes.position.numQuantizationBits =
                      I.quantization_bits()),
                    (b.attributes.position.minValues = new Float32Array(3));
                  for (var v = 0; v < 3; ++v)
                    b.attributes.position.minValues[v] = I.min_value(v);
                }
                return (
                  e.destroy(I),
                  e.destroy(t),
                  e.destroy(a),
                  (this.decode_time = c - s),
                  (this.import_time = performance.now() - c),
                  this.verbosity > 0 &&
                    (console.log("Decode time: " + this.decode_time),
                    console.log("Import time: " + this.import_time)),
                  b
                );
              },
              isVersionSupported: function (e, t) {
                THREE.DRACOLoader.getDecoderModule().then(function (r) {
                  t(r.decoder.isVersionSupported(e));
                });
              },
              getAttributeOptions: function (e) {
                return (
                  void 0 === this.attributeOptions[e] &&
                    (this.attributeOptions[e] = {}),
                  this.attributeOptions[e]
                );
              },
            }),
            (THREE.DRACOLoader.decoderPath = "./"),
            (THREE.DRACOLoader.decoderConfig = {}),
            (THREE.DRACOLoader.decoderModulePromise = null),
            (THREE.DRACOLoader.setDecoderPath = function (e) {
              THREE.DRACOLoader.decoderPath = e;
            }),
            (THREE.DRACOLoader.setDecoderConfig = function (e) {
              var t = THREE.DRACOLoader.decoderConfig.wasmBinary;
              (THREE.DRACOLoader.decoderConfig = e || {}),
                THREE.DRACOLoader.releaseDecoderModule(),
                t && (THREE.DRACOLoader.decoderConfig.wasmBinary = t);
            }),
            (THREE.DRACOLoader.releaseDecoderModule = function () {
              THREE.DRACOLoader.decoderModulePromise = null;
            }),
            (THREE.DRACOLoader.getDecoderModule = function () {
              var e = this,
                t = THREE.DRACOLoader.decoderPath,
                r = THREE.DRACOLoader.decoderConfig,
                o = THREE.DRACOLoader.decoderModulePromise;
              return (
                o ||
                ("undefined" != typeof DracoDecoderModule
                  ? (o = Promise.resolve())
                  : "object" != typeof WebAssembly || "js" === r.type
                  ? (o = THREE.DRACOLoader._loadScript(t + "draco_decoder.js"))
                  : ((r.wasmBinaryFile = t + "draco_decoder.wasm"),
                    (o = THREE.DRACOLoader._loadScript(
                      t + "draco_wasm_wrapper.js"
                    )
                      .then(function () {
                        return THREE.DRACOLoader._loadArrayBuffer(
                          r.wasmBinaryFile
                        );
                      })
                      .then(function (e) {
                        r.wasmBinary = e;
                      }))),
                (o = o.then(function () {
                  return new Promise(function (t) {
                    (r.onModuleLoaded = function (r) {
                      (e.timeLoaded = performance.now()), t({ decoder: r });
                    }),
                      DracoDecoderModule(r);
                  });
                })),
                (THREE.DRACOLoader.decoderModulePromise = o),
                o)
              );
            }),
            (THREE.DRACOLoader._loadScript = function (e) {
              var t = document.getElementById("decoder_script");
              null !== t && t.parentNode.removeChild(t);
              var r = document.getElementsByTagName("head")[0],
                o = document.createElement("script");
              return (
                (o.id = "decoder_script"),
                (o.type = "text/javascript"),
                (o.src = e),
                new Promise(function (e) {
                  (o.onload = e), r.appendChild(o);
                })
              );
            }),
            (THREE.DRACOLoader._loadArrayBuffer = function (e) {
              var t = new THREE.FileLoader();
              return (
                t.setResponseType("arraybuffer"),
                new Promise(function (r, o) {
                  t.load(e, r, void 0, o);
                })
              );
            });
        },
        {},
      ],
      41: [
        function (_dereq_, module, exports) {
          THREE.GLTFLoader = (function () {
            function e(e) {
              (this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager),
                (this.dracoLoader = null);
            }
            function r() {
              var e = {};
              return {
                get: function (r) {
                  return e[r];
                },
                add: function (r, t) {
                  e[r] = t;
                },
                remove: function (r) {
                  delete e[r];
                },
                removeAll: function () {
                  e = {};
                },
              };
            }
            function t() {
              if (!THREE.DDSLoader)
                throw new Error(
                  "THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader"
                );
              (this.name = H.MSFT_TEXTURE_DDS),
                (this.ddsLoader = new THREE.DDSLoader());
            }
            function a(e) {
              (this.name = H.KHR_LIGHTS_PUNCTUAL), (this.lights = []);
              for (
                var r =
                    (e.extensions && e.extensions[H.KHR_LIGHTS_PUNCTUAL]) || {},
                  t = r.lights || [],
                  a = 0;
                a < t.length;
                a++
              ) {
                var n,
                  i = t[a],
                  s = new THREE.Color(16777215);
                void 0 !== i.color && s.fromArray(i.color);
                var o = void 0 !== i.range ? i.range : 0;
                switch (i.type) {
                  case "directional":
                    (n = new THREE.DirectionalLight(s)),
                      n.target.position.set(0, 0, 1),
                      n.add(n.target);
                    break;
                  case "point":
                    (n = new THREE.PointLight(s)), (n.distance = o);
                    break;
                  case "spot":
                    (n = new THREE.SpotLight(s)),
                      (n.distance = o),
                      (i.spot = i.spot || {}),
                      (i.spot.innerConeAngle =
                        void 0 !== i.spot.innerConeAngle
                          ? i.spot.innerConeAngle
                          : 0),
                      (i.spot.outerConeAngle =
                        void 0 !== i.spot.outerConeAngle
                          ? i.spot.outerConeAngle
                          : Math.PI / 4),
                      (n.angle = i.spot.outerConeAngle),
                      (n.penumbra =
                        1 - i.spot.innerConeAngle / i.spot.outerConeAngle),
                      n.target.position.set(0, 0, 1),
                      n.add(n.target);
                    break;
                  default:
                    throw new Error(
                      'THREE.GLTFLoader: Unexpected light type, "' +
                        i.type +
                        '".'
                    );
                }
                (n.decay = 2),
                  void 0 !== i.intensity && (n.intensity = i.intensity),
                  (n.name = i.name || "light_" + a),
                  this.lights.push(n);
              }
            }
            function n(e) {
              this.name = H.KHR_MATERIALS_UNLIT;
            }
            function i(e) {
              (this.name = H.KHR_BINARY_GLTF),
                (this.content = null),
                (this.body = null);
              var r = new DataView(e, 0, _);
              if (
                ((this.header = {
                  magic: THREE.LoaderUtils.decodeText(
                    new Uint8Array(e.slice(0, 4))
                  ),
                  version: r.getUint32(4, !0),
                  length: r.getUint32(8, !0),
                }),
                this.header.magic !== A)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported glTF-Binary header."
                );
              if (this.header.version < 2)
                throw new Error(
                  "THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead."
                );
              for (var t = new DataView(e, _), a = 0; a < t.byteLength; ) {
                var n = t.getUint32(a, !0);
                a += 4;
                var i = t.getUint32(a, !0);
                if (((a += 4), i === b.JSON)) {
                  var s = new Uint8Array(e, _ + a, n);
                  this.content = THREE.LoaderUtils.decodeText(s);
                } else if (i === b.BIN) {
                  var o = _ + a;
                  this.body = e.slice(o, o + n);
                }
                a += n;
              }
              if (null === this.content)
                throw new Error("THREE.GLTFLoader: JSON content not found.");
            }
            function s(e, r) {
              if (!r)
                throw new Error(
                  "THREE.GLTFLoader: No DRACOLoader instance provided."
                );
              (this.name = H.KHR_DRACO_MESH_COMPRESSION),
                (this.json = e),
                (this.dracoLoader = r);
            }
            function o() {
              return {
                name: H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: [
                  "color",
                  "map",
                  "lightMap",
                  "lightMapIntensity",
                  "aoMap",
                  "aoMapIntensity",
                  "emissive",
                  "emissiveIntensity",
                  "emissiveMap",
                  "bumpMap",
                  "bumpScale",
                  "normalMap",
                  "displacementMap",
                  "displacementScale",
                  "displacementBias",
                  "specularMap",
                  "specular",
                  "glossinessMap",
                  "glossiness",
                  "alphaMap",
                  "envMap",
                  "envMapIntensity",
                  "refractionRatio",
                ],
                getMaterialType: function () {
                  return THREE.ShaderMaterial;
                },
                extendParams: function (e, r, t) {
                  var a = r.extensions[this.name],
                    n = THREE.ShaderLib.standard,
                    i = THREE.UniformsUtils.clone(n.uniforms),
                    s = [
                      "#ifdef USE_SPECULARMAP",
                      "\tuniform sampler2D specularMap;",
                      "#endif",
                    ].join("\n"),
                    o = [
                      "#ifdef USE_GLOSSINESSMAP",
                      "\tuniform sampler2D glossinessMap;",
                      "#endif",
                    ].join("\n"),
                    l = [
                      "vec3 specularFactor = specular;",
                      "#ifdef USE_SPECULARMAP",
                      "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
                      "\ttexelSpecular = sRGBToLinear( texelSpecular );",
                      "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
                      "\tspecularFactor *= texelSpecular.rgb;",
                      "#endif",
                    ].join("\n"),
                    u = [
                      "float glossinessFactor = glossiness;",
                      "#ifdef USE_GLOSSINESSMAP",
                      "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
                      "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
                      "\tglossinessFactor *= texelGlossiness.a;",
                      "#endif",
                    ].join("\n"),
                    p = [
                      "PhysicalMaterial material;",
                      "material.diffuseColor = diffuseColor.rgb;",
                      "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );",
                      "material.specularColor = specularFactor.rgb;",
                    ].join("\n"),
                    c = n.fragmentShader
                      .replace(
                        "uniform float roughness;",
                        "uniform vec3 specular;"
                      )
                      .replace(
                        "uniform float metalness;",
                        "uniform float glossiness;"
                      )
                      .replace("#include <roughnessmap_pars_fragment>", s)
                      .replace("#include <metalnessmap_pars_fragment>", o)
                      .replace("#include <roughnessmap_fragment>", l)
                      .replace("#include <metalnessmap_fragment>", u)
                      .replace("#include <lights_physical_fragment>", p);
                  delete i.roughness,
                    delete i.metalness,
                    delete i.roughnessMap,
                    delete i.metalnessMap,
                    (i.specular = { value: new THREE.Color().setHex(1118481) }),
                    (i.glossiness = { value: 0.5 }),
                    (i.specularMap = { value: null }),
                    (i.glossinessMap = { value: null }),
                    (e.vertexShader = n.vertexShader),
                    (e.fragmentShader = c),
                    (e.uniforms = i),
                    (e.defines = { STANDARD: "" }),
                    (e.color = new THREE.Color(1, 1, 1)),
                    (e.opacity = 1);
                  var d = [];
                  if (Array.isArray(a.diffuseFactor)) {
                    var h = a.diffuseFactor;
                    e.color.fromArray(h), (e.opacity = h[3]);
                  }
                  if (
                    (void 0 !== a.diffuseTexture &&
                      d.push(t.assignTexture(e, "map", a.diffuseTexture.index)),
                    (e.emissive = new THREE.Color(0, 0, 0)),
                    (e.glossiness =
                      void 0 !== a.glossinessFactor ? a.glossinessFactor : 1),
                    (e.specular = new THREE.Color(1, 1, 1)),
                    Array.isArray(a.specularFactor) &&
                      e.specular.fromArray(a.specularFactor),
                    void 0 !== a.specularGlossinessTexture)
                  ) {
                    var E = a.specularGlossinessTexture.index;
                    d.push(t.assignTexture(e, "glossinessMap", E)),
                      d.push(t.assignTexture(e, "specularMap", E));
                  }
                  return Promise.all(d);
                },
                createMaterial: function (e) {
                  var r = new THREE.ShaderMaterial({
                    defines: e.defines,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader,
                    uniforms: e.uniforms,
                    fog: !0,
                    lights: !0,
                    opacity: e.opacity,
                    transparent: e.transparent,
                  });
                  return (
                    (r.isGLTFSpecularGlossinessMaterial = !0),
                    (r.color = e.color),
                    (r.map = void 0 === e.map ? null : e.map),
                    (r.lightMap = null),
                    (r.lightMapIntensity = 1),
                    (r.aoMap = void 0 === e.aoMap ? null : e.aoMap),
                    (r.aoMapIntensity = 1),
                    (r.emissive = e.emissive),
                    (r.emissiveIntensity = 1),
                    (r.emissiveMap =
                      void 0 === e.emissiveMap ? null : e.emissiveMap),
                    (r.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
                    (r.bumpScale = 1),
                    (r.normalMap = void 0 === e.normalMap ? null : e.normalMap),
                    e.normalScale && (r.normalScale = e.normalScale),
                    (r.displacementMap = null),
                    (r.displacementScale = 1),
                    (r.displacementBias = 0),
                    (r.specularMap =
                      void 0 === e.specularMap ? null : e.specularMap),
                    (r.specular = e.specular),
                    (r.glossinessMap =
                      void 0 === e.glossinessMap ? null : e.glossinessMap),
                    (r.glossiness = e.glossiness),
                    (r.alphaMap = null),
                    (r.envMap = void 0 === e.envMap ? null : e.envMap),
                    (r.envMapIntensity = 1),
                    (r.refractionRatio = 0.98),
                    (r.extensions.derivatives = !0),
                    r
                  );
                },
                cloneMaterial: function (e) {
                  var r = e.clone();
                  r.isGLTFSpecularGlossinessMaterial = !0;
                  for (
                    var t = this.specularGlossinessParams, a = 0, n = t.length;
                    a < n;
                    a++
                  )
                    r[t[a]] = e[t[a]];
                  return r;
                },
                refreshUniforms: function (e, r, t, a, n, i) {
                  if (!0 === n.isGLTFSpecularGlossinessMaterial) {
                    var s = n.uniforms,
                      o = n.defines;
                    (s.opacity.value = n.opacity),
                      s.diffuse.value.copy(n.color),
                      s.emissive.value
                        .copy(n.emissive)
                        .multiplyScalar(n.emissiveIntensity),
                      (s.map.value = n.map),
                      (s.specularMap.value = n.specularMap),
                      (s.alphaMap.value = n.alphaMap),
                      (s.lightMap.value = n.lightMap),
                      (s.lightMapIntensity.value = n.lightMapIntensity),
                      (s.aoMap.value = n.aoMap),
                      (s.aoMapIntensity.value = n.aoMapIntensity);
                    var l;
                    n.map
                      ? (l = n.map)
                      : n.specularMap
                      ? (l = n.specularMap)
                      : n.displacementMap
                      ? (l = n.displacementMap)
                      : n.normalMap
                      ? (l = n.normalMap)
                      : n.bumpMap
                      ? (l = n.bumpMap)
                      : n.glossinessMap
                      ? (l = n.glossinessMap)
                      : n.alphaMap
                      ? (l = n.alphaMap)
                      : n.emissiveMap && (l = n.emissiveMap),
                      void 0 !== l &&
                        (l.isWebGLRenderTarget && (l = l.texture),
                        !0 === l.matrixAutoUpdate && l.updateMatrix(),
                        s.uvTransform.value.copy(l.matrix)),
                      (s.envMap.value = n.envMap),
                      (s.envMapIntensity.value = n.envMapIntensity),
                      (s.flipEnvMap.value =
                        n.envMap && n.envMap.isCubeTexture ? -1 : 1),
                      (s.refractionRatio.value = n.refractionRatio),
                      s.specular.value.copy(n.specular),
                      (s.glossiness.value = n.glossiness),
                      (s.glossinessMap.value = n.glossinessMap),
                      (s.emissiveMap.value = n.emissiveMap),
                      (s.bumpMap.value = n.bumpMap),
                      (s.normalMap.value = n.normalMap),
                      (s.displacementMap.value = n.displacementMap),
                      (s.displacementScale.value = n.displacementScale),
                      (s.displacementBias.value = n.displacementBias),
                      null !== s.glossinessMap.value &&
                        void 0 === o.USE_GLOSSINESSMAP &&
                        ((o.USE_GLOSSINESSMAP = ""), (o.USE_ROUGHNESSMAP = "")),
                      null === s.glossinessMap.value &&
                        void 0 !== o.USE_GLOSSINESSMAP &&
                        (delete o.USE_GLOSSINESSMAP, delete o.USE_ROUGHNESSMAP);
                  }
                },
              };
            }
            function l(e, r, t, a) {
              THREE.Interpolant.call(this, e, r, t, a);
            }
            function u(e, r) {
              return "string" != typeof e || "" === e
                ? ""
                : /^(https?:)?\/\//i.test(e)
                ? e
                : /^data:.*,.*$/i.test(e)
                ? e
                : /^blob:.*$/i.test(e)
                ? e
                : r + e;
            }
            function p() {
              return new THREE.MeshStandardMaterial({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: THREE.FrontSide,
              });
            }
            function c(e, r, t) {
              for (var a in t.extensions)
                void 0 === e[a] &&
                  ((r.userData.gltfExtensions =
                    r.userData.gltfExtensions || {}),
                  (r.userData.gltfExtensions[a] = t.extensions[a]));
            }
            function d(e, r) {
              void 0 !== r.extras &&
                ("object" == typeof r.extras
                  ? (e.userData = r.extras)
                  : console.warn(
                      "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                        r.extras
                    ));
            }
            function h(e, r, t) {
              for (var a = !1, n = !1, i = 0, s = r.length; i < s; i++) {
                var o = r[i];
                if (
                  (void 0 !== o.POSITION && (a = !0),
                  void 0 !== o.NORMAL && (n = !0),
                  a && n)
                )
                  break;
              }
              if (a || n) {
                for (var l = [], u = [], i = 0, s = r.length; i < s; i++) {
                  var o = r[i],
                    p = "morphTarget" + i;
                  if (a) {
                    if (void 0 !== o.POSITION) {
                      var c = M(t[o.POSITION]);
                      c.name = p;
                      for (
                        var d = e.attributes.position, h = 0, E = c.count;
                        h < E;
                        h++
                      )
                        c.setXYZ(
                          h,
                          c.getX(h) + d.getX(h),
                          c.getY(h) + d.getY(h),
                          c.getZ(h) + d.getZ(h)
                        );
                    } else c = e.attributes.position;
                    l.push(c);
                  }
                  if (n) {
                    var f;
                    if (void 0 !== o.NORMAL) {
                      var f = M(t[o.NORMAL]);
                      f.name = p;
                      for (
                        var m = e.attributes.normal, h = 0, E = f.count;
                        h < E;
                        h++
                      )
                        f.setXYZ(
                          h,
                          f.getX(h) + m.getX(h),
                          f.getY(h) + m.getY(h),
                          f.getZ(h) + m.getZ(h)
                        );
                    } else f = e.attributes.normal;
                    u.push(f);
                  }
                }
                a && (e.morphAttributes.position = l),
                  n && (e.morphAttributes.normal = u);
              }
            }
            function E(e, r) {
              if ((e.updateMorphTargets(), void 0 !== r.weights))
                for (var t = 0, a = r.weights.length; t < a; t++)
                  e.morphTargetInfluences[t] = r.weights[t];
              if (r.extras && Array.isArray(r.extras.targetNames)) {
                var n = r.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                  e.morphTargetDictionary = {};
                  for (var t = 0, a = n.length; t < a; t++)
                    e.morphTargetDictionary[n[t]] = t;
                } else
                  console.warn(
                    "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
                  );
              }
            }
            function f(e, r) {
              return e.indices === r.indices && m(e.attributes, r.attributes);
            }
            function m(e, r) {
              if (Object.keys(e).length !== Object.keys(r).length) return !1;
              for (var t in e) if (e[t] !== r[t]) return !1;
              return !0;
            }
            function v(e, r) {
              if (e.length !== r.length) return !1;
              for (var t = 0, a = e.length; t < a; t++)
                if (e[t] !== r[t]) return !1;
              return !0;
            }
            function T(e, r) {
              for (var t = 0, a = e.length; t < a; t++) {
                var n = e[t];
                if (f(n.primitive, r)) return n.promise;
              }
              return null;
            }
            function g(e, r) {
              for (var t = 0, a = e.length; t < a; t++) {
                var n = e[t];
                if (v(r, n.baseGeometries)) return n.geometry;
              }
              return null;
            }
            function R(e, r, t) {
              for (var a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (r === i.baseGeometry && v(t, i.primitives))
                  return i.geometry;
              }
              return null;
            }
            function M(e) {
              if (e.isInterleavedBufferAttribute) {
                for (
                  var r = e.count,
                    t = e.itemSize,
                    a = e.array.slice(0, r * t),
                    n = 0;
                  n < r;
                  ++n
                )
                  (a[n] = e.getX(n)),
                    t >= 2 && (a[n + 1] = e.getY(n)),
                    t >= 3 && (a[n + 2] = e.getZ(n)),
                    t >= 4 && (a[n + 3] = e.getW(n));
                return new THREE.BufferAttribute(a, t, e.normalized);
              }
              return e.clone();
            }
            function S(e) {
              if (e.length < 2) return !1;
              var r = e[0],
                t = r.targets || [];
              if (void 0 === r.indices) return !1;
              for (var a = 1, n = e.length; a < n; a++) {
                var i = e[a];
                if (r.mode !== i.mode) return !1;
                if (void 0 === i.indices) return !1;
                if (!m(r.attributes, i.attributes)) return !1;
                var s = i.targets || [];
                if (t.length !== s.length) return !1;
                for (var o = 0, l = t.length; o < l; o++)
                  if (!m(t[o], s[o])) return !1;
              }
              return !0;
            }
            function L(e, t, a) {
              (this.json = e || {}),
                (this.extensions = t || {}),
                (this.options = a || {}),
                (this.cache = new r()),
                (this.primitiveCache = []),
                (this.multiplePrimitivesCache = []),
                (this.multiPassGeometryCache = []),
                (this.textureLoader = new THREE.TextureLoader(
                  this.options.manager
                )),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                (this.fileLoader = new THREE.FileLoader(this.options.manager)),
                this.fileLoader.setResponseType("arraybuffer");
            }
            function y(e, r, t) {
              var a = r.attributes;
              for (var n in a) {
                var i = O[n],
                  s = t[a[n]];
                i && (i in e.attributes || e.addAttribute(i, s));
              }
              void 0 === r.indices || e.index || e.setIndex(t[r.indices]),
                void 0 !== r.targets && h(e, r.targets, t),
                d(e, r);
            }
            e.prototype = {
              constructor: e,
              crossOrigin: "anonymous",
              load: function (e, r, t, a) {
                var n = this,
                  i =
                    void 0 !== this.path
                      ? this.path
                      : THREE.LoaderUtils.extractUrlBase(e),
                  s = new THREE.FileLoader(n.manager);
                s.setResponseType("arraybuffer"),
                  s.load(
                    e,
                    function (e) {
                      try {
                        n.parse(e, i, r, a);
                      } catch (e) {
                        if (void 0 === a) throw e;
                        a(e);
                      }
                    },
                    t,
                    a
                  );
              },
              setCrossOrigin: function (e) {
                return (this.crossOrigin = e), this;
              },
              setPath: function (e) {
                return (this.path = e), this;
              },
              setDRACOLoader: function (e) {
                return (this.dracoLoader = e), this;
              },
              parse: function (e, r, l, u) {
                var p,
                  d = {};
                if ("string" == typeof e) p = e;
                else {
                  if (
                    THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === A
                  ) {
                    try {
                      d[H.KHR_BINARY_GLTF] = new i(e);
                    } catch (e) {
                      return void (u && u(e));
                    }
                    p = d[H.KHR_BINARY_GLTF].content;
                  } else p = THREE.LoaderUtils.decodeText(new Uint8Array(e));
                }
                var h = JSON.parse(p);
                if (void 0 === h.asset || h.asset.version[0] < 2)
                  return void (
                    u &&
                    u(
                      new Error(
                        "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead."
                      )
                    )
                  );
                if (h.extensionsUsed)
                  for (var E = 0; E < h.extensionsUsed.length; ++E) {
                    var f = h.extensionsUsed[E],
                      m = h.extensionsRequired || [];
                    switch (f) {
                      case H.KHR_LIGHTS_PUNCTUAL:
                        d[f] = new a(h);
                        break;
                      case H.KHR_MATERIALS_UNLIT:
                        d[f] = new n(h);
                        break;
                      case H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                        d[f] = new o();
                        break;
                      case H.KHR_DRACO_MESH_COMPRESSION:
                        d[f] = new s(h, this.dracoLoader);
                        break;
                      case H.MSFT_TEXTURE_DDS:
                        d[H.MSFT_TEXTURE_DDS] = new t();
                        break;
                      default:
                        m.indexOf(f) >= 0 &&
                          console.warn(
                            'THREE.GLTFLoader: Unknown extension "' + f + '".'
                          );
                    }
                  }
                var v = new L(h, d, {
                  path: r || this.path || "",
                  crossOrigin: this.crossOrigin,
                  manager: this.manager,
                });
                v.parse(function (e, r, t, a, n) {
                  var i = {
                    scene: e,
                    scenes: r,
                    cameras: t,
                    animations: a,
                    asset: n.asset,
                    parser: v,
                    userData: {},
                  };
                  c(d, i, n), l(i);
                }, u);
              },
            };
            var H = {
              KHR_BINARY_GLTF: "KHR_binary_glTF",
              KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
              KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
              KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                "KHR_materials_pbrSpecularGlossiness",
              KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
              MSFT_TEXTURE_DDS: "MSFT_texture_dds",
            };
            (n.prototype.getMaterialType = function (e) {
              return THREE.MeshBasicMaterial;
            }),
              (n.prototype.extendParams = function (e, r, t) {
                var a = [];
                (e.color = new THREE.Color(1, 1, 1)), (e.opacity = 1);
                var n = r.pbrMetallicRoughness;
                if (n) {
                  if (Array.isArray(n.baseColorFactor)) {
                    var i = n.baseColorFactor;
                    e.color.fromArray(i), (e.opacity = i[3]);
                  }
                  void 0 !== n.baseColorTexture &&
                    a.push(t.assignTexture(e, "map", n.baseColorTexture.index));
                }
                return Promise.all(a);
              });
            var A = "glTF",
              _ = 12,
              b = { JSON: 1313821514, BIN: 5130562 };
            (s.prototype.decodePrimitive = function (e, r) {
              var t = this.json,
                a = this.dracoLoader,
                n = e.extensions[this.name].bufferView,
                i = e.extensions[this.name].attributes,
                s = {},
                o = {},
                l = {};
              for (var u in i) u in O && (s[O[u]] = i[u]);
              for (u in e.attributes)
                if (void 0 !== O[u] && void 0 !== i[u]) {
                  var p = t.accessors[e.attributes[u]],
                    c = x[p.componentType];
                  (l[O[u]] = c), (o[O[u]] = !0 === p.normalized);
                }
              return r.getDependency("bufferView", n).then(function (e) {
                return new Promise(function (r) {
                  a.decodeDracoFile(
                    e,
                    function (e) {
                      for (var t in e.attributes) {
                        var a = e.attributes[t],
                          n = o[t];
                        void 0 !== n && (a.normalized = n);
                      }
                      r(e);
                    },
                    s,
                    l
                  );
                });
              });
            }),
              (l.prototype = Object.create(THREE.Interpolant.prototype)),
              (l.prototype.constructor = l),
              (l.prototype.interpolate_ = function (e, r, t, a) {
                for (
                  var n = this.resultBuffer,
                    i = this.sampleValues,
                    s = this.valueSize,
                    o = 2 * s,
                    l = 3 * s,
                    u = a - r,
                    p = (t - r) / u,
                    c = p * p,
                    d = c * p,
                    h = e * l,
                    E = h - l,
                    f = 2 * d - 3 * c + 1,
                    m = d - 2 * c + p,
                    v = -2 * d + 3 * c,
                    T = d - c,
                    g = 0;
                  g !== s;
                  g++
                ) {
                  var R = i[E + g + s],
                    M = i[E + g + o] * u,
                    S = i[h + g + s],
                    L = i[h + g] * u;
                  n[g] = f * R + m * M + v * S + T * L;
                }
                return n;
              });
            var w = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123,
              },
              x =
                (Number,
                THREE.Matrix3,
                THREE.Matrix4,
                THREE.Vector2,
                THREE.Vector3,
                THREE.Vector4,
                THREE.Texture,
                {
                  5120: Int8Array,
                  5121: Uint8Array,
                  5122: Int16Array,
                  5123: Uint16Array,
                  5125: Uint32Array,
                  5126: Float32Array,
                }),
              I = {
                9728: THREE.NearestFilter,
                9729: THREE.LinearFilter,
                9984: THREE.NearestMipMapNearestFilter,
                9985: THREE.LinearMipMapNearestFilter,
                9986: THREE.NearestMipMapLinearFilter,
                9987: THREE.LinearMipMapLinearFilter,
              },
              F = {
                33071: THREE.ClampToEdgeWrapping,
                33648: THREE.MirroredRepeatWrapping,
                10497: THREE.RepeatWrapping,
              },
              G =
                (THREE.BackSide,
                THREE.FrontSide,
                THREE.NeverDepth,
                THREE.LessDepth,
                THREE.EqualDepth,
                THREE.LessEqualDepth,
                THREE.GreaterEqualDepth,
                THREE.NotEqualDepth,
                THREE.GreaterEqualDepth,
                THREE.AlwaysDepth,
                THREE.AddEquation,
                THREE.SubtractEquation,
                THREE.ReverseSubtractEquation,
                THREE.ZeroFactor,
                THREE.OneFactor,
                THREE.SrcColorFactor,
                THREE.OneMinusSrcColorFactor,
                THREE.SrcAlphaFactor,
                THREE.OneMinusSrcAlphaFactor,
                THREE.DstAlphaFactor,
                THREE.OneMinusDstAlphaFactor,
                THREE.DstColorFactor,
                THREE.OneMinusDstColorFactor,
                THREE.SrcAlphaSaturateFactor,
                {
                  SCALAR: 1,
                  VEC2: 2,
                  VEC3: 3,
                  VEC4: 4,
                  MAT2: 4,
                  MAT3: 9,
                  MAT4: 16,
                }),
              O = {
                POSITION: "position",
                NORMAL: "normal",
                TEXCOORD_0: "uv",
                TEXCOORD0: "uv",
                TEXCOORD: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                COLOR0: "color",
                COLOR: "color",
                WEIGHTS_0: "skinWeight",
                WEIGHT: "skinWeight",
                JOINTS_0: "skinIndex",
                JOINT: "skinIndex",
              },
              N = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences",
              },
              U = {
                CUBICSPLINE: THREE.InterpolateSmooth,
                LINEAR: THREE.InterpolateLinear,
                STEP: THREE.InterpolateDiscrete,
              },
              C = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
            return (
              (L.prototype.parse = function (e, r) {
                var t = this.json;
                this.cache.removeAll(),
                  this.markDefs(),
                  this.getMultiDependencies(["scene", "animation", "camera"])
                    .then(function (r) {
                      var a = r.scenes || [],
                        n = a[t.scene || 0],
                        i = r.animations || [],
                        s = r.cameras || [];
                      e(n, a, s, i, t);
                    })
                    .catch(r);
              }),
              (L.prototype.markDefs = function () {
                for (
                  var e = this.json.nodes || [],
                    r = this.json.skins || [],
                    t = this.json.meshes || [],
                    a = {},
                    n = {},
                    i = 0,
                    s = r.length;
                  i < s;
                  i++
                )
                  for (var o = r[i].joints, l = 0, u = o.length; l < u; l++)
                    e[o[l]].isBone = !0;
                for (var p = 0, c = e.length; p < c; p++) {
                  var d = e[p];
                  void 0 !== d.mesh &&
                    (void 0 === a[d.mesh] && (a[d.mesh] = n[d.mesh] = 0),
                    a[d.mesh]++,
                    void 0 !== d.skin && (t[d.mesh].isSkinnedMesh = !0));
                }
                (this.json.meshReferences = a), (this.json.meshUses = n);
              }),
              (L.prototype.getDependency = function (e, r) {
                var t = e + ":" + r,
                  a = this.cache.get(t);
                if (!a) {
                  switch (e) {
                    case "scene":
                      a = this.loadScene(r);
                      break;
                    case "node":
                      a = this.loadNode(r);
                      break;
                    case "mesh":
                      a = this.loadMesh(r);
                      break;
                    case "accessor":
                      a = this.loadAccessor(r);
                      break;
                    case "bufferView":
                      a = this.loadBufferView(r);
                      break;
                    case "buffer":
                      a = this.loadBuffer(r);
                      break;
                    case "material":
                      a = this.loadMaterial(r);
                      break;
                    case "texture":
                      a = this.loadTexture(r);
                      break;
                    case "skin":
                      a = this.loadSkin(r);
                      break;
                    case "animation":
                      a = this.loadAnimation(r);
                      break;
                    case "camera":
                      a = this.loadCamera(r);
                      break;
                    default:
                      throw new Error("Unknown type: " + e);
                  }
                  this.cache.add(t, a);
                }
                return a;
              }),
              (L.prototype.getDependencies = function (e) {
                var r = this.cache.get(e);
                if (!r) {
                  var t = this,
                    a = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                  (r = Promise.all(
                    a.map(function (r, a) {
                      return t.getDependency(e, a);
                    })
                  )),
                    this.cache.add(e, r);
                }
                return r;
              }),
              (L.prototype.getMultiDependencies = function (e) {
                for (var r = {}, t = [], a = 0, n = e.length; a < n; a++) {
                  var i = e[a],
                    s = this.getDependencies(i);
                  (s = s.then(
                    function (e, t) {
                      r[e] = t;
                    }.bind(this, i + ("mesh" === i ? "es" : "s"))
                  )),
                    t.push(s);
                }
                return Promise.all(t).then(function () {
                  return r;
                });
              }),
              (L.prototype.loadBuffer = function (e) {
                var r = this.json.buffers[e],
                  t = this.fileLoader;
                if (r.type && "arraybuffer" !== r.type)
                  throw new Error(
                    "THREE.GLTFLoader: " +
                      r.type +
                      " buffer type is not supported."
                  );
                if (void 0 === r.uri && 0 === e)
                  return Promise.resolve(
                    this.extensions[H.KHR_BINARY_GLTF].body
                  );
                var a = this.options;
                return new Promise(function (e, n) {
                  t.load(u(r.uri, a.path), e, void 0, function () {
                    n(
                      new Error(
                        'THREE.GLTFLoader: Failed to load buffer "' +
                          r.uri +
                          '".'
                      )
                    );
                  });
                });
              }),
              (L.prototype.loadBufferView = function (e) {
                var r = this.json.bufferViews[e];
                return this.getDependency("buffer", r.buffer).then(function (
                  e
                ) {
                  var t = r.byteLength || 0,
                    a = r.byteOffset || 0;
                  return e.slice(a, a + t);
                });
              }),
              (L.prototype.loadAccessor = function (e) {
                var r = this,
                  t = this.json,
                  a = this.json.accessors[e];
                if (void 0 === a.bufferView && void 0 === a.sparse) return null;
                var n = [];
                return (
                  void 0 !== a.bufferView
                    ? n.push(this.getDependency("bufferView", a.bufferView))
                    : n.push(null),
                  void 0 !== a.sparse &&
                    (n.push(
                      this.getDependency(
                        "bufferView",
                        a.sparse.indices.bufferView
                      )
                    ),
                    n.push(
                      this.getDependency(
                        "bufferView",
                        a.sparse.values.bufferView
                      )
                    )),
                  Promise.all(n).then(function (e) {
                    var n,
                      i,
                      s = e[0],
                      o = G[a.type],
                      l = x[a.componentType],
                      u = l.BYTES_PER_ELEMENT,
                      p = u * o,
                      c = a.byteOffset || 0,
                      d = t.bufferViews[a.bufferView].byteStride,
                      h = !0 === a.normalized;
                    if (d && d !== p) {
                      var E =
                          "InterleavedBuffer:" +
                          a.bufferView +
                          ":" +
                          a.componentType,
                        f = r.cache.get(E);
                      f ||
                        ((n = new l(s)),
                        (f = new THREE.InterleavedBuffer(n, d / u)),
                        r.cache.add(E, f)),
                        (i = new THREE.InterleavedBufferAttribute(
                          f,
                          o,
                          c / u,
                          h
                        ));
                    } else (n = null === s ? new l(a.count * o) : new l(s, c, a.count * o)), (i = new THREE.BufferAttribute(n, o, h));
                    if (void 0 !== a.sparse) {
                      var m = G.SCALAR,
                        v = x[a.sparse.indices.componentType],
                        T = a.sparse.indices.byteOffset || 0,
                        g = a.sparse.values.byteOffset || 0,
                        R = new v(e[1], T, a.sparse.count * m),
                        M = new l(e[2], g, a.sparse.count * o);
                      null !== s && i.setArray(i.array.slice());
                      for (var S = 0, L = R.length; S < L; S++) {
                        var y = R[S];
                        if (
                          (i.setX(y, M[S * o]),
                          o >= 2 && i.setY(y, M[S * o + 1]),
                          o >= 3 && i.setZ(y, M[S * o + 2]),
                          o >= 4 && i.setW(y, M[S * o + 3]),
                          o >= 5)
                        )
                          throw new Error(
                            "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                          );
                      }
                    }
                    return i;
                  })
                );
              }),
              (L.prototype.loadTexture = function (e) {
                var r,
                  t = this,
                  a = this.json,
                  n = this.options,
                  i = this.textureLoader,
                  s = window.URL || window.webkitURL,
                  o = a.textures[e],
                  l = o.extensions || {};
                r = l[H.MSFT_TEXTURE_DDS]
                  ? a.images[l[H.MSFT_TEXTURE_DDS].source]
                  : a.images[o.source];
                var p = r.uri,
                  c = !1;
                return (
                  void 0 !== r.bufferView &&
                    (p = t
                      .getDependency("bufferView", r.bufferView)
                      .then(function (e) {
                        c = !0;
                        var t = new Blob([e], { type: r.mimeType });
                        return (p = s.createObjectURL(t));
                      })),
                  Promise.resolve(p)
                    .then(function (e) {
                      var r = THREE.Loader.Handlers.get(e);
                      return (
                        r ||
                          (r = l[H.MSFT_TEXTURE_DDS]
                            ? t.extensions[H.MSFT_TEXTURE_DDS].ddsLoader
                            : i),
                        new Promise(function (t, a) {
                          r.load(u(e, n.path), t, void 0, a);
                        })
                      );
                    })
                    .then(function (e) {
                      !0 === c && s.revokeObjectURL(p),
                        (e.flipY = !1),
                        void 0 !== o.name && (e.name = o.name);
                      var r = a.samplers || {},
                        t = r[o.sampler] || {};
                      return (
                        (e.magFilter = I[t.magFilter] || THREE.LinearFilter),
                        (e.minFilter =
                          I[t.minFilter] || THREE.LinearMipMapLinearFilter),
                        (e.wrapS = F[t.wrapS] || THREE.RepeatWrapping),
                        (e.wrapT = F[t.wrapT] || THREE.RepeatWrapping),
                        e
                      );
                    })
                );
              }),
              (L.prototype.assignTexture = function (e, r, t) {
                return this.getDependency("texture", t).then(function (t) {
                  e[r] = t;
                });
              }),
              (L.prototype.loadMaterial = function (e) {
                var r,
                  t = this,
                  a = (this.json, this.extensions),
                  n = this.json.materials[e],
                  i = {},
                  s = n.extensions || {},
                  o = [];
                if (s[H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                  var l = a[H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                  (r = l.getMaterialType(n)), o.push(l.extendParams(i, n, t));
                } else if (s[H.KHR_MATERIALS_UNLIT]) {
                  var u = a[H.KHR_MATERIALS_UNLIT];
                  (r = u.getMaterialType(n)), o.push(u.extendParams(i, n, t));
                } else {
                  r = THREE.MeshStandardMaterial;
                  var p = n.pbrMetallicRoughness || {};
                  if (
                    ((i.color = new THREE.Color(1, 1, 1)),
                    (i.opacity = 1),
                    Array.isArray(p.baseColorFactor))
                  ) {
                    var h = p.baseColorFactor;
                    i.color.fromArray(h), (i.opacity = h[3]);
                  }
                  if (
                    (void 0 !== p.baseColorTexture &&
                      o.push(
                        t.assignTexture(i, "map", p.baseColorTexture.index)
                      ),
                    (i.metalness =
                      void 0 !== p.metallicFactor ? p.metallicFactor : 1),
                    (i.roughness =
                      void 0 !== p.roughnessFactor ? p.roughnessFactor : 1),
                    void 0 !== p.metallicRoughnessTexture)
                  ) {
                    var E = p.metallicRoughnessTexture.index;
                    o.push(t.assignTexture(i, "metalnessMap", E)),
                      o.push(t.assignTexture(i, "roughnessMap", E));
                  }
                }
                !0 === n.doubleSided && (i.side = THREE.DoubleSide);
                var f = n.alphaMode || C.OPAQUE;
                return (
                  f === C.BLEND
                    ? (i.transparent = !0)
                    : ((i.transparent = !1),
                      f === C.MASK &&
                        (i.alphaTest =
                          void 0 !== n.alphaCutoff ? n.alphaCutoff : 0.5)),
                  void 0 !== n.normalTexture &&
                    r !== THREE.MeshBasicMaterial &&
                    (o.push(
                      t.assignTexture(i, "normalMap", n.normalTexture.index)
                    ),
                    (i.normalScale = new THREE.Vector2(1, 1)),
                    void 0 !== n.normalTexture.scale &&
                      i.normalScale.set(
                        n.normalTexture.scale,
                        n.normalTexture.scale
                      )),
                  void 0 !== n.occlusionTexture &&
                    r !== THREE.MeshBasicMaterial &&
                    (o.push(
                      t.assignTexture(i, "aoMap", n.occlusionTexture.index)
                    ),
                    void 0 !== n.occlusionTexture.strength &&
                      (i.aoMapIntensity = n.occlusionTexture.strength)),
                  void 0 !== n.emissiveFactor &&
                    r !== THREE.MeshBasicMaterial &&
                    (i.emissive = new THREE.Color().fromArray(
                      n.emissiveFactor
                    )),
                  void 0 !== n.emissiveTexture &&
                    r !== THREE.MeshBasicMaterial &&
                    o.push(
                      t.assignTexture(i, "emissiveMap", n.emissiveTexture.index)
                    ),
                  Promise.all(o).then(function () {
                    var e;
                    return (
                      (e =
                        r === THREE.ShaderMaterial
                          ? a[
                              H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                            ].createMaterial(i)
                          : new r(i)),
                      void 0 !== n.name && (e.name = n.name),
                      e.normalScale && (e.normalScale.y = -e.normalScale.y),
                      e.map && (e.map.encoding = THREE.sRGBEncoding),
                      e.emissiveMap &&
                        (e.emissiveMap.encoding = THREE.sRGBEncoding),
                      e.specularMap &&
                        (e.specularMap.encoding = THREE.sRGBEncoding),
                      d(e, n),
                      n.extensions && c(a, e, n),
                      e
                    );
                  })
                );
              }),
              (L.prototype.loadGeometries = function (e) {
                var r,
                  t = this,
                  a = this.extensions,
                  n = this.primitiveCache,
                  i = S(e);
                return (
                  i && ((r = e), (e = [e[0]])),
                  this.getDependencies("accessor").then(function (s) {
                    for (var o = [], l = 0, u = e.length; l < u; l++) {
                      var p = e[l],
                        c = T(n, p);
                      if (c) o.push(c);
                      else if (
                        p.extensions &&
                        p.extensions[H.KHR_DRACO_MESH_COMPRESSION]
                      ) {
                        var d = a[H.KHR_DRACO_MESH_COMPRESSION]
                          .decodePrimitive(p, t)
                          .then(function (e) {
                            return y(e, p, s), e;
                          });
                        n.push({ primitive: p, promise: d }), o.push(d);
                      } else {
                        var h = new THREE.BufferGeometry();
                        y(h, p, s);
                        var d = Promise.resolve(h);
                        n.push({ primitive: p, promise: d }), o.push(d);
                      }
                    }
                    return Promise.all(o).then(function (a) {
                      if (i) {
                        var n = a[0],
                          o = t.multiPassGeometryCache,
                          l = R(o, n, r);
                        if (null !== l) return [l.geometry];
                        var u = new THREE.BufferGeometry();
                        (u.name = n.name), (u.userData = n.userData);
                        for (var p in n.attributes)
                          u.addAttribute(p, n.attributes[p]);
                        for (var p in n.morphAttributes)
                          u.morphAttributes[p] = n.morphAttributes[p];
                        for (
                          var c = [], d = 0, h = 0, E = r.length;
                          h < E;
                          h++
                        ) {
                          for (
                            var f = s[r[h].indices], m = 0, v = f.count;
                            m < v;
                            m++
                          )
                            c.push(f.array[m]);
                          u.addGroup(d, f.count, h), (d += f.count);
                        }
                        return (
                          u.setIndex(c),
                          o.push({
                            geometry: u,
                            baseGeometry: n,
                            primitives: r,
                          }),
                          [u]
                        );
                      }
                      if (
                        a.length > 1 &&
                        void 0 !== THREE.BufferGeometryUtils
                      ) {
                        for (var h = 1, E = e.length; h < E; h++)
                          if (e[0].mode !== e[h].mode) return a;
                        var o = t.multiplePrimitivesCache,
                          l = g(o, a);
                        if (l) {
                          if (null !== l.geometry) return [l.geometry];
                        } else {
                          var u =
                            THREE.BufferGeometryUtils.mergeBufferGeometries(
                              a,
                              !0
                            );
                          if (
                            (o.push({ geometry: u, baseGeometries: a }),
                            null !== u)
                          )
                            return [u];
                        }
                      }
                      return a;
                    });
                  })
                );
              }),
              (L.prototype.loadMesh = function (e) {
                var r = this,
                  t = (this.json, this.extensions),
                  a = this.json.meshes[e];
                return this.getMultiDependencies(["accessor", "material"]).then(
                  function (n) {
                    for (
                      var i = a.primitives, s = [], o = 0, l = i.length;
                      o < l;
                      o++
                    )
                      s[o] =
                        void 0 === i[o].material
                          ? p()
                          : n.materials[i[o].material];
                    return r.loadGeometries(i).then(function (n) {
                      for (
                        var o = 1 === n.length && n[0].groups.length > 0,
                          l = [],
                          u = 0,
                          p = n.length;
                        u < p;
                        u++
                      ) {
                        var c,
                          h = n[u],
                          f = i[u],
                          m = o ? s : s[u];
                        if (
                          f.mode === w.TRIANGLES ||
                          f.mode === w.TRIANGLE_STRIP ||
                          f.mode === w.TRIANGLE_FAN ||
                          void 0 === f.mode
                        )
                          (c =
                            !0 === a.isSkinnedMesh
                              ? new THREE.SkinnedMesh(h, m)
                              : new THREE.Mesh(h, m)),
                            f.mode === w.TRIANGLE_STRIP
                              ? (c.drawMode = THREE.TriangleStripDrawMode)
                              : f.mode === w.TRIANGLE_FAN &&
                                (c.drawMode = THREE.TriangleFanDrawMode);
                        else if (f.mode === w.LINES)
                          c = new THREE.LineSegments(h, m);
                        else if (f.mode === w.LINE_STRIP)
                          c = new THREE.Line(h, m);
                        else if (f.mode === w.LINE_LOOP)
                          c = new THREE.LineLoop(h, m);
                        else {
                          if (f.mode !== w.POINTS)
                            throw new Error(
                              "THREE.GLTFLoader: Primitive mode unsupported: " +
                                f.mode
                            );
                          c = new THREE.Points(h, m);
                        }
                        Object.keys(c.geometry.morphAttributes).length > 0 &&
                          E(c, a),
                          (c.name = a.name || "mesh_" + e),
                          n.length > 1 && (c.name += "_" + u),
                          d(c, a),
                          l.push(c);
                        for (
                          var v = o ? c.material : [c.material],
                            T = void 0 !== h.attributes.color,
                            g = void 0 === h.attributes.normal,
                            R = !0 === c.isSkinnedMesh,
                            M = Object.keys(h.morphAttributes).length > 0,
                            S = M && void 0 !== h.morphAttributes.normal,
                            L = 0,
                            y = v.length;
                          L < y;
                          L++
                        ) {
                          var m = v[L];
                          if (c.isPoints) {
                            var A = "PointsMaterial:" + m.uuid,
                              _ = r.cache.get(A);
                            _ ||
                              ((_ = new THREE.PointsMaterial()),
                              THREE.Material.prototype.copy.call(_, m),
                              _.color.copy(m.color),
                              (_.map = m.map),
                              (_.lights = !1),
                              r.cache.add(A, _)),
                              (m = _);
                          } else if (c.isLine) {
                            var A = "LineBasicMaterial:" + m.uuid,
                              b = r.cache.get(A);
                            b ||
                              ((b = new THREE.LineBasicMaterial()),
                              THREE.Material.prototype.copy.call(b, m),
                              b.color.copy(m.color),
                              (b.lights = !1),
                              r.cache.add(A, b)),
                              (m = b);
                          }
                          if (T || g || R || M) {
                            var A = "ClonedMaterial:" + m.uuid + ":";
                            m.isGLTFSpecularGlossinessMaterial &&
                              (A += "specular-glossiness:"),
                              R && (A += "skinning:"),
                              T && (A += "vertex-colors:"),
                              g && (A += "flat-shading:"),
                              M && (A += "morph-targets:"),
                              S && (A += "morph-normals:");
                            var x = r.cache.get(A);
                            x ||
                              ((x = m.isGLTFSpecularGlossinessMaterial
                                ? t[
                                    H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                                  ].cloneMaterial(m)
                                : m.clone()),
                              R && (x.skinning = !0),
                              T && (x.vertexColors = THREE.VertexColors),
                              g && (x.flatShading = !0),
                              M && (x.morphTargets = !0),
                              S && (x.morphNormals = !0),
                              r.cache.add(A, x)),
                              (m = x);
                          }
                          (v[L] = m),
                            m.aoMap &&
                              void 0 === h.attributes.uv2 &&
                              void 0 !== h.attributes.uv &&
                              (console.log(
                                "THREE.GLTFLoader: Duplicating UVs to support aoMap."
                              ),
                              h.addAttribute(
                                "uv2",
                                new THREE.BufferAttribute(
                                  h.attributes.uv.array,
                                  2
                                )
                              )),
                            m.isGLTFSpecularGlossinessMaterial &&
                              (c.onBeforeRender =
                                t[
                                  H.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                                ].refreshUniforms);
                        }
                        c.material = o ? v : v[0];
                      }
                      if (1 === l.length) return l[0];
                      for (
                        var I = new THREE.Group(), u = 0, p = l.length;
                        u < p;
                        u++
                      )
                        I.add(l[u]);
                      return I;
                    });
                  }
                );
              }),
              (L.prototype.loadCamera = function (e) {
                var r,
                  t = this.json.cameras[e],
                  a = t[t.type];
                return a
                  ? ("perspective" === t.type
                      ? (r = new THREE.PerspectiveCamera(
                          THREE.Math.radToDeg(a.yfov),
                          a.aspectRatio || 1,
                          a.znear || 1,
                          a.zfar || 2e6
                        ))
                      : "orthographic" === t.type &&
                        (r = new THREE.OrthographicCamera(
                          a.xmag / -2,
                          a.xmag / 2,
                          a.ymag / 2,
                          a.ymag / -2,
                          a.znear,
                          a.zfar
                        )),
                    void 0 !== t.name && (r.name = t.name),
                    d(r, t),
                    Promise.resolve(r))
                  : void console.warn(
                      "THREE.GLTFLoader: Missing camera parameters."
                    );
              }),
              (L.prototype.loadSkin = function (e) {
                var r = this.json.skins[e],
                  t = { joints: r.joints };
                return void 0 === r.inverseBindMatrices
                  ? Promise.resolve(t)
                  : this.getDependency("accessor", r.inverseBindMatrices).then(
                      function (e) {
                        return (t.inverseBindMatrices = e), t;
                      }
                    );
              }),
              (L.prototype.loadAnimation = function (e) {
                var r = (this.json, this.json.animations[e]);
                return this.getMultiDependencies(["accessor", "node"]).then(
                  function (t) {
                    for (var a = [], n = 0, i = r.channels.length; n < i; n++) {
                      var s = r.channels[n],
                        o = r.samplers[s.sampler];
                      if (o) {
                        var u = s.target,
                          p = void 0 !== u.node ? u.node : u.id,
                          c =
                            void 0 !== r.parameters
                              ? r.parameters[o.input]
                              : o.input,
                          d =
                            void 0 !== r.parameters
                              ? r.parameters[o.output]
                              : o.output,
                          h = t.accessors[c],
                          E = t.accessors[d],
                          f = t.nodes[p];
                        if (f) {
                          f.updateMatrix(), (f.matrixAutoUpdate = !0);
                          var m;
                          switch (N[u.path]) {
                            case N.weights:
                              m = THREE.NumberKeyframeTrack;
                              break;
                            case N.rotation:
                              m = THREE.QuaternionKeyframeTrack;
                              break;
                            case N.position:
                            case N.scale:
                            default:
                              m = THREE.VectorKeyframeTrack;
                          }
                          var v = f.name ? f.name : f.uuid,
                            T =
                              void 0 !== o.interpolation
                                ? U[o.interpolation]
                                : THREE.InterpolateLinear,
                            g = [];
                          N[u.path] === N.weights
                            ? f.traverse(function (e) {
                                !0 === e.isMesh &&
                                  e.morphTargetInfluences &&
                                  g.push(e.name ? e.name : e.uuid);
                              })
                            : g.push(v);
                          for (var R = 0, M = g.length; R < M; R++) {
                            var S = new m(
                              g[R] + "." + N[u.path],
                              THREE.AnimationUtils.arraySlice(h.array, 0),
                              THREE.AnimationUtils.arraySlice(E.array, 0),
                              T
                            );
                            "CUBICSPLINE" === o.interpolation &&
                              ((S.createInterpolant = function (e) {
                                return new l(
                                  this.times,
                                  this.values,
                                  this.getValueSize() / 3,
                                  e
                                );
                              }),
                              (S.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                                !0)),
                              a.push(S);
                          }
                        }
                      }
                    }
                    var p = void 0 !== r.name ? r.name : "animation_" + e;
                    return new THREE.AnimationClip(p, void 0, a);
                  }
                );
              }),
              (L.prototype.loadNode = function (e) {
                var r = (this.json, this.extensions),
                  t = this.json.meshReferences,
                  a = this.json.meshUses,
                  n = this.json.nodes[e];
                return this.getMultiDependencies([
                  "mesh",
                  "skin",
                  "camera",
                  "light",
                ]).then(function (e) {
                  var i;
                  if (!0 === n.isBone) i = new THREE.Bone();
                  else if (void 0 !== n.mesh) {
                    var s = e.meshes[n.mesh];
                    if (t[n.mesh] > 1) {
                      var o = a[n.mesh]++;
                      (i = s.clone()),
                        (i.name += "_instance_" + o),
                        (i.onBeforeRender = s.onBeforeRender);
                      for (var l = 0, u = i.children.length; l < u; l++)
                        (i.children[l].name += "_instance_" + o),
                          (i.children[l].onBeforeRender =
                            s.children[l].onBeforeRender);
                    } else i = s;
                  } else if (void 0 !== n.camera) i = e.cameras[n.camera];
                  else if (
                    n.extensions &&
                    n.extensions[H.KHR_LIGHTS_PUNCTUAL] &&
                    void 0 !== n.extensions[H.KHR_LIGHTS_PUNCTUAL].light
                  ) {
                    var p = r[H.KHR_LIGHTS_PUNCTUAL].lights;
                    i = p[n.extensions[H.KHR_LIGHTS_PUNCTUAL].light];
                  } else i = new THREE.Object3D();
                  if (
                    (void 0 !== n.name &&
                      (i.name = THREE.PropertyBinding.sanitizeNodeName(n.name)),
                    d(i, n),
                    n.extensions && c(r, i, n),
                    void 0 !== n.matrix)
                  ) {
                    var h = new THREE.Matrix4();
                    h.fromArray(n.matrix), i.applyMatrix(h);
                  } else void 0 !== n.translation && i.position.fromArray(n.translation), void 0 !== n.rotation && i.quaternion.fromArray(n.rotation), void 0 !== n.scale && i.scale.fromArray(n.scale);
                  return i;
                });
              }),
              (L.prototype.loadScene = (function () {
                function e(r, t, a, n, i) {
                  var s = n[r],
                    o = a.nodes[r];
                  if (void 0 !== o.skin)
                    for (
                      var l = !0 === s.isGroup ? s.children : [s],
                        u = 0,
                        p = l.length;
                      u < p;
                      u++
                    ) {
                      for (
                        var c = l[u],
                          d = i[o.skin],
                          h = [],
                          E = [],
                          f = 0,
                          m = d.joints.length;
                        f < m;
                        f++
                      ) {
                        var v = d.joints[f],
                          T = n[v];
                        if (T) {
                          h.push(T);
                          var g = new THREE.Matrix4();
                          void 0 !== d.inverseBindMatrices &&
                            g.fromArray(d.inverseBindMatrices.array, 16 * f),
                            E.push(g);
                        } else
                          console.warn(
                            'THREE.GLTFLoader: Joint "%s" could not be found.',
                            v
                          );
                      }
                      c.bind(new THREE.Skeleton(h, E), c.matrixWorld);
                    }
                  if ((t.add(s), o.children))
                    for (var R = o.children, u = 0, p = R.length; u < p; u++) {
                      var M = R[u];
                      e(M, s, a, n, i);
                    }
                }
                return function (r) {
                  var t = this.json,
                    a = this.extensions,
                    n = this.json.scenes[r];
                  return this.getMultiDependencies(["node", "skin"]).then(
                    function (r) {
                      var i = new THREE.Scene();
                      void 0 !== n.name && (i.name = n.name),
                        d(i, n),
                        n.extensions && c(a, i, n);
                      for (
                        var s = n.nodes || [], o = 0, l = s.length;
                        o < l;
                        o++
                      )
                        e(s[o], i, t, r.nodes, r.skins);
                      return i;
                    }
                  );
                };
              })()),
              e
            );
          })();
        },
        {},
      ],
      42: [
        function (_dereq_, module, exports) {
          (THREE.MTLLoader = function (t) {
            this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager;
          }),
            (THREE.MTLLoader.prototype = {
              constructor: THREE.MTLLoader,
              load: function (t, r, a, e) {
                var s = this,
                  i = new THREE.FileLoader(this.manager);
                i.setPath(this.path),
                  i.load(
                    t,
                    function (t) {
                      r(s.parse(t));
                    },
                    a,
                    e
                  );
              },
              setPath: function (t) {
                return (this.path = t), this;
              },
              setTexturePath: function (t) {
                return (this.texturePath = t), this;
              },
              setBaseUrl: function (t) {
                return (
                  console.warn(
                    "THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead."
                  ),
                  this.setTexturePath(t)
                );
              },
              setCrossOrigin: function (t) {
                return (this.crossOrigin = t), this;
              },
              setMaterialOptions: function (t) {
                return (this.materialOptions = t), this;
              },
              parse: function (t) {
                for (
                  var r = t.split("\n"), a = {}, e = /\s+/, s = {}, i = 0;
                  i < r.length;
                  i++
                ) {
                  var o = r[i];
                  if (((o = o.trim()), 0 !== o.length && "#" !== o.charAt(0))) {
                    var n = o.indexOf(" "),
                      h = n >= 0 ? o.substring(0, n) : o;
                    h = h.toLowerCase();
                    var p = n >= 0 ? o.substring(n + 1) : "";
                    if (((p = p.trim()), "newmtl" === h))
                      (a = { name: p }), (s[p] = a);
                    else if (a)
                      if ("ka" === h || "kd" === h || "ks" === h) {
                        var l = p.split(e, 3);
                        a[h] = [
                          parseFloat(l[0]),
                          parseFloat(l[1]),
                          parseFloat(l[2]),
                        ];
                      } else a[h] = p;
                  }
                }
                var c = new THREE.MTLLoader.MaterialCreator(
                  this.texturePath || this.path,
                  this.materialOptions
                );
                return (
                  c.setCrossOrigin(this.crossOrigin),
                  c.setManager(this.manager),
                  c.setMaterials(s),
                  c
                );
              },
            }),
            (THREE.MTLLoader.MaterialCreator = function (t, r) {
              (this.baseUrl = t || ""),
                (this.options = r),
                (this.materialsInfo = {}),
                (this.materials = {}),
                (this.materialsArray = []),
                (this.nameLookup = {}),
                (this.side =
                  this.options && this.options.side
                    ? this.options.side
                    : THREE.FrontSide),
                (this.wrap =
                  this.options && this.options.wrap
                    ? this.options.wrap
                    : THREE.RepeatWrapping);
            }),
            (THREE.MTLLoader.MaterialCreator.prototype = {
              constructor: THREE.MTLLoader.MaterialCreator,
              crossOrigin: "anonymous",
              setCrossOrigin: function (t) {
                return (this.crossOrigin = t), this;
              },
              setManager: function (t) {
                this.manager = t;
              },
              setMaterials: function (t) {
                (this.materialsInfo = this.convert(t)),
                  (this.materials = {}),
                  (this.materialsArray = []),
                  (this.nameLookup = {});
              },
              convert: function (t) {
                if (!this.options) return t;
                var r = {};
                for (var a in t) {
                  var e = t[a],
                    s = {};
                  r[a] = s;
                  for (var i in e) {
                    var o = !0,
                      n = e[i],
                      h = i.toLowerCase();
                    switch (h) {
                      case "kd":
                      case "ka":
                      case "ks":
                        this.options &&
                          this.options.normalizeRGB &&
                          (n = [n[0] / 255, n[1] / 255, n[2] / 255]),
                          this.options &&
                            this.options.ignoreZeroRGBs &&
                            0 === n[0] &&
                            0 === n[1] &&
                            0 === n[2] &&
                            (o = !1);
                    }
                    o && (s[h] = n);
                  }
                }
                return r;
              },
              preload: function () {
                for (var t in this.materialsInfo) this.create(t);
              },
              getIndex: function (t) {
                return this.nameLookup[t];
              },
              getAsArray: function () {
                var t = 0;
                for (var r in this.materialsInfo)
                  (this.materialsArray[t] = this.create(r)),
                    (this.nameLookup[r] = t),
                    t++;
                return this.materialsArray;
              },
              create: function (t) {
                return (
                  void 0 === this.materials[t] && this.createMaterial_(t),
                  this.materials[t]
                );
              },
              createMaterial_: function (t) {
                function r(t, r) {
                  return "string" != typeof r || "" === r
                    ? ""
                    : /^https?:\/\//i.test(r)
                    ? r
                    : t + r;
                }
                function a(t, a) {
                  if (!i[t]) {
                    var s = e.getTextureParams(a, i),
                      o = e.loadTexture(r(e.baseUrl, s.url));
                    o.repeat.copy(s.scale),
                      o.offset.copy(s.offset),
                      (o.wrapS = e.wrap),
                      (o.wrapT = e.wrap),
                      (i[t] = o);
                  }
                }
                var e = this,
                  s = this.materialsInfo[t],
                  i = { name: t, side: this.side };
                for (var o in s) {
                  var n,
                    h = s[o];
                  if ("" !== h)
                    switch (o.toLowerCase()) {
                      case "kd":
                        i.color = new THREE.Color().fromArray(h);
                        break;
                      case "ks":
                        i.specular = new THREE.Color().fromArray(h);
                        break;
                      case "map_kd":
                        a("map", h);
                        break;
                      case "map_ks":
                        a("specularMap", h);
                        break;
                      case "norm":
                        a("normalMap", h);
                        break;
                      case "map_bump":
                      case "bump":
                        a("bumpMap", h);
                        break;
                      case "ns":
                        i.shininess = parseFloat(h);
                        break;
                      case "d":
                        (n = parseFloat(h)),
                          n < 1 && ((i.opacity = n), (i.transparent = !0));
                        break;
                      case "tr":
                        (n = parseFloat(h)),
                          this.options &&
                            this.options.invertTrProperty &&
                            (n = 1 - n),
                          n > 0 && ((i.opacity = 1 - n), (i.transparent = !0));
                    }
                }
                return (
                  (this.materials[t] = new THREE.MeshPhongMaterial(i)),
                  this.materials[t]
                );
              },
              getTextureParams: function (t, r) {
                var a,
                  e = {
                    scale: new THREE.Vector2(1, 1),
                    offset: new THREE.Vector2(0, 0),
                  },
                  s = t.split(/\s+/);
                return (
                  (a = s.indexOf("-bm")),
                  a >= 0 &&
                    ((r.bumpScale = parseFloat(s[a + 1])), s.splice(a, 2)),
                  (a = s.indexOf("-s")),
                  a >= 0 &&
                    (e.scale.set(parseFloat(s[a + 1]), parseFloat(s[a + 2])),
                    s.splice(a, 4)),
                  (a = s.indexOf("-o")),
                  a >= 0 &&
                    (e.offset.set(parseFloat(s[a + 1]), parseFloat(s[a + 2])),
                    s.splice(a, 4)),
                  (e.url = s.join(" ").trim()),
                  e
                );
              },
              loadTexture: function (t, r, a, e, s) {
                var i,
                  o = THREE.Loader.Handlers.get(t),
                  n =
                    void 0 !== this.manager
                      ? this.manager
                      : THREE.DefaultLoadingManager;
                return (
                  null === o && (o = new THREE.TextureLoader(n)),
                  o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin),
                  (i = o.load(t, a, e, s)),
                  void 0 !== r && (i.mapping = r),
                  i
                );
              },
            });
        },
        {},
      ],
      43: [
        function (_dereq_, module, exports) {
          THREE.OBJLoader = (function () {
            function t() {
              var t = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function (t, e) {
                  if (this.object && !1 === this.object.fromDeclaration)
                    return (
                      (this.object.name = t),
                      void (this.object.fromDeclaration = !1 !== e)
                    );
                  var r =
                    this.object &&
                    "function" == typeof this.object.currentMaterial
                      ? this.object.currentMaterial()
                      : void 0;
                  if (
                    (this.object &&
                      "function" == typeof this.object._finalize &&
                      this.object._finalize(!0),
                    (this.object = {
                      name: t || "",
                      fromDeclaration: !1 !== e,
                      geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                      },
                      materials: [],
                      smooth: !0,
                      startMaterial: function (t, e) {
                        var r = this._finalize(!1);
                        r &&
                          (r.inherited || r.groupCount <= 0) &&
                          this.materials.splice(r.index, 1);
                        var i = {
                          index: this.materials.length,
                          name: t || "",
                          mtllib:
                            Array.isArray(e) && e.length > 0
                              ? e[e.length - 1]
                              : "",
                          smooth: void 0 !== r ? r.smooth : this.smooth,
                          groupStart: void 0 !== r ? r.groupEnd : 0,
                          groupEnd: -1,
                          groupCount: -1,
                          inherited: !1,
                          clone: function (t) {
                            var e = {
                              index: "number" == typeof t ? t : this.index,
                              name: this.name,
                              mtllib: this.mtllib,
                              smooth: this.smooth,
                              groupStart: 0,
                              groupEnd: -1,
                              groupCount: -1,
                              inherited: !1,
                            };
                            return (e.clone = this.clone.bind(e)), e;
                          },
                        };
                        return this.materials.push(i), i;
                      },
                      currentMaterial: function () {
                        if (this.materials.length > 0)
                          return this.materials[this.materials.length - 1];
                      },
                      _finalize: function (t) {
                        var e = this.currentMaterial();
                        if (
                          (e &&
                            -1 === e.groupEnd &&
                            ((e.groupEnd = this.geometry.vertices.length / 3),
                            (e.groupCount = e.groupEnd - e.groupStart),
                            (e.inherited = !1)),
                          t && this.materials.length > 1)
                        )
                          for (var r = this.materials.length - 1; r >= 0; r--)
                            this.materials[r].groupCount <= 0 &&
                              this.materials.splice(r, 1);
                        return (
                          t &&
                            0 === this.materials.length &&
                            this.materials.push({
                              name: "",
                              smooth: this.smooth,
                            }),
                          e
                        );
                      },
                    }),
                    r && r.name && "function" == typeof r.clone)
                  ) {
                    var i = r.clone(0);
                    (i.inherited = !0), this.object.materials.push(i);
                  }
                  this.objects.push(this.object);
                },
                finalize: function () {
                  this.object &&
                    "function" == typeof this.object._finalize &&
                    this.object._finalize(!0);
                },
                parseVertexIndex: function (t, e) {
                  var r = parseInt(t, 10);
                  return 3 * (r >= 0 ? r - 1 : r + e / 3);
                },
                parseNormalIndex: function (t, e) {
                  var r = parseInt(t, 10);
                  return 3 * (r >= 0 ? r - 1 : r + e / 3);
                },
                parseUVIndex: function (t, e) {
                  var r = parseInt(t, 10);
                  return 2 * (r >= 0 ? r - 1 : r + e / 2);
                },
                addVertex: function (t, e, r) {
                  var i = this.vertices,
                    s = this.object.geometry.vertices;
                  s.push(i[t + 0], i[t + 1], i[t + 2]),
                    s.push(i[e + 0], i[e + 1], i[e + 2]),
                    s.push(i[r + 0], i[r + 1], i[r + 2]);
                },
                addVertexPoint: function (t) {
                  var e = this.vertices;
                  this.object.geometry.vertices.push(
                    e[t + 0],
                    e[t + 1],
                    e[t + 2]
                  );
                },
                addVertexLine: function (t) {
                  var e = this.vertices;
                  this.object.geometry.vertices.push(
                    e[t + 0],
                    e[t + 1],
                    e[t + 2]
                  );
                },
                addNormal: function (t, e, r) {
                  var i = this.normals,
                    s = this.object.geometry.normals;
                  s.push(i[t + 0], i[t + 1], i[t + 2]),
                    s.push(i[e + 0], i[e + 1], i[e + 2]),
                    s.push(i[r + 0], i[r + 1], i[r + 2]);
                },
                addColor: function (t, e, r) {
                  var i = this.colors,
                    s = this.object.geometry.colors;
                  s.push(i[t + 0], i[t + 1], i[t + 2]),
                    s.push(i[e + 0], i[e + 1], i[e + 2]),
                    s.push(i[r + 0], i[r + 1], i[r + 2]);
                },
                addUV: function (t, e, r) {
                  var i = this.uvs,
                    s = this.object.geometry.uvs;
                  s.push(i[t + 0], i[t + 1]),
                    s.push(i[e + 0], i[e + 1]),
                    s.push(i[r + 0], i[r + 1]);
                },
                addUVLine: function (t) {
                  var e = this.uvs;
                  this.object.geometry.uvs.push(e[t + 0], e[t + 1]);
                },
                addFace: function (t, e, r, i, s, a, n, o, h) {
                  var l = this.vertices.length,
                    u = this.parseVertexIndex(t, l),
                    c = this.parseVertexIndex(e, l),
                    p = this.parseVertexIndex(r, l);
                  if ((this.addVertex(u, c, p), void 0 !== i && "" !== i)) {
                    var m = this.uvs.length;
                    (u = this.parseUVIndex(i, m)),
                      (c = this.parseUVIndex(s, m)),
                      (p = this.parseUVIndex(a, m)),
                      this.addUV(u, c, p);
                  }
                  if (void 0 !== n && "" !== n) {
                    var f = this.normals.length;
                    (u = this.parseNormalIndex(n, f)),
                      (c = n === o ? u : this.parseNormalIndex(o, f)),
                      (p = n === h ? u : this.parseNormalIndex(h, f)),
                      this.addNormal(u, c, p);
                  }
                  this.colors.length > 0 && this.addColor(u, c, p);
                },
                addPointGeometry: function (t) {
                  this.object.geometry.type = "Points";
                  for (
                    var e = this.vertices.length, r = 0, i = t.length;
                    r < i;
                    r++
                  )
                    this.addVertexPoint(this.parseVertexIndex(t[r], e));
                },
                addLineGeometry: function (t, e) {
                  this.object.geometry.type = "Line";
                  for (
                    var r = this.vertices.length,
                      i = this.uvs.length,
                      s = 0,
                      a = t.length;
                    s < a;
                    s++
                  )
                    this.addVertexLine(this.parseVertexIndex(t[s], r));
                  for (var n = 0, a = e.length; n < a; n++)
                    this.addUVLine(this.parseUVIndex(e[n], i));
                },
              };
              return t.startObject("", !1), t;
            }
            function e(t) {
              (this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager),
                (this.materials = null);
            }
            var r = /^[og]\s*(.+)?/,
              i = /^mtllib /,
              s = /^usemtl /;
            return (
              (e.prototype = {
                constructor: e,
                load: function (t, e, r, i) {
                  var s = this,
                    a = new THREE.FileLoader(s.manager);
                  a.setPath(this.path),
                    a.load(
                      t,
                      function (t) {
                        e(s.parse(t));
                      },
                      r,
                      i
                    );
                },
                setPath: function (t) {
                  return (this.path = t), this;
                },
                setMaterials: function (t) {
                  return (this.materials = t), this;
                },
                parse: function (e) {
                  console.time("OBJLoader");
                  var a = new t();
                  -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
                    -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
                  for (
                    var n = e.split("\n"),
                      o = "",
                      h = "",
                      l = [],
                      u = "function" == typeof "".trimLeft,
                      c = 0,
                      p = n.length;
                    c < p;
                    c++
                  )
                    if (
                      ((o = n[c]),
                      (o = u ? o.trimLeft() : o.trim()),
                      0 !== o.length && "#" !== (h = o.charAt(0)))
                    )
                      if ("v" === h) {
                        var m = o.split(/\s+/);
                        switch (m[0]) {
                          case "v":
                            a.vertices.push(
                              parseFloat(m[1]),
                              parseFloat(m[2]),
                              parseFloat(m[3])
                            ),
                              8 === m.length &&
                                a.colors.push(
                                  parseFloat(m[4]),
                                  parseFloat(m[5]),
                                  parseFloat(m[6])
                                );
                            break;
                          case "vn":
                            a.normals.push(
                              parseFloat(m[1]),
                              parseFloat(m[2]),
                              parseFloat(m[3])
                            );
                            break;
                          case "vt":
                            a.uvs.push(parseFloat(m[1]), parseFloat(m[2]));
                        }
                      } else if ("f" === h) {
                        for (
                          var f = o.substr(1).trim(),
                            d = f.split(/\s+/),
                            v = [],
                            g = 0,
                            b = d.length;
                          g < b;
                          g++
                        ) {
                          var E = d[g];
                          if (E.length > 0) {
                            var x = E.split("/");
                            v.push(x);
                          }
                        }
                        for (
                          var j = v[0], g = 1, b = v.length - 1;
                          g < b;
                          g++
                        ) {
                          var y = v[g],
                            L = v[g + 1];
                          a.addFace(
                            j[0],
                            y[0],
                            L[0],
                            j[1],
                            y[1],
                            L[1],
                            j[2],
                            y[2],
                            L[2]
                          );
                        }
                      } else if ("l" === h) {
                        var H = o.substring(1).trim().split(" "),
                          R = [],
                          T = [];
                        if (-1 === o.indexOf("/")) R = H;
                        else
                          for (var w = 0, V = H.length; w < V; w++) {
                            var M = H[w].split("/");
                            "" !== M[0] && R.push(M[0]),
                              "" !== M[1] && T.push(M[1]);
                          }
                        a.addLineGeometry(R, T);
                      } else if ("p" === h) {
                        var f = o.substr(1).trim(),
                          F = f.split(" ");
                        a.addPointGeometry(F);
                      } else if (null !== (l = r.exec(o))) {
                        var I = (" " + l[0].substr(1).trim()).substr(1);
                        a.startObject(I);
                      } else if (s.test(o))
                        a.object.startMaterial(
                          o.substring(7).trim(),
                          a.materialLibraries
                        );
                      else if (i.test(o))
                        a.materialLibraries.push(o.substring(7).trim());
                      else {
                        if ("s" !== h) {
                          if ("\0" === o) continue;
                          throw new Error(
                            'THREE.OBJLoader: Unexpected line: "' + o + '"'
                          );
                        }
                        if (((l = o.split(" ")), l.length > 1)) {
                          var P = l[1].trim().toLowerCase();
                          a.object.smooth = "0" !== P && "off" !== P;
                        } else a.object.smooth = !0;
                        var A = a.object.currentMaterial();
                        A && (A.smooth = a.object.smooth);
                      }
                  a.finalize();
                  var z = new THREE.Group();
                  z.materialLibraries = [].concat(a.materialLibraries);
                  for (var c = 0, p = a.objects.length; c < p; c++) {
                    var B = a.objects[c],
                      C = B.geometry,
                      O = B.materials,
                      U = "Line" === C.type,
                      N = "Points" === C.type,
                      G = !1;
                    if (0 !== C.vertices.length) {
                      var S = new THREE.BufferGeometry();
                      S.addAttribute(
                        "position",
                        new THREE.Float32BufferAttribute(C.vertices, 3)
                      ),
                        C.normals.length > 0
                          ? S.addAttribute(
                              "normal",
                              new THREE.Float32BufferAttribute(C.normals, 3)
                            )
                          : S.computeVertexNormals(),
                        C.colors.length > 0 &&
                          ((G = !0),
                          S.addAttribute(
                            "color",
                            new THREE.Float32BufferAttribute(C.colors, 3)
                          )),
                        C.uvs.length > 0 &&
                          S.addAttribute(
                            "uv",
                            new THREE.Float32BufferAttribute(C.uvs, 2)
                          );
                      for (var _ = [], D = 0, J = O.length; D < J; D++) {
                        var k = O[D],
                          A = void 0;
                        if (null !== this.materials)
                          if (
                            ((A = this.materials.create(k.name)),
                            !U || !A || A instanceof THREE.LineBasicMaterial)
                          ) {
                            if (
                              N &&
                              A &&
                              !(A instanceof THREE.PointsMaterial)
                            ) {
                              var q = new THREE.PointsMaterial({
                                size: 10,
                                sizeAttenuation: !1,
                              });
                              K.copy(A), (A = q);
                            }
                          } else {
                            var K = new THREE.LineBasicMaterial();
                            K.copy(A), (K.lights = !1), (A = K);
                          }
                        A ||
                          ((A = U
                            ? new THREE.LineBasicMaterial()
                            : N
                            ? new THREE.PointsMaterial({
                                size: 1,
                                sizeAttenuation: !1,
                              })
                            : new THREE.MeshPhongMaterial()),
                          (A.name = k.name)),
                          (A.flatShading = !k.smooth),
                          (A.vertexColors = G
                            ? THREE.VertexColors
                            : THREE.NoColors),
                          _.push(A);
                      }
                      var Q;
                      if (_.length > 1) {
                        for (var D = 0, J = O.length; D < J; D++) {
                          var k = O[D];
                          S.addGroup(k.groupStart, k.groupCount, D);
                        }
                        Q = U
                          ? new THREE.LineSegments(S, _)
                          : N
                          ? new THREE.Points(S, _)
                          : new THREE.Mesh(S, _);
                      } else
                        Q = U
                          ? new THREE.LineSegments(S, _[0])
                          : N
                          ? new THREE.Points(S, _[0])
                          : new THREE.Mesh(S, _[0]);
                      (Q.name = B.name), z.add(Q);
                    }
                  }
                  return console.timeEnd("OBJLoader"), z;
                },
              }),
              e
            );
          })();
        },
        {},
      ],
      44: [
        function (_dereq_, module, exports) {
          (function (setImmediate, clearImmediate) {
            function Timeout(e, t) {
              (this._id = e), (this._clearFn = t);
            }
            var nextTick = _dereq_("process/browser.js").nextTick,
              apply = Function.prototype.apply,
              slice = Array.prototype.slice,
              immediateIds = {},
              nextImmediateId = 0;
            (exports.setTimeout = function () {
              return new Timeout(
                apply.call(setTimeout, window, arguments),
                clearTimeout
              );
            }),
              (exports.setInterval = function () {
                return new Timeout(
                  apply.call(setInterval, window, arguments),
                  clearInterval
                );
              }),
              (exports.clearTimeout = exports.clearInterval =
                function (e) {
                  e.close();
                }),
              (Timeout.prototype.unref = Timeout.prototype.ref =
                function () {}),
              (Timeout.prototype.close = function () {
                this._clearFn.call(window, this._id);
              }),
              (exports.enroll = function (e, t) {
                clearTimeout(e._idleTimeoutId), (e._idleTimeout = t);
              }),
              (exports.unenroll = function (e) {
                clearTimeout(e._idleTimeoutId), (e._idleTimeout = -1);
              }),
              (exports._unrefActive = exports.active =
                function (e) {
                  clearTimeout(e._idleTimeoutId);
                  var t = e._idleTimeout;
                  t >= 0 &&
                    (e._idleTimeoutId = setTimeout(function () {
                      e._onTimeout && e._onTimeout();
                    }, t));
                }),
              (exports.setImmediate =
                "function" == typeof setImmediate
                  ? setImmediate
                  : function (e) {
                      var t = nextImmediateId++,
                        i = !(arguments.length < 2) && slice.call(arguments, 1);
                      return (
                        (immediateIds[t] = !0),
                        nextTick(function () {
                          immediateIds[t] &&
                            (i ? e.apply(null, i) : e.call(null),
                            exports.clearImmediate(t));
                        }),
                        t
                      );
                    }),
              (exports.clearImmediate =
                "function" == typeof clearImmediate
                  ? clearImmediate
                  : function (e) {
                      delete immediateIds[e];
                    });
          }.call(
            this,
            _dereq_("timers").setImmediate,
            _dereq_("timers").clearImmediate
          ));
        },
        { "process/browser.js": 45, timers: 44 },
      ],
      45: [
        function (_dereq_, module, exports) {
          arguments[4][6][0].apply(exports, arguments);
        },
        { dup: 6 },
      ],
      46: [
        function (_dereq_, module, exports) {
          function idxOf(e, n, r, t) {
            var i = e.indexOf(n, r);
            return -1 === i || i > t ? t : i;
          }
          function isWhitespace(e) {
            return whitespace.test(e);
          }
          function pre(e, n, r, t, i) {
            for (var a = [], o = r, s = r; s < t && s < n.length; s++) {
              var h = n.charAt(s),
                u = newline.test(h);
              if (u || s === t - 1) {
                var f = u ? s : s + 1,
                  p = e(n, o, f, i);
                a.push(p), (o = s + 1);
              }
            }
            return a;
          }
          function greedy(e, n, r, t, i, a) {
            var o = [],
              s = i;
            for (
              "nowrap" === a && (s = Number.MAX_VALUE);
              r < t && r < n.length;

            ) {
              for (
                var h = idxOf(n, newlineChar, r, t);
                r < h && isWhitespace(n.charAt(r));

              )
                r++;
              var u = e(n, r, h, s),
                f = r + (u.end - u.start),
                p = f + newlineChar.length;
              if (f < h) {
                for (; f > r && !isWhitespace(n.charAt(f)); ) f--;
                if (f === r) p > r + newlineChar.length && p--, (f = p);
                else
                  for (
                    p = f;
                    f > r && isWhitespace(n.charAt(f - newlineChar.length));

                  )
                    f--;
              }
              if (f >= r) {
                var c = e(n, r, f, s);
                o.push(c);
              }
              r = p;
            }
            return o;
          }
          function monospace(e, n, r, t) {
            return { start: n, end: n + Math.min(t, r - n) };
          }
          var newline = /\n/,
            newlineChar = "\n",
            whitespace = /\s/;
          (module.exports = function (e, n) {
            return module.exports
              .lines(e, n)
              .map(function (n) {
                return e.substring(n.start, n.end);
              })
              .join("\n");
          }),
            (module.exports.lines = function (e, n) {
              if (((n = n || {}), 0 === n.width && "nowrap" !== n.mode))
                return [];
              e = e || "";
              var r = "number" == typeof n.width ? n.width : Number.MAX_VALUE,
                t = Math.max(0, n.start || 0),
                i = "number" == typeof n.end ? n.end : e.length,
                a = n.mode,
                o = n.measure || monospace;
              return "pre" === a
                ? pre(o, e, t, i, r)
                : greedy(o, e, t, i, r, a);
            });
        },
        {},
      ],
      47: [
        function (_dereq_, module, exports) {
          "use strict";
          function forEachArray(e, t) {
            for (var r = 0; r < e.length; r++) t(e[r]);
          }
          function isEmpty(e) {
            for (var t in e) if (e.hasOwnProperty(t)) return !1;
            return !0;
          }
          function initParams(e, t, r) {
            var n = e;
            return (
              isFunction(t)
                ? ((r = t), "string" == typeof e && (n = { uri: e }))
                : (n = xtend(t, { uri: e })),
              (n.callback = r),
              n
            );
          }
          function createXHR(e, t, r) {
            return (t = initParams(e, t, r)), _createXHR(t);
          }
          function _createXHR(e) {
            function t() {
              4 === i.readyState && setTimeout(o, 0);
            }
            function r() {
              var e = void 0;
              if (
                ((e = i.response ? i.response : i.responseText || getXml(i)), X)
              )
                try {
                  e = JSON.parse(e);
                } catch (e) {}
              return e;
            }
            function n(e) {
              return (
                clearTimeout(d),
                e instanceof Error ||
                  (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))),
                (e.statusCode = 0),
                a(e, h)
              );
            }
            function o() {
              if (!c) {
                var t;
                clearTimeout(d),
                  (t =
                    e.useXDR && void 0 === i.status
                      ? 200
                      : 1223 === i.status
                      ? 204
                      : i.status);
                var n = h,
                  o = null;
                return (
                  0 !== t
                    ? ((n = {
                        body: r(),
                        statusCode: t,
                        method: l,
                        headers: {},
                        url: p,
                        rawRequest: i,
                      }),
                      i.getAllResponseHeaders &&
                        (n.headers = parseHeaders(i.getAllResponseHeaders())))
                    : (o = new Error("Internal XMLHttpRequest Error")),
                  a(o, n, n.body)
                );
              }
            }
            if (void 0 === e.callback)
              throw new Error("callback argument missing");
            var s = !1,
              a = function (t, r, n) {
                s || ((s = !0), e.callback(t, r, n));
              },
              i = e.xhr || null;
            i ||
              (i =
                e.cors || e.useXDR
                  ? new createXHR.XDomainRequest()
                  : new createXHR.XMLHttpRequest());
            var u,
              c,
              d,
              p = (i.url = e.uri || e.url),
              l = (i.method = e.method || "GET"),
              f = e.body || e.data,
              m = (i.headers = e.headers || {}),
              R = !!e.sync,
              X = !1,
              h = {
                body: void 0,
                headers: {},
                statusCode: 0,
                method: l,
                url: p,
                rawRequest: i,
              };
            if (
              ("json" in e &&
                !1 !== e.json &&
                ((X = !0),
                m.accept || m.Accept || (m.Accept = "application/json"),
                "GET" !== l &&
                  "HEAD" !== l &&
                  (m["content-type"] ||
                    m["Content-Type"] ||
                    (m["Content-Type"] = "application/json"),
                  (f = JSON.stringify(!0 === e.json ? f : e.json)))),
              (i.onreadystatechange = t),
              (i.onload = o),
              (i.onerror = n),
              (i.onprogress = function () {}),
              (i.onabort = function () {
                c = !0;
              }),
              (i.ontimeout = n),
              i.open(l, p, !R, e.username, e.password),
              R || (i.withCredentials = !!e.withCredentials),
              !R &&
                e.timeout > 0 &&
                (d = setTimeout(function () {
                  if (!c) {
                    (c = !0), i.abort("timeout");
                    var e = new Error("XMLHttpRequest timeout");
                    (e.code = "ETIMEDOUT"), n(e);
                  }
                }, e.timeout)),
              i.setRequestHeader)
            )
              for (u in m) m.hasOwnProperty(u) && i.setRequestHeader(u, m[u]);
            else if (e.headers && !isEmpty(e.headers))
              throw new Error(
                "Headers cannot be set on an XDomainRequest object"
              );
            return (
              "responseType" in e && (i.responseType = e.responseType),
              "beforeSend" in e &&
                "function" == typeof e.beforeSend &&
                e.beforeSend(i),
              i.send(f || null),
              i
            );
          }
          function getXml(e) {
            try {
              if ("document" === e.responseType) return e.responseXML;
              var t =
                e.responseXML &&
                "parsererror" === e.responseXML.documentElement.nodeName;
              if ("" === e.responseType && !t) return e.responseXML;
            } catch (e) {}
            return null;
          }
          function noop() {}
          var window = _dereq_("global/window"),
            isFunction = _dereq_("is-function"),
            parseHeaders = _dereq_("parse-headers"),
            xtend = _dereq_("xtend");
          (module.exports = createXHR),
            (module.exports.default = createXHR),
            (createXHR.XMLHttpRequest = window.XMLHttpRequest || noop),
            (createXHR.XDomainRequest =
              "withCredentials" in new createXHR.XMLHttpRequest()
                ? createXHR.XMLHttpRequest
                : window.XDomainRequest),
            forEachArray(
              ["get", "put", "post", "patch", "head", "delete"],
              function (e) {
                createXHR["delete" === e ? "del" : e] = function (t, r, n) {
                  return (
                    (r = initParams(t, r, n)),
                    (r.method = e.toUpperCase()),
                    _createXHR(r)
                  );
                };
              }
            );
        },
        {
          "global/window": 16,
          "is-function": 20,
          "parse-headers": 30,
          xtend: 49,
        },
      ],
      48: [
        function (_dereq_, module, exports) {
          module.exports = (function () {
            return void 0 !== self.DOMParser
              ? function (e) {
                  return new self.DOMParser().parseFromString(
                    e,
                    "application/xml"
                  );
                }
              : void 0 !== self.ActiveXObject &&
                new self.ActiveXObject("Microsoft.XMLDOM")
              ? function (e) {
                  var n = new self.ActiveXObject("Microsoft.XMLDOM");
                  return (n.async = "false"), n.loadXML(e), n;
                }
              : function (e) {
                  var n = document.createElement("div");
                  return (n.innerHTML = e), n;
                };
          })();
        },
        {},
      ],
      49: [
        function (_dereq_, module, exports) {
          function extend() {
            for (var r = {}, e = 0; e < arguments.length; e++) {
              var t = arguments[e];
              for (var n in t) hasOwnProperty.call(t, n) && (r[n] = t[n]);
            }
            return r;
          }
          module.exports = extend;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
        },
        {},
      ],
      50: [
        function (_dereq_, module, exports) {
          module.exports = {
            name: "aframe",
            version: "0.8.2",
            description:
              "A web framework for building virtual reality experiences.",
            homepage: "https://aframe.io/",
            main: "dist/aframe-master.js",
            scripts: {
              browserify:
                "browserify src/index.js -s 'AFRAME' -p browserify-derequire",
              build:
                "shx mkdir -p build/ && npm run browserify -- --debug -t [envify --INSPECTOR_VERSION dev] -o build/aframe.js",
              codecov: "codecov",
              dev: "npm run build && cross-env INSPECTOR_VERSION=dev node ./scripts/budo -t envify",
              dist: "node scripts/updateVersionLog.js && npm run dist:min && npm run dist:max",
              "dist:max":
                "npm run browserify -s -- --debug | exorcist dist/aframe-master.js.map > dist/aframe-master.js",
              "dist:min":
                "npm run browserify -s -- --debug -p [minifyify --map aframe-master.min.js.map --output dist/aframe-master.min.js.map] -o dist/aframe-master.min.js",
              docs: "markserv --dir docs --port 9001",
              preghpages: "node ./scripts/preghpages.js",
              ghpages: "ghpages -p gh-pages/",
              lint: "semistandard -v | snazzy",
              "lint:fix": "semistandard --fix",
              precommit: "npm run lint",
              prepush: "node scripts/testOnlyCheck.js",
              prerelease: "node scripts/release.js 0.7.1 0.8.0",
              start: "npm run dev",
              test: "karma start ./tests/karma.conf.js",
              "test:docs": "node scripts/docsLint.js",
              "test:firefox": "npm test -- --browsers Firefox",
              "test:chrome": "npm test -- --browsers Chrome",
              "test:nobrowser": "NO_BROWSER=true npm test",
              "test:node": "mocha --ui tdd tests/node",
            },
            repository: "aframevr/aframe",
            license: "MIT",
            files: ["dist/*", "docs/**/*", "src/**/*", "vendor/**/*"],
            dependencies: {
              animejs: "^2.2.0",
              "browserify-css": "^0.8.4",
              debug: "ngokevin/debug#noTimestamp",
              "deep-assign": "^2.0.0",
              "document-register-element":
                "dmarcos/document-register-element#8ccc532b7f3744be954574caf3072a5fd260ca90",
              envify: "^3.4.1",
              "load-bmfont": "^1.2.3",
              "object-assign": "^4.0.1",
              present: "0.0.6",
              "promise-polyfill": "^3.1.0",
              "style-attr": "^1.0.2",
              three: "0.95.0",
              "three-bmfont-text": "^2.1.0",
              "webvr-polyfill": "^0.10.8",
            },
            devDependencies: {
              browserify: "^13.1.0",
              "browserify-derequire": "^0.9.4",
              "browserify-istanbul": "^2.0.0",
              budo: "^9.2.0",
              chai: "^3.5.0",
              "chai-shallow-deep-equal": "^1.4.0",
              chalk: "^1.1.3",
              codecov: "^1.0.1",
              "cross-env": "^5.0.1",
              exorcist: "^0.4.0",
              ghpages: "0.0.8",
              "git-rev": "^0.2.1",
              glob: "^7.1.1",
              husky: "^0.11.7",
              istanbul: "^0.4.5",
              jsdom: "^9.11.0",
              karma: "1.4.1",
              "karma-browserify": "^5.1.0",
              "karma-chai-shallow-deep-equal": "0.0.4",
              "karma-chrome-launcher": "^2.0.0",
              "karma-coverage": "^1.1.1",
              "karma-env-preprocessor": "^0.1.1",
              "karma-firefox-launcher": "^1.0.0",
              "karma-mocha": "^1.1.1",
              "karma-mocha-reporter": "^2.1.0",
              "karma-sinon-chai": "1.2.4",
              lolex: "^1.5.1",
              markserv:
                "github:sukima/markserv#feature/fix-broken-websoketio-link",
              minifyify: "^7.3.3",
              mocha: "^3.0.2",
              "mozilla-download": "^1.1.1",
              "replace-in-file": "^2.5.3",
              semistandard: "^9.0.0",
              shelljs: "^0.7.7",
              shx: "^0.2.2",
              sinon: "^1.17.5",
              "sinon-chai": "2.8.0",
              snazzy: "^5.0.0",
              "too-wordy": "ngokevin/too-wordy",
              uglifyjs: "^2.4.10",
              "write-good": "^0.9.1",
            },
            link: true,
            browserify: { transform: ["browserify-css", "envify"] },
            semistandard: {
              ignore: [
                "build/**",
                "dist/**",
                "examples/**/shaders/*.js",
                "**/vendor/**",
              ],
            },
            keywords: [
              "3d",
              "aframe",
              "cardboard",
              "components",
              "oculus",
              "three",
              "three.js",
              "rift",
              "vive",
              "vr",
              "web-components",
              "webvr",
            ],
            "browserify-css": { minify: true },
            engines: { node: ">= 4.6.0", npm: "^2.15.9" },
          };
        },
        {},
      ],
      51: [
        function (_dereq_, module, exports) {
          function getPropertyType(t, e) {
            var i, n, o, a;
            return (
              (o = e.split(".")),
              (n = o[0]),
              (a = o[1]),
              (i = t.components[n] || components[n]),
              i
                ? a && !i.schema[a]
                  ? null
                  : a
                  ? i.schema[a].type
                  : i.schema.type
                : null
            );
          }
          function toRadians(t) {
            (t.x = THREE.Math.degToRad(t.x)),
              (t.y = THREE.Math.degToRad(t.y)),
              (t.z = THREE.Math.degToRad(t.z));
          }
          function addEventListeners(t, e, i) {
            var n;
            for (n = 0; n < e.length; n++) t.addEventListener(e[n], i);
          }
          function removeEventListeners(t, e, i) {
            var n;
            for (n = 0; n < e.length; n++) t.removeEventListener(e[n], i);
          }
          function getRawProperty(t, e) {
            var i, n, o;
            for (n = splitDot(e), o = t, i = 0; i < n.length; i++) o = o[n[i]];
            return o;
          }
          function setRawProperty(t, e, i, n) {
            var o, a, r, s;
            for (
              e.startsWith("object3D.rotation") && (i = THREE.Math.degToRad(i)),
                a = splitDot(e),
                s = t,
                o = 0;
              o < a.length - 1;
              o++
            )
              s = s[a[o]];
            if (((r = a[a.length - 1]), n === TYPE_COLOR))
              return void ("r" in s[r]
                ? ((s[r].r = i.r), (s[r].g = i.g), (s[r].b = i.b))
                : ((s[r].x = i.r), (s[r].y = i.g), (s[r].z = i.b)));
            s[r] = i;
          }
          function splitDot(t) {
            return t in splitCache
              ? splitCache[t]
              : ((splitCache[t] = t.split(".")), splitCache[t]);
          }
          function isRawProperty(t) {
            return (
              t.isRawProperty ||
              t.property.startsWith(STRING_COMPONENTS) ||
              t.property.startsWith(STRING_OBJECT3D)
            );
          }
          var anime = _dereq_("animejs"),
            components = _dereq_("../core/component").components,
            registerComponent = _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils"),
            colorHelperFrom = new THREE.Color(),
            colorHelperTo = new THREE.Color(),
            getComponentProperty = utils.entity.getComponentProperty,
            setComponentProperty = utils.entity.setComponentProperty,
            splitCache = {},
            TYPE_COLOR = "color",
            PROP_POSITION = "position",
            PROP_ROTATION = "rotation",
            PROP_SCALE = "scale",
            STRING_COMPONENTS = "components",
            STRING_OBJECT3D = "object3D";
          module.exports.Component = registerComponent("animation", {
            schema: {
              autoplay: { default: !0 },
              delay: { default: 0 },
              dir: { default: "" },
              dur: { default: 1e3 },
              easing: { default: "easeInQuad" },
              elasticity: { default: 400 },
              enabled: { default: !0 },
              from: { default: "" },
              loop: {
                default: 0,
                parse: function (t) {
                  return (
                    !0 === t ||
                    "true" === t ||
                    (!1 !== t && "false" !== t && parseInt(t, 10))
                  );
                },
              },
              property: { default: "" },
              startEvents: { type: "array" },
              pauseEvents: { type: "array" },
              resumeEvents: { type: "array" },
              round: { default: !1 },
              to: { default: "" },
              type: { default: "" },
              isRawProperty: { default: !1 },
            },
            multiple: !0,
            init: function () {
              var t = this;
              (this.eventDetail = { name: this.attrName }),
                (this.time = 0),
                (this.animation = null),
                (this.animationIsPlaying = !1),
                (this.onStartEvent = this.onStartEvent.bind(this)),
                (this.beginAnimation = this.beginAnimation.bind(this)),
                (this.pauseAnimation = this.pauseAnimation.bind(this)),
                (this.resumeAnimation = this.resumeAnimation.bind(this)),
                (this.fromColor = {}),
                (this.toColor = {}),
                (this.targets = {}),
                (this.targetsArray = []),
                (this.updateConfigForDefault =
                  this.updateConfigForDefault.bind(this)),
                (this.updateConfigForRawColor =
                  this.updateConfigForRawColor.bind(this)),
                (this.config = {
                  complete: function () {
                    (t.animationIsPlaying = !1),
                      t.el.emit("animationcomplete", t.eventDetail, !1),
                      t.id &&
                        t.el.emit(
                          "animationcomplete__" + t.id,
                          t.eventDetail,
                          !1
                        );
                  },
                });
            },
            update: function (t) {
              var e = this.config,
                i = this.data;
              (this.animationIsPlaying = !1),
                (t.enabled && !this.data.enabled) ||
                  (i.property &&
                    ((e.autoplay = !1),
                    (e.direction = i.dir),
                    (e.duration = i.dur),
                    (e.easing = i.easing),
                    (e.elasticity = i.elasticity),
                    (e.loop = i.loop),
                    (e.round = i.round),
                    this.createAndStartAnimation()));
            },
            tick: function (t, e) {
              this.animationIsPlaying &&
                ((this.time += e), this.animation.tick(this.time));
            },
            remove: function () {
              this.pauseAnimation(), this.removeEventListeners();
            },
            pause: function () {
              (this.paused = !0),
                (this.pausedWasPlaying = this.animationIsPlaying),
                this.pauseAnimation(),
                this.removeEventListeners();
            },
            play: function () {
              this.paused &&
                ((this.paused = !1),
                this.addEventListeners(),
                this.pausedWasPlaying &&
                  (this.resumeAnimation(), (this.pausedWasPlaying = !1)));
            },
            createAndStartAnimation: function () {
              var t = this.data;
              if (
                (this.updateConfig(),
                (this.animationIsPlaying = !1),
                (this.animation = anime(this.config)),
                this.removeEventListeners(),
                this.addEventListeners(),
                !(!t.autoplay || (t.startEvents && t.startEvents.length)))
              )
                return t.delay
                  ? void setTimeout(this.beginAnimation, t.delay)
                  : void this.beginAnimation();
            },
            beginAnimation: function () {
              this.updateConfig(),
                (this.time = 0),
                (this.animationIsPlaying = !0),
                this.stopRelatedAnimations(),
                this.el.emit("animationbegin", this.eventDetail);
            },
            pauseAnimation: function () {
              this.animationIsPlaying = !1;
            },
            resumeAnimation: function () {
              this.animationIsPlaying = !0;
            },
            onStartEvent: function () {
              if (this.data.enabled) {
                if (
                  (this.updateConfig(),
                  this.animation && this.animation.pause(),
                  (this.animation = anime(this.config)),
                  this.data.delay)
                )
                  return void setTimeout(this.beginAnimation, this.data.delay);
                this.beginAnimation();
              }
            },
            updateConfigForRawColor: function () {
              var t,
                e,
                i,
                n = this.config,
                o = this.data,
                a = this.el;
              if (
                !this.waitComponentInitRawProperty(this.updateConfigForRawColor)
              ) {
                (t = "" === o.from ? getRawProperty(a, o.property) : o.from),
                  (i = o.to),
                  this.setColorConfig(t, i),
                  (t = this.fromColor),
                  (i = this.toColor),
                  (this.targetsArray.length = 0),
                  this.targetsArray.push(t),
                  (n.targets = this.targetsArray);
                for (e in i) n[e] = i[e];
                n.update = (function () {
                  var t = {};
                  return function (e) {
                    var i;
                    (i = e.animatables[0].target),
                      (i.r === t.r && i.g === t.g && i.b === t.b) ||
                        setRawProperty(a, o.property, i, o.type);
                  };
                })();
              }
            },
            updateConfigForDefault: function () {
              var t,
                e,
                i,
                n,
                o = this.config,
                a = this.data,
                r = this.el;
              this.waitComponentInitRawProperty(this.updateConfigForDefault) ||
                ((t =
                  "" === a.from
                    ? isRawProperty(a)
                      ? getRawProperty(r, a.property)
                      : getComponentProperty(r, a.property)
                    : a.from),
                (n = a.to),
                (i = !isNaN(t || n)),
                i
                  ? ((t = parseFloat(t)), (n = parseFloat(n)))
                  : ((t = t ? t.toString() : t), (n = n ? n.toString() : n)),
                (e =
                  "true" === a.to ||
                  "false" === a.to ||
                  !0 === a.to ||
                  !1 === a.to),
                e &&
                  ((t = "true" === a.from || !0 === a.from ? 1 : 0),
                  (n = "true" === a.to || !0 === a.to ? 1 : 0)),
                (this.targets.aframeProperty = t),
                (o.targets = this.targets),
                (o.aframeProperty = n),
                (o.update = (function () {
                  var t;
                  return function (i) {
                    var n;
                    (n = i.animatables[0].target.aframeProperty) !== t &&
                      ((t = n),
                      e && (n = n >= 1),
                      isRawProperty(a)
                        ? setRawProperty(r, a.property, n, a.type)
                        : setComponentProperty(r, a.property, n));
                  };
                })()));
            },
            updateConfigForVector: function () {
              var t,
                e,
                i,
                n = this.config,
                o = this.data,
                a = this.el;
              (e =
                "" !== o.from
                  ? utils.coordinates.parse(o.from)
                  : getComponentProperty(a, o.property)),
                (i = utils.coordinates.parse(o.to)),
                o.property === PROP_ROTATION && (toRadians(e), toRadians(i)),
                (this.targetsArray.length = 0),
                this.targetsArray.push(e),
                (n.targets = this.targetsArray);
              for (t in i) n[t] = i[t];
              if (
                o.property === PROP_POSITION ||
                o.property === PROP_ROTATION ||
                o.property === PROP_SCALE
              )
                return void (n.update = (function () {
                  var t = {};
                  return function (e) {
                    var i = e.animatables[0].target;
                    o.property === PROP_SCALE &&
                      ((i.x = Math.max(1e-4, i.x)),
                      (i.y = Math.max(1e-4, i.y)),
                      (i.z = Math.max(1e-4, i.z))),
                      (i.x === t.x && i.y === t.y && i.z === t.z) ||
                        ((t.x = i.x),
                        (t.y = i.y),
                        (t.z = i.z),
                        a.object3D[o.property].set(i.x, i.y, i.z));
                  };
                })());
              n.update = (function () {
                var t = {};
                return function (e) {
                  var i = e.animations[0].target;
                  (i.x === t.x && i.y === t.y && i.z === t.z) ||
                    ((t.x = i.x),
                    (t.y = i.y),
                    (t.z = i.z),
                    setComponentProperty(a, o.property, i));
                };
              })();
            },
            updateConfig: function () {
              var t;
              (t = getPropertyType(this.el, this.data.property)),
                isRawProperty(this.data) && this.data.type === TYPE_COLOR
                  ? this.updateConfigForRawColor()
                  : "vec2" === t || "vec3" === t || "vec4" === t
                  ? this.updateConfigForVector()
                  : this.updateConfigForDefault();
            },
            waitComponentInitRawProperty: function (t) {
              var e,
                i = this.data,
                n = this.el,
                o = this;
              return (
                "" === i.from &&
                !!i.property.startsWith(STRING_COMPONENTS) &&
                ((e = splitDot(i.property)[1]),
                !n.components[e] &&
                  (n.addEventListener("componentinitialized", function i(a) {
                    a.detail.name === e &&
                      (t(),
                      (o.animation = anime(o.config)),
                      n.removeEventListener("componentinitialized", i));
                  }),
                  !0))
              );
            },
            stopRelatedAnimations: function () {
              var t, e;
              for (e in this.el.components)
                (t = this.el.components[e]),
                  e !== this.attrName &&
                    "animation" === t.name &&
                    t.animationIsPlaying &&
                    t.data.property === this.data.property &&
                    (t.animationIsPlaying = !1);
            },
            addEventListeners: function () {
              var t = this.data,
                e = this.el;
              addEventListeners(e, t.startEvents, this.onStartEvent),
                addEventListeners(e, t.pauseEvents, this.pauseAnimation),
                addEventListeners(e, t.resumeEvents, this.resumeAnimation);
            },
            removeEventListeners: function () {
              var t = this.data,
                e = this.el;
              removeEventListeners(e, t.startEvents, this.onStartEvent),
                removeEventListeners(e, t.pauseEvents, this.pauseAnimation),
                removeEventListeners(e, t.resumeEvents, this.resumeAnimation);
            },
            setColorConfig: function (t, e) {
              colorHelperFrom.set(t),
                colorHelperTo.set(e),
                (t = this.fromColor),
                (e = this.toColor),
                (t.r = colorHelperFrom.r),
                (t.g = colorHelperFrom.g),
                (t.b = colorHelperFrom.b),
                (e.r = colorHelperTo.r),
                (e.g = colorHelperTo.g),
                (e.b = colorHelperTo.b);
            },
          });
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils": 173,
          animejs: 2,
        },
      ],
      52: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three");
          module.exports.Component = registerComponent("camera", {
            schema: {
              active: { default: !0 },
              far: { default: 1e4 },
              fov: { default: 80, min: 0 },
              near: { default: 0.005, min: 0 },
              spectator: { default: !1 },
              zoom: { default: 1, min: 0 },
            },
            init: function () {
              var e,
                t = this.el;
              (e = this.camera = new THREE.PerspectiveCamera()),
                t.setObject3D("camera", e);
            },
            update: function (e) {
              var t = this.data,
                a = this.camera;
              (a.aspect = t.aspect || window.innerWidth / window.innerHeight),
                (a.far = t.far),
                (a.fov = t.fov),
                (a.near = t.near),
                (a.zoom = t.zoom),
                a.updateProjectionMatrix(),
                this.updateActiveCamera(e),
                this.updateSpectatorCamera(e);
            },
            updateActiveCamera: function (e) {
              var t = this.data,
                a = this.el,
                r = this.system;
              (e && e.active === t.active) ||
                t.spectator ||
                (t.active && r.activeCameraEl !== a
                  ? r.setActiveCamera(a)
                  : t.active ||
                    r.activeCameraEl !== a ||
                    r.disableActiveCamera());
            },
            updateSpectatorCamera: function (e) {
              var t = this.data,
                a = this.el,
                r = this.system;
              (e && e.spectator === t.spectator) ||
                (t.spectator && r.spectatorCameraEl !== a
                  ? r.setSpectatorCamera(a)
                  : t.spectator ||
                    r.spectatorCameraEl !== a ||
                    r.disableSpectatorCamera());
            },
            remove: function () {
              this.el.removeObject3D("camera");
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150 },
      ],
      53: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three");
          module.exports.Component = registerComponent("collada-model", {
            schema: { type: "asset" },
            init: function () {
              (this.model = null), (this.loader = new THREE.ColladaLoader());
            },
            update: function () {
              var e = this,
                o = this.el,
                t = this.data;
              t &&
                (this.remove(),
                this.loader.load(t, function (t) {
                  (e.model = t.scene),
                    o.setObject3D("mesh", e.model),
                    o.emit("model-loaded", {
                      format: "collada",
                      model: e.model,
                    });
                }));
            },
            remove: function () {
              this.model && this.el.removeObject3D("mesh");
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150 },
      ],
      54: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            utils = _dereq_("../utils/"),
            bind = utils.bind,
            EVENTS = {
              CLICK: "click",
              FUSING: "fusing",
              MOUSEENTER: "mouseenter",
              MOUSEDOWN: "mousedown",
              MOUSELEAVE: "mouseleave",
              MOUSEUP: "mouseup",
            },
            STATES = {
              FUSING: "cursor-fusing",
              HOVERING: "cursor-hovering",
              HOVERED: "cursor-hovered",
            },
            CANVAS_EVENTS = {
              DOWN: ["mousedown", "touchstart"],
              UP: ["mouseup", "touchend"],
            };
          module.exports.Component = registerComponent("cursor", {
            dependencies: ["raycaster"],
            schema: {
              downEvents: { default: [] },
              fuse: { default: utils.device.isMobile() },
              fuseTimeout: { default: 1500, min: 0 },
              upEvents: { default: [] },
              rayOrigin: { default: "entity", oneOf: ["mouse", "entity"] },
            },
            init: function () {
              var e = this;
              (this.fuseTimeout = void 0),
                (this.cursorDownEl = null),
                (this.intersectedEl = null),
                (this.canvasBounds = document.body.getBoundingClientRect()),
                (this.updateCanvasBounds = utils.debounce(function () {
                  e.canvasBounds = e.el.sceneEl.canvas.getBoundingClientRect();
                }, 500)),
                (this.eventDetail = {}),
                (this.intersectedEventDetail = { cursorEl: this.el }),
                (this.onCursorDown = bind(this.onCursorDown, this)),
                (this.onCursorUp = bind(this.onCursorUp, this)),
                (this.onIntersection = bind(this.onIntersection, this)),
                (this.onIntersectionCleared = bind(
                  this.onIntersectionCleared,
                  this
                )),
                (this.onMouseMove = bind(this.onMouseMove, this));
            },
            update: function (e) {
              this.data.rayOrigin !== e.rayOrigin &&
                this.updateMouseEventListeners();
            },
            play: function () {
              this.addEventListeners();
            },
            pause: function () {
              this.removeEventListeners();
            },
            remove: function () {
              var e = this.el;
              e.removeState(STATES.HOVERING),
                e.removeState(STATES.FUSING),
                clearTimeout(this.fuseTimeout),
                this.intersectedEl &&
                  this.intersectedEl.removeState(STATES.HOVERED),
                this.removeEventListeners();
            },
            addEventListeners: function () {
              function e() {
                (t = s.sceneEl.canvas),
                  n.downEvents.length ||
                    n.upEvents.length ||
                    (CANVAS_EVENTS.DOWN.forEach(function (e) {
                      t.addEventListener(e, i.onCursorDown);
                    }),
                    CANVAS_EVENTS.UP.forEach(function (e) {
                      t.addEventListener(e, i.onCursorUp);
                    }));
              }
              var t,
                n = this.data,
                s = this.el,
                i = this;
              (t = s.sceneEl.canvas),
                t ? e() : s.sceneEl.addEventListener("render-target-loaded", e),
                n.downEvents.forEach(function (e) {
                  s.addEventListener(e, i.onCursorDown);
                }),
                n.upEvents.forEach(function (e) {
                  s.addEventListener(e, i.onCursorUp);
                }),
                s.addEventListener(
                  "raycaster-intersection",
                  this.onIntersection
                ),
                s.addEventListener(
                  "raycaster-intersection-cleared",
                  this.onIntersectionCleared
                ),
                s.sceneEl.addEventListener(
                  "rendererresize",
                  this.updateCanvasBounds
                ),
                window.addEventListener("resize", this.updateCanvasBounds),
                window.addEventListener("scroll", this.updateCanvasBounds);
            },
            removeEventListeners: function () {
              var e,
                t = this.data,
                n = this.el,
                s = this;
              (e = n.sceneEl.canvas),
                !e ||
                  t.downEvents.length ||
                  t.upEvents.length ||
                  (CANVAS_EVENTS.DOWN.forEach(function (t) {
                    e.removeEventListener(t, s.onCursorDown);
                  }),
                  CANVAS_EVENTS.UP.forEach(function (t) {
                    e.removeEventListener(t, s.onCursorUp);
                  })),
                t.downEvents.forEach(function (e) {
                  n.removeEventListener(e, s.onCursorDown);
                }),
                t.upEvents.forEach(function (e) {
                  n.removeEventListener(e, s.onCursorUp);
                }),
                n.removeEventListener(
                  "raycaster-intersection",
                  this.onIntersection
                ),
                n.removeEventListener(
                  "raycaster-intersection-cleared",
                  this.onIntersectionCleared
                ),
                e.removeEventListener("mousemove", this.onMouseMove),
                e.removeEventListener("touchstart", this.onMouseMove),
                e.removeEventListener("touchmove", this.onMouseMove),
                n.sceneEl.removeEventListener(
                  "rendererresize",
                  this.updateCanvasBounds
                ),
                window.removeEventListener("resize", this.updateCanvasBounds),
                window.removeEventListener("scroll", this.updateCanvasBounds);
            },
            updateMouseEventListeners: function () {
              var e,
                t = this.el;
              (e = t.sceneEl.canvas),
                e.removeEventListener("mousemove", this.onMouseMove),
                e.removeEventListener("touchmove", this.onMouseMove),
                t.setAttribute("raycaster", "useWorldCoordinates", !1),
                "mouse" === this.data.rayOrigin &&
                  (e.addEventListener("mousemove", this.onMouseMove, !1),
                  e.addEventListener("touchmove", this.onMouseMove, !1),
                  t.setAttribute("raycaster", "useWorldCoordinates", !0),
                  this.updateCanvasBounds());
            },
            onMouseMove: (function () {
              var e = new THREE.Vector3(),
                t = new THREE.Vector2(),
                n = new THREE.Vector3(),
                s = { origin: n, direction: e };
              return function (i) {
                var o,
                  r,
                  a,
                  u = this.canvasBounds,
                  c = this.el.sceneEl.camera;
                c.parent.updateMatrixWorld(),
                  (r =
                    "touchmove" === i.type || "touchstart" === i.type
                      ? i.touches.item(0)
                      : i),
                  (o = r.clientX - u.left),
                  (a = r.clientY - u.top),
                  (t.x = (o / u.width) * 2 - 1),
                  (t.y = (-a / u.height) * 2 + 1),
                  n.setFromMatrixPosition(c.matrixWorld),
                  e.set(t.x, t.y, 0.5).unproject(c).sub(n).normalize(),
                  this.el.setAttribute("raycaster", s),
                  "touchmove" === i.type && i.preventDefault();
              };
            })(),
            onCursorDown: function (e) {
              "mouse" === this.data.rayOrigin &&
                "touchstart" === e.type &&
                (this.onMouseMove(e),
                this.el.components.raycaster.checkIntersections(),
                e.preventDefault()),
                this.twoWayEmit(EVENTS.MOUSEDOWN),
                (this.cursorDownEl = this.intersectedEl);
            },
            onCursorUp: function (e) {
              this.twoWayEmit(EVENTS.MOUSEUP),
                this.cursorDownEl &&
                  this.cursorDownEl !== this.intersectedEl &&
                  ((this.intersectedEventDetail.intersection = null),
                  this.cursorDownEl.emit(
                    EVENTS.MOUSEUP,
                    this.intersectedEventDetail
                  )),
                !this.data.fuse &&
                  this.intersectedEl &&
                  this.cursorDownEl === this.intersectedEl &&
                  this.twoWayEmit(EVENTS.CLICK),
                (this.cursorDownEl = null),
                "touchend" === e.type && e.preventDefault();
            },
            onIntersection: function (e) {
              var t,
                n,
                s,
                i,
                o = this.el;
              (n = e.detail.els[0] === o ? 1 : 0),
                (i = e.detail.intersections[n]),
                (s = e.detail.els[n]) &&
                  this.intersectedEl !== s &&
                  ((this.intersectedEl &&
                    (t = this.el.components.raycaster.getIntersection(
                      this.intersectedEl
                    )) &&
                    t.distance <= i.distance) ||
                    (this.clearCurrentIntersection(!0),
                    this.setIntersection(s, i)));
            },
            onIntersectionCleared: function (e) {
              -1 !== e.detail.clearedEls.indexOf(this.intersectedEl) &&
                this.clearCurrentIntersection();
            },
            setIntersection: function (e, t) {
              var n = this.el,
                s = this.data,
                i = this;
              this.intersectedEl !== e &&
                ((this.intersectedEl = e),
                n.addState(STATES.HOVERING),
                e.addState(STATES.HOVERED),
                this.twoWayEmit(EVENTS.MOUSEENTER),
                0 !== s.fuseTimeout &&
                  s.fuse &&
                  (n.addState(STATES.FUSING),
                  this.twoWayEmit(EVENTS.FUSING),
                  (this.fuseTimeout = setTimeout(function () {
                    n.removeState(STATES.FUSING), i.twoWayEmit(EVENTS.CLICK);
                  }, s.fuseTimeout))));
            },
            clearCurrentIntersection: function (e) {
              var t,
                n,
                s,
                i = this.el;
              this.intersectedEl &&
                (this.intersectedEl.removeState(STATES.HOVERED),
                i.removeState(STATES.HOVERING),
                i.removeState(STATES.FUSING),
                this.twoWayEmit(EVENTS.MOUSELEAVE),
                (this.intersectedEl = null),
                clearTimeout(this.fuseTimeout),
                !0 !== e &&
                  ((s = this.el.components.raycaster.intersections),
                  0 !== s.length &&
                    ((t = s[0].object.el === i ? 1 : 0),
                    (n = s[t]) && this.setIntersection(n.object.el, n))));
            },
            twoWayEmit: function (e) {
              var t,
                n = this.el,
                s = this.intersectedEl;
              (t = this.el.components.raycaster.getIntersection(s)),
                (this.eventDetail.intersectedEl = s),
                (this.eventDetail.intersection = t),
                n.emit(e, this.eventDetail),
                s &&
                  ((this.intersectedEventDetail.intersection = t),
                  s.emit(e, this.intersectedEventDetail));
            },
          });
        },
        { "../core/component": 101, "../utils/": 173 },
      ],
      55: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            bind = _dereq_("../utils/bind"),
            checkControllerPresentAndSetup = _dereq_(
              "../utils/tracked-controls"
            ).checkControllerPresentAndSetup,
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged,
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            DAYDREAM_CONTROLLER_MODEL_BASE_URL =
              "https://cdn.aframe.io/controllers/google/",
            DAYDREAM_CONTROLLER_MODEL_OBJ_URL =
              DAYDREAM_CONTROLLER_MODEL_BASE_URL + "vr_controller_daydream.obj",
            DAYDREAM_CONTROLLER_MODEL_OBJ_MTL =
              DAYDREAM_CONTROLLER_MODEL_BASE_URL + "vr_controller_daydream.mtl",
            GAMEPAD_ID_PREFIX = "Daydream Controller";
          module.exports.Component = registerComponent("daydream-controls", {
            schema: {
              hand: { default: "" },
              buttonColor: { type: "color", default: "#000000" },
              buttonTouchedColor: { type: "color", default: "#777777" },
              buttonHighlightColor: { type: "color", default: "#FFFFFF" },
              model: { default: !0 },
              orientationOffset: { type: "vec3" },
              armModel: { default: !0 },
            },
            mapping: {
              axes: { trackpad: [0, 1] },
              buttons: ["trackpad", "menu", "system"],
            },
            bindMethods: function () {
              (this.onModelLoaded = bind(this.onModelLoaded, this)),
                (this.onControllersUpdate = bind(
                  this.onControllersUpdate,
                  this
                )),
                (this.checkIfControllerPresent = bind(
                  this.checkIfControllerPresent,
                  this
                )),
                (this.removeControllersUpdateListener = bind(
                  this.removeControllersUpdateListener,
                  this
                )),
                (this.onAxisMoved = bind(this.onAxisMoved, this));
            },
            init: function () {
              var t = this;
              (this.animationActive = "pointing"),
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                (this.onButtonDown = function (e) {
                  onButtonEvent(e.detail.id, "down", t);
                }),
                (this.onButtonUp = function (e) {
                  onButtonEvent(e.detail.id, "up", t);
                }),
                (this.onButtonTouchStart = function (e) {
                  onButtonEvent(e.detail.id, "touchstart", t);
                }),
                (this.onButtonTouchEnd = function (e) {
                  onButtonEvent(e.detail.id, "touchend", t);
                }),
                (this.onAxisMoved = bind(this.onAxisMoved, this)),
                (this.controllerPresent = !1),
                (this.lastControllerCheck = 0),
                this.bindMethods(),
                (this.checkControllerPresentAndSetup =
                  checkControllerPresentAndSetup),
                (this.emitIfAxesChanged = emitIfAxesChanged);
            },
            addEventListeners: function () {
              var t = this.el;
              t.addEventListener("buttonchanged", this.onButtonChanged),
                t.addEventListener("buttondown", this.onButtonDown),
                t.addEventListener("buttonup", this.onButtonUp),
                t.addEventListener("touchstart", this.onButtonTouchStart),
                t.addEventListener("touchend", this.onButtonTouchEnd),
                t.addEventListener("model-loaded", this.onModelLoaded),
                t.addEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !0);
            },
            removeEventListeners: function () {
              var t = this.el;
              t.removeEventListener("buttonchanged", this.onButtonChanged),
                t.removeEventListener("buttondown", this.onButtonDown),
                t.removeEventListener("buttonup", this.onButtonUp),
                t.removeEventListener("touchstart", this.onButtonTouchStart),
                t.removeEventListener("touchend", this.onButtonTouchEnd),
                t.removeEventListener("model-loaded", this.onModelLoaded),
                t.removeEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !1);
            },
            checkIfControllerPresent: function () {
              this.checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                hand: this.data.hand,
              });
            },
            play: function () {
              this.checkIfControllerPresent(),
                this.addControllersUpdateListener();
            },
            pause: function () {
              this.removeEventListeners(),
                this.removeControllersUpdateListener();
            },
            injectTrackedControls: function () {
              var t = this.el,
                e = this.data;
              t.setAttribute("tracked-controls", {
                armModel: e.armModel,
                hand: e.hand,
                idPrefix: GAMEPAD_ID_PREFIX,
                orientationOffset: e.orientationOffset,
              }),
                this.data.model &&
                  this.el.setAttribute("obj-model", {
                    obj: DAYDREAM_CONTROLLER_MODEL_OBJ_URL,
                    mtl: DAYDREAM_CONTROLLER_MODEL_OBJ_MTL,
                  });
            },
            addControllersUpdateListener: function () {
              this.el.sceneEl.addEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            removeControllersUpdateListener: function () {
              this.el.sceneEl.removeEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            onControllersUpdate: function () {
              this.checkIfControllerPresent();
            },
            onModelLoaded: function (t) {
              var e,
                o = t.detail.model;
              this.data.model &&
                ((e = this.buttonMeshes = {}),
                (e.menu = o.getObjectByName(
                  "AppButton_AppButton_Cylinder.004"
                )),
                (e.system = o.getObjectByName(
                  "HomeButton_HomeButton_Cylinder.005"
                )),
                (e.trackpad = o.getObjectByName(
                  "TouchPad_TouchPad_Cylinder.003"
                )),
                o.position.set(0, 0, -0.04));
            },
            onAxisMoved: function (t) {
              this.emitIfAxesChanged(this, this.mapping.axes, t);
            },
            onButtonChanged: function (t) {
              var e = this.mapping.buttons[t.detail.id];
              e && this.el.emit(e + "changed", t.detail.state);
            },
            updateModel: function (t, e) {
              this.data.model && this.updateButtonModel(t, e);
            },
            updateButtonModel: function (t, e) {
              var o = this.buttonMeshes;
              if (o && o[t]) {
                var n;
                switch (e) {
                  case "down":
                    n = this.data.buttonHighlightColor;
                    break;
                  case "touchstart":
                    n = this.data.buttonTouchedColor;
                    break;
                  default:
                    n = this.data.buttonColor;
                }
                o[t].material.color.set(n);
              }
            },
          });
        },
        {
          "../core/component": 101,
          "../utils/bind": 167,
          "../utils/tracked-controls": 180,
        },
      ],
      56: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            bind = _dereq_("../utils/bind"),
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            checkControllerPresentAndSetup =
              trackedControlsUtils.checkControllerPresentAndSetup,
            emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged,
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            GEARVR_CONTROLLER_MODEL_BASE_URL =
              "https://cdn.aframe.io/controllers/samsung/",
            GEARVR_CONTROLLER_MODEL_OBJ_URL =
              GEARVR_CONTROLLER_MODEL_BASE_URL + "gear_vr_controller.obj",
            GEARVR_CONTROLLER_MODEL_OBJ_MTL =
              GEARVR_CONTROLLER_MODEL_BASE_URL + "gear_vr_controller.mtl",
            GAMEPAD_ID_PREFIX = "Gear VR";
          module.exports.Component = registerComponent("gearvr-controls", {
            schema: {
              hand: { default: "" },
              buttonColor: { type: "color", default: "#000000" },
              buttonTouchedColor: { type: "color", default: "#777777" },
              buttonHighlightColor: { type: "color", default: "#FFFFFF" },
              model: { default: !0 },
              orientationOffset: { type: "vec3" },
              armModel: { default: !0 },
            },
            mapping: {
              axes: { trackpad: [0, 1] },
              buttons: ["trackpad", "trigger"],
            },
            bindMethods: function () {
              (this.onModelLoaded = bind(this.onModelLoaded, this)),
                (this.onControllersUpdate = bind(
                  this.onControllersUpdate,
                  this
                )),
                (this.checkIfControllerPresent = bind(
                  this.checkIfControllerPresent,
                  this
                )),
                (this.removeControllersUpdateListener = bind(
                  this.removeControllersUpdateListener,
                  this
                )),
                (this.onAxisMoved = bind(this.onAxisMoved, this));
            },
            init: function () {
              var t = this;
              (this.animationActive = "pointing"),
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                (this.onButtonDown = function (e) {
                  onButtonEvent(e.detail.id, "down", t);
                }),
                (this.onButtonUp = function (e) {
                  onButtonEvent(e.detail.id, "up", t);
                }),
                (this.onButtonTouchStart = function (e) {
                  onButtonEvent(e.detail.id, "touchstart", t);
                }),
                (this.onButtonTouchEnd = function (e) {
                  onButtonEvent(e.detail.id, "touchend", t);
                }),
                (this.onAxisMoved = bind(this.onAxisMoved, this)),
                (this.controllerPresent = !1),
                (this.lastControllerCheck = 0),
                this.bindMethods(),
                (this.checkControllerPresentAndSetup =
                  checkControllerPresentAndSetup),
                (this.emitIfAxesChanged = emitIfAxesChanged);
            },
            addEventListeners: function () {
              var t = this.el;
              t.addEventListener("buttonchanged", this.onButtonChanged),
                t.addEventListener("buttondown", this.onButtonDown),
                t.addEventListener("buttonup", this.onButtonUp),
                t.addEventListener("touchstart", this.onButtonTouchStart),
                t.addEventListener("touchend", this.onButtonTouchEnd),
                t.addEventListener("model-loaded", this.onModelLoaded),
                t.addEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !0);
            },
            removeEventListeners: function () {
              var t = this.el;
              t.removeEventListener("buttonchanged", this.onButtonChanged),
                t.removeEventListener("buttondown", this.onButtonDown),
                t.removeEventListener("buttonup", this.onButtonUp),
                t.removeEventListener("touchstart", this.onButtonTouchStart),
                t.removeEventListener("touchend", this.onButtonTouchEnd),
                t.removeEventListener("model-loaded", this.onModelLoaded),
                t.removeEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !1);
            },
            checkIfControllerPresent: function () {
              this.checkControllerPresentAndSetup(
                this,
                GAMEPAD_ID_PREFIX,
                this.data.hand ? { hand: this.data.hand } : {}
              );
            },
            play: function () {
              this.checkIfControllerPresent(),
                this.addControllersUpdateListener();
            },
            pause: function () {
              this.removeEventListeners(),
                this.removeControllersUpdateListener();
            },
            injectTrackedControls: function () {
              var t = this.el,
                e = this.data;
              t.setAttribute("tracked-controls", {
                armModel: e.armModel,
                idPrefix: GAMEPAD_ID_PREFIX,
                orientationOffset: e.orientationOffset,
              }),
                this.data.model &&
                  this.el.setAttribute("obj-model", {
                    obj: GEARVR_CONTROLLER_MODEL_OBJ_URL,
                    mtl: GEARVR_CONTROLLER_MODEL_OBJ_MTL,
                  });
            },
            addControllersUpdateListener: function () {
              this.el.sceneEl.addEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            removeControllersUpdateListener: function () {
              this.el.sceneEl.removeEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            onControllersUpdate: function () {
              this.checkIfControllerPresent();
            },
            onModelLoaded: function (t) {
              var e,
                n = t.detail.model;
              this.data.model &&
                ((e = this.buttonMeshes = {}),
                (e.trigger = n.children[2]),
                (e.trackpad = n.children[1]));
            },
            onButtonChanged: function (t) {
              var e = this.mapping.buttons[t.detail.id];
              e && this.el.emit(e + "changed", t.detail.state);
            },
            onAxisMoved: function (t) {
              this.emitIfAxesChanged(this, this.mapping.axes, t);
            },
            updateModel: function (t, e) {
              this.data.model && this.updateButtonModel(t, e);
            },
            updateButtonModel: function (t, e) {
              var n = this.buttonMeshes;
              if (n && n[t]) {
                var o;
                switch (e) {
                  case "down":
                    o = this.data.buttonHighlightColor;
                    break;
                  case "touchstart":
                    o = this.data.buttonTouchedColor;
                    break;
                  default:
                    o = this.data.buttonColor;
                }
                n[t].material.color.set(o);
              }
            },
          });
        },
        {
          "../core/component": 101,
          "../utils/bind": 167,
          "../utils/tracked-controls": 180,
        },
      ],
      57: [
        function (_dereq_, module, exports) {
          var geometries = _dereq_("../core/geometry").geometries,
            geometryNames = _dereq_("../core/geometry").geometryNames,
            registerComponent = _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            dummyGeometry = new THREE.Geometry();
          module.exports.Component = registerComponent("geometry", {
            schema: {
              buffer: { default: !0 },
              primitive: {
                default: "box",
                oneOf: geometryNames,
                schemaChange: !0,
              },
              skipCache: { default: !1 },
            },
            init: function () {
              this.geometry = null;
            },
            update: function (e) {
              var t,
                r = this.data,
                m = this.el,
                o = this.system;
              this.geometry && (o.unuseGeometry(e), (this.geometry = null)),
                (this.geometry = o.getOrCreateGeometry(r)),
                (t = m.getObject3D("mesh")),
                t
                  ? (t.geometry = this.geometry)
                  : ((t = new THREE.Mesh()),
                    (t.geometry = this.geometry),
                    m.setObject3D("mesh", t));
            },
            remove: function () {
              this.system.unuseGeometry(this.data),
                (this.el.getObject3D("mesh").geometry = dummyGeometry),
                (this.geometry = null);
            },
            updateSchema: function (e) {
              var t = this.oldData && this.oldData.primitive,
                r = e.primitive,
                m = geometries[r] && geometries[r].schema;
              if (!m) throw new Error("Unknown geometry schema `" + r + "`");
              (t && t === r) || this.extendSchema(m);
            },
          });
        },
        {
          "../core/component": 101,
          "../core/geometry": 102,
          "../lib/three": 150,
        },
      ],
      58: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            warn = utils.debug("components:gltf-model:warn");
          module.exports.Component = registerComponent("gltf-model", {
            schema: { type: "model" },
            init: function () {
              var e = this.system.getDRACOLoader();
              (this.model = null),
                (this.loader = new THREE.GLTFLoader()),
                e && this.loader.setDRACOLoader(e);
            },
            update: function () {
              var e = this,
                o = this.el,
                t = this.data;
              t &&
                (this.remove(),
                this.loader.load(
                  t,
                  function (t) {
                    (e.model = t.scene || t.scenes[0]),
                      (e.model.animations = t.animations),
                      o.setObject3D("mesh", e.model),
                      o.emit("model-loaded", {
                        format: "gltf",
                        model: e.model,
                      });
                  },
                  void 0,
                  function (e) {
                    var r =
                      e && e.message ? e.message : "Failed to load glTF model";
                    warn(r), o.emit("model-error", { format: "gltf", src: t });
                  }
                ));
            },
            remove: function () {
              this.model && this.el.removeObject3D("mesh");
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150, "../utils/": 173 },
      ],
      59: [
        function (_dereq_, module, exports) {
          function getGestureEventName(t, e) {
            var n;
            if (t)
              return (
                (n = EVENTS[t]),
                "grip" === n
                  ? n + (e ? "close" : "open")
                  : "point" === n || "thumb" === n
                  ? n + (e ? "up" : "down")
                  : "pointing" === n || "pistol" === n
                  ? n + (e ? "start" : "end")
                  : void 0
              );
          }
          function isViveController(t) {
            var e = t && t.controller && t.controller.id;
            return e && 0 === e.indexOf("OpenVR ");
          }
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            MODEL_URLS = {
              left: "https://cdn.aframe.io/controllers/oculus-hands/v2/leftHand.json",
              right:
                "https://cdn.aframe.io/controllers/oculus-hands/v2/rightHand.json",
            },
            ANIMATIONS = {
              open: "Open",
              point: "Point",
              pointThumb: "Point + Thumb",
              fist: "Fist",
              hold: "Hold",
              thumbUp: "Thumb Up",
            },
            EVENTS = {};
          (EVENTS[ANIMATIONS.fist] = "grip"),
            (EVENTS[ANIMATIONS.thumbUp] = "pistol"),
            (EVENTS[ANIMATIONS.point] = "pointing"),
            (EVENTS[ANIMATIONS.thumb] = "thumb"),
            (module.exports.Component = registerComponent("hand-controls", {
              schema: { default: "left" },
              init: function () {
                var t = this,
                  e = this.el;
                (this.gesture = ANIMATIONS.open),
                  (this.pressedButtons = {}),
                  (this.touchedButtons = {}),
                  (this.loader = new THREE.ObjectLoader()),
                  this.loader.setCrossOrigin("anonymous"),
                  (this.onGripDown = function () {
                    t.handleButton("grip", "down");
                  }),
                  (this.onGripUp = function () {
                    t.handleButton("grip", "up");
                  }),
                  (this.onTrackpadDown = function () {
                    t.handleButton("trackpad", "down");
                  }),
                  (this.onTrackpadUp = function () {
                    t.handleButton("trackpad", "up");
                  }),
                  (this.onTrackpadTouchStart = function () {
                    t.handleButton("trackpad", "touchstart");
                  }),
                  (this.onTrackpadTouchEnd = function () {
                    t.handleButton("trackpad", "touchend");
                  }),
                  (this.onTriggerDown = function () {
                    t.handleButton("trigger", "down");
                  }),
                  (this.onTriggerUp = function () {
                    t.handleButton("trigger", "up");
                  }),
                  (this.onTriggerTouchStart = function () {
                    t.handleButton("trigger", "touchstart");
                  }),
                  (this.onTriggerTouchEnd = function () {
                    t.handleButton("trigger", "touchend");
                  }),
                  (this.onGripTouchStart = function () {
                    t.handleButton("grip", "touchstart");
                  }),
                  (this.onGripTouchEnd = function () {
                    t.handleButton("grip", "touchend");
                  }),
                  (this.onThumbstickDown = function () {
                    t.handleButton("thumbstick", "down");
                  }),
                  (this.onThumbstickUp = function () {
                    t.handleButton("thumbstick", "up");
                  }),
                  (this.onAorXTouchStart = function () {
                    t.handleButton("AorX", "touchstart");
                  }),
                  (this.onAorXTouchEnd = function () {
                    t.handleButton("AorX", "touchend");
                  }),
                  (this.onBorYTouchStart = function () {
                    t.handleButton("BorY", "touchstart");
                  }),
                  (this.onBorYTouchEnd = function () {
                    t.handleButton("BorY", "touchend");
                  }),
                  (this.onSurfaceTouchStart = function () {
                    t.handleButton("surface", "touchstart");
                  }),
                  (this.onSurfaceTouchEnd = function () {
                    t.handleButton("surface", "touchend");
                  }),
                  (this.onControllerConnected = function () {
                    t.setModelVisibility(!0);
                  }),
                  (this.onControllerDisconnected = function () {
                    t.setModelVisibility(!1);
                  }),
                  e.addEventListener(
                    "controllerconnected",
                    this.onControllerConnected
                  ),
                  e.addEventListener(
                    "controllerdisconnected",
                    this.onControllerDisconnected
                  );
              },
              play: function () {
                this.addEventListeners();
              },
              pause: function () {
                this.removeEventListeners();
              },
              tick: function (t, e) {
                var n = this.el.getObject3D("mesh");
                n && n.mixer && n.mixer.update(e / 1e3);
              },
              addEventListeners: function () {
                var t = this.el;
                t.addEventListener("gripdown", this.onGripDown),
                  t.addEventListener("gripup", this.onGripUp),
                  t.addEventListener("trackpaddown", this.onTrackpadDown),
                  t.addEventListener("trackpadup", this.onTrackpadUp),
                  t.addEventListener(
                    "trackpadtouchstart",
                    this.onTrackpadTouchStart
                  ),
                  t.addEventListener(
                    "trackpadtouchend",
                    this.onTrackpadTouchEnd
                  ),
                  t.addEventListener("triggerdown", this.onTriggerDown),
                  t.addEventListener("triggerup", this.onTriggerUp),
                  t.addEventListener(
                    "triggertouchstart",
                    this.onTriggerTouchStart
                  ),
                  t.addEventListener("triggertouchend", this.onTriggerTouchEnd),
                  t.addEventListener("griptouchstart", this.onGripTouchStart),
                  t.addEventListener("griptouchend", this.onGripTouchEnd),
                  t.addEventListener("thumbstickdown", this.onThumbstickDown),
                  t.addEventListener("thumbstickup", this.onThumbstickUp),
                  t.addEventListener(
                    "abuttontouchstart",
                    this.onAorXTouchStart
                  ),
                  t.addEventListener("abuttontouchend", this.onAorXTouchEnd),
                  t.addEventListener(
                    "bbuttontouchstart",
                    this.onBorYTouchStart
                  ),
                  t.addEventListener("bbuttontouchend", this.onBorYTouchEnd),
                  t.addEventListener(
                    "xbuttontouchstart",
                    this.onAorXTouchStart
                  ),
                  t.addEventListener("xbuttontouchend", this.onAorXTouchEnd),
                  t.addEventListener(
                    "ybuttontouchstart",
                    this.onBorYTouchStart
                  ),
                  t.addEventListener("ybuttontouchend", this.onBorYTouchEnd),
                  t.addEventListener(
                    "surfacetouchstart",
                    this.onSurfaceTouchStart
                  ),
                  t.addEventListener("surfacetouchend", this.onSurfaceTouchEnd);
              },
              removeEventListeners: function () {
                var t = this.el;
                t.removeEventListener("gripdown", this.onGripDown),
                  t.removeEventListener("gripup", this.onGripUp),
                  t.removeEventListener("trackpaddown", this.onTrackpadDown),
                  t.removeEventListener("trackpadup", this.onTrackpadUp),
                  t.removeEventListener(
                    "trackpadtouchstart",
                    this.onTrackpadTouchStart
                  ),
                  t.removeEventListener(
                    "trackpadtouchend",
                    this.onTrackpadTouchEnd
                  ),
                  t.removeEventListener("triggerdown", this.onTriggerDown),
                  t.removeEventListener("triggerup", this.onTriggerUp),
                  t.removeEventListener(
                    "triggertouchstart",
                    this.onTriggerTouchStart
                  ),
                  t.removeEventListener(
                    "triggertouchend",
                    this.onTriggerTouchEnd
                  ),
                  t.removeEventListener(
                    "griptouchstart",
                    this.onGripTouchStart
                  ),
                  t.removeEventListener("griptouchend", this.onGripTouchEnd),
                  t.removeEventListener(
                    "thumbstickdown",
                    this.onThumbstickDown
                  ),
                  t.removeEventListener("thumbstickup", this.onThumbstickUp),
                  t.removeEventListener(
                    "abuttontouchstart",
                    this.onAorXTouchStart
                  ),
                  t.removeEventListener("abuttontouchend", this.onAorXTouchEnd),
                  t.removeEventListener(
                    "bbuttontouchstart",
                    this.onBorYTouchStart
                  ),
                  t.removeEventListener("bbuttontouchend", this.onBorYTouchEnd),
                  t.removeEventListener(
                    "xbuttontouchstart",
                    this.onAorXTouchStart
                  ),
                  t.removeEventListener("xbuttontouchend", this.onAorXTouchEnd),
                  t.removeEventListener(
                    "ybuttontouchstart",
                    this.onBorYTouchStart
                  ),
                  t.removeEventListener("ybuttontouchend", this.onBorYTouchEnd),
                  t.removeEventListener(
                    "surfacetouchstart",
                    this.onSurfaceTouchStart
                  ),
                  t.removeEventListener(
                    "surfacetouchend",
                    this.onSurfaceTouchEnd
                  );
              },
              update: function (t) {
                var e,
                  n = this.el,
                  o = this.data;
                (e = {
                  hand: o,
                  model: !1,
                  orientationOffset: { x: 0, y: 0, z: "left" === o ? 90 : -90 },
                }),
                  o !== t &&
                    this.loader.load(MODEL_URLS[o], function (t) {
                      var o = t.getObjectByName("Hand");
                      (o.material.skinning = !0),
                        (o.mixer = new THREE.AnimationMixer(o)),
                        n.setObject3D("mesh", o),
                        o.position.set(0, 0, 0),
                        o.rotation.set(0, 0, 0),
                        (o.visible = !1),
                        n.setAttribute("vive-controls", e),
                        n.setAttribute("oculus-touch-controls", e),
                        n.setAttribute("windows-motion-controls", e);
                    });
              },
              remove: function () {
                this.el.removeObject3D("mesh");
              },
              handleButton: function (t, e) {
                var n,
                  o = "down" === e,
                  i = "touchstart" === e;
                if (0 === e.indexOf("touch")) {
                  if (i === this.touchedButtons[t]) return;
                  this.touchedButtons[t] = i;
                } else {
                  if (o === this.pressedButtons[t]) return;
                  this.pressedButtons[t] = o;
                }
                (n = this.gesture),
                  (this.gesture = this.determineGesture()),
                  this.gesture !== n &&
                    (this.animateGesture(this.gesture, n),
                    this.emitGestureEvents(this.gesture, n));
              },
              determineGesture: function () {
                var t,
                  e = this.pressedButtons.grip,
                  n =
                    this.pressedButtons.surface || this.touchedButtons.surface,
                  o =
                    this.pressedButtons.trackpad ||
                    this.touchedButtons.trackpad,
                  i =
                    this.pressedButtons.trigger || this.touchedButtons.trigger,
                  r = this.touchedButtons.AorX || this.touchedButtons.BorY,
                  s = isViveController(this.el.components["tracked-controls"]);
                return (
                  e
                    ? (t = s
                        ? ANIMATIONS.fist
                        : n || r || o
                        ? i
                          ? ANIMATIONS.fist
                          : ANIMATIONS.point
                        : i
                        ? ANIMATIONS.thumbUp
                        : ANIMATIONS.pointThumb)
                    : i
                    ? (t = s ? ANIMATIONS.fist : ANIMATIONS.hold)
                    : s && o && (t = ANIMATIONS.point),
                  t
                );
              },
              animateGesture: function (t, e) {
                if (t)
                  return void this.playAnimation(t || ANIMATIONS.open, e, !1);
                this.playAnimation(e, e, !0);
              },
              emitGestureEvents: function (t, e) {
                var n,
                  o = this.el;
                e !== t &&
                  ((n = getGestureEventName(e, !1)),
                  n && o.emit(n),
                  (n = getGestureEventName(t, !0)) && o.emit(n));
              },
              playAnimation: function (t, e, n) {
                var o,
                  i,
                  r = this.el.getObject3D("mesh");
                if (r) {
                  if (
                    ((i = r.mixer.clipAction(t)),
                    (i.clampWhenFinished = !0),
                    (i.loop = THREE.LoopRepeat),
                    (i.repetitions = 0),
                    (i.timeScale = n ? -1 : 1),
                    (i.weight = 1),
                    !e || t === e)
                  )
                    return r.mixer.stopAllAction(), void i.play();
                  (o = r.mixer.clipAction(e)),
                    r.mixer.stopAllAction(),
                    (o.weight = 0.15),
                    o.play(),
                    i.play(),
                    o.crossFadeTo(i, 0.15, !0);
                }
              },
              setModelVisibility: function (t) {
                var e = this.el.getObject3D("mesh");
                e && (e.visible = t);
              },
            }));
        },
        { "../core/component": 101 },
      ],
      60: [
        function (_dereq_, module, exports) {
          _dereq_("./animation"),
            _dereq_("./camera"),
            _dereq_("./collada-model"),
            _dereq_("./cursor"),
            _dereq_("./daydream-controls"),
            _dereq_("./gearvr-controls"),
            _dereq_("./geometry"),
            _dereq_("./gltf-model"),
            _dereq_("./hand-controls"),
            _dereq_("./laser-controls"),
            _dereq_("./light"),
            _dereq_("./line"),
            _dereq_("./link"),
            _dereq_("./look-controls"),
            _dereq_("./material"),
            _dereq_("./obj-model"),
            _dereq_("./oculus-go-controls"),
            _dereq_("./oculus-touch-controls"),
            _dereq_("./position"),
            _dereq_("./raycaster"),
            _dereq_("./rotation"),
            _dereq_("./scale"),
            _dereq_("./shadow"),
            _dereq_("./sound"),
            _dereq_("./text"),
            _dereq_("./tracked-controls"),
            _dereq_("./visible"),
            _dereq_("./vive-controls"),
            _dereq_("./wasd-controls"),
            _dereq_("./windows-motion-controls"),
            _dereq_("./scene/background"),
            _dereq_("./scene/debug"),
            _dereq_("./scene/embedded"),
            _dereq_("./scene/inspector"),
            _dereq_("./scene/fog"),
            _dereq_("./scene/keyboard-shortcuts"),
            _dereq_("./scene/pool"),
            _dereq_("./scene/renderer"),
            _dereq_("./scene/screenshot"),
            _dereq_("./scene/stats"),
            _dereq_("./scene/vr-mode-ui");
        },
        {
          "./animation": 51,
          "./camera": 52,
          "./collada-model": 53,
          "./cursor": 54,
          "./daydream-controls": 55,
          "./gearvr-controls": 56,
          "./geometry": 57,
          "./gltf-model": 58,
          "./hand-controls": 59,
          "./laser-controls": 61,
          "./light": 62,
          "./line": 63,
          "./link": 64,
          "./look-controls": 65,
          "./material": 66,
          "./obj-model": 67,
          "./oculus-go-controls": 68,
          "./oculus-touch-controls": 69,
          "./position": 70,
          "./raycaster": 71,
          "./rotation": 72,
          "./scale": 73,
          "./scene/background": 74,
          "./scene/debug": 75,
          "./scene/embedded": 76,
          "./scene/fog": 77,
          "./scene/inspector": 78,
          "./scene/keyboard-shortcuts": 79,
          "./scene/pool": 80,
          "./scene/renderer": 81,
          "./scene/screenshot": 82,
          "./scene/stats": 83,
          "./scene/vr-mode-ui": 84,
          "./shadow": 85,
          "./sound": 86,
          "./text": 87,
          "./tracked-controls": 88,
          "./visible": 89,
          "./vive-controls": 90,
          "./wasd-controls": 91,
          "./windows-motion-controls": 92,
        },
      ],
      61: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            utils = _dereq_("../utils/");
          registerComponent("laser-controls", {
            schema: { hand: { default: "right" } },
            init: function () {
              function t(t) {
                var r = e[t.detail.name];
                if (r) {
                  var n = utils.extend({ showLine: !0 }, r.raycaster || {});
                  t.detail.rayOrigin &&
                    ((n.origin = t.detail.rayOrigin.origin),
                    (n.direction = t.detail.rayOrigin.direction),
                    (n.showLine = !0)),
                    t.detail.rayOrigin || !i.modelReady
                      ? o.setAttribute("raycaster", n)
                      : o.setAttribute("raycaster", "showLine", !0),
                    o.setAttribute(
                      "cursor",
                      utils.extend({ fuse: !1 }, r.cursor)
                    );
                }
              }
              function r() {
                o.setAttribute("raycaster", "showLine", !1);
              }
              var e = this.config,
                n = this.data,
                o = this.el,
                i = this;
              o.setAttribute("daydream-controls", { hand: n.hand }),
                o.setAttribute("gearvr-controls", { hand: n.hand }),
                o.setAttribute("oculus-go-controls", { hand: n.hand }),
                o.setAttribute("oculus-touch-controls", { hand: n.hand }),
                o.setAttribute("vive-controls", { hand: n.hand }),
                o.setAttribute("windows-motion-controls", { hand: n.hand }),
                o.addEventListener("controllerconnected", t),
                o.addEventListener("controllerdisconnected", r),
                o.addEventListener("controllermodelready", function (r) {
                  t(r), (i.modelReady = !0);
                });
            },
            config: {
              "daydream-controls": {
                cursor: {
                  downEvents: ["trackpaddown"],
                  upEvents: ["trackpadup"],
                },
              },
              "gearvr-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"],
                },
                raycaster: { origin: { x: 0, y: 5e-4, z: 0 } },
              },
              "oculus-go-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"],
                },
                raycaster: { origin: { x: 0, y: 5e-4, z: 0 } },
              },
              "oculus-touch-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"],
                },
                raycaster: { origin: { x: 0, y: 0, z: 0 } },
              },
              "vive-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"],
                },
              },
              "windows-motion-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"],
                },
                raycaster: { showLine: !1 },
              },
            },
          });
        },
        { "../core/component": 101, "../utils/": 173 },
      ],
      62: [
        function (_dereq_, module, exports) {
          var bind = _dereq_("../utils/bind"),
            diff = _dereq_("../utils").diff,
            debug = _dereq_("../utils/debug"),
            registerComponent = _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad,
            warn = debug("components:light:warn");
          module.exports.Component = registerComponent("light", {
            schema: {
              angle: { default: 60, if: { type: ["spot"] } },
              color: { type: "color" },
              groundColor: { type: "color", if: { type: ["hemisphere"] } },
              decay: { default: 1, if: { type: ["point", "spot"] } },
              distance: { default: 0, min: 0, if: { type: ["point", "spot"] } },
              intensity: {
                default: 1,
                min: 0,
                if: {
                  type: [
                    "ambient",
                    "directional",
                    "hemisphere",
                    "point",
                    "spot",
                  ],
                },
              },
              penumbra: { default: 0, min: 0, max: 1, if: { type: ["spot"] } },
              type: {
                default: "directional",
                oneOf: [
                  "ambient",
                  "directional",
                  "hemisphere",
                  "point",
                  "spot",
                ],
                schemaChange: !0,
              },
              target: {
                type: "selector",
                if: { type: ["spot", "directional"] },
              },
              castShadow: {
                default: !1,
                if: { type: ["point", "spot", "directional"] },
              },
              shadowBias: { default: 0, if: { castShadow: !0 } },
              shadowCameraFar: { default: 500, if: { castShadow: !0 } },
              shadowCameraFov: { default: 90, if: { castShadow: !0 } },
              shadowCameraNear: { default: 0.5, if: { castShadow: !0 } },
              shadowCameraTop: { default: 5, if: { castShadow: !0 } },
              shadowCameraRight: { default: 5, if: { castShadow: !0 } },
              shadowCameraBottom: { default: -5, if: { castShadow: !0 } },
              shadowCameraLeft: { default: -5, if: { castShadow: !0 } },
              shadowCameraVisible: { default: !1, if: { castShadow: !0 } },
              shadowMapHeight: { default: 512, if: { castShadow: !0 } },
              shadowMapWidth: { default: 512, if: { castShadow: !0 } },
              shadowRadius: { default: 1, if: { castShadow: !0 } },
            },
            init: function () {
              var e = this.el;
              (this.light = null),
                (this.defaultTarget = null),
                this.system.registerLight(e);
            },
            update: function (e) {
              var a = this.data,
                t = diff(a, e),
                o = this.light,
                i = this;
              if (o && !("type" in t)) {
                var s = !1;
                return void Object.keys(t).forEach(function (e) {
                  var t = a[e];
                  switch (e) {
                    case "color":
                      o.color.set(t);
                      break;
                    case "groundColor":
                      o.groundColor.set(t);
                      break;
                    case "angle":
                      o.angle = degToRad(t);
                      break;
                    case "target":
                      null === t
                        ? ("spot" !== a.type && "directional" !== a.type) ||
                          (o.target = i.defaultTarget)
                        : t.hasLoaded
                        ? i.onSetTarget(t, o)
                        : t.addEventListener(
                            "loaded",
                            bind(i.onSetTarget, i, t, o)
                          );
                      break;
                    case "castShadow":
                    case "shadowBias":
                    case "shadowCameraFar":
                    case "shadowCameraFov":
                    case "shadowCameraNear":
                    case "shadowCameraTop":
                    case "shadowCameraRight":
                    case "shadowCameraBottom":
                    case "shadowCameraLeft":
                    case "shadowCameraVisible":
                    case "shadowMapHeight":
                    case "shadowMapWidth":
                    case "shadowRadius":
                      s || (i.updateShadow(), (s = !0));
                      break;
                    default:
                      o[e] = t;
                  }
                });
              }
              this.setLight(this.data), this.updateShadow();
            },
            setLight: function (e) {
              var a = this.el,
                t = this.getLight(e);
              t &&
                (this.light && a.removeObject3D("light"),
                (this.light = t),
                (this.light.el = a),
                a.setObject3D("light", this.light),
                ("spot" !== e.type &&
                  "directional" !== e.type &&
                  "hemisphere" !== e.type) ||
                  a.getObject3D("light").translateY(-1),
                "spot" === e.type &&
                  (a.setObject3D("light-target", this.defaultTarget),
                  a.getObject3D("light-target").position.set(0, 0, -1)));
            },
            updateShadow: function () {
              var e = this.el,
                a = this.data,
                t = this.light;
              t.castShadow = a.castShadow;
              var o = e.getObject3D("cameraHelper");
              if (
                (a.shadowCameraVisible && !o
                  ? e.setObject3D(
                      "cameraHelper",
                      new THREE.CameraHelper(t.shadow.camera)
                    )
                  : !a.shadowCameraVisible &&
                    o &&
                    e.removeObject3D("cameraHelper"),
                !a.castShadow)
              )
                return t;
              (t.shadow.bias = a.shadowBias),
                (t.shadow.radius = a.shadowRadius),
                (t.shadow.mapSize.height = a.shadowMapHeight),
                (t.shadow.mapSize.width = a.shadowMapWidth),
                (t.shadow.camera.near = a.shadowCameraNear),
                (t.shadow.camera.far = a.shadowCameraFar),
                t.shadow.camera instanceof THREE.OrthographicCamera
                  ? ((t.shadow.camera.top = a.shadowCameraTop),
                    (t.shadow.camera.right = a.shadowCameraRight),
                    (t.shadow.camera.bottom = a.shadowCameraBottom),
                    (t.shadow.camera.left = a.shadowCameraLeft))
                  : (t.shadow.camera.fov = a.shadowCameraFov),
                t.shadow.camera.updateProjectionMatrix(),
                o && o.update();
            },
            getLight: function (e) {
              var a = e.angle,
                t = new THREE.Color(e.color).getHex(),
                o = e.decay,
                i = e.distance,
                s = new THREE.Color(e.groundColor).getHex(),
                r = e.intensity,
                d = e.type,
                h = e.target,
                n = null;
              switch (d.toLowerCase()) {
                case "ambient":
                  return new THREE.AmbientLight(t, r);
                case "directional":
                  return (
                    (n = new THREE.DirectionalLight(t, r)),
                    (this.defaultTarget = n.target),
                    h &&
                      (h.hasLoaded
                        ? this.onSetTarget(h, n)
                        : h.addEventListener(
                            "loaded",
                            bind(this.onSetTarget, this, h, n)
                          )),
                    n
                  );
                case "hemisphere":
                  return new THREE.HemisphereLight(t, s, r);
                case "point":
                  return new THREE.PointLight(t, r, i, o);
                case "spot":
                  return (
                    (n = new THREE.SpotLight(
                      t,
                      r,
                      i,
                      degToRad(a),
                      e.penumbra,
                      o
                    )),
                    (this.defaultTarget = n.target),
                    h &&
                      (h.hasLoaded
                        ? this.onSetTarget(h, n)
                        : h.addEventListener(
                            "loaded",
                            bind(this.onSetTarget, this, h, n)
                          )),
                    n
                  );
                default:
                  warn(
                    "%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.",
                    d
                  );
              }
            },
            onSetTarget: function (e, a) {
              a.target = e.object3D;
            },
            remove: function () {
              var e = this.el;
              e.removeObject3D("light"),
                e.getObject3D("cameraHelper") &&
                  e.removeObject3D("cameraHelper");
            },
          });
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils": 173,
          "../utils/bind": 167,
          "../utils/debug": 169,
        },
      ],
      63: [
        function (_dereq_, module, exports) {
          function isEqualVec3(t, e) {
            return !(!t || !e) && t.x === e.x && t.y === e.y && t.z === e.z;
          }
          var registerComponent =
            _dereq_("../core/component").registerComponent;
          module.exports.Component = registerComponent("line", {
            schema: {
              start: { type: "vec3", default: { x: 0, y: 0, z: 0 } },
              end: { type: "vec3", default: { x: 0, y: 0, z: 0 } },
              color: { type: "color", default: "#74BEC1" },
              opacity: { type: "number", default: 1 },
              visible: { default: !0 },
            },
            multiple: !0,
            init: function () {
              var t,
                e,
                i = this.data;
              (e = this.material =
                new THREE.LineBasicMaterial({
                  color: i.color,
                  opacity: i.opacity,
                  transparent: i.opacity < 1,
                  visible: i.visible,
                })),
                (t = this.geometry = new THREE.BufferGeometry()),
                t.addAttribute(
                  "position",
                  new THREE.BufferAttribute(new Float32Array(6), 3)
                ),
                (this.line = new THREE.Line(t, e)),
                this.el.setObject3D(this.attrName, this.line);
            },
            update: function (t) {
              var e = this.data,
                i = this.geometry,
                r = !1,
                a = this.material,
                o = i.attributes.position.array;
              isEqualVec3(e.start, t.start) ||
                ((o[0] = e.start.x),
                (o[1] = e.start.y),
                (o[2] = e.start.z),
                (r = !0)),
                isEqualVec3(e.end, t.end) ||
                  ((o[3] = e.end.x),
                  (o[4] = e.end.y),
                  (o[5] = e.end.z),
                  (r = !0)),
                r &&
                  ((i.attributes.position.needsUpdate = !0),
                  i.computeBoundingSphere()),
                a.color.setStyle(e.color),
                (a.opacity = e.opacity),
                (a.transparent = e.opacity < 1),
                (a.visible = e.visible);
            },
            remove: function () {
              this.el.removeObject3D("line", this.line);
            },
          });
        },
        { "../core/component": 101 },
      ],
      64: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            registerShader = _dereq_("../core/shader").registerShader,
            THREE = _dereq_("../lib/three");
          (module.exports.Component = registerComponent("link", {
            schema: {
              backgroundColor: { default: "red", type: "color" },
              borderColor: { default: "white", type: "color" },
              highlighted: { default: !1 },
              highlightedColor: { default: "#24CAFF", type: "color" },
              href: { default: "" },
              image: { type: "asset" },
              on: { default: "click" },
              peekMode: { default: !1 },
              title: { default: "" },
              titleColor: { default: "white", type: "color" },
              visualAspectEnabled: { default: !1 },
            },
            init: function () {
              (this.navigate = this.navigate.bind(this)),
                (this.previousQuaternion = void 0),
                (this.quaternionClone = new THREE.Quaternion()),
                (this.hiddenEls = []);
            },
            update: function (e) {
              var t,
                i,
                r = this.data,
                o = this.el;
              r.visualAspectEnabled &&
                (this.initVisualAspect(),
                (t = r.highlighted ? r.highlightedColor : r.backgroundColor),
                (i = r.highlighted ? r.highlightedColor : r.borderColor),
                o.setAttribute("material", "backgroundColor", t),
                o.setAttribute("material", "strokeColor", i),
                r.on !== e.on && this.updateEventListener(),
                void 0 !== e.peekMode &&
                  r.peekMode !== e.peekMode &&
                  this.updatePeekMode(),
                r.image &&
                  e.image !== r.image &&
                  o.setAttribute(
                    "material",
                    "pano",
                    "string" == typeof r.image ? r.image : r.image.src
                  ));
            },
            updatePeekMode: function () {
              var e = this.el,
                t = this.sphereEl;
              this.data.peekMode
                ? (this.hideAll(),
                  (e.getObject3D("mesh").visible = !1),
                  t.setAttribute("visible", !0))
                : (this.showAll(),
                  (e.getObject3D("mesh").visible = !0),
                  t.setAttribute("visible", !1));
            },
            play: function () {
              this.updateEventListener();
            },
            pause: function () {
              this.removeEventListener();
            },
            updateEventListener: function () {
              var e = this.el;
              e.isPlaying &&
                (this.removeEventListener(),
                e.addEventListener(this.data.on, this.navigate));
            },
            removeEventListener: function () {
              var e = this.data.on;
              e && this.el.removeEventListener(e, this.navigate);
            },
            initVisualAspect: function () {
              var e,
                t,
                i,
                r = this.el;
              this.data.visualAspectEnabled &&
                !this.visualAspectInitialized &&
                ((i = this.textEl =
                  this.textEl || document.createElement("a-entity")),
                (t = this.sphereEl =
                  this.sphereEl || document.createElement("a-entity")),
                (e = this.semiSphereEl =
                  this.semiSphereEl || document.createElement("a-entity")),
                r.setAttribute("geometry", {
                  primitive: "circle",
                  radius: 1,
                  segments: 64,
                }),
                r.setAttribute("material", {
                  shader: "portal",
                  pano: this.data.image,
                  side: "double",
                }),
                i.setAttribute("text", {
                  color: this.data.titleColor,
                  align: "center",
                  font: "kelsonsans",
                  value: this.data.title || this.data.href,
                  width: 4,
                }),
                i.setAttribute("position", "0 1.5 0"),
                r.appendChild(i),
                e.setAttribute("geometry", {
                  primitive: "sphere",
                  radius: 1,
                  phiStart: 0,
                  segmentsWidth: 64,
                  segmentsHeight: 64,
                  phiLength: 180,
                  thetaStart: 0,
                  thetaLength: 360,
                }),
                e.setAttribute("material", {
                  shader: "portal",
                  borderEnabled: 0,
                  pano: this.data.image,
                  side: "back",
                }),
                e.setAttribute("rotation", "0 180 0"),
                e.setAttribute("position", "0 0 0"),
                e.setAttribute("visible", !1),
                r.appendChild(e),
                t.setAttribute("geometry", {
                  primitive: "sphere",
                  radius: 10,
                  segmentsWidth: 64,
                  segmentsHeight: 64,
                }),
                t.setAttribute("material", {
                  shader: "portal",
                  borderEnabled: 0,
                  pano: this.data.image,
                  side: "back",
                }),
                t.setAttribute("visible", !1),
                r.appendChild(t),
                (this.visualAspectInitialized = !0));
            },
            navigate: function () {
              window.location = this.data.href;
            },
            tick: (function () {
              var e = new THREE.Vector3(),
                t = new THREE.Vector3(),
                i = new THREE.Quaternion(),
                r = new THREE.Vector3();
              return function () {
                var o,
                  a,
                  n = this.el,
                  s = n.object3D,
                  l = n.sceneEl.camera,
                  d = this.textEl;
                if (this.data.visualAspectEnabled)
                  if (
                    (s.updateMatrixWorld(),
                    l.parent.updateMatrixWorld(),
                    l.updateMatrixWorld(),
                    s.matrix.decompose(t, i, r),
                    t.setFromMatrixPosition(s.matrixWorld),
                    e.setFromMatrixPosition(l.matrixWorld),
                    (a = t.distanceTo(e)) > 20)
                  )
                    this.previousQuaternion ||
                      (this.quaternionClone.copy(i),
                      (this.previousQuaternion = this.quaternionClone)),
                      s.lookAt(e);
                  else {
                    if (
                      ((o = this.calculateCameraPortalOrientation()), a < 0.5)
                    ) {
                      if (!0 === this.semiSphereEl.getAttribute("visible"))
                        return;
                      d.setAttribute("text", "width", 1.5),
                        o <= 0
                          ? (d.setAttribute("position", "0 0 0.75"),
                            d.setAttribute("rotation", "0 180 0"),
                            this.semiSphereEl.setAttribute("rotation", "0 0 0"))
                          : (d.setAttribute("position", "0 0 -0.75"),
                            d.setAttribute("rotation", "0 0 0"),
                            this.semiSphereEl.setAttribute(
                              "rotation",
                              "0 180 0"
                            )),
                        (n.getObject3D("mesh").visible = !1),
                        this.semiSphereEl.setAttribute("visible", !0),
                        (this.peekCameraPortalOrientation = o);
                    } else
                      o <= 0
                        ? d.setAttribute("rotation", "0 180 0")
                        : d.setAttribute("rotation", "0 0 0"),
                        d.setAttribute("text", "width", 5),
                        d.setAttribute("position", "0 1.5 0"),
                        (n.getObject3D("mesh").visible = !0),
                        this.semiSphereEl.setAttribute("visible", !1),
                        (this.peekCameraPortalOrientation = void 0);
                    this.previousQuaternion &&
                      (s.quaternion.copy(this.previousQuaternion),
                      (this.previousQuaternion = void 0));
                  }
              };
            })(),
            hideAll: function () {
              var e = this.el,
                t = this.hiddenEls,
                i = this;
              t.length > 0 ||
                e.sceneEl.object3D.traverse(function (r) {
                  (r && r.el && r.el.hasAttribute("link-controls")) ||
                    (r.el &&
                      r !== e.sceneEl.object3D &&
                      r.el !== e &&
                      r.el !== i.sphereEl &&
                      r.el !== e.sceneEl.cameraEl &&
                      !1 !== r.el.getAttribute("visible") &&
                      r.el !== i.textEl &&
                      r.el !== i.semiSphereEl &&
                      (r.el.setAttribute("visible", !1), t.push(r.el)));
                });
            },
            showAll: function () {
              this.hiddenEls.forEach(function (e) {
                e.setAttribute("visible", !0);
              }),
                (this.hiddenEls = []);
            },
            calculateCameraPortalOrientation: (function () {
              var e = new THREE.Matrix4(),
                t = new THREE.Vector3(),
                i = new THREE.Vector3(0, 0, 1),
                r = new THREE.Vector3(0, 0, 0);
              return function () {
                var o = this.el,
                  a = o.sceneEl.camera;
                return (
                  t.set(0, 0, 0),
                  i.set(0, 0, 1),
                  r.set(0, 0, 0),
                  o.object3D.matrixWorld.extractRotation(e),
                  i.applyMatrix4(e),
                  o.object3D.updateMatrixWorld(),
                  o.object3D.localToWorld(r),
                  a.parent.parent.updateMatrixWorld(),
                  a.parent.updateMatrixWorld(),
                  a.updateMatrixWorld(),
                  a.localToWorld(t),
                  t.sub(r).normalize(),
                  i.normalize(),
                  Math.sign(i.dot(t))
                );
              };
            })(),
            remove: function () {
              this.removeEventListener();
            },
          })),
            registerShader("portal", {
              schema: {
                borderEnabled: { default: 1, type: "int", is: "uniform" },
                backgroundColor: {
                  default: "red",
                  type: "color",
                  is: "uniform",
                },
                pano: { type: "map", is: "uniform" },
                strokeColor: { default: "white", type: "color", is: "uniform" },
              },
              vertexShader: [
                "vec3 portalPosition;",
                "varying vec3 vWorldPosition;",
                "varying float vDistanceToCenter;",
                "varying float vDistance;",
                "void main() {",
                "vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);",
                "portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;",
                "vDistance = length(portalPosition - cameraPosition);",
                "vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;",
                "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
                "}",
              ].join("\n"),
              fragmentShader: [
                "#define RECIPROCAL_PI2 0.15915494",
                "uniform sampler2D pano;",
                "uniform vec3 strokeColor;",
                "uniform vec3 backgroundColor;",
                "uniform float borderEnabled;",
                "varying float vDistanceToCenter;",
                "varying float vDistance;",
                "varying vec3 vWorldPosition;",
                "void main() {",
                "vec3 direction = normalize(vWorldPosition - cameraPosition);",
                "vec2 sampleUV;",
                "float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);",
                "sampleUV.y = saturate(direction.y * 0.5  + 0.5);",
                "sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;",
                "if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {",
                "gl_FragColor = vec4(strokeColor, 1.0);",
                "} else {",
                "gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / 15.0), 2.0), 0.0, 1.0));",
                "}",
                "}",
              ].join("\n"),
            });
        },
        {
          "../core/component": 101,
          "../core/shader": 111,
          "../lib/three": 150,
        },
      ],
      65: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            bind = utils.bind,
            PolyfillControls = _dereq_("../utils").device.PolyfillControls,
            PI_2 = Math.PI / 2,
            checkHasPositionalTracking =
              utils.device.checkHasPositionalTracking;
          module.exports.Component = registerComponent("look-controls", {
            dependencies: ["position", "rotation"],
            schema: {
              enabled: { default: !0 },
              hmdEnabled: { default: !0 },
              pointerLockEnabled: { default: !1 },
              reverseMouseDrag: { default: !1 },
              reverseTouchDrag: { default: !1 },
              touchEnabled: { default: !0 },
            },
            init: function () {
              (this.previousHMDPosition = new THREE.Vector3()),
                (this.hmdQuaternion = new THREE.Quaternion()),
                (this.hmdEuler = new THREE.Euler()),
                (this.position = new THREE.Vector3()),
                (this.savedRotation = new THREE.Vector3()),
                (this.savedPosition = new THREE.Vector3()),
                (this.polyfillObject = new THREE.Object3D()),
                (this.polyfillControls = new PolyfillControls(
                  this.polyfillObject
                )),
                (this.rotation = {}),
                (this.deltaRotation = {}),
                (this.savedPose = null),
                (this.pointerLocked = !1),
                this.setupMouseControls(),
                this.bindMethods(),
                (this.savedPose = {
                  position: new THREE.Vector3(),
                  rotation: new THREE.Euler(),
                }),
                this.el.sceneEl.is("vr-mode") && this.onEnterVR();
            },
            update: function (e) {
              var t = this.data;
              t.enabled !== e.enabled && this.updateGrabCursor(t.enabled),
                !e ||
                  t.hmdEnabled ||
                  e.hmdEnabled ||
                  (this.pitchObject.rotation.set(0, 0, 0),
                  this.yawObject.rotation.set(0, 0, 0)),
                e &&
                  !t.pointerLockEnabled !== e.pointerLockEnabled &&
                  (this.removeEventListeners(),
                  this.addEventListeners(),
                  this.pointerLocked && document.exitPointerLock());
            },
            tick: function (e) {
              this.data.enabled && this.updateOrientation();
            },
            play: function () {
              this.addEventListeners();
            },
            pause: function () {
              this.removeEventListeners();
            },
            remove: function () {
              this.removeEventListeners();
            },
            bindMethods: function () {
              (this.onMouseDown = bind(this.onMouseDown, this)),
                (this.onMouseMove = bind(this.onMouseMove, this)),
                (this.onMouseUp = bind(this.onMouseUp, this)),
                (this.onTouchStart = bind(this.onTouchStart, this)),
                (this.onTouchMove = bind(this.onTouchMove, this)),
                (this.onTouchEnd = bind(this.onTouchEnd, this)),
                (this.onEnterVR = bind(this.onEnterVR, this)),
                (this.onExitVR = bind(this.onExitVR, this)),
                (this.onPointerLockChange = bind(
                  this.onPointerLockChange,
                  this
                )),
                (this.onPointerLockError = bind(this.onPointerLockError, this));
            },
            setupMouseControls: function () {
              (this.mouseDown = !1),
                (this.pitchObject = new THREE.Object3D()),
                (this.yawObject = new THREE.Object3D()),
                (this.yawObject.position.y = 10),
                this.yawObject.add(this.pitchObject);
            },
            addEventListeners: function () {
              var e = this.el.sceneEl,
                t = e.canvas;
              if (!t)
                return void e.addEventListener(
                  "render-target-loaded",
                  bind(this.addEventListeners, this)
                );
              t.addEventListener("mousedown", this.onMouseDown, !1),
                window.addEventListener("mousemove", this.onMouseMove, !1),
                window.addEventListener("mouseup", this.onMouseUp, !1),
                t.addEventListener("touchstart", this.onTouchStart),
                window.addEventListener("touchmove", this.onTouchMove),
                window.addEventListener("touchend", this.onTouchEnd),
                e.addEventListener("enter-vr", this.onEnterVR),
                e.addEventListener("exit-vr", this.onExitVR),
                this.data.pointerLockEnabled &&
                  (document.addEventListener(
                    "pointerlockchange",
                    this.onPointerLockChange,
                    !1
                  ),
                  document.addEventListener(
                    "mozpointerlockchange",
                    this.onPointerLockChange,
                    !1
                  ),
                  document.addEventListener(
                    "pointerlockerror",
                    this.onPointerLockError,
                    !1
                  ));
            },
            removeEventListeners: function () {
              var e = this.el.sceneEl,
                t = e && e.canvas;
              t &&
                (t.removeEventListener("mousedown", this.onMouseDown),
                window.removeEventListener("mousemove", this.onMouseMove),
                window.removeEventListener("mouseup", this.onMouseUp),
                t.removeEventListener("touchstart", this.onTouchStart),
                window.removeEventListener("touchmove", this.onTouchMove),
                window.removeEventListener("touchend", this.onTouchEnd),
                e.removeEventListener("enter-vr", this.onEnterVR),
                e.removeEventListener("exit-vr", this.onExitVR),
                document.removeEventListener(
                  "pointerlockchange",
                  this.onPointerLockChange,
                  !1
                ),
                document.removeEventListener(
                  "mozpointerlockchange",
                  this.onPointerLockChange,
                  !1
                ),
                document.removeEventListener(
                  "pointerlockerror",
                  this.onPointerLockError,
                  !1
                ));
            },
            updateOrientation: function () {
              var e = this.el,
                t = this.hmdEuler,
                o = this.pitchObject,
                n = this.yawObject,
                i = this.el.sceneEl;
              (i.is("vr-mode") && i.checkHeadsetConnected()) ||
                (this.polyfillControls.update(),
                t.setFromQuaternion(this.polyfillObject.quaternion, "YXZ"),
                (e.object3D.rotation.x = t.x + o.rotation.x),
                (e.object3D.rotation.y = t.y + n.rotation.y));
            },
            onMouseMove: function (e) {
              var t,
                o,
                n,
                i = this.pitchObject,
                s = this.previousMouseEvent,
                r = this.yawObject;
              this.data.enabled &&
                (this.mouseDown || this.pointerLocked) &&
                (this.pointerLocked
                  ? ((o = e.movementX || e.mozMovementX || 0),
                    (n = e.movementY || e.mozMovementY || 0))
                  : ((o = e.screenX - s.screenX), (n = e.screenY - s.screenY)),
                (this.previousMouseEvent = e),
                (t = this.data.reverseMouseDrag ? 1 : -1),
                (r.rotation.y += 0.002 * o * t),
                (i.rotation.x += 0.002 * n * t),
                (i.rotation.x = Math.max(-PI_2, Math.min(PI_2, i.rotation.x))));
            },
            onMouseDown: function (e) {
              if (this.data.enabled && 0 === e.button) {
                var t = this.el.sceneEl,
                  o = t && t.canvas;
                (this.mouseDown = !0),
                  (this.previousMouseEvent = e),
                  this.showGrabbingCursor(),
                  this.data.pointerLockEnabled &&
                    !this.pointerLocked &&
                    (o.requestPointerLock
                      ? o.requestPointerLock()
                      : o.mozRequestPointerLock && o.mozRequestPointerLock());
              }
            },
            showGrabbingCursor: function () {
              this.el.sceneEl.canvas.style.cursor = "grabbing";
            },
            hideGrabbingCursor: function () {
              this.el.sceneEl.canvas.style.cursor = "";
            },
            onMouseUp: function () {
              (this.mouseDown = !1), this.hideGrabbingCursor();
            },
            onTouchStart: function (e) {
              1 === e.touches.length &&
                this.data.touchEnabled &&
                ((this.touchStart = {
                  x: e.touches[0].pageX,
                  y: e.touches[0].pageY,
                }),
                (this.touchStarted = !0));
            },
            onTouchMove: function (e) {
              var t,
                o,
                n = this.el.sceneEl.canvas,
                i = this.yawObject;
              this.touchStarted &&
                this.data.touchEnabled &&
                ((o =
                  (2 * Math.PI * (e.touches[0].pageX - this.touchStart.x)) /
                  n.clientWidth),
                (t = this.data.reverseTouchDrag ? 1 : -1),
                (i.rotation.y -= 0.5 * o * t),
                (this.touchStart = {
                  x: e.touches[0].pageX,
                  y: e.touches[0].pageY,
                }));
            },
            onTouchEnd: function () {
              this.touchStarted = !1;
            },
            onEnterVR: function () {
              this.saveCameraPose();
            },
            onExitVR: function () {
              this.restoreCameraPose(), this.previousHMDPosition.set(0, 0, 0);
            },
            onPointerLockChange: function () {
              this.pointerLocked = !(
                !document.pointerLockElement && !document.mozPointerLockElement
              );
            },
            onPointerLockError: function () {
              this.pointerLocked = !1;
            },
            updateGrabCursor: function (e) {
              function t() {
                n.canvas.classList.add("a-grab-cursor");
              }
              function o() {
                n.canvas.classList.remove("a-grab-cursor");
              }
              var n = this.el.sceneEl;
              return n.canvas
                ? e
                  ? void t()
                  : void o()
                : void (e
                    ? n.addEventListener("render-target-loaded", t)
                    : n.addEventListener("render-target-loaded", o));
            },
            saveCameraPose: function () {
              var e = this.el,
                t =
                  void 0 !== this.hasPositionalTracking
                    ? this.hasPositionalTracking
                    : checkHasPositionalTracking();
              !this.hasSavedPose &&
                t &&
                (this.savedPose.position.copy(e.object3D.position),
                this.savedPose.rotation.copy(e.object3D.rotation),
                (this.hasSavedPose = !0));
            },
            restoreCameraPose: function () {
              var e = this.el,
                t = this.savedPose,
                o =
                  void 0 !== this.hasPositionalTracking
                    ? this.hasPositionalTracking
                    : checkHasPositionalTracking();
              this.hasSavedPose &&
                o &&
                (e.object3D.position.copy(t.position),
                e.object3D.rotation.copy(t.rotation),
                (this.hasSavedPose = !1));
            },
          });
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils": 173,
          "../utils/": 173,
        },
      ],
      66: [
        function (_dereq_, module, exports) {
          function parseSide(e) {
            switch (e) {
              case "back":
                return THREE.BackSide;
              case "double":
                return THREE.DoubleSide;
              default:
                return THREE.FrontSide;
            }
          }
          function parseVertexColors(e) {
            switch (e) {
              case "face":
                return THREE.FaceColors;
              case "vertex":
                return THREE.VertexColors;
              default:
                return THREE.NoColors;
            }
          }
          function parseBlending(e) {
            switch (e) {
              case "none":
                return THREE.NoBlending;
              case "additive":
                return THREE.AdditiveBlending;
              case "subtractive":
                return THREE.SubtractiveBlending;
              case "multiply":
                return THREE.MultiplyBlending;
              default:
                return THREE.NormalBlending;
            }
          }
          function disposeMaterial(e, t) {
            e.dispose(), t.unregisterMaterial(e);
          }
          var utils = _dereq_("../utils/"),
            component = _dereq_("../core/component"),
            THREE = _dereq_("../lib/three"),
            shader = _dereq_("../core/shader"),
            error = utils.debug("components:material:error"),
            registerComponent = component.registerComponent,
            shaders = shader.shaders,
            shaderNames = shader.shaderNames;
          module.exports.Component = registerComponent("material", {
            schema: {
              alphaTest: { default: 0, min: 0, max: 1 },
              depthTest: { default: !0 },
              depthWrite: { default: !0 },
              flatShading: { default: !1 },
              npot: { default: !1 },
              offset: { type: "vec2", default: { x: 0, y: 0 } },
              opacity: { default: 1, min: 0, max: 1 },
              repeat: { type: "vec2", default: { x: 1, y: 1 } },
              shader: {
                default: "standard",
                oneOf: shaderNames,
                schemaChange: !0,
              },
              side: { default: "front", oneOf: ["front", "back", "double"] },
              transparent: { default: !1 },
              vertexColors: {
                type: "string",
                default: "none",
                oneOf: ["face", "vertex"],
              },
              visible: { default: !0 },
              blending: {
                default: "normal",
                oneOf: [
                  "none",
                  "normal",
                  "additive",
                  "subtractive",
                  "multiply",
                ],
              },
            },
            init: function () {
              this.material = null;
            },
            update: function (e) {
              var t = this.data;
              (this.shader && t.shader === e.shader) ||
                this.updateShader(t.shader),
                this.shader.update(this.data),
                this.updateMaterial(e);
            },
            updateSchema: function (e) {
              var t, a, r, i;
              (a = e && e.shader),
                (t = this.oldData && this.oldData.shader),
                (i = a || t),
                (r = shaders[i] && shaders[i].schema),
                r || error("Unknown shader schema " + i),
                (t && a === t) || (this.extendSchema(r), this.updateBehavior());
            },
            updateBehavior: function () {
              function e(e, t) {
                var r;
                for (r in a) a[r] = e;
                s.shader.update(a);
              }
              var t,
                a,
                r = this.el.sceneEl,
                i = this.schema,
                s = this;
              (this.tick = void 0), (a = {});
              for (t in i)
                "time" === i[t].type && ((this.tick = e), (a[t] = !0));
              r && (this.tick ? r.addBehavior(this) : r.removeBehavior(this));
            },
            updateShader: function (e) {
              var t,
                a = this.data,
                r = shaders[e] && shaders[e].Shader;
              if (!r) throw new Error("Unknown shader " + e);
              (t = this.shader = new r()),
                (t.el = this.el),
                t.init(a),
                this.setMaterial(t.material),
                this.updateSchema(a);
            },
            updateMaterial: function (e) {
              var t,
                a = this.data,
                r = this.material;
              (r.alphaTest = a.alphaTest),
                (r.depthTest = !1 !== a.depthTest),
                (r.depthWrite = !1 !== a.depthWrite),
                (r.opacity = a.opacity),
                (r.flatShading = a.flatShading),
                (r.side = parseSide(a.side)),
                (r.transparent = !1 !== a.transparent || a.opacity < 1),
                (r.vertexColors = parseVertexColors(a.vertexColors)),
                (r.visible = a.visible),
                (r.blending = parseBlending(a.blending));
              for (t in e) break;
              !t ||
                (e.alphaTest === a.alphaTest &&
                  e.side === a.side &&
                  e.vertexColors === a.vertexColors) ||
                (r.needsUpdate = !0);
            },
            remove: function () {
              var e = new THREE.MeshBasicMaterial(),
                t = this.material,
                a = this.el.getObject3D("mesh");
              a && (a.material = e), disposeMaterial(t, this.system);
            },
            setMaterial: function (e) {
              var t,
                a = this.el,
                r = this.system;
              this.material && disposeMaterial(this.material, r),
                (this.material = e),
                r.registerMaterial(e),
                (t = a.getObject3D("mesh")),
                t
                  ? (t.material = e)
                  : a.addEventListener("object3dset", function t(r) {
                      "mesh" === r.detail.type &&
                        r.target === a &&
                        ((a.getObject3D("mesh").material = e),
                        a.removeEventListener("object3dset", t));
                    });
            },
          });
        },
        {
          "../core/component": 101,
          "../core/shader": 111,
          "../lib/three": 150,
          "../utils/": 173,
        },
      ],
      67: [
        function (_dereq_, module, exports) {
          var debug = _dereq_("../utils/debug"),
            registerComponent = _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            warn = debug("components:obj-model:warn");
          module.exports.Component = registerComponent("obj-model", {
            schema: { mtl: { type: "model" }, obj: { type: "model" } },
            init: function () {
              (this.model = null),
                (this.objLoader = new THREE.OBJLoader()),
                (this.mtlLoader = new THREE.MTLLoader(this.objLoader.manager)),
                (this.mtlLoader.crossOrigin = "");
            },
            update: function () {
              var e = this.data;
              e.obj && (this.resetMesh(), this.loadObj(e.obj, e.mtl));
            },
            remove: function () {
              this.model && this.resetMesh();
            },
            resetMesh: function () {
              this.el.removeObject3D("mesh");
            },
            loadObj: function (e, t) {
              var o = this,
                r = this.el,
                i = this.mtlLoader,
                a = this.objLoader;
              if (t)
                return (
                  r.hasAttribute("material") &&
                    warn(
                      "Material component properties are ignored when a .MTL is provided"
                    ),
                  i.setTexturePath(t.substr(0, t.lastIndexOf("/") + 1)),
                  void i.load(t, function (t) {
                    t.preload(),
                      a.setMaterials(t),
                      a.load(e, function (e) {
                        (o.model = e),
                          r.setObject3D("mesh", e),
                          r.emit("model-loaded", { format: "obj", model: e });
                      });
                  })
                );
              a.load(e, function (e) {
                var t = r.components.material;
                t &&
                  e.traverse(function (e) {
                    e instanceof THREE.Mesh && (e.material = t.material);
                  }),
                  (o.model = e),
                  r.setObject3D("mesh", e),
                  r.emit("model-loaded", { format: "obj", model: e });
              });
            },
          });
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils/debug": 169,
        },
      ],
      68: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            bind = _dereq_("../utils/bind"),
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            checkControllerPresentAndSetup =
              trackedControlsUtils.checkControllerPresentAndSetup,
            emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged,
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            GAMEPAD_ID_PREFIX = "Oculus Go",
            OCULUS_GO_CONTROLLER_MODEL_URL =
              "https://cdn.aframe.io/controllers/oculus/go/oculus-go-controller.gltf";
          module.exports.Component = registerComponent("oculus-go-controls", {
            schema: {
              hand: { default: "" },
              buttonColor: { type: "color", default: "#FFFFFF" },
              buttonTouchedColor: { type: "color", default: "#BBBBBB" },
              buttonHighlightColor: { type: "color", default: "#7A7A7A" },
              model: { default: !0 },
              rotationOffset: { default: 0 },
              armModel: { default: !0 },
            },
            mapping: {
              axes: { trackpad: [0, 1] },
              buttons: ["trackpad", "trigger"],
            },
            bindMethods: function () {
              (this.onModelLoaded = bind(this.onModelLoaded, this)),
                (this.onControllersUpdate = bind(
                  this.onControllersUpdate,
                  this
                )),
                (this.checkIfControllerPresent = bind(
                  this.checkIfControllerPresent,
                  this
                )),
                (this.removeControllersUpdateListener = bind(
                  this.removeControllersUpdateListener,
                  this
                )),
                (this.onAxisMoved = bind(this.onAxisMoved, this));
            },
            init: function () {
              var t = this;
              (this.animationActive = "pointing"),
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                (this.onButtonDown = function (e) {
                  onButtonEvent(e.detail.id, "down", t);
                }),
                (this.onButtonUp = function (e) {
                  onButtonEvent(e.detail.id, "up", t);
                }),
                (this.onButtonTouchStart = function (e) {
                  onButtonEvent(e.detail.id, "touchstart", t);
                }),
                (this.onButtonTouchEnd = function (e) {
                  onButtonEvent(e.detail.id, "touchend", t);
                }),
                (this.onAxisMoved = bind(this.onAxisMoved, this)),
                (this.controllerPresent = !1),
                (this.lastControllerCheck = 0),
                this.bindMethods(),
                (this.checkControllerPresentAndSetup =
                  checkControllerPresentAndSetup),
                (this.emitIfAxesChanged = emitIfAxesChanged);
            },
            addEventListeners: function () {
              var t = this.el;
              t.addEventListener("buttonchanged", this.onButtonChanged),
                t.addEventListener("buttondown", this.onButtonDown),
                t.addEventListener("buttonup", this.onButtonUp),
                t.addEventListener("touchstart", this.onButtonTouchStart),
                t.addEventListener("touchend", this.onButtonTouchEnd),
                t.addEventListener("model-loaded", this.onModelLoaded),
                t.addEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !0);
            },
            removeEventListeners: function () {
              var t = this.el;
              t.removeEventListener("buttonchanged", this.onButtonChanged),
                t.removeEventListener("buttondown", this.onButtonDown),
                t.removeEventListener("buttonup", this.onButtonUp),
                t.removeEventListener("touchstart", this.onButtonTouchStart),
                t.removeEventListener("touchend", this.onButtonTouchEnd),
                t.removeEventListener("model-loaded", this.onModelLoaded),
                t.removeEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !1);
            },
            checkIfControllerPresent: function () {
              this.checkControllerPresentAndSetup(
                this,
                GAMEPAD_ID_PREFIX,
                this.data.hand ? { hand: this.data.hand } : {}
              );
            },
            play: function () {
              this.checkIfControllerPresent(),
                this.addControllersUpdateListener();
            },
            pause: function () {
              this.removeEventListeners(),
                this.removeControllersUpdateListener();
            },
            injectTrackedControls: function () {
              var t = this.el,
                e = this.data;
              t.setAttribute("tracked-controls", {
                armModel: e.armModel,
                idPrefix: GAMEPAD_ID_PREFIX,
                rotationOffset: e.rotationOffset,
              }),
                this.data.model &&
                  this.el.setAttribute(
                    "gltf-model",
                    OCULUS_GO_CONTROLLER_MODEL_URL
                  );
            },
            addControllersUpdateListener: function () {
              this.el.sceneEl.addEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            removeControllersUpdateListener: function () {
              this.el.sceneEl.removeEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            onControllersUpdate: function () {
              this.checkIfControllerPresent();
            },
            onModelLoaded: function (t) {
              var e,
                o = t.detail.model;
              this.data.model &&
                ((e = this.buttonMeshes = {}),
                (e.trigger = o.getObjectByName("oculus_go_button_trigger")),
                (e.trackpad = o.getObjectByName("oculus_go_touchpad")));
            },
            onButtonChanged: function (t) {
              var e = this.mapping.buttons[t.detail.id];
              e && this.el.emit(e + "changed", t.detail.state);
            },
            onAxisMoved: function (t) {
              this.emitIfAxesChanged(this, this.mapping.axes, t);
            },
            updateModel: function (t, e) {
              this.data.model && this.updateButtonModel(t, e);
            },
            updateButtonModel: function (t, e) {
              var o = this.buttonMeshes;
              if (o && o[t]) {
                var n;
                switch (e) {
                  case "down":
                    n = this.data.buttonHighlightColor;
                    break;
                  case "touchstart":
                    n = this.data.buttonTouchedColor;
                    break;
                  default:
                    n = this.data.buttonColor;
                }
                o[t].material.color.set(n);
              }
            },
          });
        },
        {
          "../core/component": 101,
          "../utils/bind": 167,
          "../utils/tracked-controls": 180,
        },
      ],
      69: [
        function (_dereq_, module, exports) {
          var bind = _dereq_("../utils/bind"),
            registerComponent = _dereq_("../core/component").registerComponent,
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            THREE = _dereq_("../lib/three"),
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            TOUCH_CONTROLLER_MODEL_BASE_URL =
              "https://cdn.aframe.io/controllers/oculus/oculus-touch-controller-",
            TOUCH_CONTROLLER_MODEL_URL = {
              left: TOUCH_CONTROLLER_MODEL_BASE_URL + "left.gltf",
              right: TOUCH_CONTROLLER_MODEL_BASE_URL + "right.gltf",
            },
            GAMEPAD_ID_PREFIX = "Oculus Touch",
            DEFAULT_MODEL_PIVOT_OFFSET = new THREE.Vector3(0, 0, -0.053),
            RAY_ORIGIN = {
              left: {
                origin: { x: 0.008, y: -0.004, z: 0 },
                direction: { x: 0, y: -0.8, z: -1 },
              },
              right: {
                origin: { x: -0.008, y: -0.004, z: 0 },
                direction: { x: 0, y: -0.8, z: -1 },
              },
            };
          module.exports.Component = registerComponent(
            "oculus-touch-controls",
            {
              schema: {
                hand: { default: "left" },
                buttonColor: { type: "color", default: "#999" },
                buttonTouchColor: { type: "color", default: "#8AB" },
                buttonHighlightColor: { type: "color", default: "#2DF" },
                model: { default: !0 },
                orientationOffset: {
                  type: "vec3",
                  default: { x: 43, y: 0, z: 0 },
                },
              },
              mapping: {
                left: {
                  axes: { thumbstick: [0, 1] },
                  buttons: [
                    "thumbstick",
                    "trigger",
                    "grip",
                    "xbutton",
                    "ybutton",
                    "surface",
                  ],
                },
                right: {
                  axes: { thumbstick: [0, 1] },
                  buttons: [
                    "thumbstick",
                    "trigger",
                    "grip",
                    "abutton",
                    "bbutton",
                    "surface",
                  ],
                },
              },
              bindMethods: function () {
                (this.onModelLoaded = bind(this.onModelLoaded, this)),
                  (this.onControllersUpdate = bind(
                    this.onControllersUpdate,
                    this
                  )),
                  (this.checkIfControllerPresent = bind(
                    this.checkIfControllerPresent,
                    this
                  )),
                  (this.onAxisMoved = bind(this.onAxisMoved, this));
              },
              init: function () {
                var t = this;
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                  (this.onButtonDown = function (e) {
                    onButtonEvent(e.detail.id, "down", t, t.data.hand);
                  }),
                  (this.onButtonUp = function (e) {
                    onButtonEvent(e.detail.id, "up", t, t.data.hand);
                  }),
                  (this.onButtonTouchStart = function (e) {
                    onButtonEvent(e.detail.id, "touchstart", t, t.data.hand);
                  }),
                  (this.onButtonTouchEnd = function (e) {
                    onButtonEvent(e.detail.id, "touchend", t, t.data.hand);
                  }),
                  (this.controllerPresent = !1),
                  (this.lastControllerCheck = 0),
                  (this.previousButtonValues = {}),
                  this.bindMethods(),
                  (this.emitIfAxesChanged =
                    trackedControlsUtils.emitIfAxesChanged),
                  (this.checkControllerPresentAndSetup =
                    trackedControlsUtils.checkControllerPresentAndSetup);
              },
              addEventListeners: function () {
                var t = this.el;
                t.addEventListener("buttonchanged", this.onButtonChanged),
                  t.addEventListener("buttondown", this.onButtonDown),
                  t.addEventListener("buttonup", this.onButtonUp),
                  t.addEventListener("touchstart", this.onButtonTouchStart),
                  t.addEventListener("touchend", this.onButtonTouchEnd),
                  t.addEventListener("axismove", this.onAxisMoved),
                  t.addEventListener("model-loaded", this.onModelLoaded),
                  (this.controllerEventsActive = !0);
              },
              removeEventListeners: function () {
                var t = this.el;
                t.removeEventListener("buttonchanged", this.onButtonChanged),
                  t.removeEventListener("buttondown", this.onButtonDown),
                  t.removeEventListener("buttonup", this.onButtonUp),
                  t.removeEventListener("touchstart", this.onButtonTouchStart),
                  t.removeEventListener("touchend", this.onButtonTouchEnd),
                  t.removeEventListener("axismove", this.onAxisMoved),
                  t.removeEventListener("model-loaded", this.onModelLoaded),
                  (this.controllerEventsActive = !1);
              },
              checkIfControllerPresent: function () {
                this.checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                  hand: this.data.hand,
                });
              },
              play: function () {
                this.checkIfControllerPresent(),
                  this.addControllersUpdateListener();
              },
              pause: function () {
                this.removeEventListeners(),
                  this.removeControllersUpdateListener();
              },
              loadModel: function () {
                var t = this.data;
                t.model &&
                  this.el.setAttribute(
                    "gltf-model",
                    "url(" + TOUCH_CONTROLLER_MODEL_URL[t.hand] + ")"
                  );
              },
              injectTrackedControls: function () {
                var t = this.data;
                this.el.setAttribute("tracked-controls", {
                  id:
                    "right" === t.hand
                      ? "Oculus Touch (Right)"
                      : "Oculus Touch (Left)",
                  controller: 0,
                  orientationOffset: t.orientationOffset,
                }),
                  this.loadModel();
              },
              addControllersUpdateListener: function () {
                this.el.sceneEl.addEventListener(
                  "controllersupdated",
                  this.onControllersUpdate,
                  !1
                );
              },
              removeControllersUpdateListener: function () {
                this.el.sceneEl.removeEventListener(
                  "controllersupdated",
                  this.onControllersUpdate,
                  !1
                );
              },
              onControllersUpdate: function () {
                this.checkIfControllerPresent();
              },
              onButtonChanged: function (t) {
                var e,
                  o = this.mapping[this.data.hand].buttons[t.detail.id],
                  n = this.buttonMeshes;
                o &&
                  (("trigger" !== o && "grip" !== o) ||
                    (e = t.detail.state.value),
                  n &&
                    ("trigger" === o &&
                      n.trigger &&
                      (n.trigger.rotation.x = -e * (Math.PI / 24)),
                    "grip" === o &&
                      n.grip &&
                      (n.grip.rotation.y =
                        ("left" === this.data.hand ? -1 : 1) *
                        e *
                        (Math.PI / 60))),
                  this.el.emit(o + "changed", t.detail.state));
              },
              onModelLoaded: function (t) {
                var e,
                  o = t.detail.model;
                if (this.data.model) {
                  var n = "left" === this.data.hand;
                  (e = this.buttonMeshes = {}),
                    (e.grip = o.getObjectByName(
                      n
                        ? "buttonHand_oculus-touch-controller-left.004"
                        : "buttonHand_oculus-touch-controller-right.005"
                    )),
                    (e.thumbstick = o.getObjectByName(
                      n
                        ? "stick_oculus-touch-controller-left.007"
                        : "stick_oculus-touch-controller-right.004"
                    )),
                    (e.trigger = o.getObjectByName(
                      n
                        ? "buttonTrigger_oculus-touch-controller-left.005"
                        : "buttonTrigger_oculus-touch-controller-right.006"
                    )),
                    (e.xbutton = o.getObjectByName(
                      "buttonX_oculus-touch-controller-left.002"
                    )),
                    (e.abutton = o.getObjectByName(
                      "buttonA_oculus-touch-controller-right.002"
                    )),
                    (e.ybutton = o.getObjectByName(
                      "buttonY_oculus-touch-controller-left.001"
                    )),
                    (e.bbutton = o.getObjectByName(
                      "buttonB_oculus-touch-controller-right.003"
                    )),
                    o.position.copy(DEFAULT_MODEL_PIVOT_OFFSET),
                    this.el.emit("controllermodelready", {
                      name: "oculus-touch-controls",
                      model: this.data.model,
                      rayOrigin: RAY_ORIGIN[this.data.hand],
                    });
                }
              },
              onAxisMoved: function (t) {
                this.emitIfAxesChanged(
                  this,
                  this.mapping[this.data.hand].axes,
                  t
                );
              },
              updateModel: function (t, e) {
                this.data.model && this.updateButtonModel(t, e);
              },
              updateButtonModel: function (t, e) {
                var o =
                    "up" === e || "touchend" === e
                      ? this.data.buttonColor
                      : "touchstart" === e
                      ? this.data.buttonTouchColor
                      : this.data.buttonHighlightColor,
                  n = this.buttonMeshes;
                this.data.model && n && n[t] && n[t].material.color.set(o);
              },
            }
          );
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils/bind": 167,
          "../utils/tracked-controls": 180,
        },
      ],
      70: [
        function (_dereq_, module, exports) {
          var registerComponent =
            _dereq_("../core/component").registerComponent;
          module.exports.Component = registerComponent("position", {
            schema: { type: "vec3" },
            update: function () {
              var e = this.el.object3D,
                o = this.data;
              e.position.set(o.x, o.y, o.z);
            },
            remove: function () {
              this.el.object3D.position.set(0, 0, 0);
            },
          });
        },
        { "../core/component": 101 },
      ],
      71: [
        function (_dereq_, module, exports) {
          function copyArray(e, t) {
            var i;
            for (e.length = t.length, i = 0; i < t.length; i++) e[i] = t[i];
          }
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            warn = utils.debug("components:raycaster:warn"),
            OBSERVER_SELECTOR_RE = /^[\w\s-.,[\]#]*$/,
            OBSERVER_CONFIG = { childList: !0, attributes: !0, subtree: !0 },
            EVENTS = {
              INTERSECT: "raycaster-intersected",
              INTERSECTION: "raycaster-intersection",
              INTERSECT_CLEAR: "raycaster-intersected-cleared",
              INTERSECTION_CLEAR: "raycaster-intersection-cleared",
            };
          module.exports.Component = registerComponent("raycaster", {
            schema: {
              autoRefresh: { default: !0 },
              direction: { type: "vec3", default: { x: 0, y: 0, z: -1 } },
              enabled: { default: !0 },
              far: { default: 1e3 },
              interval: { default: 0 },
              near: { default: 0 },
              objects: { default: "" },
              origin: { type: "vec3" },
              recursive: { default: !0 },
              showLine: { default: !1 },
              useWorldCoordinates: { default: !1 },
            },
            multiple: !0,
            init: function () {
              (this.clearedIntersectedEls = []),
                (this.unitLineEndVec3 = new THREE.Vector3()),
                (this.intersectedEls = []),
                (this.intersections = []),
                (this.newIntersectedEls = []),
                (this.newIntersections = []),
                (this.objects = []),
                (this.prevCheckTime = void 0),
                (this.prevIntersectedEls = []),
                (this.rawIntersections = []),
                (this.raycaster = new THREE.Raycaster()),
                this.updateOriginDirection(),
                (this.setDirty = this.setDirty.bind(this)),
                (this.updateLine = this.updateLine.bind(this)),
                (this.observer = new MutationObserver(this.setDirty)),
                (this.dirty = !0),
                (this.lineEndVec3 = new THREE.Vector3()),
                (this.otherLineEndVec3 = new THREE.Vector3()),
                (this.lineData = { end: this.lineEndVec3 }),
                (this.getIntersection = this.getIntersection.bind(this)),
                (this.intersectedDetail = {
                  el: this.el,
                  getIntersection: this.getIntersection,
                }),
                (this.intersectedClearedDetail = { el: this.el }),
                (this.intersectionClearedDetail = {
                  clearedEls: this.clearedIntersectedEls,
                }),
                (this.intersectionDetail = {});
            },
            update: function (e) {
              var t = this.data,
                i = this.el,
                s = this.raycaster;
              (s.far = t.far),
                (s.near = t.near),
                !t.showLine ||
                  (t.far === e.far &&
                    t.origin === e.origin &&
                    t.direction === e.direction &&
                    e.showLine) ||
                  (this.unitLineEndVec3
                    .copy(t.origin)
                    .add(t.direction)
                    .normalize(),
                  this.drawLine()),
                !t.showLine && e.showLine && i.removeAttribute("line"),
                t.objects === e.objects ||
                  OBSERVER_SELECTOR_RE.test(t.objects) ||
                  warn(
                    '[raycaster] Selector "' +
                      t.objects +
                      '" may not update automatically with DOM changes.'
                  ),
                t.objects ||
                  warn(
                    '[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'
                  ),
                t.autoRefresh !== e.autoRefresh &&
                  i.isPlaying &&
                  (t.autoRefresh
                    ? this.addEventListeners()
                    : this.removeEventListeners()),
                e.enabled && !t.enabled && this.clearAllIntersections(),
                this.setDirty();
            },
            play: function () {
              this.addEventListeners();
            },
            pause: function () {
              this.removeEventListeners();
            },
            remove: function () {
              this.data.showLine && this.el.removeAttribute("line"),
                this.clearAllIntersections();
            },
            addEventListeners: function () {
              this.data.autoRefresh &&
                (this.observer.observe(this.el.sceneEl, OBSERVER_CONFIG),
                this.el.sceneEl.addEventListener("object3dset", this.setDirty),
                this.el.sceneEl.addEventListener(
                  "object3dremove",
                  this.setDirty
                ));
            },
            removeEventListeners: function () {
              this.observer.disconnect(),
                this.el.sceneEl.removeEventListener(
                  "object3dset",
                  this.setDirty
                ),
                this.el.sceneEl.removeEventListener(
                  "object3dremove",
                  this.setDirty
                );
            },
            setDirty: function () {
              this.dirty = !0;
            },
            refreshObjects: function () {
              var e,
                t = this.data;
              (e = t.objects
                ? this.el.sceneEl.querySelectorAll(t.objects)
                : this.el.sceneEl.querySelectorAll("*")),
                (this.objects = this.flattenObject3DMaps(e)),
                (this.dirty = !1);
            },
            tick: function (e) {
              var t = this.data,
                i = this.prevCheckTime;
              t.enabled &&
                ((i && e - i < t.interval) ||
                  ((this.prevCheckTime = e), this.checkIntersections()));
            },
            checkIntersections: function () {
              var e,
                t,
                i = this.clearedIntersectedEls,
                s = this.el,
                n = this.data,
                r = this.intersectedEls,
                c = this.intersections,
                o = this.newIntersectedEls,
                a = this.newIntersections,
                h = this.prevIntersectedEls,
                l = this.rawIntersections;
              for (
                this.dirty && this.refreshObjects(),
                  copyArray(this.prevIntersectedEls, this.intersectedEls),
                  this.updateOriginDirection(),
                  l.length = 0,
                  this.raycaster.intersectObjects(this.objects, n.recursive, l),
                  c.length = 0,
                  r.length = 0,
                  e = 0;
                e < l.length;
                e++
              )
                (t = l[e]),
                  (n.showLine && t.object === s.getObject3D("line")) ||
                    (t.object.el && (c.push(t), r.push(t.object.el)));
              for (a.length = 0, o.length = 0, e = 0; e < c.length; e++)
                -1 === h.indexOf(c[e].object.el) &&
                  (a.push(c[e]), o.push(c[e].object.el));
              for (i.length = 0, e = 0; e < h.length; e++)
                -1 === r.indexOf(h[e]) &&
                  (h[e].emit(
                    EVENTS.INTERSECT_CLEAR,
                    this.intersectedClearedDetail
                  ),
                  i.push(h[e]));
              for (
                i.length &&
                  s.emit(
                    EVENTS.INTERSECTION_CLEAR,
                    this.intersectionClearedDetail
                  ),
                  e = 0;
                e < o.length;
                e++
              )
                o[e].emit(EVENTS.INTERSECT, this.intersectedDetail);
              a.length &&
                ((this.intersectionDetail.els = o),
                (this.intersectionDetail.intersections = a),
                s.emit(EVENTS.INTERSECTION, this.intersectionDetail)),
                setTimeout(this.updateLine);
            },
            updateLine: function () {
              var e,
                t = this.el,
                i = this.intersections;
              this.data.showLine &&
                (i.length &&
                  (e =
                    i[0].object.el === t && i[1]
                      ? i[1].distance
                      : i[0].distance),
                this.drawLine(e));
            },
            getIntersection: function (e) {
              var t, i;
              for (t = 0; t < this.intersections.length; t++)
                if (((i = this.intersections[t]), i.object.el === e)) return i;
              return null;
            },
            updateOriginDirection: (function () {
              var e = new THREE.Vector3(),
                t = new THREE.Vector3();
              return function () {
                var i = this.el,
                  s = this.data;
                if (s.useWorldCoordinates)
                  return void this.raycaster.set(s.origin, s.direction);
                i.object3D.getWorldPosition(t),
                  (0 === s.origin.x && 0 === s.origin.y && 0 === s.origin.z) ||
                    (t = i.object3D.localToWorld(t.copy(s.origin))),
                  e
                    .copy(s.direction)
                    .transformDirection(i.object3D.matrixWorld)
                    .normalize(),
                  this.raycaster.set(t, e);
              };
            })(),
            drawLine: function (e) {
              var t,
                i = this.data,
                s = this.el;
              (t =
                this.lineData.end === this.lineEndVec3
                  ? this.otherLineEndVec3
                  : this.lineEndVec3),
                void 0 === e && (e = i.far === 1 / 0 ? 1e3 : i.far),
                (this.lineData.start = i.origin),
                (this.lineData.end = t
                  .copy(this.unitLineEndVec3)
                  .multiplyScalar(e)),
                s.setAttribute("line", this.lineData);
            },
            flattenObject3DMaps: function (e) {
              var t,
                i,
                s = this.objects;
              for (s.length = 0, i = 0; i < e.length; i++)
                if (e[i].isEntity && e[i].object3D)
                  for (t in e[i].object3DMap) s.push(e[i].getObject3D(t));
              return s;
            },
            clearAllIntersections: function () {
              var e;
              for (e = 0; e < this.intersectedEls.length; e++)
                this.intersectedEls[e].emit(
                  EVENTS.INTERSECT_CLEAR,
                  this.intersectedClearedDetail
                );
              copyArray(this.clearedIntersectedEls, this.intersectedEls),
                (this.intersectedEls.length = 0),
                (this.intersections.length = 0),
                this.el.emit(
                  EVENTS.INTERSECTION_CLEAR,
                  this.intersectionClearedDetail
                );
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150, "../utils/": 173 },
      ],
      72: [
        function (_dereq_, module, exports) {
          var degToRad = _dereq_("../lib/three").Math.degToRad,
            registerComponent = _dereq_("../core/component").registerComponent;
          module.exports.Component = registerComponent("rotation", {
            schema: { type: "vec3" },
            update: function () {
              var e = this.data,
                o = this.el.object3D;
              o.rotation.set(degToRad(e.x), degToRad(e.y), degToRad(e.z)),
                (o.rotation.order = "YXZ");
            },
            remove: function () {
              this.el.object3D.rotation.set(0, 0, 0);
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150 },
      ],
      73: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            zeroScale = 1e-5;
          module.exports.Component = registerComponent("scale", {
            schema: { type: "vec3", default: { x: 1, y: 1, z: 1 } },
            update: function () {
              var e = this.data,
                o = this.el.object3D,
                t = 0 === e.x ? zeroScale : e.x,
                r = 0 === e.y ? zeroScale : e.y,
                c = 0 === e.z ? zeroScale : e.z;
              o.scale.set(t, r, c);
            },
            remove: function () {
              this.el.object3D.scale.set(1, 1, 1);
            },
          });
        },
        { "../core/component": 101 },
      ],
      74: [
        function (_dereq_, module, exports) {
          var register = _dereq_("../../core/component").registerComponent;
          module.exports.Component = register("background", {
            schema: {
              color: { type: "color", default: "black" },
              transparent: { default: !1 },
            },
            update: function () {
              var e = this.data,
                r = this.el.object3D;
              if (e.transparent) return void (r.background = null);
              r.background = new THREE.Color(e.color);
            },
          });
        },
        { "../../core/component": 101 },
      ],
      75: [
        function (_dereq_, module, exports) {
          var register = _dereq_("../../core/component").registerComponent;
          module.exports.Component = register("debug", {
            schema: { default: !0 },
          });
        },
        { "../../core/component": 101 },
      ],
      76: [
        function (_dereq_, module, exports) {
          var registerComponent = _dereq_(
            "../../core/component"
          ).registerComponent;
          module.exports.Component = registerComponent("embedded", {
            dependencies: ["vr-mode-ui"],
            schema: { default: !0 },
            update: function () {
              var e = this.el,
                r = e.querySelector(".a-enter-vr");
              !0 === this.data
                ? (r && r.classList.add("embedded"), e.removeFullScreenStyles())
                : (r && r.classList.remove("embedded"),
                  e.addFullScreenStyles());
            },
          });
        },
        { "../../core/component": 101 },
      ],
      77: [
        function (_dereq_, module, exports) {
          function getFog(e) {
            var o;
            return (
              (o =
                "exponential" === e.type
                  ? new THREE.FogExp2(e.color, e.density)
                  : new THREE.Fog(e.color, e.near, e.far)),
              (o.name = e.type),
              o
            );
          }
          var register = _dereq_("../../core/component").registerComponent,
            THREE = _dereq_("../../lib/three"),
            debug = _dereq_("../../utils/debug"),
            warn = debug("components:fog:warn");
          module.exports.Component = register("fog", {
            schema: {
              color: { type: "color", default: "#000" },
              density: { default: 25e-5 },
              far: { default: 1e3, min: 0 },
              near: { default: 1, min: 0 },
              type: { default: "linear", oneOf: ["linear", "exponential"] },
            },
            update: function () {
              var e = this.data,
                o = this.el,
                t = this.el.object3D.fog;
              return o.isScene
                ? t && e.type === t.name
                  ? void Object.keys(this.schema).forEach(function (o) {
                      var n = e[o];
                      "color" === o && (n = new THREE.Color(n)), (t[o] = n);
                    })
                  : ((o.object3D.fog = getFog(e)),
                    void o.systems.material.updateMaterials())
                : void warn("Fog component can only be applied to <a-scene>");
            },
            remove: function () {
              var e = this.el.object3D.fog;
              e && ((e.far = 0), (e.near = 0.1));
            },
          });
        },
        {
          "../../core/component": 101,
          "../../lib/three": 150,
          "../../utils/debug": 169,
        },
      ],
      78: [
        function (_dereq_, module, exports) {
          (function (process) {
            function getFuzzyPatchVersion(e) {
              var n = e.split(".");
              return (n[2] = "x"), n.join(".");
            }
            var AFRAME_INJECTED = _dereq_("../../constants").AFRAME_INJECTED,
              bind = _dereq_("../../utils/bind"),
              pkg = _dereq_("../../../package"),
              registerComponent = _dereq_(
                "../../core/component"
              ).registerComponent,
              INSPECTOR_DEV_URL =
                "https://aframe.io/aframe-inspector/dist/aframe-inspector.js",
              INSPECTOR_RELEASE_URL =
                "https://unpkg.com/aframe-inspector@" +
                getFuzzyPatchVersion(pkg.version) +
                "/dist/aframe-inspector.min.js",
              INSPECTOR_URL =
                "dev" === process.env.INSPECTOR_VERSION
                  ? INSPECTOR_DEV_URL
                  : INSPECTOR_RELEASE_URL,
              LOADING_MESSAGE = "Loading Inspector",
              LOADING_ERROR_MESSAGE = "Error loading Inspector";
            module.exports.Component = registerComponent("inspector", {
              schema: { url: { default: INSPECTOR_URL } },
              init: function () {
                (this.onKeydown = bind(this.onKeydown, this)),
                  (this.onMessage = bind(this.onMessage, this)),
                  this.initOverlay(),
                  window.addEventListener("keydown", this.onKeydown),
                  window.addEventListener("message", this.onMessage);
              },
              initOverlay: function () {
                (this.loadingMessageEl = document.createElement("div")),
                  this.loadingMessageEl.classList.add("a-inspector-loader"),
                  (this.loadingMessageEl.innerHTML =
                    LOADING_MESSAGE +
                    '<span class="dots"><span>.</span><span>.</span><span>.</span></span>');
              },
              remove: function () {
                this.removeEventListeners();
              },
              onKeydown: function (e) {
                var n = 73 === e.keyCode && e.ctrlKey && e.altKey;
                this.data && n && this.injectInspector();
              },
              showLoader: function () {
                document.body.appendChild(this.loadingMessageEl);
              },
              hideLoader: function () {
                document.body.removeChild(this.loadingMessageEl);
              },
              onMessage: function (e) {
                "INJECT_AFRAME_INSPECTOR" === e.data && this.injectInspector();
              },
              injectInspector: function () {
                var e,
                  n = this;
                AFRAME.INSPECTOR ||
                  AFRAME.inspectorInjected ||
                  (this.showLoader(),
                  (e = document.createElement("script")),
                  (e.src = this.data.url),
                  e.setAttribute("data-name", "aframe-inspector"),
                  e.setAttribute(AFRAME_INJECTED, ""),
                  (e.onload = function () {
                    AFRAME.INSPECTOR.open(),
                      n.hideLoader(),
                      n.removeEventListeners();
                  }),
                  (e.onerror = function () {
                    n.loadingMessageEl.innerHTML = LOADING_ERROR_MESSAGE;
                  }),
                  document.head.appendChild(e),
                  (AFRAME.inspectorInjected = !0));
              },
              removeEventListeners: function () {
                window.removeEventListener("keydown", this.onKeydown),
                  window.removeEventListener("message", this.onMessage);
              },
            });
          }.call(this, _dereq_("_process")));
        },
        {
          "../../../package": 50,
          "../../constants": 93,
          "../../core/component": 101,
          "../../utils/bind": 167,
          _process: 6,
        },
      ],
      79: [
        function (_dereq_, module, exports) {
          var registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            shouldCaptureKeyEvent =
              _dereq_("../../utils/").shouldCaptureKeyEvent;
          module.exports.Component = registerComponent("keyboard-shortcuts", {
            schema: { enterVR: { default: !0 }, exitVR: { default: !0 } },
            init: function () {
              this.onKeyup = this.onKeyup.bind(this);
            },
            update: function (e) {
              var t = this.data;
              this.enterVREnabled = t.enterVR;
            },
            play: function () {
              window.addEventListener("keyup", this.onKeyup, !1);
            },
            pause: function () {
              window.removeEventListener("keyup", this.onKeyup);
            },
            onKeyup: function (e) {
              var t = this.el;
              shouldCaptureKeyEvent(e) &&
                (this.enterVREnabled && 70 === e.keyCode && t.enterVR(),
                this.enterVREnabled && 27 === e.keyCode && t.exitVR());
            },
          });
        },
        { "../../core/component": 101, "../../utils/": 173 },
      ],
      80: [
        function (_dereq_, module, exports) {
          var debug = _dereq_("../../utils/debug"),
            registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            warn = debug("components:pool:warn");
          module.exports.Component = registerComponent("pool", {
            schema: {
              container: { default: "" },
              mixin: { default: "" },
              size: { default: 0 },
              dynamic: { default: !1 },
            },
            multiple: !0,
            initPool: function () {
              var t;
              for (
                this.availableEls = [],
                  this.usedEls = [],
                  this.data.mixin ||
                    warn("No mixin provided for pool component."),
                  this.data.container &&
                    ((this.container = document.querySelector(
                      this.data.container
                    )),
                    this.container ||
                      warn("Container " + this.data.container + " not found.")),
                  this.container = this.container || this.el,
                  t = 0;
                t < this.data.size;
                ++t
              )
                this.createEntity();
            },
            update: function (t) {
              var i = this.data;
              (t.mixin === i.mixin && t.size === i.size) || this.initPool();
            },
            createEntity: function () {
              var t;
              (t = document.createElement("a-entity")),
                (t.play = this.wrapPlay(t.play)),
                t.setAttribute("mixin", this.data.mixin),
                (t.object3D.visible = !1),
                t.pause(),
                this.container.appendChild(t),
                this.availableEls.push(t);
            },
            wrapPlay: function (t) {
              var i = this.usedEls;
              return function () {
                -1 !== i.indexOf(this) && t.call(this);
              };
            },
            requestEntity: function () {
              var t;
              if (0 === this.availableEls.length) {
                if (!1 === this.data.dynamic) return;
                this.createEntity();
              }
              return (
                (t = this.availableEls.shift()),
                this.usedEls.push(t),
                (t.object3D.visible = !0),
                t
              );
            },
            returnEntity: function (t) {
              var i = this.usedEls.indexOf(t);
              if (-1 !== i)
                return (
                  this.usedEls.splice(i, 1),
                  this.availableEls.push(t),
                  (t.object3D.visible = !1),
                  t.pause(),
                  t
                );
            },
          });
        },
        { "../../core/component": 101, "../../utils/debug": 169 },
      ],
      81: [
        function (_dereq_, module, exports) {
          var register = _dereq_("../../core/component").registerComponent,
            debug = _dereq_("../../utils/debug"),
            warn = debug("components:renderer:warn");
          module.exports.Component = register("renderer", {
            schema: {
              antialias: { default: "auto", oneOf: ["true", "false", "auto"] },
              logarithmicDepthBuffer: {
                default: "auto",
                oneOf: ["true", "false", "auto"],
              },
              maxCanvasWidth: { default: 1920 },
              maxCanvasHeight: { default: 1920 },
              gammaOutput: { default: !1 },
              physicallyCorrectLights: { default: !1 },
              sortObjects: { default: !1 },
            },
            init: function () {
              this.el.isScene ||
                warn("Renderer component can only be applied to <a-scene>");
            },
            update: function (e) {
              var t = this.data,
                a = this.el,
                r = a.renderer,
                i = !1;
              a.time > 0 &&
                t.antialias !== e.antialias &&
                warn(
                  'Property "antialias" cannot be changed after scene initialization'
                ),
                a.time > 0 &&
                  t.logarithmicDepthBuffer !== e.logarithmicDepthBuffer &&
                  warn(
                    'Property "logarithmicDepthBuffer" cannot be changed after scene initialization'
                  ),
                t.sortObjects !== e.sortObjects &&
                  (r.sortObjects = t.sortObjects),
                t.gammaOutput !== e.gammaOutput &&
                  ((r.gammaOutput = t.gammaOutput), (i = !0)),
                t.physicallyCorrectLights !== e.physicallyCorrectLights &&
                  ((r.physicallyCorrectLights = t.physicallyCorrectLights),
                  (i = !0)),
                i &&
                  0 !== a.time &&
                  (warn(
                    "Modifying renderer properties at runtime requires shader update and may drop frames."
                  ),
                  a.object3D.traverse(function (e) {
                    e.isMesh &&
                      (Array.isArray(e.material)
                        ? e.material.forEach(function (e) {
                            e.needsUpdate = !0;
                          })
                        : (e.material.needsUpdate = !0));
                  }));
            },
          });
        },
        { "../../core/component": 101, "../../utils/debug": 169 },
      ],
      82: [
        function (_dereq_, module, exports) {
          var registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            THREE = _dereq_("../../lib/three"),
            VERTEX_SHADER = [
              "attribute vec3 position;",
              "attribute vec2 uv;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 modelViewMatrix;",
              "varying vec2 vUv;",
              "void main()  {",
              "  vUv = vec2( 1.- uv.x, uv.y );",
              "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
              "}",
            ].join("\n"),
            FRAGMENT_SHADER = [
              "precision mediump float;",
              "uniform samplerCube map;",
              "varying vec2 vUv;",
              "#define M_PI 3.141592653589793238462643383279",
              "void main() {",
              "  vec2 uv = vUv;",
              "  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;",
              "  float latitude = uv.y * M_PI;",
              "  vec3 dir = vec3(",
              "    - sin( longitude ) * sin( latitude ),",
              "    cos( latitude ),",
              "    - cos( longitude ) * sin( latitude )",
              "  );",
              "  normalize( dir );",
              "  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );",
              "}",
            ].join("\n");
          module.exports.Component = registerComponent("screenshot", {
            schema: {
              width: { default: 4096 },
              height: { default: 2048 },
              camera: { type: "selector" },
            },
            init: function () {
              function e() {
                var e = t.renderer.getContext();
                e &&
                  ((a.cubeMapSize = e.getParameter(
                    e.MAX_CUBE_MAP_TEXTURE_SIZE
                  )),
                  (a.material = new THREE.RawShaderMaterial({
                    uniforms: { map: { type: "t", value: null } },
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    side: THREE.DoubleSide,
                  })),
                  (a.quad = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry(1, 1),
                    a.material
                  )),
                  (a.quad.visible = !1),
                  (a.camera = new THREE.OrthographicCamera(
                    -0.5,
                    0.5,
                    0.5,
                    -0.5,
                    -1e4,
                    1e4
                  )),
                  (a.canvas = document.createElement("canvas")),
                  (a.ctx = a.canvas.getContext("2d")),
                  t.camera && t.camera.add(a.quad),
                  (a.onKeyDown = a.onKeyDown.bind(a)),
                  (a.onCameraActive = a.onCameraActive.bind(a)),
                  t.addEventListener("camera-set-active", a.onCameraActive));
              }
              var t = this.el,
                a = this;
              t.renderer ? e() : t.addEventListener("render-target-loaded", e);
            },
            getRenderTarget: function (e, t) {
              return new THREE.WebGLRenderTarget(e, t, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                wrapS: THREE.ClampToEdgeWrapping,
                wrapT: THREE.ClampToEdgeWrapping,
                format: THREE.RGBAFormat,
                type: THREE.UnsignedByteType,
              });
            },
            resize: function (e, t) {
              this.quad.scale.set(e, t, 1),
                (this.camera.left = (-1 * e) / 2),
                (this.camera.right = e / 2),
                (this.camera.top = t / 2),
                (this.camera.bottom = (-1 * t) / 2),
                this.camera.updateProjectionMatrix(),
                (this.canvas.width = e),
                (this.canvas.height = t);
            },
            play: function () {
              window.addEventListener("keydown", this.onKeyDown);
            },
            onCameraActive: function (e) {
              var t = this.quad.parent;
              t && t.remove(this.quad),
                e.detail.cameraEl.getObject3D("camera").add(this.quad);
            },
            onKeyDown: function (e) {
              var t = 83 === e.keyCode && e.ctrlKey && e.altKey;
              if (this.data && t) {
                var a = e.shiftKey ? "equirectangular" : "perspective";
                this.capture(a);
              }
            },
            setCapture: function (e) {
              var t,
                a,
                i,
                r = this.el;
              return (
                "perspective" === e
                  ? ((this.quad.visible = !1),
                    (a =
                      (this.data.camera &&
                        this.data.camera.components.camera.camera) ||
                      r.camera),
                    (t = { width: this.data.width, height: this.data.height }))
                  : ((a = this.camera),
                    r.camera.getWorldPosition(a.position),
                    r.camera.getWorldRotation(a.rotation),
                    (i = new THREE.CubeCamera(
                      r.camera.near,
                      r.camera.far,
                      Math.min(this.cubeMapSize, 2048)
                    )),
                    r.camera.getWorldPosition(i.position),
                    r.camera.getWorldRotation(i.rotation),
                    i.updateCubeMap(r.renderer, r.object3D),
                    (this.quad.material.uniforms.map.value =
                      i.renderTarget.texture),
                    (t = { width: this.data.width, height: this.data.height }),
                    (this.quad.visible = !0)),
                { camera: a, size: t, projection: e }
              );
            },
            capture: function (e) {
              var t = this.setCapture(e);
              this.renderCapture(t.camera, t.size, t.projection),
                this.saveCapture();
            },
            getCanvas: function (e) {
              var t = this.setCapture(e);
              return (
                this.renderCapture(t.camera, t.size, t.projection), this.canvas
              );
            },
            renderCapture: function (e, t, a) {
              var i,
                r,
                n,
                o = this.el.renderer.autoClear,
                d = this.el,
                s = this.el.renderer;
              (r = this.getRenderTarget(t.width, t.height)),
                (n = new Uint8Array(4 * t.width * t.height)),
                this.resize(t.width, t.height),
                (s.autoClear = !0),
                s.render(d.object3D, e, r, !0),
                (s.autoClear = o),
                s.readRenderTargetPixels(r, 0, 0, t.width, t.height, n),
                "perspective" === a &&
                  (n = this.flipPixelsVertically(n, t.width, t.height)),
                (i = new ImageData(
                  new Uint8ClampedArray(n),
                  t.width,
                  t.height
                )),
                (this.quad.visible = !1),
                this.ctx.putImageData(i, 0, 0);
            },
            flipPixelsVertically: function (e, t, a) {
              for (var i = e.slice(0), r = 0; r < t; ++r)
                for (var n = 0; n < a; ++n)
                  (i[4 * r + n * t * 4] = e[4 * r + (a - n) * t * 4]),
                    (i[4 * r + 1 + n * t * 4] = e[4 * r + 1 + (a - n) * t * 4]),
                    (i[4 * r + 2 + n * t * 4] = e[4 * r + 2 + (a - n) * t * 4]),
                    (i[4 * r + 3 + n * t * 4] = e[4 * r + 3 + (a - n) * t * 4]);
              return i;
            },
            saveCapture: function () {
              this.canvas.toBlob(function (e) {
                var t =
                    "screenshot-" +
                    document.title.toLowerCase() +
                    "-" +
                    Date.now() +
                    ".png",
                  a = document.createElement("a"),
                  i = URL.createObjectURL(e);
                (a.href = i),
                  a.setAttribute("download", t),
                  (a.innerHTML = "downloading..."),
                  (a.style.display = "none"),
                  document.body.appendChild(a),
                  setTimeout(function () {
                    a.click(), document.body.removeChild(a);
                  }, 1);
              }, "image/png");
            },
          });
        },
        { "../../core/component": 101, "../../lib/three": 150 },
      ],
      83: [
        function (_dereq_, module, exports) {
          function createStats(t) {
            var e = new ThreeStats(t.renderer),
              s = new AFrameStats(t),
              i = t.isMobile ? [] : [e, s];
            return new RStats({
              css: [],
              values: { fps: { caption: "fps", below: 30 } },
              groups: [{ caption: "Framerate", values: ["fps", "raf"] }],
              plugins: i,
            });
          }
          var registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            RStats = _dereq_("../../../vendor/rStats"),
            utils = _dereq_("../../utils");
          _dereq_("../../../vendor/rStats.extras"),
            _dereq_("../../lib/rStatsAframe");
          var AFrameStats = window.aframeStats,
            bind = utils.bind,
            HIDDEN_CLASS = "a-hidden",
            ThreeStats = window.threeStats;
          module.exports.Component = registerComponent("stats", {
            schema: { default: !0 },
            init: function () {
              var t = this.el;
              "false" !== utils.getUrlParameter("stats") &&
                ((this.stats = createStats(t)),
                (this.statsEl = document.querySelector(".rs-base")),
                (this.hideBound = bind(this.hide, this)),
                (this.showBound = bind(this.show, this)),
                t.addEventListener("enter-vr", this.hideBound),
                t.addEventListener("exit-vr", this.showBound));
            },
            update: function () {
              if (this.stats) return this.data ? this.show() : this.hide();
            },
            remove: function () {
              this.el.removeEventListener("enter-vr", this.hideBound),
                this.el.removeEventListener("exit-vr", this.showBound),
                this.statsEl &&
                  this.statsEl.parentNode.removeChild(this.statsEl);
            },
            tick: function () {
              var t = this.stats;
              t && (t("rAF").tick(), t("FPS").frame(), t().update());
            },
            hide: function () {
              this.statsEl.classList.add(HIDDEN_CLASS);
            },
            show: function () {
              this.statsEl.classList.remove(HIDDEN_CLASS);
            },
          });
        },
        {
          "../../../vendor/rStats": 182,
          "../../../vendor/rStats.extras": 181,
          "../../core/component": 101,
          "../../lib/rStatsAframe": 149,
          "../../utils": 173,
        },
      ],
      84: [
        function (_dereq_, module, exports) {
          function createEnterVRButton(t) {
            var e, n;
            return (
              (n = document.createElement("div")),
              n.classList.add(ENTER_VR_CLASS),
              n.setAttribute(constants.AFRAME_INJECTED, ""),
              (e = document.createElement("button")),
              (e.className = ENTER_VR_BTN_CLASS),
              e.setAttribute(
                "title",
                "Enter VR mode with a headset or fullscreen mode on a desktop. Visit https://webvr.rocks or https://webvr.info for more information."
              ),
              e.setAttribute(constants.AFRAME_INJECTED, ""),
              n.appendChild(e),
              e.addEventListener("click", function (e) {
                t(), e.stopPropagation();
              }),
              n
            );
          }
          function createOrientationModal(t) {
            var e = document.createElement("div");
            (e.className = ORIENTATION_MODAL_CLASS),
              e.classList.add(HIDDEN_CLASS),
              e.setAttribute(constants.AFRAME_INJECTED, "");
            var n = document.createElement("button");
            return (
              n.setAttribute(constants.AFRAME_INJECTED, ""),
              (n.innerHTML = "Exit VR"),
              n.addEventListener("click", t),
              e.appendChild(n),
              e
            );
          }
          var registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            constants = _dereq_("../../constants/"),
            utils = _dereq_("../../utils/"),
            bind = utils.bind,
            ENTER_VR_CLASS = "a-enter-vr",
            ENTER_VR_BTN_CLASS = "a-enter-vr-button",
            HIDDEN_CLASS = "a-hidden",
            ORIENTATION_MODAL_CLASS = "a-orientation-modal";
          module.exports.Component = registerComponent("vr-mode-ui", {
            dependencies: ["canvas"],
            schema: {
              enabled: { default: !0 },
              enterVRButton: { default: "" },
            },
            init: function () {
              var t = this,
                e = this.el;
              "false" !== utils.getUrlParameter("ui") &&
                ((this.insideLoader = !1),
                (this.enterVREl = null),
                (this.orientationModalEl = null),
                this.bindMethods(),
                e.addEventListener("enter-vr", this.updateEnterVRInterface),
                e.addEventListener("exit-vr", this.updateEnterVRInterface),
                window.addEventListener("message", function (e) {
                  "loaderReady" === e.data.type &&
                    ((t.insideLoader = !0), t.remove());
                }),
                window.addEventListener(
                  "orientationchange",
                  this.toggleOrientationModalIfNeeded
                ));
            },
            bindMethods: function () {
              (this.onEnterVRButtonClick = bind(
                this.onEnterVRButtonClick,
                this
              )),
                (this.onModalClick = bind(this.onModalClick, this)),
                (this.toggleOrientationModalIfNeeded = bind(
                  this.toggleOrientationModalIfNeeded,
                  this
                )),
                (this.updateEnterVRInterface = bind(
                  this.updateEnterVRInterface,
                  this
                ));
            },
            onModalClick: function () {
              this.el.exitVR();
            },
            onEnterVRButtonClick: function () {
              this.el.enterVR();
            },
            update: function () {
              var t = this.data,
                e = this.el;
              if (
                !t.enabled ||
                this.insideLoader ||
                "false" === utils.getUrlParameter("ui")
              )
                return this.remove();
              this.enterVREl ||
                this.orientationModalEl ||
                (t.enterVRButton
                  ? ((this.enterVREl = document.querySelector(t.enterVRButton)),
                    this.enterVREl.addEventListener(
                      "click",
                      this.onEnterVRButtonClick
                    ))
                  : ((this.enterVREl = createEnterVRButton(
                      this.onEnterVRButtonClick
                    )),
                    e.appendChild(this.enterVREl)),
                (this.orientationModalEl = createOrientationModal(
                  this.onModalClick
                )),
                e.appendChild(this.orientationModalEl),
                this.updateEnterVRInterface());
            },
            remove: function () {
              [this.enterVREl, this.orientationModalEl].forEach(function (t) {
                t && t.parentNode && t.parentNode.removeChild(t);
              });
            },
            updateEnterVRInterface: function () {
              this.toggleEnterVRButtonIfNeeded(),
                this.toggleOrientationModalIfNeeded();
            },
            toggleEnterVRButtonIfNeeded: function () {
              var t = this.el;
              this.enterVREl &&
                (t.is("vr-mode")
                  ? this.enterVREl.classList.add(HIDDEN_CLASS)
                  : this.enterVREl.classList.remove(HIDDEN_CLASS));
            },
            toggleOrientationModalIfNeeded: function () {
              var t = this.el,
                e = this.orientationModalEl;
              e &&
                t.isMobile &&
                (!utils.device.isLandscape() && t.is("vr-mode")
                  ? e.classList.remove(HIDDEN_CLASS)
                  : e.classList.add(HIDDEN_CLASS));
            },
          });
        },
        {
          "../../constants/": 93,
          "../../core/component": 101,
          "../../utils/": 173,
        },
      ],
      85: [
        function (_dereq_, module, exports) {
          var component = _dereq_("../core/component"),
            THREE = _dereq_("../lib/three"),
            bind = _dereq_("../utils/bind"),
            registerComponent = component.registerComponent;
          module.exports.Component = registerComponent("shadow", {
            schema: { cast: { default: !0 }, receive: { default: !0 } },
            init: function () {
              (this.onMeshChanged = bind(this.update, this)),
                this.el.addEventListener("object3dset", this.onMeshChanged),
                this.system.setShadowMapEnabled(!0);
            },
            update: function () {
              var e = this.data;
              this.updateDescendants(e.cast, e.receive);
            },
            remove: function () {
              this.el.removeEventListener("object3dset", this.onMeshChanged),
                this.updateDescendants(!1, !1);
            },
            updateDescendants: function (e, t) {
              var n = this.el.sceneEl;
              this.el.object3D.traverse(function (s) {
                if (
                  s instanceof THREE.Mesh &&
                  ((s.castShadow = e),
                  (s.receiveShadow = t),
                  n.hasLoaded && s.material)
                )
                  for (
                    var a = Array.isArray(s.material)
                        ? s.material
                        : [s.material],
                      i = 0;
                    i < a.length;
                    i++
                  )
                    a[i].needsUpdate = !0;
              });
            },
          });
        },
        { "../core/component": 101, "../lib/three": 150, "../utils/bind": 167 },
      ],
      86: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            debug = _dereq_("../utils/debug"),
            THREE = _dereq_("../lib/three"),
            warn = debug("components:sound:warn");
          module.exports.Component = registerComponent("sound", {
            schema: {
              autoplay: { default: !1 },
              distanceModel: {
                default: "inverse",
                oneOf: ["linear", "inverse", "exponential"],
              },
              loop: { default: !1 },
              maxDistance: { default: 1e4 },
              on: { default: "" },
              poolSize: { default: 1 },
              positional: { default: !0 },
              refDistance: { default: 1 },
              rolloffFactor: { default: 1 },
              src: { type: "audio" },
              volume: { default: 1 },
            },
            multiple: !0,
            init: function () {
              var e = this;
              (this.listener = null),
                (this.audioLoader = new THREE.AudioLoader()),
                (this.pool = new THREE.Group()),
                (this.loaded = !1),
                (this.mustPlay = !1),
                (this.playSoundBound = function () {
                  e.playSound();
                });
            },
            update: function (e) {
              var t,
                o,
                i = this.data,
                n = i.src !== e.src;
              if (n) {
                if (!i.src) return;
                this.setupSound();
              }
              for (t = 0; t < this.pool.children.length; t++)
                (o = this.pool.children[t]),
                  i.positional &&
                    (o.setDistanceModel(i.distanceModel),
                    o.setMaxDistance(i.maxDistance),
                    o.setRefDistance(i.refDistance),
                    o.setRolloffFactor(i.rolloffFactor)),
                  o.setLoop(i.loop),
                  o.setVolume(i.volume),
                  (o.isPaused = !1);
              if ((i.on !== e.on && this.updateEventListener(e.on), n)) {
                var s = this;
                (this.loaded = !1),
                  this.audioLoader.load(i.src, function (e) {
                    for (t = 0; t < s.pool.children.length; t++)
                      (o = s.pool.children[t]), o.setBuffer(e);
                    (s.loaded = !0),
                      THREE.Cache.remove(i.src),
                      (s.data.autoplay || s.mustPlay) && s.playSound(),
                      s.el.emit("sound-loaded", s.evtDetail, !1);
                  });
              }
            },
            pause: function () {
              this.stopSound(), this.removeEventListener();
            },
            play: function () {
              this.data.autoplay && this.playSound(),
                this.updateEventListener();
            },
            remove: function () {
              var e, t;
              this.removeEventListener(), this.el.removeObject3D(this.attrName);
              try {
                for (e = 0; e < this.pool.children.length; e++)
                  (t = this.pool.children[e]), t.disconnect();
              } catch (e) {
                warn("Audio source not properly disconnected");
              }
            },
            updateEventListener: function (e) {
              var t = this.el;
              e && t.removeEventListener(e, this.playSoundBound),
                t.addEventListener(this.data.on, this.playSoundBound);
            },
            removeEventListener: function () {
              this.el.removeEventListener(this.data.on, this.playSoundBound);
            },
            setupSound: function () {
              var e,
                t,
                o = this,
                i = this.el,
                n = i.sceneEl;
              this.pool.children.length > 0 &&
                (this.stopSound(), i.removeObject3D("sound"));
              var s = (this.listener =
                n.audioListener || new THREE.AudioListener());
              for (
                n.audioListener = s,
                  n.camera && n.camera.add(s),
                  n.addEventListener("camera-set-active", function (e) {
                    e.detail.cameraEl.getObject3D("camera").add(s);
                  }),
                  this.pool = new THREE.Group(),
                  e = 0;
                e < this.data.poolSize;
                e++
              )
                (t = this.data.positional
                  ? new THREE.PositionalAudio(s)
                  : new THREE.Audio(s)),
                  this.pool.add(t);
              for (
                i.setObject3D(this.attrName, this.pool), e = 0;
                e < this.pool.children.length;
                e++
              )
                (t = this.pool.children[e]),
                  (t.onEnded = function () {
                    (this.isPlaying = !1),
                      i.emit("sound-ended", o.evtDetail, !1);
                  });
            },
            pauseSound: function () {
              var e, t;
              for (
                this.isPlaying = !1, e = 0;
                e < this.pool.children.length;
                e++
              )
                (t = this.pool.children[e]),
                  t.source &&
                    t.source.buffer &&
                    t.isPlaying &&
                    !t.isPaused &&
                    ((t.isPaused = !0), t.pause());
            },
            playSound: function (e) {
              var t, o, i;
              if (!this.loaded)
                return (
                  warn(
                    "Sound not loaded yet. It will be played once it finished loading"
                  ),
                  void (this.mustPlay = !0)
                );
              for (
                t = !1, this.isPlaying = !0, o = 0;
                o < this.pool.children.length;
                o++
              )
                (i = this.pool.children[o]),
                  i.isPlaying ||
                    !i.buffer ||
                    t ||
                    (e && e(i), i.play(), (i.isPaused = !1), (t = !0));
              t && (this.mustPlay = !1);
            },
            stopSound: function () {
              var e, t;
              for (
                this.isPlaying = !1, e = 0;
                e < this.pool.children.length;
                e++
              ) {
                if (
                  ((t = this.pool.children[e]), !t.source || !t.source.buffer)
                )
                  return;
                t.stop();
              }
            },
          });
        },
        {
          "../core/component": 101,
          "../lib/three": 150,
          "../utils/debug": 169,
        },
      ],
      87: [
        function (_dereq_, module, exports) {
          function parseSide(t) {
            switch (t) {
              case "back":
                return THREE.FrontSide;
              case "double":
                return THREE.DoubleSide;
              default:
                return THREE.BackSide;
            }
          }
          function loadFont(t, e) {
            return new Promise(function (r, n) {
              loadBMFont(t, function (o, a) {
                if (o) return error("Error loading font", t), void n(o);
                t.indexOf("/Roboto-msdf.json") >= 0 && (e = 30),
                  e &&
                    a.chars.map(function (t) {
                      t.yoffset += e;
                    }),
                  r(a);
              });
            });
          }
          function loadTexture(t) {
            return new Promise(function (e, r) {
              new THREE.ImageLoader().load(
                t,
                function (t) {
                  e(t);
                },
                void 0,
                function () {
                  error("Error loading font image", t), r(null);
                }
              );
            });
          }
          function createShader(t, e, r) {
            var n, o;
            return (
              (o = new shaders[e].Shader()),
              (o.el = t),
              o.init(r),
              o.update(r),
              (n = o.material),
              (n.transparent = r.transparent),
              { material: n, shader: o }
            );
          }
          function computeWidth(t, e, r) {
            return t || (0.5 + e) * r;
          }
          function computeFontWidthFactor(t) {
            var e = 0,
              r = 0,
              n = 0;
            return (
              t.chars.map(function (t) {
                (e += t.xadvance),
                  t.id >= 48 && t.id <= 57 && (n++, (r += t.xadvance));
              }),
              n ? r / n : e / t.chars.length
            );
          }
          function PromiseCache() {
            var t = (this.cache = {});
            this.get = function (e, r) {
              return e in t ? t[e] : ((t[e] = r()), t[e]);
            };
          }
          var createTextGeometry = _dereq_("three-bmfont-text"),
            loadBMFont = _dereq_("load-bmfont"),
            registerComponent = _dereq_("../core/component").registerComponent,
            coreShader = _dereq_("../core/shader"),
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            error = utils.debug("components:text:error"),
            shaders = coreShader.shaders,
            warn = utils.debug("components:text:warn"),
            DEFAULT_WIDTH = 1,
            MAX_ANISOTROPY = 16,
            FONT_BASE_URL = "https://cdn.aframe.io/fonts/",
            FONTS = {
              aileronsemibold: FONT_BASE_URL + "Aileron-Semibold.fnt",
              dejavu: FONT_BASE_URL + "DejaVu-sdf.fnt",
              exo2bold: FONT_BASE_URL + "Exo2Bold.fnt",
              exo2semibold: FONT_BASE_URL + "Exo2SemiBold.fnt",
              kelsonsans: FONT_BASE_URL + "KelsonSans.fnt",
              monoid: FONT_BASE_URL + "Monoid.fnt",
              mozillavr: FONT_BASE_URL + "mozillavr.fnt",
              roboto: FONT_BASE_URL + "Roboto-msdf.json",
              sourcecodepro: FONT_BASE_URL + "SourceCodePro.fnt",
            },
            MSDF_FONTS = ["roboto"],
            DEFAULT_FONT = "roboto";
          module.exports.FONTS = FONTS;
          var cache = new PromiseCache(),
            fontWidthFactors = {},
            textures = {},
            protocolRe = /^\w+:/;
          module.exports.Component = registerComponent("text", {
            multiple: !0,
            schema: {
              align: {
                type: "string",
                default: "left",
                oneOf: ["left", "right", "center"],
              },
              alphaTest: { default: 0.5 },
              anchor: {
                default: "center",
                oneOf: ["left", "right", "center", "align"],
              },
              baseline: {
                default: "center",
                oneOf: ["top", "center", "bottom"],
              },
              color: { type: "color", default: "#FFF" },
              font: { type: "string", default: DEFAULT_FONT },
              fontImage: { type: "string" },
              height: { type: "number" },
              letterSpacing: { type: "number", default: 0 },
              lineHeight: { type: "number" },
              negate: { type: "boolean", default: !0 },
              opacity: { type: "number", default: 1 },
              shader: { default: "sdf", oneOf: shaders },
              side: { default: "front", oneOf: ["front", "back", "double"] },
              tabSize: { default: 4 },
              transparent: { default: !0 },
              value: { type: "string" },
              whiteSpace: {
                default: "normal",
                oneOf: ["normal", "pre", "nowrap"],
              },
              width: { type: "number" },
              wrapCount: { type: "number", default: 40 },
              wrapPixels: { type: "number" },
              xOffset: { type: "number", default: 0 },
              yOffset: { type: "number", default: 0 },
              zOffset: { type: "number", default: 0.001 },
            },
            init: function () {
              (this.shaderData = {}),
                (this.geometry = createTextGeometry()),
                this.createOrUpdateMaterial(),
                (this.mesh = new THREE.Mesh(this.geometry, this.material)),
                this.el.setObject3D(this.attrName, this.mesh);
            },
            update: function (t) {
              var e = this.data,
                r = this.currentFont;
              if (
                (textures[e.font]
                  ? (this.texture = textures[e.font])
                  : ((this.texture = textures[e.font] = new THREE.Texture()),
                    (this.texture.anisotropy = MAX_ANISOTROPY)),
                this.createOrUpdateMaterial(),
                t.font !== e.font)
              )
                return void this.updateFont();
              r && (this.updateGeometry(this.geometry, r), this.updateLayout());
            },
            remove: function () {
              this.geometry.dispose(),
                (this.geometry = null),
                this.el.removeObject3D(this.attrName),
                this.material.dispose(),
                (this.material = null),
                this.texture.dispose(),
                (this.texture = null),
                this.shaderObject && delete this.shaderObject;
            },
            createOrUpdateMaterial: function () {
              var t,
                e,
                r,
                n = this.data,
                o = this.material,
                a = this.shaderData;
              if (
                ((r = n.shader),
                -1 !== MSDF_FONTS.indexOf(n.font) ||
                n.font.indexOf("-msdf.") >= 0
                  ? (r = "msdf")
                  : n.font in FONTS &&
                    -1 === MSDF_FONTS.indexOf(n.font) &&
                    (r = "sdf"),
                (t = (this.shaderObject && this.shaderObject.name) !== r),
                (a.alphaTest = n.alphaTest),
                (a.color = n.color),
                (a.map = this.texture),
                (a.opacity = n.opacity),
                (a.side = parseSide(n.side)),
                (a.transparent = n.transparent),
                (a.negate = n.negate),
                !t)
              )
                return (
                  this.shaderObject.update(a),
                  (o.transparent = a.transparent),
                  void (o.side = a.side)
                );
              (e = createShader(this.el, r, a)),
                (this.material = e.material),
                (this.shaderObject = e.shader),
                (this.material.side = a.side),
                this.mesh && (this.mesh.material = this.material);
            },
            updateFont: function () {
              var t,
                e = this.data,
                r = this.el,
                n = this.geometry,
                o = this;
              e.font || warn("No font specified. Using the default font."),
                (this.mesh.visible = !1),
                (t = this.lookupFont(e.font || DEFAULT_FONT) || e.font),
                cache
                  .get(t, function () {
                    return loadFont(t, e.yOffset);
                  })
                  .then(function (a) {
                    var i;
                    if (1 !== a.pages.length)
                      throw new Error(
                        "Currently only single-page bitmap fonts are supported."
                      );
                    fontWidthFactors[t] ||
                      (a.widthFactor = fontWidthFactors[a] =
                        computeFontWidthFactor(a)),
                      o.updateGeometry(n, a),
                      (o.currentFont = a),
                      o.updateLayout(),
                      (i = o.getFontImageSrc()),
                      cache
                        .get(i, function () {
                          return loadTexture(i);
                        })
                        .then(function (t) {
                          var n = o.texture;
                          (n.image = t),
                            (n.needsUpdate = !0),
                            (textures[e.font] = n),
                            (o.texture = n),
                            (o.mesh.visible = !0),
                            r.emit("textfontset", { font: e.font, fontObj: a });
                        })
                        .catch(function (t) {
                          throw (error(t), t);
                        });
                  })
                  .catch(function (t) {
                    throw (error(t), t);
                  });
            },
            getFontImageSrc: function () {
              if (this.data.fontImage) return this.data.fontImage;
              var t =
                  this.lookupFont(this.data.font || DEFAULT_FONT) ||
                  this.data.font,
                e = this.currentFont.pages[0];
              return e.match(protocolRe) && 0 !== e.indexOf("http")
                ? t.replace(/(\.fnt)|(\.json)/, ".png")
                : THREE.LoaderUtils.extractUrlBase(t) + e;
            },
            updateLayout: function () {
              var t,
                e,
                r,
                n,
                o,
                a,
                i,
                s,
                h,
                u,
                d = this.el,
                f = this.data,
                l = this.geometry,
                c = this.mesh;
              if (l.layout) {
                if (
                  ((r = d.getAttribute("geometry")),
                  (s = f.width || (r && r.width) || DEFAULT_WIDTH),
                  (a = computeWidth(
                    f.wrapPixels,
                    f.wrapCount,
                    this.currentFont.widthFactor
                  )),
                  (i = s / a),
                  (o = l.layout),
                  (n = i * (o.height + o.descender)),
                  r &&
                    (r.width || d.setAttribute("geometry", "width", s),
                    r.height || d.setAttribute("geometry", "height", n)),
                  "left" === (t = "align" === f.anchor ? f.align : f.anchor))
                )
                  h = 0;
                else if ("right" === t) h = -1 * o.width;
                else {
                  if ("center" !== t)
                    throw new TypeError(
                      "Invalid text.anchor property value",
                      t
                    );
                  h = (-1 * o.width) / 2;
                }
                if ("bottom" === (e = f.baseline)) u = 0;
                else if ("top" === e) u = -1 * o.height + o.ascender;
                else {
                  if ("center" !== e)
                    throw new TypeError(
                      "Invalid text.baseline property value",
                      e
                    );
                  u = (-1 * o.height) / 2;
                }
                (c.position.x = h * i + f.xOffset),
                  (c.position.y = u * i),
                  (c.position.z = f.zOffset),
                  c.scale.set(i, -1 * i, i);
              }
            },
            lookupFont: function (t) {
              return FONTS[t];
            },
            updateGeometry: (function () {
              var t = {},
                e = {},
                r = /\\n/g,
                n = /\\t/g;
              return function (o, a) {
                var i = this.data;
                (e.font = a),
                  (e.lineHeight =
                    i.lineHeight && isFinite(i.lineHeight)
                      ? i.lineHeight
                      : a.common.lineHeight),
                  (e.text = i.value
                    .toString()
                    .replace(r, "\n")
                    .replace(n, "\t")),
                  (e.width = computeWidth(
                    i.wrapPixels,
                    i.wrapCount,
                    a.widthFactor
                  )),
                  o.update(utils.extend(t, i, e));
              };
            })(),
          });
        },
        {
          "../core/component": 101,
          "../core/shader": 111,
          "../lib/three": 150,
          "../utils/": 173,
          "load-bmfont": 23,
          "three-bmfont-text": 34,
        },
      ],
      88: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            controllerUtils = _dereq_("../utils/tracked-controls"),
            DEFAULT_CAMERA_HEIGHT =
              _dereq_("../constants").DEFAULT_CAMERA_HEIGHT,
            THREE = _dereq_("../lib/three"),
            DEFAULT_HANDEDNESS = _dereq_("../constants").DEFAULT_HANDEDNESS,
            EYES_TO_ELBOW = { x: 0.175, y: -0.3, z: -0.03 },
            FOREARM = { x: 0, y: 0, z: -0.175 },
            EMPTY_DAYDREAM_TOUCHES = { touches: [] },
            EVENTS = {
              AXISMOVE: "axismove",
              BUTTONCHANGED: "buttonchanged",
              BUTTONDOWN: "buttondown",
              BUTTONUP: "buttonup",
              TOUCHSTART: "touchstart",
              TOUCHEND: "touchend",
            };
          module.exports.Component = registerComponent("tracked-controls", {
            schema: {
              controller: { default: 0 },
              id: { type: "string", default: "" },
              hand: { type: "string", default: "" },
              idPrefix: { type: "string", default: "" },
              orientationOffset: { type: "vec3" },
              armModel: { default: !0 },
              headElement: { type: "selector" },
            },
            init: function () {
              (this.axis = [0, 0, 0]),
                (this.buttonStates = {}),
                (this.changedAxes = []),
                (this.targetControllerNumber = this.data.controller),
                (this.axisMoveEventDetail = {
                  axis: this.axis,
                  changed: this.changedAxes,
                }),
                (this.deltaControllerPosition = new THREE.Vector3()),
                (this.controllerQuaternion = new THREE.Quaternion()),
                (this.controllerEuler = new THREE.Euler()),
                this.updateGamepad(),
                (this.buttonEventDetails = {});
            },
            tick: function (t, e) {
              var i = this.el.getObject3D("mesh");
              i && i.update && i.update(e / 1e3),
                this.updateGamepad(),
                this.updatePose(),
                this.updateButtons();
            },
            defaultUserHeight: function () {
              return DEFAULT_CAMERA_HEIGHT;
            },
            getHeadElement: function () {
              return this.data.headElement || this.el.sceneEl.camera.el;
            },
            updateGamepad: function () {
              var t = this.data,
                e = controllerUtils.findMatchingController(
                  this.system.controllers,
                  t.id,
                  t.idPrefix,
                  t.hand,
                  t.controller
                );
              this.controller = e;
            },
            applyArmModel: function (t) {
              var e,
                i,
                n,
                o,
                s,
                r = this.controller,
                a = this.controllerEuler,
                l = this.controllerQuaternion,
                h = this.deltaControllerPosition;
              (i = this.getHeadElement()),
                (n = i.object3D),
                (s = this.defaultUserHeight()),
                (o = r.pose),
                (e = (r ? r.hand : void 0) || DEFAULT_HANDEDNESS),
                t.copy(n.position),
                h.set(
                  EYES_TO_ELBOW.x * ("left" === e ? -1 : "right" === e ? 1 : 0),
                  EYES_TO_ELBOW.y,
                  EYES_TO_ELBOW.z
                ),
                h.multiplyScalar(s),
                h.applyAxisAngle(n.up, n.rotation.y),
                t.add(h),
                h.set(FOREARM.x, FOREARM.y, FOREARM.z),
                h.multiplyScalar(s),
                o.orientation
                  ? l.fromArray(o.orientation)
                  : l.copy(n.quaternion),
                a.setFromQuaternion(l),
                a.set(a.x, a.y, 0),
                h.applyEuler(a),
                t.add(h);
            },
            updatePose: function () {
              var t,
                e,
                i = this.controller,
                n = this.data,
                o = this.el.object3D,
                s = this.system.vrDisplay;
              i &&
                ((t = i.pose),
                t.position
                  ? o.position.fromArray(t.position)
                  : n.armModel && this.applyArmModel(o.position),
                t.orientation && o.quaternion.fromArray(t.orientation),
                s &&
                  t.position &&
                  ((e = this.el.sceneEl.renderer.vr.getStandingMatrix()),
                  o.matrix.compose(o.position, o.quaternion, o.scale),
                  o.matrix.multiplyMatrices(e, o.matrix),
                  o.matrix.decompose(o.position, o.quaternion, o.scale)),
                o.rotateX(this.data.orientationOffset.x * THREE.Math.DEG2RAD),
                o.rotateY(this.data.orientationOffset.y * THREE.Math.DEG2RAD),
                o.rotateZ(this.data.orientationOffset.z * THREE.Math.DEG2RAD));
            },
            updateButtons: function () {
              var t,
                e,
                i = this.controller;
              if (i) {
                for (e = 0; e < i.buttons.length; ++e)
                  this.buttonStates[e] ||
                    (this.buttonStates[e] = {
                      pressed: !1,
                      touched: !1,
                      value: 0,
                    }),
                    this.buttonEventDetails[e] ||
                      (this.buttonEventDetails[e] = {
                        id: e,
                        state: this.buttonStates[e],
                      }),
                    (t = i.buttons[e]),
                    this.handleButton(e, t);
                this.handleAxes();
              }
            },
            handleButton: function (t, e) {
              return (
                !!(
                  this.handlePress(t, e) |
                  this.handleTouch(t, e) |
                  this.handleValue(t, e)
                ) &&
                (this.el.emit(
                  EVENTS.BUTTONCHANGED,
                  this.buttonEventDetails[t],
                  !1
                ),
                !0)
              );
            },
            handleAxes: function () {
              var t,
                e = !1,
                i = this.controller.axes,
                n = this.axis,
                o = this.changedAxes;
              for (this.changedAxes.length = 0, t = 0; t < i.length; ++t)
                o.push(n[t] !== i[t]), o[t] && (e = !0);
              if (!e) return !1;
              for (this.axis.length = 0, t = 0; t < i.length; t++)
                this.axis.push(i[t]);
              return (
                this.el.emit(EVENTS.AXISMOVE, this.axisMoveEventDetail, !1), !0
              );
            },
            handlePress: function (t, e) {
              var i,
                n = this.buttonStates[t];
              return (
                e.pressed !== n.pressed &&
                ((i = e.pressed ? EVENTS.BUTTONDOWN : EVENTS.BUTTONUP),
                this.el.emit(i, this.buttonEventDetails[t], !1),
                (n.pressed = e.pressed),
                !0)
              );
            },
            handleTouch: function (t, e) {
              var i,
                n = this.buttonStates[t];
              return (
                e.touched !== n.touched &&
                ((i = e.touched ? EVENTS.TOUCHSTART : EVENTS.TOUCHEND),
                this.el.emit(
                  i,
                  this.buttonEventDetails[t],
                  !1,
                  EMPTY_DAYDREAM_TOUCHES
                ),
                (n.touched = e.touched),
                !0)
              );
            },
            handleValue: function (t, e) {
              var i = this.buttonStates[t];
              return e.value !== i.value && ((i.value = e.value), !0);
            },
          });
        },
        {
          "../constants": 93,
          "../core/component": 101,
          "../lib/three": 150,
          "../utils/tracked-controls": 180,
        },
      ],
      89: [
        function (_dereq_, module, exports) {
          var registerComponent =
            _dereq_("../core/component").registerComponent;
          module.exports.Component = registerComponent("visible", {
            schema: { default: !0 },
            update: function () {
              this.el.object3D.visible = this.data;
            },
          });
        },
        { "../core/component": 101 },
      ],
      90: [
        function (_dereq_, module, exports) {
          var registerComponent =
              _dereq_("../core/component").registerComponent,
            utils = _dereq_("../utils/"),
            bind = utils.bind,
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            checkControllerPresentAndSetup =
              trackedControlsUtils.checkControllerPresentAndSetup,
            emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged,
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            VIVE_CONTROLLER_MODEL_OBJ_URL =
              "https://cdn.aframe.io/controllers/vive/vr_controller_vive.obj",
            VIVE_CONTROLLER_MODEL_OBJ_MTL =
              "https://cdn.aframe.io/controllers/vive/vr_controller_vive.mtl",
            GAMEPAD_ID_PREFIX = "OpenVR ";
          module.exports.Component = registerComponent("vive-controls", {
            schema: {
              hand: { default: "left" },
              buttonColor: { type: "color", default: "#FAFAFA" },
              buttonHighlightColor: { type: "color", default: "#22D1EE" },
              model: { default: !0 },
              orientationOffset: { type: "vec3" },
            },
            mapping: {
              axes: { trackpad: [0, 1] },
              buttons: ["trackpad", "trigger", "grip", "menu", "system"],
            },
            init: function () {
              var t = this;
              (this.animationActive = "pointing"),
                (this.checkControllerPresentAndSetup =
                  checkControllerPresentAndSetup),
                (this.controllerPresent = !1),
                (this.emitIfAxesChanged = emitIfAxesChanged),
                (this.lastControllerCheck = 0),
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                (this.onButtonDown = function (e) {
                  onButtonEvent(e.detail.id, "down", t);
                }),
                (this.onButtonUp = function (e) {
                  onButtonEvent(e.detail.id, "up", t);
                }),
                (this.onButtonTouchEnd = function (e) {
                  onButtonEvent(e.detail.id, "touchend", t);
                }),
                (this.onButtonTouchStart = function (e) {
                  onButtonEvent(e.detail.id, "touchstart", t);
                }),
                (this.onAxisMoved = bind(this.onAxisMoved, this)),
                (this.previousButtonValues = {}),
                this.bindMethods();
            },
            play: function () {
              this.checkIfControllerPresent(),
                this.addControllersUpdateListener();
            },
            pause: function () {
              this.removeEventListeners(),
                this.removeControllersUpdateListener();
            },
            bindMethods: function () {
              (this.onModelLoaded = bind(this.onModelLoaded, this)),
                (this.onControllersUpdate = bind(
                  this.onControllersUpdate,
                  this
                )),
                (this.checkIfControllerPresent = bind(
                  this.checkIfControllerPresent,
                  this
                )),
                (this.removeControllersUpdateListener = bind(
                  this.removeControllersUpdateListener,
                  this
                )),
                (this.onAxisMoved = bind(this.onAxisMoved, this));
            },
            addEventListeners: function () {
              var t = this.el;
              t.addEventListener("buttonchanged", this.onButtonChanged),
                t.addEventListener("buttondown", this.onButtonDown),
                t.addEventListener("buttonup", this.onButtonUp),
                t.addEventListener("touchend", this.onButtonTouchEnd),
                t.addEventListener("touchstart", this.onButtonTouchStart),
                t.addEventListener("model-loaded", this.onModelLoaded),
                t.addEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !0);
            },
            removeEventListeners: function () {
              var t = this.el;
              t.removeEventListener("buttonchanged", this.onButtonChanged),
                t.removeEventListener("buttondown", this.onButtonDown),
                t.removeEventListener("buttonup", this.onButtonUp),
                t.removeEventListener("touchend", this.onButtonTouchEnd),
                t.removeEventListener("touchstart", this.onButtonTouchStart),
                t.removeEventListener("model-loaded", this.onModelLoaded),
                t.removeEventListener("axismove", this.onAxisMoved),
                (this.controllerEventsActive = !1);
            },
            checkIfControllerPresent: function () {
              var t = this.data,
                e = "right" === t.hand ? 0 : "left" === t.hand ? 1 : 2;
              this.checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                index: e,
              });
            },
            injectTrackedControls: function () {
              var t = this.el,
                e = this.data;
              t.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID_PREFIX,
                controller: "right" === e.hand ? 0 : "left" === e.hand ? 1 : 2,
                orientationOffset: e.orientationOffset,
              }),
                this.data.model &&
                  this.el.setAttribute("obj-model", {
                    obj: VIVE_CONTROLLER_MODEL_OBJ_URL,
                    mtl: VIVE_CONTROLLER_MODEL_OBJ_MTL,
                  });
            },
            addControllersUpdateListener: function () {
              this.el.sceneEl.addEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            removeControllersUpdateListener: function () {
              this.el.sceneEl.removeEventListener(
                "controllersupdated",
                this.onControllersUpdate,
                !1
              );
            },
            onControllersUpdate: function () {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function (t) {
              var e,
                n = this.mapping.buttons[t.detail.id],
                o = this.buttonMeshes;
              n &&
                ("trigger" === n &&
                  ((e = t.detail.state.value),
                  o &&
                    o.trigger &&
                    (o.trigger.rotation.x = -e * (Math.PI / 12))),
                this.el.emit(n + "changed", t.detail.state));
            },
            onModelLoaded: function (t) {
              var e,
                n = t.detail.model,
                o = this;
              this.data.model &&
                ((e = this.buttonMeshes = {}),
                (e.grip = {
                  left: n.getObjectByName("leftgrip"),
                  right: n.getObjectByName("rightgrip"),
                }),
                (e.menu = n.getObjectByName("menubutton")),
                (e.system = n.getObjectByName("systembutton")),
                (e.trackpad = n.getObjectByName("touchpad")),
                (e.trigger = n.getObjectByName("trigger")),
                Object.keys(e).forEach(function (t) {
                  o.setButtonColor(t, o.data.buttonColor);
                }),
                n.position.set(0, -0.015, 0.04));
            },
            onAxisMoved: function (t) {
              this.emitIfAxesChanged(this, this.mapping.axes, t);
            },
            updateModel: function (t, e) {
              var n;
              this.data.model &&
                (-1 !== e.indexOf("touch") ||
                  ((n =
                    "up" === e
                      ? this.data.buttonColor
                      : this.data.buttonHighlightColor),
                  this.setButtonColor(t, n)));
            },
            setButtonColor: function (t, e) {
              var n = this.buttonMeshes;
              if (n)
                return "grip" === t
                  ? (n.grip.left.material.color.set(e),
                    void n.grip.right.material.color.set(e))
                  : void n[t].material.color.set(e);
            },
          });
        },
        {
          "../core/component": 101,
          "../utils/": 173,
          "../utils/tracked-controls": 180,
        },
      ],
      91: [
        function (_dereq_, module, exports) {
          function isEmptyObject(e) {
            var t;
            for (t in e) return !1;
            return !0;
          }
          var KEYCODE_TO_CODE =
              _dereq_("../constants").keyboardevent.KEYCODE_TO_CODE,
            registerComponent = _dereq_("../core/component").registerComponent,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            bind = utils.bind,
            shouldCaptureKeyEvent = utils.shouldCaptureKeyEvent,
            CLAMP_VELOCITY = 1e-5,
            MAX_DELTA = 0.2,
            KEYS = [
              "KeyW",
              "KeyA",
              "KeyS",
              "KeyD",
              "ArrowUp",
              "ArrowLeft",
              "ArrowRight",
              "ArrowDown",
            ];
          module.exports.Component = registerComponent("wasd-controls", {
            schema: {
              acceleration: { default: 65 },
              adAxis: { default: "x", oneOf: ["x", "y", "z"] },
              adEnabled: { default: !0 },
              adInverted: { default: !1 },
              easing: { default: 20 },
              enabled: { default: !0 },
              fly: { default: !1 },
              wsAxis: { default: "z", oneOf: ["x", "y", "z"] },
              wsEnabled: { default: !0 },
              wsInverted: { default: !1 },
            },
            init: function () {
              (this.keys = {}),
                (this.velocity = new THREE.Vector3()),
                (this.onBlur = bind(this.onBlur, this)),
                (this.onFocus = bind(this.onFocus, this)),
                (this.onKeyDown = bind(this.onKeyDown, this)),
                (this.onKeyUp = bind(this.onKeyUp, this)),
                (this.onVisibilityChange = bind(this.onVisibilityChange, this)),
                this.attachVisibilityEventListeners();
            },
            tick: function (e, t) {
              var i = this.data,
                n = this.el,
                s = this.velocity;
              (s[i.adAxis] || s[i.wsAxis] || !isEmptyObject(this.keys)) &&
                ((t /= 1e3),
                this.updateVelocity(t),
                (s[i.adAxis] || s[i.wsAxis]) &&
                  n.object3D.position.add(this.getMovementVector(t)));
            },
            remove: function () {
              this.removeKeyEventListeners(),
                this.removeVisibilityEventListeners();
            },
            play: function () {
              this.attachKeyEventListeners();
            },
            pause: function () {
              (this.keys = {}), this.removeKeyEventListeners();
            },
            updateVelocity: function (e) {
              var t,
                i,
                n,
                s,
                o,
                r = this.data,
                a = this.keys,
                d = this.velocity;
              if (((i = r.adAxis), (s = r.wsAxis), e > MAX_DELTA))
                return (d[i] = 0), void (d[s] = 0);
              0 !== d[i] && (d[i] -= d[i] * r.easing * e),
                0 !== d[s] && (d[s] -= d[s] * r.easing * e),
                Math.abs(d[i]) < CLAMP_VELOCITY && (d[i] = 0),
                Math.abs(d[s]) < CLAMP_VELOCITY && (d[s] = 0),
                r.enabled &&
                  ((t = r.acceleration),
                  r.adEnabled &&
                    ((n = r.adInverted ? -1 : 1),
                    (a.KeyA || a.ArrowLeft) && (d[i] -= n * t * e),
                    (a.KeyD || a.ArrowRight) && (d[i] += n * t * e)),
                  r.wsEnabled &&
                    ((o = r.wsInverted ? -1 : 1),
                    (a.KeyW || a.ArrowUp) && (d[s] -= o * t * e),
                    (a.KeyS || a.ArrowDown) && (d[s] += o * t * e)));
            },
            getMovementVector: (function () {
              var e = new THREE.Vector3(0, 0, 0),
                t = new THREE.Euler(0, 0, 0, "YXZ");
              return function (i) {
                var n,
                  s = this.el.getAttribute("rotation"),
                  o = this.velocity;
                return (
                  e.copy(o),
                  e.multiplyScalar(i),
                  s
                    ? ((n = this.data.fly ? s.x : 0),
                      t.set(
                        THREE.Math.degToRad(n),
                        THREE.Math.degToRad(s.y),
                        0
                      ),
                      e.applyEuler(t),
                      e)
                    : e
                );
              };
            })(),
            attachVisibilityEventListeners: function () {
              window.addEventListener("blur", this.onBlur),
                window.addEventListener("focus", this.onFocus),
                document.addEventListener(
                  "visibilitychange",
                  this.onVisibilityChange
                );
            },
            removeVisibilityEventListeners: function () {
              window.removeEventListener("blur", this.onBlur),
                window.removeEventListener("focus", this.onFocus),
                document.removeEventListener(
                  "visibilitychange",
                  this.onVisibilityChange
                );
            },
            attachKeyEventListeners: function () {
              window.addEventListener("keydown", this.onKeyDown),
                window.addEventListener("keyup", this.onKeyUp);
            },
            removeKeyEventListeners: function () {
              window.removeEventListener("keydown", this.onKeyDown),
                window.removeEventListener("keyup", this.onKeyUp);
            },
            onBlur: function () {
              this.pause();
            },
            onFocus: function () {
              this.play();
            },
            onVisibilityChange: function () {
              document.hidden ? this.onBlur() : this.onFocus();
            },
            onKeyDown: function (e) {
              var t;
              shouldCaptureKeyEvent(e) &&
                ((t = e.code || KEYCODE_TO_CODE[e.keyCode]),
                -1 !== KEYS.indexOf(t) && (this.keys[t] = !0));
            },
            onKeyUp: function (e) {
              var t;
              (t = e.code || KEYCODE_TO_CODE[e.keyCode]), delete this.keys[t];
            },
          });
        },
        {
          "../constants": 93,
          "../core/component": 101,
          "../lib/three": 150,
          "../utils/": 173,
        },
      ],
      92: [
        function (_dereq_, module, exports) {
          var bind = _dereq_("../utils/bind"),
            registerComponent = _dereq_("../core/component").registerComponent,
            trackedControlsUtils = _dereq_("../utils/tracked-controls"),
            onButtonEvent = trackedControlsUtils.onButtonEvent,
            utils = _dereq_("../utils/"),
            debug = utils.debug("components:windows-motion-controls:debug"),
            warn = utils.debug("components:windows-motion-controls:warn"),
            DEFAULT_HANDEDNESS = _dereq_("../constants").DEFAULT_HANDEDNESS,
            MODEL_BASE_URL = "https://cdn.aframe.io/controllers/microsoft/",
            MODEL_FILENAMES = {
              left: "left.glb",
              right: "right.glb",
              default: "universal.glb",
            },
            GAMEPAD_ID_PREFIX =
              "Spatial Controller (Spatial Interaction Source) ",
            GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;
          module.exports.Component = registerComponent(
            "windows-motion-controls",
            {
              schema: {
                hand: { default: DEFAULT_HANDEDNESS },
                pair: { default: 0 },
                model: { default: !0 },
                hideDisconnected: { default: !0 },
              },
              mapping: {
                axes: { thumbstick: [0, 1], trackpad: [2, 3] },
                buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
                axisMeshNames: [
                  "THUMBSTICK_X",
                  "THUMBSTICK_Y",
                  "TOUCHPAD_TOUCH_X",
                  "TOUCHPAD_TOUCH_Y",
                ],
                buttonMeshNames: {
                  trigger: "SELECT",
                  menu: "MENU",
                  grip: "GRASP",
                  thumbstick: "THUMBSTICK_PRESS",
                  trackpad: "TOUCHPAD_PRESS",
                },
                pointingPoseMeshName: "POINTING_POSE",
              },
              bindMethods: function () {
                (this.onModelError = bind(this.onModelError, this)),
                  (this.onModelLoaded = bind(this.onModelLoaded, this)),
                  (this.onControllersUpdate = bind(
                    this.onControllersUpdate,
                    this
                  )),
                  (this.checkIfControllerPresent = bind(
                    this.checkIfControllerPresent,
                    this
                  )),
                  (this.onAxisMoved = bind(this.onAxisMoved, this));
              },
              init: function () {
                var t = this,
                  e = this.el;
                (this.onButtonChanged = bind(this.onButtonChanged, this)),
                  (this.onButtonDown = function (e) {
                    onButtonEvent(e.detail.id, "down", t);
                  }),
                  (this.onButtonUp = function (e) {
                    onButtonEvent(e.detail.id, "up", t);
                  }),
                  (this.onButtonTouchStart = function (e) {
                    onButtonEvent(e.detail.id, "touchstart", t);
                  }),
                  (this.onButtonTouchEnd = function (e) {
                    onButtonEvent(e.detail.id, "touchend", t);
                  }),
                  (this.onControllerConnected = function () {
                    t.setModelVisibility(!0);
                  }),
                  (this.onControllerDisconnected = function () {
                    t.setModelVisibility(!1);
                  }),
                  (this.controllerPresent = !1),
                  (this.lastControllerCheck = 0),
                  (this.previousButtonValues = {}),
                  this.bindMethods(),
                  (this.loadedMeshInfo = {
                    buttonMeshes: null,
                    axisMeshes: null,
                  }),
                  (this.rayOrigin = {
                    origin: new THREE.Vector3(),
                    direction: new THREE.Vector3(0, 0, -1),
                    createdFromMesh: !1,
                  }),
                  (this.emitIfAxesChanged =
                    trackedControlsUtils.emitIfAxesChanged),
                  (this.checkControllerPresentAndSetup =
                    trackedControlsUtils.checkControllerPresentAndSetup),
                  e.addEventListener(
                    "controllerconnected",
                    this.onControllerConnected
                  ),
                  e.addEventListener(
                    "controllerdisconnected",
                    this.onControllerDisconnected
                  );
              },
              addEventListeners: function () {
                var t = this.el;
                t.addEventListener("buttonchanged", this.onButtonChanged),
                  t.addEventListener("buttondown", this.onButtonDown),
                  t.addEventListener("buttonup", this.onButtonUp),
                  t.addEventListener("touchstart", this.onButtonTouchStart),
                  t.addEventListener("touchend", this.onButtonTouchEnd),
                  t.addEventListener("axismove", this.onAxisMoved),
                  t.addEventListener("model-error", this.onModelError),
                  t.addEventListener("model-loaded", this.onModelLoaded),
                  (this.controllerEventsActive = !0);
              },
              removeEventListeners: function () {
                var t = this.el;
                t.removeEventListener("buttonchanged", this.onButtonChanged),
                  t.removeEventListener("buttondown", this.onButtonDown),
                  t.removeEventListener("buttonup", this.onButtonUp),
                  t.removeEventListener("touchstart", this.onButtonTouchStart),
                  t.removeEventListener("touchend", this.onButtonTouchEnd),
                  t.removeEventListener("axismove", this.onAxisMoved),
                  t.removeEventListener("model-error", this.onModelError),
                  t.removeEventListener("model-loaded", this.onModelLoaded),
                  (this.controllerEventsActive = !1);
              },
              checkIfControllerPresent: function () {
                this.checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                  hand: this.data.hand,
                  index: this.data.pair,
                });
              },
              play: function () {
                this.checkIfControllerPresent(),
                  this.addControllersUpdateListener();
              },
              pause: function () {
                this.removeEventListeners(),
                  this.removeControllersUpdateListener();
              },
              updateControllerModel: function () {
                if (!this.data.model || this.rayOrigin.createdFromMesh)
                  return void this.modelReady();
                var t = this.createControllerModelUrl();
                this.loadModel(t);
              },
              createControllerModelUrl: function (t) {
                var e,
                  n = this.el.components["tracked-controls"],
                  o = n ? n.controller : null,
                  i = "default",
                  s = this.data.hand;
                if (o && ((s = o.hand), !t)) {
                  var r = o.id.match(GAMEPAD_ID_PATTERN);
                  i = (r && r[0]) || i;
                }
                return (
                  (e = MODEL_FILENAMES[s] || MODEL_FILENAMES.default),
                  MODEL_BASE_URL + i + "/" + e
                );
              },
              injectTrackedControls: function () {
                var t = this.data;
                this.el.setAttribute("tracked-controls", {
                  idPrefix: GAMEPAD_ID_PREFIX,
                  controller: t.pair,
                  hand: t.hand,
                  armModel: !1,
                }),
                  this.updateControllerModel();
              },
              addControllersUpdateListener: function () {
                this.el.sceneEl.addEventListener(
                  "controllersupdated",
                  this.onControllersUpdate,
                  !1
                );
              },
              removeControllersUpdateListener: function () {
                this.el.sceneEl.removeEventListener(
                  "controllersupdated",
                  this.onControllersUpdate,
                  !1
                );
              },
              onControllersUpdate: function () {
                this.checkIfControllerPresent();
              },
              onModelError: function (t) {
                var e = this.createControllerModelUrl(!0);
                t.detail.src !== e
                  ? (warn(
                      "Failed to load controller model for device, attempting to load default."
                    ),
                    this.loadModel(e))
                  : warn("Failed to load default controller model.");
              },
              loadModel: function (t) {
                this.el.setAttribute("gltf-model", "url(" + t + ")");
              },
              onModelLoaded: function (t) {
                function e(t, e) {
                  for (var n = 0, o = t.children.length; n < o; n++) {
                    var i = t.children[n];
                    if (i && i.name === e) return i;
                  }
                }
                var n,
                  o,
                  i,
                  s,
                  r = (this.controllerModel = t.detail.model),
                  a = this.loadedMeshInfo;
                if (
                  (debug("Processing model"),
                  (a.buttonMeshes = {}),
                  (a.axisMeshes = {}),
                  r)
                ) {
                  for (n = 0; n < this.mapping.buttons.length; n++)
                    (o = this.mapping.buttonMeshNames[this.mapping.buttons[n]]),
                      o
                        ? ((i = r.getObjectByName(o)),
                          i
                            ? ((s = {
                                index: n,
                                value: e(i, "VALUE"),
                                pressed: e(i, "PRESSED"),
                                unpressed: e(i, "UNPRESSED"),
                              }),
                              s.value && s.pressed && s.unpressed
                                ? (a.buttonMeshes[this.mapping.buttons[n]] = s)
                                : warn(
                                    "Missing button submesh under mesh with name: " +
                                      o +
                                      "(VALUE: " +
                                      !!s.value +
                                      ", PRESSED: " +
                                      !!s.pressed +
                                      ", UNPRESSED:" +
                                      !!s.unpressed +
                                      ")"
                                  ))
                            : warn("Missing button mesh with name: " + o))
                        : debug(
                            "Skipping unknown button at index: " +
                              n +
                              " with mapped name: " +
                              this.mapping.buttons[n]
                          );
                  for (n = 0; n < this.mapping.axisMeshNames.length; n++)
                    (o = this.mapping.axisMeshNames[n]),
                      o
                        ? ((i = r.getObjectByName(o)),
                          i
                            ? ((s = {
                                index: n,
                                value: e(i, "VALUE"),
                                min: e(i, "MIN"),
                                max: e(i, "MAX"),
                              }),
                              s.value && s.min && s.max
                                ? (a.axisMeshes[n] = s)
                                : warn(
                                    "Missing axis submesh under mesh with name: " +
                                      o +
                                      "(VALUE: " +
                                      !!s.value +
                                      ", MIN: " +
                                      !!s.min +
                                      ", MAX:" +
                                      !!s.max +
                                      ")"
                                  ))
                            : warn("Missing axis mesh with name: " + o))
                        : debug("Skipping unknown axis at index: " + n);
                  this.calculateRayOriginFromMesh(r), this.setModelVisibility();
                }
                debug("Model load complete.");
              },
              calculateRayOriginFromMesh: (function () {
                var t = new THREE.Quaternion();
                return function (e) {
                  var n;
                  if (
                    (this.rayOrigin.origin.set(0, 0, 0),
                    this.rayOrigin.direction.set(0, 0, -1),
                    (this.rayOrigin.createdFromMesh = !0),
                    (n = e.getObjectByName(this.mapping.pointingPoseMeshName)))
                  ) {
                    var o = e.parent;
                    o &&
                      ((e.parent = null),
                      e.updateMatrixWorld(!0),
                      (e.parent = o)),
                      n.getWorldPosition(this.rayOrigin.origin),
                      n.getWorldQuaternion(t),
                      this.rayOrigin.direction.applyQuaternion(t),
                      o && e.updateMatrixWorld(!0);
                  } else
                    debug(
                      "Mesh does not contain pointing origin data, defaulting to none."
                    );
                  this.modelReady();
                };
              })(),
              lerpAxisTransform: (function () {
                var t = new THREE.Quaternion();
                return function (e, n) {
                  var o = this.loadedMeshInfo.axisMeshes[e];
                  if (o) {
                    var i = o.min,
                      s = o.max,
                      r = o.value,
                      a = 0.5 * n + 0.5;
                    r.setRotationFromQuaternion(
                      t.copy(i.quaternion).slerp(s.quaternion, a)
                    ),
                      r.position.lerpVectors(i.position, s.position, a);
                  }
                };
              })(),
              lerpButtonTransform: (function () {
                var t = new THREE.Quaternion();
                return function (e, n) {
                  var o = this.loadedMeshInfo.buttonMeshes[e];
                  if (o) {
                    var i = o.unpressed,
                      s = o.pressed,
                      r = o.value;
                    r.setRotationFromQuaternion(
                      t.copy(i.quaternion).slerp(s.quaternion, n)
                    ),
                      r.position.lerpVectors(i.position, s.position, n);
                  }
                };
              })(),
              modelReady: function () {
                this.el.emit("controllermodelready", {
                  name: "windows-motion-controls",
                  model: this.data.model,
                  rayOrigin: this.rayOrigin,
                });
              },
              onButtonChanged: function (t) {
                var e = this.mapping.buttons[t.detail.id];
                e &&
                  (this.loadedMeshInfo &&
                    this.loadedMeshInfo.buttonMeshes &&
                    this.lerpButtonTransform(e, t.detail.state.value),
                  this.el.emit(e + "changed", t.detail.state));
              },
              onAxisMoved: function (t) {
                var e = this.mapping.axisMeshNames.length;
                if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes)
                  for (var n = 0; n < e; n++)
                    this.lerpAxisTransform(n, t.detail.axis[n] || 0);
                this.emitIfAxesChanged(this, this.mapping.axes, t);
              },
              setModelVisibility: function (t) {
                var e = this.el.getObject3D("mesh");
                (t = void 0 !== t ? t : this.modelVisible),
                  (this.modelVisible = t),
                  e && (e.visible = t);
              },
            }
          );
        },
        {
          "../constants": 93,
          "../core/component": 101,
          "../utils/": 173,
          "../utils/bind": 167,
          "../utils/tracked-controls": 180,
        },
      ],
      93: [
        function (_dereq_, module, exports) {
          module.exports = {
            AFRAME_INJECTED: "aframe-injected",
            DEFAULT_CAMERA_HEIGHT: 1.6,
            DEFAULT_HANDEDNESS: "right",
            keyboardevent: _dereq_("./keyboardevent"),
          };
        },
        { "./keyboardevent": 94 },
      ],
      94: [
        function (_dereq_, module, exports) {
          module.exports = {
            KEYCODE_TO_CODE: {
              38: "ArrowUp",
              37: "ArrowLeft",
              40: "ArrowDown",
              39: "ArrowRight",
              87: "KeyW",
              65: "KeyA",
              83: "KeyS",
              68: "KeyD",
            },
          };
        },
        {},
      ],
      95: [
        function (_dereq_, module, exports) {
          function mediaElementLoaded(e) {
            if (
              e.hasAttribute("autoplay") ||
              "auto" === e.getAttribute("preload")
            )
              return new Promise(function (t, r) {
                function i() {
                  for (var r = 0, i = 0; i < e.buffered.length; i++)
                    r += e.buffered.end(i) - e.buffered.start(i);
                  r >= e.duration &&
                    ("VIDEO" === e.tagName &&
                      (THREE.Cache.files[e.getAttribute("src")] = e),
                    t());
                }
                return 4 === e.readyState
                  ? t()
                  : e.error
                  ? r()
                  : (e.addEventListener("loadeddata", i, !1),
                    e.addEventListener("progress", i, !1),
                    void e.addEventListener("error", r, !1));
              });
          }
          function fixUpMediaElement(e) {
            var t = setCrossOrigin(e);
            return (
              t.tagName &&
                "video" === t.tagName.toLowerCase() &&
                (t.setAttribute("playsinline", ""),
                t.setAttribute("webkit-playsinline", "")),
              t !== e &&
                (e.parentNode.appendChild(t), e.parentNode.removeChild(e)),
              t
            );
          }
          function setCrossOrigin(e) {
            var t;
            if (e.hasAttribute("crossorigin")) return e;
            if (null !== (t = e.getAttribute("src"))) {
              if (-1 === t.indexOf("://")) return e;
              if (extractDomain(t) === window.location.host) return e;
            }
            return (
              warn(
                'Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)',
                t
              ),
              (e.crossOrigin = "anonymous"),
              e.cloneNode(!0)
            );
          }
          function extractDomain(e) {
            var t = e.indexOf("://") > -1 ? e.split("/")[2] : e.split("/")[0];
            return t.substring(0, t.indexOf(":"));
          }
          function inferResponseType(e) {
            var t = e.lastIndexOf(".");
            if (t >= 0) {
              var r = e.slice(t, e.length);
              if (".gltf" === r || ".glb" === r) return "arraybuffer";
            }
            return "text";
          }
          var ANode = _dereq_("./a-node"),
            bind = _dereq_("../utils/bind"),
            debug = _dereq_("../utils/debug"),
            registerElement = _dereq_("./a-register-element").registerElement,
            THREE = _dereq_("../lib/three"),
            fileLoader = new THREE.FileLoader(),
            warn = debug("core:a-assets:warn");
          (module.exports = registerElement("a-assets", {
            prototype: Object.create(ANode.prototype, {
              createdCallback: {
                value: function () {
                  (this.isAssets = !0),
                    (this.fileLoader = fileLoader),
                    (this.timeout = null);
                },
              },
              attachedCallback: {
                value: function () {
                  var e,
                    t,
                    r,
                    i,
                    s,
                    o,
                    n = this,
                    a = [];
                  if (!this.parentNode.isScene)
                    throw new Error(
                      "<a-assets> must be a child of a <a-scene>."
                    );
                  for (
                    s = this.querySelectorAll("img"), e = 0;
                    e < s.length;
                    e++
                  )
                    (i = fixUpMediaElement(s[e])),
                      a.push(
                        new Promise(function (t, r) {
                          (THREE.Cache.files[s[e].getAttribute("src")] = i),
                            (i.onload = t),
                            (i.onerror = r);
                        })
                      );
                  for (
                    r = this.querySelectorAll("audio, video"), e = 0;
                    e < r.length;
                    e++
                  )
                    (t = fixUpMediaElement(r[e])),
                      t.src ||
                        t.srcObject ||
                        warn(
                          "Audio/video asset has neither `src` nor `srcObject` attributes."
                        ),
                      a.push(mediaElementLoaded(t));
                  Promise.all(a).then(bind(this.load, this)),
                    (o = parseInt(this.getAttribute("timeout"), 10) || 3e3),
                    (this.timeout = setTimeout(function () {
                      n.hasLoaded ||
                        (warn("Asset loading timed out in ", o, "ms"),
                        n.emit("timeout"),
                        n.load());
                    }, o));
                },
              },
              detachedCallback: {
                value: function () {
                  this.timeout && clearTimeout(this.timeout);
                },
              },
              load: {
                value: function () {
                  ANode.prototype.load.call(this, null, function (e) {
                    return e.isAssetItem && e.hasAttribute("src");
                  });
                },
              },
            }),
          })),
            registerElement("a-asset-item", {
              prototype: Object.create(ANode.prototype, {
                createdCallback: {
                  value: function () {
                    (this.data = null), (this.isAssetItem = !0);
                  },
                },
                attachedCallback: {
                  value: function () {
                    var e = this,
                      t = this.getAttribute("src");
                    fileLoader.setResponseType(
                      this.getAttribute("response-type") || inferResponseType(t)
                    ),
                      fileLoader.load(
                        t,
                        function (t) {
                          (e.data = t),
                            setTimeout(function () {
                              ANode.prototype.load.call(e);
                            });
                        },
                        function (t) {
                          e.emit("progress", {
                            loadedBytes: t.loaded,
                            totalBytes: t.total,
                            xhr: t,
                          });
                        },
                        function (t) {
                          e.emit("error", { xhr: t });
                        }
                      );
                  },
                },
              }),
            }),
            (module.exports.inferResponseType = inferResponseType);
        },
        {
          "../lib/three": 150,
          "../utils/bind": 167,
          "../utils/debug": 169,
          "./a-node": 99,
          "./a-register-element": 100,
        },
      ],
      96: [
        function (_dereq_, module, exports) {
          var debug = _dereq_("../utils/debug"),
            registerElement = _dereq_("./a-register-element").registerElement,
            warn = debug("core:cubemap:warn");
          module.exports = registerElement("a-cubemap", {
            prototype: Object.create(window.HTMLElement.prototype, {
              attachedCallback: {
                value: function () {
                  this.srcs = this.validate();
                },
                writable: window.debug,
              },
              validate: {
                value: function () {
                  var e,
                    t = this.querySelectorAll("[src]"),
                    r = [];
                  if (6 === t.length) {
                    for (e = 0; e < t.length; e++)
                      r.push(t[e].getAttribute("src"));
                    return r;
                  }
                  warn(
                    "<a-cubemap> did not contain exactly six elements each with a `src` attribute."
                  );
                },
                writable: window.debug,
              },
            }),
          });
        },
        { "../utils/debug": 169, "./a-register-element": 100 },
      ],
      97: [
        function (_dereq_, module, exports) {
          function checkComponentDefined(t, e) {
            return (
              !(!t.components[e] || !t.components[e].attrValue) ||
              isComponentMixedIn(e, t.mixinEls)
            );
          }
          function isComponentMixedIn(t, e) {
            var i,
              n = !1;
            for (i = 0; i < e.length && !(n = e[i].hasAttribute(t)); ++i);
            return n;
          }
          function mergeComponentData(t, e) {
            return e
              ? e.constructor === Object
                ? utils.extend(e, utils.styleParser.parse(t || {}))
                : t || e
              : t;
          }
          function isComponent(t) {
            return (
              -1 !== t.indexOf(MULTIPLE_COMPONENT_DELIMITER) &&
                (t = utils.split(t, MULTIPLE_COMPONENT_DELIMITER)[0]),
              !!COMPONENTS[t]
            );
          }
          function getRotation(t) {
            var e = THREE.Math.radToDeg,
              i = t.object3D.rotation,
              n = t.rotationObj;
            return (n.x = e(i.x)), (n.y = e(i.y)), (n.z = e(i.z)), n;
          }
          var ANode = _dereq_("./a-node"),
            COMPONENTS = _dereq_("./component").components,
            registerElement = _dereq_("./a-register-element").registerElement,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            AEntity,
            debug = utils.debug("core:a-entity:debug"),
            warn = utils.debug("core:a-entity:warn"),
            MULTIPLE_COMPONENT_DELIMITER = "__",
            OBJECT3D_COMPONENTS = ["position", "rotation", "scale", "visible"],
            ONCE = { once: !0 },
            proto = Object.create(ANode.prototype, {
              createdCallback: {
                value: function () {
                  (this.components = {}),
                    (this.initializingComponents = {}),
                    (this.componentsToUpdate = {}),
                    (this.isEntity = !0),
                    (this.isPlaying = !1),
                    (this.object3D = new THREE.Group()),
                    (this.object3D.el = this),
                    (this.object3DMap = {}),
                    (this.parentEl = null),
                    (this.rotationObj = {}),
                    (this.states = []);
                },
              },
              attributeChangedCallback: {
                value: function (t, e, i) {
                  var n = this.components[t];
                  if (n && n.justInitialized && "" === i)
                    return void delete n.justInitialized;
                  (n || null !== i) && this.setEntityAttribute(t, e, i);
                },
              },
              attachedCallback: {
                value: function () {
                  var t,
                    e = this.sceneEl,
                    i = this;
                  if ((this.addToParent(), !this.isScene)) {
                    if (!e) return void this.load();
                    if ((t = e.querySelector("a-assets")) && !t.hasLoaded)
                      return void t.addEventListener("loaded", function () {
                        i.load();
                      });
                    this.load();
                  }
                },
              },
              detachedCallback: {
                value: function () {
                  var t;
                  if (this.parentEl) {
                    for (t in this.components) this.removeComponent(t);
                    this.isScene ||
                      (this.removeFromParent(),
                      ANode.prototype.detachedCallback.call(this),
                      (this.object3D.el = null));
                  }
                },
              },
              getObject3D: {
                value: function (t) {
                  return this.object3DMap[t];
                },
              },
              setObject3D: {
                value: function (t, e) {
                  var i,
                    n = this;
                  if (!(e instanceof THREE.Object3D))
                    throw new Error(
                      "`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D."
                    );
                  (i = this.getObject3D(t)),
                    i && this.object3D.remove(i),
                    (e.el = this),
                    e.children.length &&
                      e.traverse(function (t) {
                        t.el = n;
                      }),
                    this.object3D.add(e),
                    (this.object3DMap[t] = e),
                    this.emit("object3dset", { object: e, type: t });
                },
              },
              removeObject3D: {
                value: function (t) {
                  var e = this.getObject3D(t);
                  e &&
                    (this.object3D.remove(e),
                    delete this.object3DMap[t],
                    this.emit("object3dremove", { type: t }));
                },
              },
              getOrCreateObject3D: {
                value: function (t, e) {
                  var i = this.getObject3D(t);
                  return (
                    !i && e && ((i = new e()), this.setObject3D(t, i)),
                    warn(
                      "`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."
                    ),
                    i
                  );
                },
              },
              add: {
                value: function (t) {
                  if (!t.object3D)
                    throw new Error(
                      "Trying to add an element that doesn't have an `object3D`"
                    );
                  this.object3D.add(t.object3D),
                    this.emit("child-attached", { el: t });
                },
              },
              addToParent: {
                value: function () {
                  var t = (this.parentEl = this.parentNode);
                  t &&
                    t.add &&
                    !this.attachedToParent &&
                    (t.add(this), (this.attachedToParent = !0));
                },
              },
              removeFromParent: {
                value: function () {
                  var t = this.parentEl;
                  this.parentEl.remove(this),
                    (this.attachedToParent = !1),
                    (this.parentEl = null),
                    t.emit("child-detached", { el: this });
                },
              },
              load: {
                value: function () {
                  var t = this;
                  !this.hasLoaded &&
                    this.parentEl &&
                    ANode.prototype.load.call(this, function () {
                      t.parentEl &&
                        (t.updateComponents(),
                        (t.isScene || t.parentEl.isPlaying) && t.play());
                    });
                },
                writable: window.debug,
              },
              remove: {
                value: function (t) {
                  this.object3D.remove(t.object3D);
                },
              },
              getChildEntities: {
                value: function () {
                  for (
                    var t = this.children, e = [], i = 0;
                    i < t.length;
                    i++
                  ) {
                    var n = t[i];
                    n instanceof AEntity && e.push(n);
                  }
                  return e;
                },
              },
              initComponent: {
                value: function (t, e, i) {
                  var n, o, s, a;
                  if (
                    ((s = utils.split(t, MULTIPLE_COMPONENT_DELIMITER)),
                    (a = s[0]),
                    (o = s.length > 2 ? s.slice(1).join("__") : s[1]),
                    COMPONENTS[a] &&
                      (checkComponentDefined(this, t) || void 0 !== e || i) &&
                      !(t in this.components))
                  ) {
                    if (
                      (this.initComponentDependencies(a),
                      o && !COMPONENTS[a].multiple)
                    )
                      throw new Error(
                        "Trying to initialize multiple components of type `" +
                          a +
                          "`. There can only be one component of this type per entity."
                      );
                    (n = new COMPONENTS[a].Component(this, e, o)),
                      this.isPlaying && n.play(),
                      this.hasAttribute(t) ||
                        ((n.justInitialized = !0),
                        window.HTMLElement.prototype.setAttribute.call(
                          this,
                          t,
                          ""
                        )),
                      debug("Component initialized: %s", t);
                  }
                },
                writable: window.debug,
              },
              initComponentDependencies: {
                value: function (t) {
                  var e,
                    i,
                    n = this,
                    o = COMPONENTS[t];
                  if (o && (e = COMPONENTS[t].dependencies))
                    for (i = 0; i < e.length; i++)
                      n.initComponent(
                        e[i],
                        window.HTMLElement.prototype.getAttribute.call(
                          n,
                          e[i]
                        ) || void 0,
                        !0
                      );
                },
              },
              removeComponent: {
                value: function (t) {
                  var e;
                  if ((e = this.components[t])) {
                    if (!e.initialized)
                      return void this.addEventListener(
                        "componentinitialized",
                        function e(i) {
                          i.detail.name === t &&
                            (this.removeComponent(t),
                            this.removeEventListener(
                              "componentinitialized",
                              e
                            ));
                        }
                      );
                    e.pause(),
                      e.remove(),
                      delete this.components[t],
                      this.emit("componentremoved", e.evtDetail);
                  }
                },
                writable: window.debug,
              },
              updateComponents: {
                value: function () {
                  var t,
                    e,
                    i,
                    n,
                    o = this.componentsToUpdate;
                  if (this.hasLoaded) {
                    for (i = 0; i < this.mixinEls.length; i++)
                      for (n in this.mixinEls[i].componentCache)
                        isComponent(n) && (o[n] = !0);
                    if (this.getExtraComponents) {
                      e = this.getExtraComponents();
                      for (n in e) isComponent(n) && (o[n] = !0);
                    }
                    for (i = 0; i < this.attributes.length; ++i)
                      (n = this.attributes[i].name),
                        -1 === OBJECT3D_COMPONENTS.indexOf(n) &&
                          isComponent(n) &&
                          (o[n] = !0);
                    for (i = 0; i < OBJECT3D_COMPONENTS.length; i++)
                      (n = OBJECT3D_COMPONENTS[i]),
                        this.hasAttribute(n) &&
                          this.updateComponent(n, this.getDOMAttribute(n));
                    for (n in o)
                      (t = mergeComponentData(
                        this.getDOMAttribute(n),
                        e && e[n]
                      )),
                        this.updateComponent(n, t),
                        delete o[n];
                  }
                },
                writable: window.debug,
              },
              updateComponent: {
                value: function (t, e, i) {
                  var n = this.components[t];
                  if (n)
                    return null !== e || checkComponentDefined(this, t)
                      ? void n.updateProperties(e, i)
                      : void this.removeComponent(t);
                  this.initComponent(t, e, !1);
                },
              },
              removeAttribute: {
                value: function (t, e) {
                  var i = this.components[t];
                  if (
                    (i && void 0 === e && this.removeComponent(t),
                    i && void 0 !== e)
                  )
                    return void i.resetProperty(e);
                  "mixin" === t && this.mixinUpdate(""),
                    window.HTMLElement.prototype.removeAttribute.call(this, t);
                },
              },
              play: {
                value: function () {
                  var t, e, i;
                  if (!this.isPlaying && this.hasLoaded) {
                    this.isPlaying = !0;
                    for (i in this.components) this.components[i].play();
                    for (t = this.getChildEntities(), e = 0; e < t.length; e++)
                      t[e].play();
                    this.emit("play");
                  }
                },
                writable: !0,
              },
              pause: {
                value: function () {
                  var t, e, i;
                  if (this.isPlaying) {
                    this.isPlaying = !1;
                    for (i in this.components) this.components[i].pause();
                    for (t = this.getChildEntities(), e = 0; e < t.length; e++)
                      t[e].pause();
                    this.emit("pause");
                  }
                },
                writable: !0,
              },
              setEntityAttribute: {
                value: function (t, e, i) {
                  if (COMPONENTS[t] || this.components[t])
                    return void this.updateComponent(t, i);
                  if ("mixin" === t) {
                    if (i === this.computedMixinStr) return;
                    this.mixinUpdate(i, e);
                  }
                },
              },
              mixinUpdate: {
                value: (function () {
                  var t = [];
                  return function (e, i) {
                    var n,
                      o,
                      s,
                      a,
                      r = this;
                    if (!this.hasLoaded)
                      return void this.addEventListener(
                        "loaded",
                        function () {
                          r.mixinUpdate(e, i);
                        },
                        ONCE
                      );
                    for (
                      i = i || this.getAttribute("mixin"),
                        s = this.updateMixins(e, i),
                        t.length = 0,
                        a = 0;
                      a < this.mixinEls.length;
                      a++
                    )
                      for (n in this.mixinEls[a].componentCache)
                        -1 === t.indexOf(n) &&
                          (this.components[n]
                            ? this.components[n].handleMixinUpdate()
                            : this.initComponent(n, null),
                          t.push(n));
                    for (a = 0; a < s.oldMixinIds.length; a++)
                      if ((o = document.getElementById(s.oldMixinIds[a])))
                        for (n in o.componentCache)
                          -1 === t.indexOf(n) &&
                            this.components[n] &&
                            this.components[n].handleMixinUpdate();
                  };
                })(),
              },
              setAttribute: {
                value: (function () {
                  var t = {};
                  return function (e, i, n) {
                    var o, s, a, r, h, l;
                    if (
                      ((r = e.indexOf(MULTIPLE_COMPONENT_DELIMITER)),
                      (a = r > 0 ? e.substring(0, r) : e),
                      !COMPONENTS[a])
                    )
                      return (
                        "mixin" === e && this.mixinUpdate(i),
                        void ANode.prototype.setAttribute.call(this, e, i)
                      );
                    if (
                      (!this.components[e] &&
                        this.hasAttribute(e) &&
                        this.updateComponent(
                          e,
                          window.HTMLElement.prototype.getAttribute.call(
                            this,
                            e
                          )
                        ),
                      void 0 !== n &&
                        "string" == typeof i &&
                        i.length > 0 &&
                        "string" == typeof utils.styleParser.parse(i))
                    ) {
                      for (l in t) delete t[l];
                      (o = t), (o[i] = n), (s = !1);
                    } else (o = i), (s = !0 === n);
                    this.updateComponent(e, o, s),
                      (h =
                        this.sceneEl && this.sceneEl.getAttribute("debug")) &&
                        this.components[e].flushToDOM();
                  };
                })(),
                writable: window.debug,
              },
              flushToDOM: {
                value: function (t) {
                  var e,
                    i,
                    n,
                    o = this.components,
                    s = this.children;
                  for (n in o) o[n].flushToDOM();
                  if (t)
                    for (i = 0; i < s.length; ++i)
                      (e = s[i]), e.flushToDOM && e.flushToDOM(t);
                },
              },
              getAttribute: {
                value: function (t) {
                  var e;
                  return "position" === t
                    ? this.object3D.position
                    : "rotation" === t
                    ? getRotation(this)
                    : "scale" === t
                    ? this.object3D.scale
                    : "visible" === t
                    ? this.object3D.visible
                    : ((e = this.components[t]),
                      e
                        ? e.data
                        : window.HTMLElement.prototype.getAttribute.call(
                            this,
                            t
                          ));
                },
                writable: window.debug,
              },
              getDOMAttribute: {
                value: function (t) {
                  var e = this.components[t];
                  return e
                    ? e.attrValue
                    : window.HTMLElement.prototype.getAttribute.call(this, t);
                },
                writable: window.debug,
              },
              addState: {
                value: function (t) {
                  this.is(t) ||
                    (this.states.push(t), this.emit("stateadded", t));
                },
              },
              removeState: {
                value: function (t) {
                  var e = this.states.indexOf(t);
                  -1 !== e &&
                    (this.states.splice(e, 1), this.emit("stateremoved", t));
                },
              },
              is: {
                value: function (t) {
                  return -1 !== this.states.indexOf(t);
                },
              },
            });
          (AEntity = registerElement("a-entity", { prototype: proto })),
            (module.exports = AEntity);
        },
        {
          "../lib/three": 150,
          "../utils/": 173,
          "./a-node": 99,
          "./a-register-element": 100,
          "./component": 101,
        },
      ],
      98: [
        function (_dereq_, module, exports) {
          var ANode = _dereq_("./a-node"),
            registerElement = _dereq_("./a-register-element").registerElement,
            components = _dereq_("./component").components,
            utils = _dereq_("../utils"),
            MULTIPLE_COMPONENT_DELIMITER = "__";
          module.exports = registerElement("a-mixin", {
            prototype: Object.create(ANode.prototype, {
              createdCallback: {
                value: function () {
                  (this.componentCache = {}),
                    (this.id = this.getAttribute("id")),
                    (this.isMixin = !0);
                },
              },
              attributeChangedCallback: {
                value: function (t, e, i) {
                  this.cacheAttribute(t, i), this.updateEntities();
                },
              },
              attachedCallback: {
                value: function () {
                  (this.sceneEl = this.closestScene()),
                    this.cacheAttributes(),
                    this.updateEntities(),
                    this.load();
                },
              },
              setAttribute: {
                value: function (t, e) {
                  window.HTMLElement.prototype.setAttribute.call(this, t, e),
                    this.cacheAttribute(t, e);
                },
              },
              cacheAttribute: {
                value: function (t, e) {
                  var i, n;
                  (n = utils.split(t, MULTIPLE_COMPONENT_DELIMITER)[0]),
                    (i = components[n]) &&
                      (void 0 === e &&
                        (e = window.HTMLElement.prototype.getAttribute.call(
                          this,
                          t
                        )),
                      (this.componentCache[t] = i.parseAttrValueForCache(e)));
                },
              },
              getAttribute: {
                value: function (t) {
                  return (
                    this.componentCache[t] ||
                    window.HTMLElement.prototype.getAttribute.call(this, t)
                  );
                },
              },
              cacheAttributes: {
                value: function () {
                  var t,
                    e,
                    i = this.attributes;
                  for (e = 0; e < i.length; e++)
                    (t = i[e].name), this.cacheAttribute(t);
                },
              },
              updateEntities: {
                value: function () {
                  var t, e, i;
                  if (this.sceneEl)
                    for (
                      e = this.sceneEl.querySelectorAll(
                        "[mixin~=" + this.id + "]"
                      ),
                        i = 0;
                      i < e.length;
                      i++
                    )
                      (t = e[i]),
                        t.hasLoaded && !t.isMixin && t.mixinUpdate(this.id);
                },
              },
            }),
          });
        },
        {
          "../utils": 173,
          "./a-node": 99,
          "./a-register-element": 100,
          "./component": 101,
        },
      ],
      99: [
        function (_dereq_, module, exports) {
          var registerElement = _dereq_("./a-register-element").registerElement,
            isNode = _dereq_("./a-register-element").isNode,
            utils = _dereq_("../utils/"),
            warn = utils.debug("core:a-node:warn"),
            error = utils.debug("core:a-node:error");
          module.exports = registerElement("a-node", {
            prototype: Object.create(window.HTMLElement.prototype, {
              createdCallback: {
                value: function () {
                  (this.computedMixinStr = ""),
                    (this.hasLoaded = !1),
                    (this.isNode = !0),
                    (this.mixinEls = []);
                },
                writable: window.debug,
              },
              attachedCallback: {
                value: function () {
                  var t;
                  (this.sceneEl = this.closestScene()),
                    this.sceneEl ||
                      warn(
                        "You are attempting to attach <" +
                          this.tagName +
                          "> outside of an A-Frame scene. Append this element to `<a-scene>` instead."
                      ),
                    (this.hasLoaded = !1),
                    this.emit("nodeready", void 0, !1),
                    this.isMixin ||
                      ((t = this.getAttribute("mixin")) &&
                        this.updateMixins(t));
                },
                writable: window.debug,
              },
              attributeChangedCallback: {
                value: function (t, e, i) {
                  i !== this.computedMixinStr &&
                    ("mixin" !== t || this.isMixin || this.updateMixins(i, e));
                },
              },
              closestScene: {
                value: function () {
                  for (var t = this; t && !t.isScene; ) t = t.parentElement;
                  return t;
                },
              },
              closest: {
                value: function (t) {
                  for (
                    var e =
                        this.matches ||
                        this.mozMatchesSelector ||
                        this.msMatchesSelector ||
                        this.oMatchesSelector ||
                        this.webkitMatchesSelector,
                      i = this;
                    i && !e.call(i, t);

                  )
                    i = i.parentElement;
                  return i;
                },
              },
              detachedCallback: {
                value: function () {
                  this.hasLoaded = !1;
                },
              },
              load: {
                value: function (t, e) {
                  var i,
                    n,
                    s = this;
                  this.hasLoaded ||
                    ((e = e || isNode),
                    (i = this.getChildren()),
                    (n = i.filter(e).map(function (t) {
                      return new Promise(function (e) {
                        if (t.hasLoaded) return e();
                        t.addEventListener("loaded", e);
                      });
                    })),
                    Promise.all(n)
                      .then(function () {
                        (s.hasLoaded = !0),
                          t && t(),
                          s.emit("loaded", void 0, !1);
                      })
                      .catch(function (t) {
                        error("Failure loading node: ", t);
                      }));
                },
                writable: !0,
              },
              getChildren: {
                value: function () {
                  return Array.prototype.slice.call(this.children, 0);
                },
              },
              updateMixins: {
                value: (function () {
                  var t = [],
                    e = [],
                    i = {};
                  return function (n, s) {
                    var r, a, o;
                    for (
                      t.length = 0,
                        e.length = 0,
                        a = n ? utils.split(n.trim(), /\s+/) : t,
                        o = s ? utils.split(s.trim(), /\s+/) : e,
                        i.newMixinIds = a,
                        i.oldMixinIds = o,
                        r = 0;
                      r < o.length;
                      r++
                    )
                      -1 === a.indexOf(o[r]) && this.unregisterMixin(o[r]);
                    for (
                      this.computedMixinStr = "",
                        this.mixinEls.length = 0,
                        r = 0;
                      r < a.length;
                      r++
                    )
                      this.registerMixin(document.getElementById(a[r]));
                    return (
                      this.computedMixinStr &&
                        ((this.computedMixinStr = this.computedMixinStr.trim()),
                        window.HTMLElement.prototype.setAttribute.call(
                          this,
                          "mixin",
                          this.computedMixinStr
                        )),
                      i
                    );
                  };
                })(),
              },
              registerMixin: {
                value: function (t) {
                  var e, i, n;
                  if (t) {
                    if ((n = t.getAttribute("mixin")))
                      for (
                        e = utils.split(n.trim(), /\s+/), i = 0;
                        i < e.length;
                        i++
                      )
                        this.registerMixin(document.getElementById(e[i]));
                    (this.computedMixinStr =
                      this.computedMixinStr + " " + t.id),
                      this.mixinEls.push(t);
                  }
                },
              },
              setAttribute: {
                value: function (t, e) {
                  "mixin" === t && this.updateMixins(e),
                    window.HTMLElement.prototype.setAttribute.call(this, t, e);
                },
              },
              unregisterMixin: {
                value: function (t) {
                  var e,
                    i,
                    n = this.mixinEls;
                  for (e = 0; e < n.length; ++e)
                    if (((i = n[e]), t === i.id)) {
                      n.splice(e, 1);
                      break;
                    }
                },
              },
              emit: {
                value: (function () {
                  var t = {};
                  return function (e, i, n, s) {
                    void 0 === n && (n = !0),
                      (t.bubbles = !!n),
                      (t.detail = i),
                      s && (t = utils.extend({}, s, t)),
                      this.dispatchEvent(new CustomEvent(e, t));
                  };
                })(),
                writable: window.debug,
              },
            }),
          });
        },
        { "../utils/": 173, "./a-register-element": 100 },
      ],
      100: [
        function (_dereq_, module, exports) {
          function addTagName(e) {
            knownTags[e.toLowerCase()] = !0;
          }
          function wrapANodeMethods(e) {
            var t = {};
            return (
              wrapMethods(
                t,
                [
                  "attachedCallback",
                  "attributeChangedCallback",
                  "createdCallback",
                  "detachedCallback",
                ],
                e,
                ANode.prototype
              ),
              copyProperties(e, t),
              t
            );
          }
          function wrapAEntityMethods(e) {
            var t = {},
              o = [
                "attachedCallback",
                "attributeChangedCallback",
                "createdCallback",
                "detachedCallback",
              ],
              a = [
                "attachedCallback",
                "attributeChangedCallback",
                "createdCallback",
                "detachedCallback",
              ];
            return (
              wrapMethods(t, o, e, ANode.prototype),
              wrapMethods(t, a, e, AEntity.prototype),
              copyProperties(e, t),
              t
            );
          }
          function wrapMethods(e, t, o, a) {
            t.forEach(function (t) {
              wrapMethod(e, t, o, a);
            });
          }
          function wrapMethod(e, t, o, a) {
            var r = o[t],
              n = a[t];
            r &&
              n &&
              r !== n &&
              (e[t] = {
                value: function () {
                  return n.apply(this, arguments), r.apply(this, arguments);
                },
                writable: window.debug,
              });
          }
          function copyProperties(e, t) {
            Object.getOwnPropertyNames(e).forEach(function (o) {
              var a;
              t[o] ||
                ((a = Object.getOwnPropertyDescriptor(e, o)),
                (t[o] = { value: e[o], writable: a.writable }));
            });
          }
          _dereq_("document-register-element");
          var ANode,
            AEntity,
            knownTags = (module.exports.knownTags = {});
          (module.exports.isNode = function (e) {
            return e.tagName.toLowerCase() in knownTags || e.isNode;
          }),
            (module.exports.registerElement = function (e, t) {
              var o = Object.getPrototypeOf(t.prototype),
                a = t,
                r = ANode && o === ANode.prototype,
                n = AEntity && o === AEntity.prototype;
              return (
                (r || n) && addTagName(e),
                r &&
                  ((a = wrapANodeMethods(t.prototype)),
                  (a = { prototype: Object.create(o, a) })),
                n &&
                  ((a = wrapAEntityMethods(t.prototype)),
                  (a = { prototype: Object.create(o, a) })),
                Object.getOwnPropertyNames(a.prototype).forEach(function (e) {
                  var t = a.prototype[e];
                  "function" == typeof t && (t.displayName = e);
                }),
                document.registerElement(e, a)
              );
            }),
            (module.exports.wrapMethods = wrapMethods),
            (ANode = _dereq_("./a-node")),
            (AEntity = _dereq_("./a-entity"));
        },
        { "./a-entity": 97, "./a-node": 99, "document-register-element": 13 },
      ],
      101: [
        function (_dereq_, module, exports) {
          function copyData(t, e) {
            var i, s;
            for (s in e)
              void 0 !== e[s] &&
                ((i = e[s]), (t[s] = isObjectOrArray(i) ? utils.clone(i) : i));
            return t;
          }
          function extendProperties(t, e, i) {
            var s;
            if (i && e.constructor === Object) {
              for (s in e)
                void 0 !== e[s] &&
                  (e[s] && e[s].constructor === Object
                    ? (t[s] = utils.clone(e[s]))
                    : (t[s] = e[s]));
              return t;
            }
            return e;
          }
          function hasBehavior(t) {
            return t.tick || t.tock;
          }
          function wrapPause(t) {
            return function () {
              var e = this.el.sceneEl;
              this.isPlaying &&
                (t.call(this),
                (this.isPlaying = !1),
                hasBehavior(this) && e.removeBehavior(this));
            };
          }
          function wrapPlay(t) {
            return function () {
              var e = this.el.sceneEl,
                i = this.el.isPlaying && !this.isPlaying;
              this.initialized &&
                i &&
                (t.call(this),
                (this.isPlaying = !0),
                hasBehavior(this) && e.addBehavior(this));
            };
          }
          function wrapRemove(t) {
            return function () {
              t.call(this),
                this.objectPool.recycle(this.attrValue),
                this.objectPool.recycle(this.oldData),
                this.objectPool.recycle(this.parsingAttrValue),
                (this.attrValue =
                  this.oldData =
                  this.parsingAttrValue =
                    void 0);
            };
          }
          function isObject(t) {
            return t && t.constructor === Object;
          }
          function isObjectOrArray(t) {
            return t && (t.constructor === Object || t.constructor === Array);
          }
          var schema = _dereq_("./schema"),
            scenes = _dereq_("./scene/scenes"),
            systems = _dereq_("./system"),
            utils = _dereq_("../utils/"),
            components = (module.exports.components = {}),
            parseProperties = schema.parseProperties,
            parseProperty = schema.parseProperty,
            processSchema = schema.process,
            isSingleProp = schema.isSingleProperty,
            stringifyProperties = schema.stringifyProperties,
            stringifyProperty = schema.stringifyProperty,
            styleParser = utils.styleParser,
            warn = utils.debug("core:component:warn"),
            aframeScript = document.currentScript,
            upperCaseRegExp = new RegExp("[A-Z]+"),
            objectPools = {},
            Component = (module.exports.Component = function (t, e, i) {
              var s = this;
              (this.el = t),
                (this.id = i),
                (this.attrName = this.name + (i ? "__" + i : "")),
                (this.evtDetail = { id: this.id, name: this.name }),
                (this.initialized = !1),
                (this.isSingleProperty = isSingleProp(this.schema)),
                (this.isSinglePropertyObject =
                  this.isSingleProperty &&
                  isObject(parseProperty(void 0, this.schema))),
                (this.isObjectBased =
                  !this.isSingleProperty || this.isSinglePropertyObject),
                (this.el.components[this.attrName] = this),
                (this.objectPool = objectPools[this.name]),
                (this.attrValue = void 0),
                (this.nextData = this.isObjectBased
                  ? this.objectPool.use()
                  : void 0),
                (this.oldData = this.isObjectBased
                  ? this.objectPool.use()
                  : void 0),
                (this.previousOldData = this.isObjectBased
                  ? this.objectPool.use()
                  : void 0),
                (this.parsingAttrValue = this.isObjectBased
                  ? this.objectPool.use()
                  : void 0),
                (this.throttledEmitComponentChanged = utils.throttle(
                  function () {
                    t.emit("componentchanged", s.evtDetail, !1);
                  },
                  200
                )),
                this.updateProperties(e);
            });
          if (
            ((Component.prototype = {
              schema: {},
              init: function () {},
              update: function (t) {},
              updateSchema: void 0,
              tick: void 0,
              tock: void 0,
              play: function () {},
              pause: function () {},
              remove: function () {},
              parse: function (t, e) {
                var i = this.schema;
                return this.isSingleProperty
                  ? parseProperty(t, i)
                  : parseProperties(styleParser.parse(t), i, !0, this.name, e);
              },
              stringify: function (t) {
                var e = this.schema;
                return "string" == typeof t
                  ? t
                  : this.isSingleProperty
                  ? stringifyProperty(t, e)
                  : ((t = stringifyProperties(t, e)), styleParser.stringify(t));
              },
              updateCachedAttrValue: function (t, e) {
                var i, s, a;
                if (void 0 !== t) {
                  if (null === t)
                    return (
                      this.isObjectBased &&
                        this.attrValue &&
                        this.objectPool.recycle(this.attrValue),
                      void (this.attrValue = void 0)
                    );
                  if (
                    (t instanceof Object
                      ? ((s = this.objectPool.use()), (i = utils.extend(s, t)))
                      : (i = this.parseAttrValueForCache(t)),
                    this.isObjectBased && !e && this.attrValue)
                  )
                    for (a in this.attrValue)
                      void 0 === i[a] && (i[a] = this.attrValue[a]);
                  this.isObjectBased &&
                    !this.attrValue &&
                    (this.attrValue = this.objectPool.use()),
                    utils.objectPool.clearObject(this.attrValue),
                    (this.attrValue = extendProperties(
                      this.attrValue,
                      i,
                      this.isObjectBased
                    )),
                    utils.objectPool.clearObject(s);
                }
              },
              parseAttrValueForCache: function (t) {
                var e;
                return "string" != typeof t
                  ? t
                  : (this.isSingleProperty
                      ? "string" == typeof (e = this.schema.parse(t)) && (e = t)
                      : (utils.objectPool.clearObject(this.parsingAttrValue),
                        (e = styleParser.parse(t, this.parsingAttrValue))),
                    e);
              },
              flushToDOM: function (t) {
                var e = t ? this.data : this.attrValue;
                e &&
                  window.HTMLElement.prototype.setAttribute.call(
                    this.el,
                    this.attrName,
                    this.stringify(e)
                  );
              },
              updateProperties: function (t, e) {
                if (!this.el.hasLoaded)
                  return void this.updateCachedAttrValue(t);
                null !== t && (t = this.parseAttrValueForCache(t)),
                  this.updateCachedAttrValue(t, e),
                  this.initialized
                    ? (this.updateComponent(t, e), this.callUpdateHandler())
                    : this.initComponent();
              },
              initComponent: function () {
                var t,
                  e = this.el;
                this.updateSchema &&
                  this.updateSchema(this.buildData(this.attrValue, !1, !0)),
                  (this.data = this.buildData(this.attrValue)),
                  e.initializingComponents[this.name] ||
                    ((e.initializingComponents[this.name] = !0),
                    this.init(),
                    (this.initialized = !0),
                    delete e.initializingComponents[this.name],
                    (this.oldData = extendProperties(
                      this.oldData,
                      this.data,
                      this.isObjectBased
                    )),
                    (t = this.isObjectBased ? this.objectPool.use() : void 0),
                    this.update(t),
                    this.isObjectBased && this.objectPool.recycle(t),
                    e.isPlaying && this.play(),
                    e.emit("componentinitialized", this.evtDetail, !1));
              },
              updateComponent: function (t, e) {
                var i, s;
                if (e)
                  return (
                    this.updateSchema &&
                      this.updateSchema(this.buildData(this.attrValue, !0, !0)),
                    void (this.data = this.buildData(this.attrValue, !0, !1))
                  );
                if (this.isSingleProperty) return void (this.data = t);
                if (
                  (parseProperties(t, this.schema, !0, this.name),
                  this.schemaChangeKeys.length)
                )
                  for (i in t)
                    if (this.schema[i].schemaChange) {
                      s = !0;
                      break;
                    }
                if (s)
                  return (
                    this.updateSchema &&
                      this.updateSchema(this.buildData(this.attrValue, !0, !0)),
                    void (this.data = this.buildData(this.attrValue, !0, !1))
                  );
                for (i in t) void 0 !== t[i] && (this.data[i] = t[i]);
              },
              callUpdateHandler: function () {
                var t;
                this.previousOldData instanceof Object &&
                  utils.objectPool.clearObject(this.previousOldData),
                  this.isObjectBased
                    ? copyData(this.previousOldData, this.oldData)
                    : (this.previousOldData = this.oldData),
                  (t = !utils.deepEqual(this.oldData, this.data)),
                  (this.isPositionRotationScale || t) &&
                    (this.oldData instanceof Object &&
                      utils.objectPool.clearObject(this.oldData),
                    (this.oldData = extendProperties(
                      this.oldData,
                      this.data,
                      this.isObjectBased
                    )),
                    this.update(this.previousOldData),
                    this.throttledEmitComponentChanged());
              },
              handleMixinUpdate: function () {
                (this.data = this.buildData(this.attrValue)),
                  this.callUpdateHandler();
              },
              resetProperty: function (t) {
                if (this.isObjectBased) {
                  if (!(t in this.attrValue)) return;
                  delete this.attrValue[t],
                    (this.data[t] = this.schema[t].default);
                } else
                  (this.attrValue = this.schema.default),
                    (this.data = this.schema.default);
                this.updateProperties(this.attrValue);
              },
              extendSchema: function (t) {
                var e;
                (e = utils.extend({}, components[this.name].schema)),
                  utils.extend(e, t),
                  (this.schema = processSchema(e)),
                  this.el.emit("schemachanged", this.evtDetail);
              },
              buildData: function (t, e, i) {
                var s,
                  a,
                  r,
                  o,
                  n,
                  h,
                  c,
                  l = this.nextData,
                  p = this.schema,
                  u = this.el.mixinEls;
                if (
                  ((s =
                    t && t.constructor === Array
                      ? t.length
                      : void 0 !== t && null !== t),
                  this.isObjectBased && utils.objectPool.clearObject(l),
                  this.isSingleProperty)
                )
                  a = this.isObjectBased
                    ? copyData(l, p.default)
                    : isObjectOrArray(p.default)
                    ? utils.clone(p.default)
                    : p.default;
                else {
                  (c = !e && this.attrValue),
                    (a = c instanceof Object ? copyData(l, c) : l);
                  for (o in p)
                    (r = p[o].default),
                      void 0 === a[o] &&
                        (a[o] = isObjectOrArray(r) ? utils.clone(r) : r);
                }
                for (h = 0; h < u.length; h++)
                  (n = u[h].getAttribute(this.attrName)) &&
                    (a = extendProperties(a, n, this.isObjectBased));
                if (s) {
                  if (this.isSingleProperty)
                    return isObject(t)
                      ? (copyData(this.parsingAttrValue, t),
                        parseProperty(this.parsingAttrValue, p))
                      : parseProperty(t, p);
                  a = extendProperties(a, t, this.isObjectBased);
                } else if (this.isSingleProperty) return parseProperty(a, p);
                return parseProperties(a, p, void 0, this.name, i);
              },
            }),
            window.debug)
          )
            var registrationOrderWarnings =
              (module.exports.registrationOrderWarnings = {});
          module.exports.registerComponent = function (t, e) {
            var i,
              s,
              a,
              r,
              o = {};
            if (
              (document.currentScript &&
                document.currentScript !== aframeScript &&
                scenes.forEach(function (e) {
                  e.hasLoaded ||
                    (document.currentScript.compareDocumentPosition(e) !==
                      Node.DOCUMENT_POSITION_FOLLOWING &&
                      (warn(
                        "The component `" +
                          t +
                          "` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."
                      ),
                      window.debug && (registrationOrderWarnings[t] = !0)));
                }),
              !0 === upperCaseRegExp.test(t) &&
                warn(
                  "The component name `" +
                    t +
                    "` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `" +
                    t.toLowerCase() +
                    "`"
                ),
              -1 !== t.indexOf("__"))
            )
              throw new Error(
                "The component name `" +
                  t +
                  "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type"
              );
            if (
              (Object.keys(e).forEach(function (t) {
                o[t] = { value: e[t], writable: !0 };
              }),
              components[t])
            )
              throw new Error(
                "The component `" +
                  t +
                  "` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name."
              );
            if (
              ((i = function (t, e, i) {
                Component.call(this, t, e, i);
              }),
              (i.prototype = Object.create(Component.prototype, o)),
              (i.prototype.name = t),
              (i.prototype.isPositionRotationScale =
                "position" === t || "rotation" === t || "scale" === t),
              (i.prototype.constructor = i),
              (i.prototype.system = systems && systems.systems[t]),
              (i.prototype.play = wrapPlay(i.prototype.play)),
              (i.prototype.pause = wrapPause(i.prototype.pause)),
              (i.prototype.remove = wrapRemove(i.prototype.remove)),
              (a = utils.extend(
                processSchema(i.prototype.schema, i.prototype.name)
              )),
              !(r = isSingleProp(i.prototype.schema)))
            ) {
              i.prototype.schemaChangeKeys = [];
              for (s in a)
                a[s].schemaChange && i.prototype.schemaChangeKeys.push(s);
            }
            return (
              (objectPools[t] = utils.objectPool.createPool()),
              (components[t] = {
                Component: i,
                dependencies: i.prototype.dependencies,
                isSingleProp: r,
                multiple: i.prototype.multiple,
                name: t,
                parse: i.prototype.parse,
                parseAttrValueForCache: i.prototype.parseAttrValueForCache,
                schema: a,
                stringify: i.prototype.stringify,
                type: i.prototype.type,
              }),
              i
            );
          };
        },
        {
          "../utils/": 173,
          "./scene/scenes": 108,
          "./schema": 110,
          "./system": 112,
        },
      ],
      102: [
        function (_dereq_, module, exports) {
          var schema = _dereq_("./schema"),
            processSchema = schema.process,
            geometries = (module.exports.geometries = {}),
            geometryNames = (module.exports.geometryNames = []),
            THREE = _dereq_("../lib/three"),
            Geometry = (module.exports.Geometry = function () {});
          (Geometry.prototype = {
            schema: {},
            init: function (e) {
              return (this.geometry = new THREE.Geometry()), this.geometry;
            },
            update: function (e) {},
          }),
            (module.exports.registerGeometry = function (e, t) {
              var r,
                o = {};
              if (
                (Object.keys(t).forEach(function (e) {
                  o[e] = { value: t[e], writable: !0 };
                }),
                geometries[e])
              )
                throw new Error(
                  "The geometry `" + e + "` has been already registered"
                );
              return (
                (r = function () {
                  Geometry.call(this);
                }),
                (r.prototype = Object.create(Geometry.prototype, o)),
                (r.prototype.name = e),
                (r.prototype.constructor = r),
                (geometries[e] = {
                  Geometry: r,
                  schema: processSchema(r.prototype.schema),
                }),
                geometryNames.push(e),
                r
              );
            });
        },
        { "../lib/three": 150, "./schema": 110 },
      ],
      103: [
        function (_dereq_, module, exports) {
          function registerPropertyType(e, r, t, n) {
            if ("type" in propertyTypes)
              return void error(
                "Property type " + e + " is already registered."
              );
            propertyTypes[e] = {
              default: r,
              parse: t || defaultParse,
              stringify: n || defaultStringify,
            };
          }
          function arrayParse(e) {
            function r(e) {
              return e.trim();
            }
            return Array.isArray(e)
              ? e
              : e && "string" == typeof e
              ? e.split(",").map(r)
              : [];
          }
          function arrayStringify(e) {
            return e.join(", ");
          }
          function assetParse(e) {
            var r, t;
            return "string" != typeof e
              ? e
              : ((t = e.match(urlRegex)),
                t
                  ? t[1]
                  : "#" === e.charAt(0)
                  ? (r = document.getElementById(e.substring(1)))
                    ? "CANVAS" === r.tagName ||
                      "VIDEO" === r.tagName ||
                      "IMG" === r.tagName
                      ? r
                      : r.getAttribute("src")
                    : void warn('"' + e + '" asset not found.')
                  : e);
          }
          function defaultParse(e) {
            return e;
          }
          function defaultStringify(e) {
            return null === e ? "null" : e.toString();
          }
          function boolParse(e) {
            return "false" !== e && !1 !== e;
          }
          function intParse(e) {
            return parseInt(e, 10);
          }
          function numberParse(e) {
            return parseFloat(e, 10);
          }
          function selectorParse(e) {
            return e
              ? "string" != typeof e
                ? e
                : "#" !== e[0] || nonCharRegex.test(e)
                ? document.querySelector(e)
                : document.getElementById(e.substring(1))
              : null;
          }
          function selectorAllParse(e) {
            return e
              ? "string" != typeof e
                ? e
                : Array.prototype.slice.call(document.querySelectorAll(e), 0)
              : null;
          }
          function selectorStringify(e) {
            return e.getAttribute
              ? "#" + e.getAttribute("id")
              : defaultStringify(e);
          }
          function selectorAllStringify(e) {
            return e instanceof Array
              ? e
                  .map(function (e) {
                    return "#" + e.getAttribute("id");
                  })
                  .join(", ")
              : defaultStringify(e);
          }
          function srcParse(e) {
            return (
              warn("`src` property type is deprecated. Use `asset` instead."),
              assetParse(e)
            );
          }
          function vecParse(e) {
            return coordinates.parse(e, this.default);
          }
          function isValidDefaultValue(e, r) {
            return (
              ("audio" !== e || "string" == typeof r) &&
              !("array" === e && !Array.isArray(r)) &&
              ("asset" !== e || "string" == typeof r) &&
              ("boolean" !== e || "boolean" == typeof r) &&
              ("color" !== e || "string" == typeof r) &&
              ("int" !== e || "number" == typeof r) &&
              ("number" !== e || "number" == typeof r) &&
              ("map" !== e || "string" == typeof r) &&
              ("model" !== e || "string" == typeof r) &&
              ("selector" !== e || "string" == typeof r || null === r) &&
              ("selectorAll" !== e || "string" == typeof r || null === r) &&
              ("src" !== e || "string" == typeof r) &&
              ("string" !== e || "string" == typeof r) &&
              ("time" !== e || "number" == typeof r) &&
              ("vec2" === e
                ? isValidDefaultCoordinate(r, 2)
                : "vec3" === e
                ? isValidDefaultCoordinate(r, 3)
                : "vec4" !== e || isValidDefaultCoordinate(r, 4))
            );
          }
          function isValidDefaultCoordinate(e, r) {
            if (null === e) return !0;
            if ("object" != typeof e) return !1;
            if (Object.keys(e).length !== r) return !1;
            var t = e.x,
              n = e.y,
              i = e.z,
              o = e.w;
            return (
              "number" == typeof t &&
              "number" == typeof n &&
              !(r > 2 && "number" != typeof i) &&
              !(r > 3 && "number" != typeof o)
            );
          }
          var coordinates = _dereq_("../utils/coordinates"),
            debug = _dereq_("debug"),
            error = debug("core:propertyTypes:warn"),
            warn = debug("core:propertyTypes:warn"),
            propertyTypes = (module.exports.propertyTypes = {}),
            nonCharRegex = /[,> .[\]:]/,
            urlRegex = /\url\((.+)\)/;
          registerPropertyType("audio", "", assetParse),
            registerPropertyType("array", [], arrayParse, arrayStringify),
            registerPropertyType("asset", "", assetParse),
            registerPropertyType("boolean", !1, boolParse),
            registerPropertyType(
              "color",
              "#FFF",
              defaultParse,
              defaultStringify
            ),
            registerPropertyType("int", 0, intParse),
            registerPropertyType("number", 0, numberParse),
            registerPropertyType("map", "", assetParse),
            registerPropertyType("model", "", assetParse),
            registerPropertyType(
              "selector",
              null,
              selectorParse,
              selectorStringify
            ),
            registerPropertyType(
              "selectorAll",
              null,
              selectorAllParse,
              selectorAllStringify
            ),
            registerPropertyType("src", "", srcParse),
            registerPropertyType("string", "", defaultParse, defaultStringify),
            registerPropertyType("time", 0, intParse),
            registerPropertyType(
              "vec2",
              { x: 0, y: 0 },
              vecParse,
              coordinates.stringify
            ),
            registerPropertyType(
              "vec3",
              { x: 0, y: 0, z: 0 },
              vecParse,
              coordinates.stringify
            ),
            registerPropertyType(
              "vec4",
              { x: 0, y: 0, z: 0, w: 1 },
              vecParse,
              coordinates.stringify
            ),
            (module.exports.registerPropertyType = registerPropertyType),
            (module.exports.isValidDefaultValue = isValidDefaultValue),
            (module.exports.isValidDefaultCoordinate =
              isValidDefaultCoordinate);
        },
        { "../utils/coordinates": 168, debug: 10 },
      ],
      104: [
        function (_dereq_, module, exports) {
          function getCanvasSize(e, t, i, s) {
            return t
              ? {
                  height: e.parentElement.offsetHeight,
                  width: e.parentElement.offsetWidth,
                }
              : getMaxSize(i, s);
          }
          function getMaxSize(e, t) {
            var i,
              s,
              n = window.devicePixelRatio;
            return (
              (s = {
                height: document.body.offsetHeight,
                width: document.body.offsetWidth,
              }),
              !e || t || (-1 === e.width && -1 === e.height)
                ? s
                : s.width * n < e.width && s.height * n < e.height
                ? s
                : ((i = s.width / s.height),
                  s.width * n > e.width &&
                    -1 !== e.width &&
                    ((s.width = Math.round(e.width / n)),
                    (s.height = Math.round(e.width / i / n))),
                  s.height * n > e.height &&
                    -1 !== e.height &&
                    ((s.height = Math.round(e.height / n)),
                    (s.width = Math.round((e.height * i) / n))),
                  s)
            );
          }
          function requestFullscreen(e) {
            (
              e.requestFullscreen ||
              e.webkitRequestFullscreen ||
              e.mozRequestFullScreen ||
              e.msRequestFullscreen
            ).apply(e);
          }
          function exitFullscreen() {
            document.exitFullscreen
              ? document.exitFullscreen()
              : document.mozCancelFullScreen
              ? document.mozCancelFullScreen()
              : document.webkitExitFullscreen &&
                document.webkitExitFullscreen();
          }
          function setupCanvas(e) {
            function t() {
              document.fullscreenElement ||
                document.mozFullScreenElement ||
                document.webkitFullscreenElement ||
                e.exitVR(),
                document.activeElement.blur(),
                document.body.focus();
            }
            var i;
            (i = document.createElement("canvas")),
              i.classList.add("a-canvas"),
              (i.dataset.aframeCanvas = !0),
              e.appendChild(i),
              document.addEventListener("fullscreenchange", t),
              document.addEventListener("mozfullscreenchange", t),
              document.addEventListener("webkitfullscreenchange", t),
              i.addEventListener("touchmove", function (e) {
                e.preventDefault();
              }),
              (e.canvas = i),
              e.emit("render-target-loaded", { target: i }),
              setTimeout(bind(e.resize, e), 0);
          }
          var initMetaTags = _dereq_("./metaTags").inject,
            initWakelock = _dereq_("./wakelock"),
            loadingScreen = _dereq_("./loadingScreen"),
            re = _dereq_("../a-register-element"),
            scenes = _dereq_("./scenes"),
            systems = _dereq_("../system").systems,
            THREE = _dereq_("../../lib/three"),
            utils = _dereq_("../../utils/"),
            AEntity = _dereq_("../a-entity"),
            ANode = _dereq_("../a-node"),
            initPostMessageAPI = _dereq_("./postMessage"),
            bind = utils.bind,
            isIOS = utils.device.isIOS(),
            isMobile = utils.device.isMobile(),
            registerElement = re.registerElement,
            warn = utils.debug("core:a-scene:warn");
          (module.exports.AScene = registerElement("a-scene", {
            prototype: Object.create(AEntity.prototype, {
              createdCallback: {
                value: function () {
                  (this.isIOS = isIOS),
                    (this.isMobile = isMobile),
                    (this.isScene = !0),
                    (this.object3D = new THREE.Scene());
                  var e = this;
                  (this.object3D.onAfterRender = function (t, i, s) {
                    e.isPlaying && e.tock(e.time, e.delta, s);
                  }),
                    (this.render = bind(this.render, this)),
                    (this.systems = {}),
                    (this.systemNames = []),
                    (this.time = this.delta = 0),
                    (this.behaviors = { tick: [], tock: [] }),
                    (this.hasLoaded = !1),
                    (this.isPlaying = !1),
                    (this.originalHTML = this.innerHTML),
                    (this.renderTarget = null),
                    this.setAttribute("inspector", ""),
                    this.setAttribute("keyboard-shortcuts", ""),
                    this.setAttribute("screenshot", ""),
                    this.setAttribute("vr-mode-ui", "");
                },
              },
              addFullScreenStyles: {
                value: function () {
                  document.documentElement.classList.add("a-fullscreen");
                },
              },
              removeFullScreenStyles: {
                value: function () {
                  document.documentElement.classList.remove("a-fullscreen");
                },
              },
              attachedCallback: {
                value: function () {
                  var e = this;
                  setupCanvas(this),
                    this.setupRenderer(),
                    this.resize(),
                    this.addFullScreenStyles(),
                    initPostMessageAPI(this),
                    initMetaTags(this),
                    initWakelock(this),
                    this.addEventListener("cameraready", function () {
                      e.attachedCallbackPostCamera();
                    }),
                    this.initSystems();
                },
              },
              attachedCallbackPostCamera: {
                value: function () {
                  var e,
                    t = this;
                  (e = bind(this.resize, this)),
                    window.addEventListener("load", e),
                    window.addEventListener("resize", function () {
                      t.isIOS ? setTimeout(e, 100) : e();
                    }),
                    this.play(),
                    scenes.push(this),
                    (this.onVRPresentChangeBound = bind(
                      this.onVRPresentChange,
                      this
                    )),
                    (this.enterVRBound = function () {
                      t.enterVR();
                    }),
                    (this.exitVRBound = function () {
                      t.exitVR();
                    }),
                    (this.exitVRTrueBound = function () {
                      t.exitVR(!0);
                    }),
                    (this.pointerRestrictedBound = function () {
                      t.pointerRestricted();
                    }),
                    (this.pointerUnrestrictedBound = function () {
                      t.pointerUnrestricted();
                    });
                },
                writable: window.debug,
              },
              initSystems: {
                value: function () {
                  var e;
                  this.initSystem("camera");
                  for (e in systems) "camera" !== e && this.initSystem(e);
                },
              },
              initSystem: {
                value: function (e) {
                  this.systems[e] ||
                    ((this.systems[e] = new systems[e](this)),
                    this.systemNames.push(e));
                },
              },
              detachedCallback: {
                value: function () {
                  var e = scenes.indexOf(this);
                  scenes.splice(e, 1);
                },
              },
              addBehavior: {
                value: function (e) {
                  var t,
                    i,
                    s = this.behaviors;
                  for (i in s)
                    e[i] &&
                      ((t = this.behaviors[i]),
                      -1 === t.indexOf(e) && t.push(e));
                },
              },
              getPointerLockElement: {
                value: function () {
                  return document.pointerLockElement;
                },
                writable: window.debug,
              },
              checkHeadsetConnected: {
                value: utils.device.checkHeadsetConnected,
                writable: window.debug,
              },
              enterVR: {
                value: function () {
                  function e() {
                    s.addState("vr-mode"),
                      s.emit("enter-vr", { target: s }),
                      s.isMobile &&
                        screen.orientation &&
                        screen.orientation.lock &&
                        screen.orientation.lock("landscape"),
                      s.addFullScreenStyles(),
                      s.isMobile ||
                        s.checkHeadsetConnected() ||
                        requestFullscreen(s.canvas),
                      s.resize();
                  }
                  function t(e) {
                    throw e && e.message
                      ? new Error(
                          "Failed to enter VR mode (`requestPresent`): " +
                            e.message
                        )
                      : new Error(
                          "Failed to enter VR mode (`requestPresent`)."
                        );
                  }
                  var i,
                    s = this,
                    n = s.renderer.vr;
                  return this.is("vr-mode")
                    ? Promise.resolve("Already in VR.")
                    : (!this.checkHeadsetConnected() && !this.isMobile) ||
                      ((i = utils.device.getVRDisplay()),
                      n.setDevice(i),
                      i.isPresenting)
                    ? (e(), Promise.resolve())
                    : i.requestPresent([{ source: this.canvas }]).then(e, t);
                },
                writable: !0,
              },
              exitVR: {
                value: function () {
                  function e() {
                    s.removeState("vr-mode"),
                      s.isMobile &&
                        screen.orientation &&
                        screen.orientation.unlock &&
                        screen.orientation.unlock(),
                      s.hasAttribute("embedded") && s.removeFullScreenStyles(),
                      s.resize(),
                      s.isIOS && utils.forceCanvasResizeSafariMobile(s.canvas),
                      s.emit("exit-vr", { target: s });
                  }
                  function t(e) {
                    throw e && e.message
                      ? new Error(
                          "Failed to exit VR mode (`exitPresent`): " + e.message
                        )
                      : new Error("Failed to exit VR mode (`exitPresent`).");
                  }
                  var i,
                    s = this;
                  return this.is("vr-mode")
                    ? (exitFullscreen(),
                      (this.checkHeadsetConnected() || this.isMobile) &&
                      ((this.renderer.vr.enabled = !1),
                      (i = utils.device.getVRDisplay()),
                      i.isPresenting)
                        ? i.exitPresent().then(e, t)
                        : (e(), Promise.resolve()))
                    : Promise.resolve("Not in VR.");
                },
                writable: !0,
              },
              pointerRestricted: {
                value: function () {
                  if (this.canvas) {
                    var e = this.getPointerLockElement();
                    e &&
                      e !== this.canvas &&
                      document.exitPointerLock &&
                      document.exitPointerLock(),
                      this.canvas.requestPointerLock &&
                        this.canvas.requestPointerLock();
                  }
                },
              },
              pointerUnrestricted: {
                value: function () {
                  var e = this.getPointerLockElement();
                  e &&
                    e === this.canvas &&
                    document.exitPointerLock &&
                    document.exitPointerLock();
                },
              },
              onVRPresentChange: {
                value: function (e) {
                  if ((e.display || e.detail.display).isPresenting)
                    return void this.enterVR();
                  this.exitVR();
                },
              },
              getAttribute: {
                value: function (e) {
                  var t = this.systems[e];
                  return t
                    ? t.data
                    : AEntity.prototype.getAttribute.call(this, e);
                },
              },
              getComputedAttribute: {
                value: function (e) {
                  warn(
                    "`getComputedAttribute` is deprecated. Use `getAttribute` instead."
                  ),
                    this.getAttribute(e);
                },
              },
              getDOMAttribute: {
                value: function (e) {
                  var t = this.systems[e];
                  return t
                    ? t.data
                    : AEntity.prototype.getDOMAttribute.call(this, e);
                },
              },
              setAttribute: {
                value: function (e, t, i) {
                  var s = this.systems[e];
                  if (s)
                    return (
                      ANode.prototype.setAttribute.call(this, e, t),
                      void s.updateProperties(t)
                    );
                  AEntity.prototype.setAttribute.call(this, e, t, i);
                },
              },
              removeBehavior: {
                value: function (e) {
                  var t,
                    i,
                    s,
                    n = this.behaviors;
                  for (i in n)
                    e[i] &&
                      ((t = this.behaviors[i]),
                      -1 !== (s = t.indexOf(e)) && t.splice(s, 1));
                },
              },
              resize: {
                value: function () {
                  var e,
                    t,
                    i = this.camera,
                    s = this.canvas;
                  !i ||
                    !s ||
                    (this.is("vr-mode") && this.isMobile) ||
                    ((e = this.getAttribute("embedded") && !this.is("vr-mode")),
                    (t = getCanvasSize(
                      s,
                      e,
                      this.maxCanvasSize,
                      this.is("vr-mode")
                    )),
                    (i.aspect = t.width / t.height),
                    i.updateProjectionMatrix(),
                    this.renderer.setSize(t.width, t.height, !1),
                    this.emit("rendererresize", null, !1));
                },
                writable: !0,
              },
              setupRenderer: {
                value: function () {
                  var e, t, i, s;
                  (s = {
                    alpha: !0,
                    antialias: !isMobile,
                    canvas: this.canvas,
                    logarithmicDepthBuffer: !1,
                  }),
                    this.hasAttribute("antialias") &&
                      (s.antialias = "true" === this.getAttribute("antialias")),
                    this.hasAttribute("logarithmicDepthBuffer") &&
                      (s.logarithmicDepthBuffer =
                        "true" === this.getAttribute("logarithmicDepthBuffer")),
                    (this.maxCanvasSize = { height: 1920, width: 1920 }),
                    this.hasAttribute("renderer") &&
                      ((i = this.getAttribute("renderer")),
                      (t = utils.styleParser.parse(i)),
                      t.antialias &&
                        "auto" !== t.antialias &&
                        (s.antialias = "true" === t.antialias),
                      (this.maxCanvasSize = {
                        width: t.maxCanvasWidth
                          ? parseInt(t.maxCanvasWidth)
                          : this.maxCanvasSize.width,
                        height: t.maxCanvasHeight
                          ? parseInt(t.maxCanvasHeight)
                          : this.maxCanvasSize.height,
                      })),
                    (e = this.renderer = new THREE.WebGLRenderer(s)),
                    (e.sortObjects = !1),
                    loadingScreen.setup(this, getCanvasSize);
                },
                writable: window.debug,
              },
              play: {
                value: function () {
                  var e = this,
                    t = this;
                  if (this.renderStarted)
                    return void AEntity.prototype.play.call(this);
                  this.addEventListener("loaded", function () {
                    AEntity.prototype.play.call(this),
                      t.renderStarted ||
                        (t.resize(),
                        t.renderer &&
                          (window.performance &&
                            window.performance.mark("render-started"),
                          (t.clock = new THREE.Clock()),
                          loadingScreen.remove(),
                          t.render(),
                          (t.renderStarted = !0),
                          t.emit("renderstart")));
                  }),
                    setTimeout(function () {
                      AEntity.prototype.load.call(e);
                    });
                },
              },
              updateComponent: {
                value: function (e) {
                  e in systems ||
                    AEntity.prototype.updateComponent.apply(this, arguments);
                },
              },
              tick: {
                value: function (e, t) {
                  var i,
                    s = this.systems;
                  for (i = 0; i < this.behaviors.tick.length; i++)
                    this.behaviors.tick[i].el.isPlaying &&
                      this.behaviors.tick[i].tick(e, t);
                  for (i = 0; i < this.systemNames.length; i++)
                    s[this.systemNames[i]].tick &&
                      s[this.systemNames[i]].tick(e, t);
                },
              },
              tock: {
                value: function (e, t, i) {
                  var s,
                    n = this.systems;
                  for (s = 0; s < this.behaviors.tock.length; s++)
                    this.behaviors.tock[s].el.isPlaying &&
                      this.behaviors.tock[s].tock(e, t, i);
                  for (s = 0; s < this.systemNames.length; s++)
                    n[this.systemNames[s]].tock &&
                      n[this.systemNames[s]].tock(e, t, i);
                },
              },
              render: {
                value: function () {
                  var e = this.renderer;
                  (this.delta = 1e3 * this.clock.getDelta()),
                    (this.time = 1e3 * this.clock.elapsedTime),
                    this.isPlaying && this.tick(this.time, this.delta),
                    e.setAnimationLoop(this.render),
                    e.render(this.object3D, this.camera, this.renderTarget);
                },
                writable: !0,
              },
            }),
          })),
            (module.exports.setupCanvas = setupCanvas);
        },
        {
          "../../lib/three": 150,
          "../../utils/": 173,
          "../a-entity": 97,
          "../a-node": 99,
          "../a-register-element": 100,
          "../system": 112,
          "./loadingScreen": 105,
          "./metaTags": 106,
          "./postMessage": 107,
          "./scenes": 108,
          "./wakelock": 109,
        },
      ],
      105: [
        function (_dereq_, module, exports) {
          function resize(e) {
            var t = getSceneCanvasSize(
              sceneEl.canvas,
              !1,
              sceneEl.maxCanvasSize,
              sceneEl.is("vr-mode")
            );
            (e.aspect = t.width / t.height),
              e.updateProjectionMatrix(),
              sceneEl.renderer.setSize(t.width, t.height, !1);
          }
          function setupTitle() {
            (titleEl = document.createElement("div")),
              (titleEl.className = LOADER_TITLE_CLASS),
              (titleEl.innerHTML = document.title),
              (titleEl.style.display = "none"),
              sceneEl.appendChild(titleEl);
          }
          var utils = _dereq_("../../utils/"),
            styleParser = utils.styleParser,
            sceneEl,
            titleEl,
            getSceneCanvasSize,
            ATTR_NAME = "loading-screen",
            LOADER_TITLE_CLASS = "a-loader-title";
          (module.exports.setup = function (e, t) {
            (sceneEl = e), (getSceneCanvasSize = t);
            var i,
              n,
              s,
              l,
              r,
              o,
              a,
              d,
              E,
              c,
              u = sceneEl.hasAttribute(ATTR_NAME)
                ? styleParser.parse(sceneEl.getAttribute(ATTR_NAME))
                : void 0,
              T = (u && u.dotsColor) || "white",
              v = (u && u.backgroundColor) || "#24CAFF",
              p = void 0 === u || !0 === u.enabled || void 0 === u.enabled;
            p &&
              ((i = new THREE.Scene()),
              (n = new THREE.SphereGeometry(
                0.2,
                36,
                18,
                0,
                2 * Math.PI,
                0,
                Math.PI
              )),
              (s = new THREE.MeshBasicMaterial({ color: T })),
              (l = new THREE.Mesh(n, s)),
              (r = l.clone()),
              (o = l.clone()),
              (a = new THREE.PerspectiveCamera(
                80,
                window.innerWidth / window.innerHeight,
                5e-4,
                1e4
              )),
              (d = new THREE.Clock()),
              (E = 0),
              (c = function () {
                sceneEl.renderer.render(i, a),
                  (E = d.getElapsedTime() % 4),
                  (l.visible = E >= 1),
                  (r.visible = E >= 2),
                  (o.visible = E >= 3);
              }),
              (i.background = new THREE.Color(v)),
              i.add(a),
              l.position.set(-1, 0, -15),
              r.position.set(0, 0, -15),
              o.position.set(1, 0, -15),
              a.add(l),
              a.add(r),
              a.add(o),
              setupTitle(),
              setTimeout(function () {
                sceneEl.hasLoaded ||
                  (resize(a),
                  (titleEl.style.display = "block"),
                  window.addEventListener("resize", function () {
                    resize(a);
                  }),
                  sceneEl.renderer.setAnimationLoop(c));
              }, 200));
          }),
            (module.exports.remove = function () {
              window.removeEventListener("resize", resize),
                titleEl && (titleEl.style.display = "none");
            });
        },
        { "../../utils/": 173 },
      ],
      106: [
        function (_dereq_, module, exports) {
          function Meta(e) {
            return {
              tagName: "meta",
              attributes: e,
              exists: function () {
                return document.querySelector('meta[name="' + e.name + '"]');
              },
            };
          }
          function Link(e) {
            return {
              tagName: "link",
              attributes: e,
              exists: function () {
                return document.querySelector('link[rel="' + e.rel + '"]');
              },
            };
          }
          function createTag(e) {
            if (e && e.tagName) {
              var t = document.createElement(e.tagName);
              return (
                t.setAttribute(constants.AFRAME_INJECTED, ""),
                extend(t, e.attributes)
              );
            }
          }
          var constants = _dereq_("../../constants/"),
            extend = _dereq_("../../utils").extend,
            MOBILE_HEAD_TAGS = (module.exports.MOBILE_HEAD_TAGS = [
              Meta({
                name: "viewport",
                content:
                  "width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui",
              }),
              Meta({ name: "mobile-web-app-capable", content: "yes" }),
              Meta({ name: "theme-color", content: "black" }),
            ]),
            MOBILE_IOS_HEAD_TAGS = [
              Meta({ name: "apple-mobile-web-app-capable", content: "yes" }),
              Meta({
                name: "apple-mobile-web-app-status-bar-style",
                content: "black",
              }),
              Link({
                rel: "apple-touch-icon",
                href: "https://aframe.io/images/aframe-logo-152.png",
              }),
            ];
          module.exports.inject = function (e) {
            function t(e) {
              e &&
                !e.exists() &&
                (a = createTag(e)) &&
                (r ? r.parentNode.insertBefore(a, r) : n.appendChild(a),
                i.push(a));
            }
            var a,
              n = document.head,
              r = n.querySelector("script"),
              i = [];
            return (
              MOBILE_HEAD_TAGS.forEach(t),
              e.isIOS && MOBILE_IOS_HEAD_TAGS.forEach(t),
              i
            );
          };
        },
        { "../../constants/": 93, "../../utils": 173 },
      ],
      107: [
        function (_dereq_, module, exports) {
          function postMessageAPIHandler(e) {
            var a = this;
            if (e.data)
              switch (e.data.type) {
                case "vr":
                  switch (e.data.data) {
                    case "enter":
                      a.enterVR();
                      break;
                    case "exit":
                      a.exitVR();
                  }
              }
          }
          var bind = _dereq_("../../utils/bind"),
            isIframed = _dereq_("../../utils/").isIframed;
          module.exports = function (e) {
            isIframed() &&
              window.addEventListener(
                "message",
                bind(postMessageAPIHandler, e)
              );
          };
        },
        { "../../utils/": 173, "../../utils/bind": 167 },
      ],
      108: [
        function (_dereq_, module, exports) {
          module.exports = [];
        },
        {},
      ],
      109: [
        function (_dereq_, module, exports) {
          var Wakelock = _dereq_("../../../vendor/wakelock/wakelock");
          module.exports = function (e) {
            if (e.isMobile) {
              var n = (e.wakelock = new Wakelock());
              e.addEventListener("enter-vr", function () {
                n.request();
              }),
                e.addEventListener("exit-vr", function () {
                  n.release();
                });
            }
          };
        },
        { "../../../vendor/wakelock/wakelock": 184 },
      ],
      110: [
        function (_dereq_, module, exports) {
          function isSingleProperty(r) {
            return "type" in r ? "string" == typeof r.type : "default" in r;
          }
          function processPropertyDefinition(r, e) {
            var t,
              o,
              n = r.default,
              p = r.type;
            return (
              r.type
                ? "bool" === r.type
                  ? (p = "boolean")
                  : "float" === r.type && (p = "number")
                : (p =
                    void 0 === n ||
                    ("boolean" != typeof n && "number" != typeof n)
                      ? Array.isArray(n)
                        ? "array"
                        : "string"
                      : typeof n),
              (o = propertyTypes[p]),
              o ||
                warn("Unknown property type for component `" + e + "`: " + p),
              (t = !!r.parse),
              (r.parse = r.parse || o.parse),
              (r.stringify = r.stringify || o.stringify),
              (r.type = p),
              "default" in r
                ? t ||
                  isValidDefaultValue(p, n) ||
                  warn(
                    "Default value `" +
                      n +
                      "` does not match type `" +
                      p +
                      "` in component `" +
                      e +
                      "`"
                  )
                : (r.default = o.default),
              r
            );
          }
          function parseProperty(r, e) {
            return (
              (void 0 !== r && null !== r && "" !== r) ||
                ((r = e.default), Array.isArray(r) && (r = r.slice())),
              e.parse(r, e.default)
            );
          }
          function stringifyProperty(r, e) {
            return "object" != typeof r
              ? r
              : e && null !== r
              ? e.stringify(r)
              : JSON.stringify(r);
          }
          var utils = _dereq_("../utils/"),
            PropertyTypes = _dereq_("./propertyTypes"),
            debug = utils.debug,
            isValidDefaultValue = PropertyTypes.isValidDefaultValue,
            propertyTypes = PropertyTypes.propertyTypes,
            warn = debug("core:schema:warn");
          (module.exports.isSingleProperty = isSingleProperty),
            (module.exports.process = function (r, e) {
              var t;
              if (isSingleProperty(r)) return processPropertyDefinition(r, e);
              for (t in r) r[t] = processPropertyDefinition(r[t], e);
              return r;
            }),
            (module.exports.processPropertyDefinition =
              processPropertyDefinition),
            (module.exports.parseProperties = (function () {
              var r = [];
              return function (e, t, o, n, p) {
                var i, s, y, u;
                r.length = 0;
                for (s in o ? e : t) (o && void 0 === e[s]) || r.push(s);
                if (null === e || "object" != typeof e) return e;
                for (s in e)
                  void 0 === e[s] ||
                    t[s] ||
                    p ||
                    warn(
                      "Unknown property `" +
                        s +
                        "` for component/system `" +
                        n +
                        "`."
                    );
                for (i = 0; i < r.length; i++) {
                  if (((s = r[i]), (y = t[s]), (u = e[s]), !t[s])) return;
                  e[s] = parseProperty(u, y);
                }
                return e;
              };
            })()),
            (module.exports.parseProperty = parseProperty),
            (module.exports.stringifyProperties = function (r, e) {
              var t,
                o,
                n,
                p,
                i = {};
              for (t in r)
                (o = e[t]),
                  (n = r[t]),
                  (p = n),
                  "object" == typeof p &&
                    ((p = stringifyProperty(n, o)),
                    o || warn("Unknown component property: " + t)),
                  (i[t] = p);
              return i;
            }),
            (module.exports.stringifyProperty = stringifyProperty);
        },
        { "../utils/": 173, "./propertyTypes": 103 },
      ],
      111: [
        function (_dereq_, module, exports) {
          var schema = _dereq_("./schema"),
            processSchema = schema.process,
            shaders = (module.exports.shaders = {}),
            shaderNames = (module.exports.shaderNames = []),
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils"),
            propertyToThreeMapping = {
              array: "v3",
              color: "v3",
              int: "i",
              number: "f",
              map: "t",
              time: "f",
              vec2: "v2",
              vec3: "v3",
              vec4: "v4",
            },
            Shader = (module.exports.Shader = function () {});
          (Shader.prototype = {
            schema: {},
            vertexShader:
              "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
            fragmentShader:
              "void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",
            init: function (e) {
              return (
                (this.attributes = this.initVariables(e, "attribute")),
                (this.uniforms = this.initVariables(e, "uniform")),
                (this.material = new (
                  this.raw ? THREE.RawShaderMaterial : THREE.ShaderMaterial
                )({
                  uniforms: this.uniforms,
                  vertexShader: this.vertexShader,
                  fragmentShader: this.fragmentShader,
                })),
                this.material
              );
            },
            initVariables: function (e, r) {
              var t,
                a,
                i = this.schema,
                s = {};
              for (t in i)
                i[t].is === r &&
                  ((a = propertyToThreeMapping[i[t].type]),
                  (s[t] = { type: a, value: void 0 }));
              return s;
            },
            update: function (e) {
              this.updateVariables(e, "attribute"),
                this.updateVariables(e, "uniform");
            },
            updateVariables: function (e, r) {
              var t,
                a,
                i,
                s = this.schema;
              i = "uniform" === r ? this.uniforms : this.attributes;
              for (t in e)
                if (s[t] && s[t].is === r)
                  if ("map" !== s[t].type)
                    (i[t].value = this.parseValue(s[t].type, e[t])),
                      (i[t].needsUpdate = !0);
                  else {
                    if (!i[t] || i[t].value === e[t]) continue;
                    (a = "_texture_" + t),
                      this.setMapOnTextureLoad(i, t, a),
                      utils.material.updateMapMaterialFromData(a, t, this, e);
                  }
            },
            parseValue: function (e, r) {
              var t;
              switch (e) {
                case "vec2":
                  return new THREE.Vector2(r.x, r.y);
                case "vec3":
                  return new THREE.Vector3(r.x, r.y, r.z);
                case "vec4":
                  return new THREE.Vector4(r.x, r.y, r.z, r.w);
                case "color":
                  return (
                    (t = new THREE.Color(r)), new THREE.Vector3(t.r, t.g, t.b)
                  );
                case "map":
                  return THREE.ImageUtils.loadTexture(r);
                default:
                  return r;
              }
            },
            setMapOnTextureLoad: function (e, r, t) {
              var a = this;
              this.el.addEventListener("materialtextureloaded", function () {
                (e[r].value = a.material[t]), (e[r].needsUpdate = !0);
              });
            },
          }),
            (module.exports.registerShader = function (e, r) {
              var t,
                a = {};
              if (
                (Object.keys(r).forEach(function (e) {
                  a[e] = { value: r[e], writable: !0 };
                }),
                shaders[e])
              )
                throw new Error(
                  "The shader " + e + " has been already registered"
                );
              return (
                (t = function () {
                  Shader.call(this);
                }),
                (t.prototype = Object.create(Shader.prototype, a)),
                (t.prototype.name = e),
                (t.prototype.constructor = t),
                (shaders[e] = {
                  Shader: t,
                  schema: processSchema(t.prototype.schema),
                }),
                shaderNames.push(e),
                t
              );
            });
        },
        { "../lib/three": 150, "../utils": 173, "./schema": 110 },
      ],
      112: [
        function (_dereq_, module, exports) {
          var components = _dereq_("./component"),
            schema = _dereq_("./schema"),
            utils = _dereq_("../utils/"),
            parseProperties = schema.parseProperties,
            parseProperty = schema.parseProperty,
            processSchema = schema.process,
            isSingleProp = schema.isSingleProperty,
            styleParser = utils.styleParser,
            systems = (module.exports.systems = {}),
            System = (module.exports.System = function (e) {
              var t = components && components.components[this.name];
              (this.el = e),
                (this.sceneEl = e),
                t && (t.Component.prototype.system = this),
                this.buildData(),
                this.init(),
                this.update({});
            });
          (System.prototype = {
            schema: {},
            init: function () {},
            update: function (e) {},
            updateProperties: function (e) {
              var t = this.data;
              Object.keys(schema).length && (this.buildData(e), this.update(t));
            },
            buildData: function (e) {
              var t = this.schema;
              Object.keys(t).length &&
                ((e =
                  e ||
                  window.HTMLElement.prototype.getAttribute.call(
                    this.sceneEl,
                    this.name
                  )),
                isSingleProp(t)
                  ? (this.data = parseProperty(e, t))
                  : (this.data = parseProperties(
                      styleParser.parse(e) || {},
                      t
                    )));
            },
            tick: void 0,
            tock: void 0,
            play: function () {},
            pause: function () {},
          }),
            (module.exports.registerSystem = function (e, t) {
              var s,
                o,
                r = {},
                i = utils.findAllScenes(document);
              if (
                (Object.keys(t).forEach(function (e) {
                  r[e] = { value: t[e], writable: !0 };
                }),
                systems[e])
              )
                throw new Error(
                  "The system `" +
                    e +
                    "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name."
                );
              for (
                o = function (e) {
                  System.call(this, e);
                },
                  o.prototype = Object.create(System.prototype, r),
                  o.prototype.name = e,
                  o.prototype.constructor = o,
                  o.prototype.schema = utils.extend(
                    processSchema(o.prototype.schema)
                  ),
                  systems[e] = o,
                  s = 0;
                s < i.length;
                s++
              )
                i[s].initSystem(e);
            });
        },
        { "../utils/": 173, "./component": 101, "./schema": 110 },
      ],
      113: [
        function (_dereq_, module, exports) {
          _dereq_("./pivot");
        },
        { "./pivot": 114 },
      ],
      114: [
        function (_dereq_, module, exports) {
          var registerComponent = _dereq_(
              "../../core/component"
            ).registerComponent,
            THREE = _dereq_("../../lib/three"),
            originalPosition = new THREE.Vector3(),
            originalRotation = new THREE.Vector3();
          registerComponent("pivot", {
            dependencies: ["position"],
            schema: { type: "vec3" },
            init: function () {
              var o = this.data,
                i = this.el,
                t = i.object3D.parent,
                e = i.object3D,
                n = new THREE.Group();
              originalPosition.copy(e.position),
                originalRotation.copy(e.rotation),
                t.remove(e),
                n.add(e),
                t.add(n),
                (i.object3D = n),
                e.position.set(-1 * o.x, -1 * o.y, -1 * o.z),
                n.position.set(
                  o.x + originalPosition.x,
                  o.y + originalPosition.y,
                  o.z + originalPosition.z
                ),
                n.rotation.copy(e.rotation),
                e.rotation.set(0, 0, 0);
            },
          });
        },
        { "../../core/component": 101, "../../lib/three": 150 },
      ],
      115: [
        function (_dereq_, module, exports) {
          function addMapping(e) {
            var a = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            "fog" === e && (a = "material-fog"),
              "visible" === e && (a = "material-visible"),
              (materialMappings[a] = "material." + e);
          }
          var components = _dereq_("../../core/component").components,
            shaders = _dereq_("../../core/shader").shaders,
            utils = _dereq_("../../utils/"),
            materialMappings = {};
          Object.keys(components.material.schema).forEach(addMapping),
            Object.keys(shaders.standard.schema).forEach(addMapping),
            (module.exports = function () {
              return {
                defaultComponents: { material: {} },
                mappings: utils.extend({}, materialMappings),
              };
            });
        },
        {
          "../../core/component": 101,
          "../../core/shader": 111,
          "../../utils/": 173,
        },
      ],
      116: [
        function (_dereq_, module, exports) {
          _dereq_("./primitives/a-camera"),
            _dereq_("./primitives/a-collada-model"),
            _dereq_("./primitives/a-cursor"),
            _dereq_("./primitives/a-curvedimage"),
            _dereq_("./primitives/a-gltf-model"),
            _dereq_("./primitives/a-image"),
            _dereq_("./primitives/a-light"),
            _dereq_("./primitives/a-link"),
            _dereq_("./primitives/a-obj-model"),
            _dereq_("./primitives/a-sky"),
            _dereq_("./primitives/a-sound"),
            _dereq_("./primitives/a-text"),
            _dereq_("./primitives/a-video"),
            _dereq_("./primitives/a-videosphere"),
            _dereq_("./primitives/meshPrimitives");
        },
        {
          "./primitives/a-camera": 118,
          "./primitives/a-collada-model": 119,
          "./primitives/a-cursor": 120,
          "./primitives/a-curvedimage": 121,
          "./primitives/a-gltf-model": 122,
          "./primitives/a-image": 123,
          "./primitives/a-light": 124,
          "./primitives/a-link": 125,
          "./primitives/a-obj-model": 126,
          "./primitives/a-sky": 127,
          "./primitives/a-sound": 128,
          "./primitives/a-text": 129,
          "./primitives/a-video": 130,
          "./primitives/a-videosphere": 131,
          "./primitives/meshPrimitives": 132,
        },
      ],
      117: [
        function (_dereq_, module, exports) {
          function addComponentMapping(e, t) {
            var i = components[e].schema;
            Object.keys(i).map(function (i) {
              var n = i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
              void 0 !== t[n] && (n = e + "-" + i), (t[n] = e + "." + i);
            });
          }
          function definePrimitive(e, t, i) {
            (i = i || {}),
              Object.keys(t).map(function (e) {
                addComponentMapping(e, i);
              }),
              module.exports.registerPrimitive(
                e,
                utils.extendDeep({}, null, {
                  defaultComponents: t,
                  mappings: i,
                })
              );
          }
          var AEntity = _dereq_("../../core/a-entity"),
            components = _dereq_("../../core/component").components,
            registerElement = _dereq_(
              "../../core/a-register-element"
            ).registerElement,
            utils = _dereq_("../../utils/"),
            debug = utils.debug,
            setComponentProperty = utils.entity.setComponentProperty,
            log = debug("extras:primitives:debug"),
            warn = debug("extras:primitives:warn"),
            primitives = (module.exports.primitives = {});
          (module.exports.registerPrimitive = function (e, t) {
            (e = e.toLowerCase()),
              log("Registering <%s>", e),
              t.defaultAttributes &&
                warn(
                  "The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead."
                );
            var i = registerElement(e, {
              prototype: Object.create(AEntity.prototype, {
                defaultComponentsFromPrimitive: {
                  value: t.defaultComponents || t.defaultAttributes || {},
                },
                deprecated: { value: t.deprecated || null },
                deprecatedMappings: { value: t.deprecatedMappings || {} },
                mappings: { value: t.mappings || {} },
                createdCallback: {
                  value: function () {
                    t.deprecated && console.warn(t.deprecated),
                      this.resolveMappingCollisions();
                  },
                },
                resolveMappingCollisions: {
                  value: function () {
                    var e = this.mappings,
                      t = this;
                    Object.keys(e).forEach(function (i) {
                      var n;
                      i !== i.toLowerCase() &&
                        warn(
                          "Mapping keys should be specified in lower case. The mapping key " +
                            i +
                            " may not be recognized"
                        ),
                        components[i] &&
                          ((n = e[i].replace(".", "-")),
                          (e[n] = e[i]),
                          delete e[i],
                          console.warn(
                            "The primitive " +
                              t.tagName.toLowerCase() +
                              " has a mapping collision. The attribute " +
                              i +
                              " has the same name as a registered component and has been renamed to " +
                              n
                          ));
                    });
                  },
                },
                getExtraComponents: {
                  value: function () {
                    function e(e, r) {
                      return t(e)
                        ? i(r)
                        : t(r)
                        ? i(e)
                        : n(e) && n(r)
                        ? utils.extendDeep(e, r)
                        : i(r);
                    }
                    function t(e) {
                      return void 0 === e;
                    }
                    function i(e) {
                      return n(e) ? utils.extendDeep({}, e) : e;
                    }
                    function n(e) {
                      return null !== e && e.constructor === Object;
                    }
                    var r,
                      o,
                      a,
                      s,
                      p,
                      u,
                      l = this;
                    for (
                      o = utils.clone(this.defaultComponentsFromPrimitive),
                        p = this.getAttribute("mixin"),
                        p &&
                          ((p = p.trim().split(" ")),
                          p.forEach(function (t) {
                            var i = l.sceneEl.querySelector(
                              "#" + t
                            ).componentCache;
                            Object.keys(i).forEach(function (t) {
                              o[t] = e(o[t], i[t]);
                            });
                          })),
                        a = 0;
                      a < this.attributes.length;
                      a++
                    )
                      (r = this.attributes[a]),
                        (s = this.mappings[r.name]) &&
                          ((u = utils.entity.getComponentPropertyPath(s)),
                          u.constructor === Array
                            ? ((o[u[0]] = o[u[0]] || {}),
                              (o[u[0]][u[1]] = r.value.trim()))
                            : (o[u] = r.value.trim()));
                    return o;
                  },
                },
                attributeChangedCallback: {
                  value: function (e, t, i) {
                    var n = this.mappings[e];
                    e in this.deprecatedMappings &&
                      console.warn(this.deprecatedMappings[e]),
                      e && n && setComponentProperty(this, n, i);
                  },
                },
              }),
            });
            return (primitives[e] = i), i;
          }),
            (module.exports.definePrimitive = definePrimitive);
        },
        {
          "../../core/a-entity": 97,
          "../../core/a-register-element": 100,
          "../../core/component": 101,
          "../../utils/": 173,
        },
      ],
      118: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-camera", {
            defaultComponents: {
              camera: {},
              "look-controls": {},
              "wasd-controls": {},
              position: { y: 1.6 },
            },
            mappings: {
              active: "camera.active",
              far: "camera.far",
              fov: "camera.fov",
              "look-controls-enabled": "look-controls.enabled",
              near: "camera.near",
              "pointer-lock-enabled": "look-controls.pointerLockEnabled",
              "wasd-controls-enabled": "wasd-controls.enabled",
              "reverse-mouse-drag": "look-controls.reverseMouseDrag",
              zoom: "camera.zoom",
            },
          });
        },
        { "../primitives": 117 },
      ],
      119: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-collada-model", {
            mappings: { src: "collada-model" },
          });
        },
        { "../primitives": 117 },
      ],
      120: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-cursor",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                cursor: {},
                geometry: {
                  primitive: "ring",
                  radiusOuter: 0.016,
                  radiusInner: 0.01,
                  segmentsTheta: 32,
                },
                material: { color: "#000", shader: "flat", opacity: 0.8 },
                position: { x: 0, y: 0, z: -1 },
              },
              mappings: {
                far: "raycaster.far",
                fuse: "cursor.fuse",
                "fuse-timeout": "cursor.fuseTimeout",
                interval: "raycaster.interval",
                objects: "raycaster.objects",
              },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      121: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-curvedimage",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: {
                  height: 1,
                  primitive: "cylinder",
                  radius: 2,
                  segmentsRadial: 48,
                  thetaLength: 270,
                  openEnded: !0,
                  thetaStart: 0,
                },
                material: {
                  color: "#FFF",
                  shader: "flat",
                  side: "double",
                  transparent: !0,
                  repeat: "-1 1",
                },
              },
              mappings: {
                height: "geometry.height",
                "open-ended": "geometry.openEnded",
                radius: "geometry.radius",
                segments: "geometry.segmentsRadial",
                start: "geometry.thetaStart",
                "theta-length": "geometry.thetaLength",
                "theta-start": "geometry.thetaStart",
                width: "geometry.thetaLength",
              },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      122: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-gltf-model", {
            mappings: { src: "gltf-model" },
          });
        },
        { "../primitives": 117 },
      ],
      123: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-image",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: { primitive: "plane" },
                material: {
                  color: "#FFF",
                  shader: "flat",
                  side: "double",
                  transparent: !0,
                },
              },
              mappings: { height: "geometry.height", width: "geometry.width" },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      124: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-light", {
            defaultComponents: { light: {} },
            mappings: {
              angle: "light.angle",
              color: "light.color",
              "ground-color": "light.groundColor",
              decay: "light.decay",
              distance: "light.distance",
              intensity: "light.intensity",
              penumbra: "light.penumbra",
              type: "light.type",
              target: "light.target",
            },
          });
        },
        { "../primitives": 117 },
      ],
      125: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-link", {
            defaultComponents: { link: { visualAspectEnabled: !0 } },
            mappings: {
              href: "link.href",
              image: "link.image",
              title: "link.title",
            },
          });
        },
        { "../primitives": 117 },
      ],
      126: [
        function (_dereq_, module, exports) {
          var meshMixin = _dereq_("../getMeshMixin")(),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-obj-model",
            utils.extendDeep({}, meshMixin, {
              defaultComponents: { "obj-model": {} },
              mappings: { src: "obj-model.obj", mtl: "obj-model.mtl" },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      127: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/"),
            meshPrimitives = _dereq_("./meshPrimitives");
          registerPrimitive(
            "a-sky",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: {
                  primitive: "sphere",
                  radius: 5e3,
                  segmentsWidth: 64,
                  segmentsHeight: 32,
                },
                material: {
                  color: "#FFF",
                  side: "back",
                  shader: "flat",
                  npot: !0,
                },
                scale: "-1 1 1",
              },
              mappings: utils.extendDeep(
                {},
                meshPrimitives["a-sphere"].prototype.mappings
              ),
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
          "./meshPrimitives": 132,
        },
      ],
      128: [
        function (_dereq_, module, exports) {
          var registerPrimitive = _dereq_("../primitives").registerPrimitive;
          registerPrimitive("a-sound", {
            defaultComponents: { sound: {} },
            mappings: {
              src: "sound.src",
              on: "sound.on",
              autoplay: "sound.autoplay",
              loop: "sound.loop",
              volume: "sound.volume",
            },
          });
        },
        { "../primitives": 117 },
      ],
      129: [
        function (_dereq_, module, exports) {
          var definePrimitive = _dereq_("../primitives").definePrimitive;
          definePrimitive("a-text", { text: { anchor: "align", width: 5 } });
        },
        { "../primitives": 117 },
      ],
      130: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-video",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: { primitive: "plane" },
                material: {
                  color: "#FFF",
                  shader: "flat",
                  side: "double",
                  transparent: !0,
                },
              },
              mappings: { height: "geometry.height", width: "geometry.width" },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      131: [
        function (_dereq_, module, exports) {
          var getMeshMixin = _dereq_("../getMeshMixin"),
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/");
          registerPrimitive(
            "a-videosphere",
            utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: {
                  primitive: "sphere",
                  radius: 5e3,
                  segmentsWidth: 64,
                  segmentsHeight: 32,
                },
                material: {
                  color: "#FFF",
                  shader: "flat",
                  side: "back",
                  npot: !0,
                },
                scale: "-1 1 1",
              },
              mappings: {
                radius: "geometry.radius",
                "segments-height": "geometry.segmentsHeight",
                "segments-width": "geometry.segmentsWidth",
              },
            })
          );
        },
        {
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      132: [
        function (_dereq_, module, exports) {
          function unCamelCase(e) {
            return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          }
          var getMeshMixin = _dereq_("../getMeshMixin"),
            geometries = _dereq_("../../../core/geometry").geometries,
            geometryNames = _dereq_("../../../core/geometry").geometryNames,
            registerPrimitive = _dereq_("../primitives").registerPrimitive,
            utils = _dereq_("../../../utils/"),
            meshPrimitives = (module.exports = {});
          geometryNames.forEach(function (e) {
            var i = geometries[e],
              r = unCamelCase(e),
              t = {};
            Object.keys(i.schema).forEach(function (e) {
              t[unCamelCase(e)] = "geometry." + e;
            });
            var m = "a-" + r,
              s = registerPrimitive(
                m,
                utils.extendDeep({}, getMeshMixin(), {
                  defaultComponents: { geometry: { primitive: e } },
                  mappings: t,
                })
              );
            meshPrimitives[m] = s;
          });
        },
        {
          "../../../core/geometry": 102,
          "../../../utils/": 173,
          "../getMeshMixin": 115,
          "../primitives": 117,
        },
      ],
      133: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("box", {
            schema: {
              depth: { default: 1, min: 0 },
              height: { default: 1, min: 0 },
              width: { default: 1, min: 0 },
              segmentsHeight: { default: 1, min: 1, max: 20, type: "int" },
              segmentsWidth: { default: 1, min: 1, max: 20, type: "int" },
              segmentsDepth: { default: 1, min: 1, max: 20, type: "int" },
            },
            init: function (e) {
              this.geometry = new THREE.BoxGeometry(
                e.width,
                e.height,
                e.depth,
                e.segmentsWidth,
                e.segmentsHeight,
                e.segmentsDepth
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      134: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("circle", {
            schema: {
              radius: { default: 1, min: 0 },
              segments: { default: 32, min: 3, type: "int" },
              thetaLength: { default: 360, min: 0 },
              thetaStart: { default: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.CircleGeometry(
                e.radius,
                e.segments,
                degToRad(e.thetaStart),
                degToRad(e.thetaLength)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      135: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("cone", {
            schema: {
              height: { default: 1, min: 0 },
              openEnded: { default: !1 },
              radiusBottom: { default: 1, min: 0 },
              radiusTop: { default: 0.01, min: 0 },
              segmentsHeight: { default: 18, min: 1, type: "int" },
              segmentsRadial: { default: 36, min: 3, type: "int" },
              thetaLength: { default: 360, min: 0 },
              thetaStart: { default: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.CylinderGeometry(
                e.radiusTop,
                e.radiusBottom,
                e.height,
                e.segmentsRadial,
                e.segmentsHeight,
                e.openEnded,
                degToRad(e.thetaStart),
                degToRad(e.thetaLength)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      136: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("cylinder", {
            schema: {
              height: { default: 1, min: 0 },
              openEnded: { default: !1 },
              radius: { default: 1, min: 0 },
              segmentsHeight: { default: 18, min: 1, type: "int" },
              segmentsRadial: { default: 36, min: 3, type: "int" },
              thetaLength: { default: 360, min: 0 },
              thetaStart: { default: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.CylinderGeometry(
                e.radius,
                e.radius,
                e.height,
                e.segmentsRadial,
                e.segmentsHeight,
                e.openEnded,
                degToRad(e.thetaStart),
                degToRad(e.thetaLength)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      137: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("dodecahedron", {
            schema: {
              detail: { default: 0, min: 0, max: 5, type: "int" },
              radius: { default: 1, min: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.DodecahedronGeometry(
                e.radius,
                e.detail
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      138: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("icosahedron", {
            schema: {
              detail: { default: 0, min: 0, max: 5, type: "int" },
              radius: { default: 1, min: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.IcosahedronGeometry(e.radius, e.detail);
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      139: [
        function (_dereq_, module, exports) {
          _dereq_("./box.js"),
            _dereq_("./circle.js"),
            _dereq_("./cone.js"),
            _dereq_("./cylinder.js"),
            _dereq_("./dodecahedron.js"),
            _dereq_("./icosahedron.js"),
            _dereq_("./octahedron.js"),
            _dereq_("./plane.js"),
            _dereq_("./ring.js"),
            _dereq_("./sphere.js"),
            _dereq_("./tetrahedron.js"),
            _dereq_("./torus.js"),
            _dereq_("./torusKnot.js"),
            _dereq_("./triangle.js");
        },
        {
          "./box.js": 133,
          "./circle.js": 134,
          "./cone.js": 135,
          "./cylinder.js": 136,
          "./dodecahedron.js": 137,
          "./icosahedron.js": 138,
          "./octahedron.js": 140,
          "./plane.js": 141,
          "./ring.js": 142,
          "./sphere.js": 143,
          "./tetrahedron.js": 144,
          "./torus.js": 145,
          "./torusKnot.js": 146,
          "./triangle.js": 147,
        },
      ],
      140: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("octahedron", {
            schema: {
              detail: { default: 0, min: 0, max: 5, type: "int" },
              radius: { default: 1, min: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.OctahedronGeometry(e.radius, e.detail);
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      141: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("plane", {
            schema: {
              height: { default: 1, min: 0 },
              width: { default: 1, min: 0 },
              segmentsHeight: { default: 1, min: 1, max: 20, type: "int" },
              segmentsWidth: { default: 1, min: 1, max: 20, type: "int" },
            },
            init: function (e) {
              this.geometry = new THREE.PlaneGeometry(
                e.width,
                e.height,
                e.segmentsWidth,
                e.segmentsHeight
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      142: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("ring", {
            schema: {
              radiusInner: { default: 0.8, min: 0 },
              radiusOuter: { default: 1.2, min: 0 },
              segmentsPhi: { default: 10, min: 1, type: "int" },
              segmentsTheta: { default: 32, min: 3, type: "int" },
              thetaLength: { default: 360, min: 0 },
              thetaStart: { default: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.RingGeometry(
                e.radiusInner,
                e.radiusOuter,
                e.segmentsTheta,
                e.segmentsPhi,
                degToRad(e.thetaStart),
                degToRad(e.thetaLength)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      143: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("sphere", {
            schema: {
              radius: { default: 1, min: 0 },
              phiLength: { default: 360 },
              phiStart: { default: 0, min: 0 },
              thetaLength: { default: 180, min: 0 },
              thetaStart: { default: 0 },
              segmentsHeight: { default: 18, min: 2, type: "int" },
              segmentsWidth: { default: 36, min: 3, type: "int" },
            },
            init: function (e) {
              this.geometry = new THREE.SphereGeometry(
                e.radius,
                e.segmentsWidth,
                e.segmentsHeight,
                degToRad(e.phiStart),
                degToRad(e.phiLength),
                degToRad(e.thetaStart),
                degToRad(e.thetaLength)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      144: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("tetrahedron", {
            schema: {
              detail: { default: 0, min: 0, max: 5, type: "int" },
              radius: { default: 1, min: 0 },
            },
            init: function (e) {
              this.geometry = new THREE.TetrahedronGeometry(e.radius, e.detail);
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      145: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            degToRad = THREE.Math.degToRad;
          registerGeometry("torus", {
            schema: {
              arc: { default: 360 },
              radius: { default: 1, min: 0 },
              radiusTubular: { default: 0.2, min: 0 },
              segmentsRadial: { default: 36, min: 2, type: "int" },
              segmentsTubular: { default: 32, min: 3, type: "int" },
            },
            init: function (e) {
              this.geometry = new THREE.TorusGeometry(
                e.radius,
                2 * e.radiusTubular,
                e.segmentsRadial,
                e.segmentsTubular,
                degToRad(e.arc)
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      146: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three");
          registerGeometry("torusKnot", {
            schema: {
              p: { default: 2, min: 1 },
              q: { default: 3, min: 1 },
              radius: { default: 1, min: 0 },
              radiusTubular: { default: 0.2, min: 0 },
              segmentsRadial: { default: 8, min: 3, type: "int" },
              segmentsTubular: { default: 100, min: 3, type: "int" },
            },
            init: function (e) {
              this.geometry = new THREE.TorusKnotGeometry(
                e.radius,
                2 * e.radiusTubular,
                e.segmentsTubular,
                e.segmentsRadial,
                e.p,
                e.q
              );
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      147: [
        function (_dereq_, module, exports) {
          var registerGeometry = _dereq_("../core/geometry").registerGeometry,
            THREE = _dereq_("../lib/three"),
            quaternion = new THREE.Quaternion(),
            rotateVector = new THREE.Vector3(0, 0, 1),
            uvMinVector = new THREE.Vector2(),
            uvMaxVector = new THREE.Vector2(),
            uvScaleVector = new THREE.Vector2();
          registerGeometry("triangle", {
            schema: {
              vertexA: { type: "vec3", default: { x: 0, y: 0.5, z: 0 } },
              vertexB: { type: "vec3", default: { x: -0.5, y: -0.5, z: 0 } },
              vertexC: { type: "vec3", default: { x: 0.5, y: -0.5, z: 0 } },
            },
            init: function (e) {
              var t, r, o, c, n, a;
              (o = new THREE.Triangle()),
                o.a.set(e.vertexA.x, e.vertexA.y, e.vertexA.z),
                o.b.set(e.vertexB.x, e.vertexB.y, e.vertexB.z),
                o.c.set(e.vertexC.x, e.vertexC.y, e.vertexC.z),
                (r = o.getNormal(new THREE.Vector3())),
                quaternion.setFromUnitVectors(r, rotateVector),
                (c = o.a.clone().applyQuaternion(quaternion)),
                (n = o.b.clone().applyQuaternion(quaternion)),
                (a = o.c.clone().applyQuaternion(quaternion)),
                uvMinVector.set(
                  Math.min(c.x, n.x, a.x),
                  Math.min(c.y, n.y, a.y)
                ),
                uvMaxVector.set(
                  Math.max(c.x, n.x, a.x),
                  Math.max(c.y, n.y, a.y)
                ),
                uvScaleVector.set(0, 0).subVectors(uvMaxVector, uvMinVector),
                (c = new THREE.Vector2()
                  .subVectors(c, uvMinVector)
                  .divide(uvScaleVector)),
                (n = new THREE.Vector2()
                  .subVectors(n, uvMinVector)
                  .divide(uvScaleVector)),
                (a = new THREE.Vector2()
                  .subVectors(a, uvMinVector)
                  .divide(uvScaleVector)),
                (t = this.geometry = new THREE.Geometry()),
                t.vertices.push(o.a),
                t.vertices.push(o.b),
                t.vertices.push(o.c),
                t.faces.push(new THREE.Face3(0, 1, 2, r)),
                (t.faceVertexUvs[0] = [[c, n, a]]);
            },
          });
        },
        { "../core/geometry": 102, "../lib/three": 150 },
      ],
      148: [
        function (_dereq_, module, exports) {
          (window.Promise = window.Promise || _dereq_("promise-polyfill")),
            window.vrDisabled
              ? (window.hasNativeWebVRImplementation = !1)
              : (window.hasNativeWebVRImplementation =
                  !!window.navigator.getVRDisplays ||
                  !!window.navigator.getVRDevices);
          var isIOSOlderThan10 = _dereq_("./utils/isIOSOlderThan10"),
            bufferScale = isIOSOlderThan10(window.navigator.userAgent)
              ? 1 / window.devicePixelRatio
              : 1,
            utils = _dereq_("./utils/"),
            debug = utils.debug,
            error = debug("A-Frame:error"),
            warn = debug("A-Frame:warn");
          window.document.currentScript &&
            window.document.currentScript.parentNode !== window.document.head &&
            !window.debug &&
            warn(
              "Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."
            ),
            "file:" === window.location.protocol &&
              error(
                "This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/0.5.0/introduction/getting-started.html#using-a-local-server."
              ),
            _dereq_("present"),
            utils.device.isBrowserEnvironment &&
              (_dereq_("./style/aframe.css"), _dereq_("./style/rStats.css"));
          var AScene = _dereq_("./core/scene/a-scene").AScene,
            components = _dereq_("./core/component").components,
            registerComponent = _dereq_("./core/component").registerComponent,
            registerGeometry = _dereq_("./core/geometry").registerGeometry,
            registerPrimitive = _dereq_(
              "./extras/primitives/primitives"
            ).registerPrimitive,
            registerShader = _dereq_("./core/shader").registerShader,
            registerSystem = _dereq_("./core/system").registerSystem,
            shaders = _dereq_("./core/shader").shaders,
            systems = _dereq_("./core/system").systems,
            THREE = (window.THREE = _dereq_("./lib/three")),
            pkg = _dereq_("../package");
          _dereq_("./components/index"),
            _dereq_("./geometries/index"),
            _dereq_("./shaders/index"),
            _dereq_("./systems/index");
          var ANode = _dereq_("./core/a-node"),
            AEntity = _dereq_("./core/a-entity");
          _dereq_("./core/a-assets"),
            _dereq_("./core/a-cubemap"),
            _dereq_("./core/a-mixin"),
            _dereq_("./extras/components/"),
            _dereq_("./extras/primitives/"),
            console.log(
              "A-Frame Version: 0.8.2 (Date 2019-11-22, Commit #358c5da5)"
            ),
            console.log("three Version:", pkg.dependencies.three),
            (module.exports = window.AFRAME =
              {
                AComponent: _dereq_("./core/component").Component,
                AEntity: AEntity,
                ANode: ANode,
                ANIME: _dereq_("animejs"),
                AScene: AScene,
                components: components,
                geometries: _dereq_("./core/geometry").geometries,
                registerComponent: registerComponent,
                registerElement: _dereq_("./core/a-register-element")
                  .registerElement,
                registerGeometry: registerGeometry,
                registerPrimitive: registerPrimitive,
                registerShader: registerShader,
                registerSystem: registerSystem,
                primitives: {
                  getMeshMixin: _dereq_("./extras/primitives/getMeshMixin"),
                  primitives: _dereq_("./extras/primitives/primitives")
                    .primitives,
                },
                scenes: _dereq_("./core/scene/scenes"),
                schema: _dereq_("./core/schema"),
                shaders: shaders,
                systems: systems,
                THREE: THREE,
                utils: utils,
                version: pkg.version,
              });
        },
        {
          "../package": 50,
          "./components/index": 60,
          "./core/a-assets": 95,
          "./core/a-cubemap": 96,
          "./core/a-entity": 97,
          "./core/a-mixin": 98,
          "./core/a-node": 99,
          "./core/a-register-element": 100,
          "./core/component": 101,
          "./core/geometry": 102,
          "./core/scene/a-scene": 104,
          "./core/scene/scenes": 108,
          "./core/schema": 110,
          "./core/shader": 111,
          "./core/system": 112,
          "./extras/components/": 113,
          "./extras/primitives/": 116,
          "./extras/primitives/getMeshMixin": 115,
          "./extras/primitives/primitives": 117,
          "./geometries/index": 139,
          "./lib/three": 150,
          "./shaders/index": 152,
          "./style/aframe.css": 157,
          "./style/rStats.css": 158,
          "./systems/index": 162,
          "./utils/": 173,
          "./utils/isIOSOlderThan10": 174,
          animejs: 2,
          present: 31,
          "promise-polyfill": 32,
        },
      ],
      149: [
        function (_dereq_, module, exports) {
          (window.aframeStats = function (t) {
            function e() {
              i("te").set(n()),
                window.performance.getEntriesByName &&
                  i("lt").set(
                    window.performance
                      .getEntriesByName("render-started")[0]
                      .startTime.toFixed(0)
                  );
            }
            function n() {
              var t = c.querySelectorAll("*");
              return (
                Array.prototype.slice.call(t).filter(function (t) {
                  return t.isEntity;
                }),
                t.length
              );
            }
            function r() {}
            function a() {}
            function o(t) {
              i = t;
            }
            var i = null,
              c = t;
            return {
              update: e,
              start: r,
              end: a,
              attach: o,
              values: {
                te: { caption: "Entities" },
                lt: { caption: "Load Time" },
              },
              groups: [{ caption: "A-Frame", values: ["te", "lt"] }],
              fractions: [],
            };
          }),
            "object" == typeof module &&
              (module.exports = { aframeStats: window.aframeStats });
        },
        {},
      ],
      150: [
        function (_dereq_, module, exports) {
          (function (global) {
            var THREE = (global.THREE = _dereq_("three"));
            THREE.TextureLoader &&
              (THREE.TextureLoader.prototype.crossOrigin = "anonymous"),
              THREE.ImageLoader &&
                (THREE.ImageLoader.prototype.crossOrigin = "anonymous"),
              THREE.Cache && (THREE.Cache.enabled = !0),
              _dereq_("three/examples/js/loaders/DRACOLoader"),
              _dereq_("three/examples/js/loaders/GLTFLoader"),
              _dereq_("three/examples/js/loaders/OBJLoader"),
              _dereq_("three/examples/js/loaders/MTLLoader"),
              _dereq_("three/examples/js/loaders/ColladaLoader"),
              (THREE.ColladaLoader.prototype.crossOrigin = "anonymous"),
              (THREE.GLTFLoader.prototype.crossOrigin = "anonymous"),
              (THREE.MTLLoader.prototype.crossOrigin = "anonymous"),
              (THREE.OBJLoader.prototype.crossOrigin = "anonymous"),
              (module.exports = THREE);
          }.call(
            this,
            typeof global !== "undefined"
              ? global
              : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
              ? window
              : {}
          ));
        },
        {
          three: 38,
          "three/examples/js/loaders/ColladaLoader": 39,
          "three/examples/js/loaders/DRACOLoader": 40,
          "three/examples/js/loaders/GLTFLoader": 41,
          "three/examples/js/loaders/MTLLoader": 42,
          "three/examples/js/loaders/OBJLoader": 43,
        },
      ],
      151: [
        function (_dereq_, module, exports) {
          function getMaterialData(e, a) {
            return (
              a.color.set(e.color),
              (a.fog = e.fog),
              (a.wireframe = e.wireframe),
              (a.wireframeLinewidth = e.wireframeLinewidth),
              a
            );
          }
          var registerShader = _dereq_("../core/shader").registerShader,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/");
          module.exports.Shader = registerShader("flat", {
            schema: {
              color: { type: "color" },
              fog: { default: !0 },
              height: { default: 256 },
              offset: { type: "vec2", default: { x: 0, y: 0 } },
              repeat: { type: "vec2", default: { x: 1, y: 1 } },
              src: { type: "map" },
              width: { default: 512 },
              wireframe: { default: !1 },
              wireframeLinewidth: { default: 2 },
            },
            init: function (e) {
              (this.materialData = { color: new THREE.Color() }),
                (this.textureSrc = null),
                getMaterialData(e, this.materialData),
                (this.material = new THREE.MeshBasicMaterial(
                  this.materialData
                )),
                utils.material.updateMap(this, e);
            },
            update: function (e) {
              this.updateMaterial(e), utils.material.updateMap(this, e);
            },
            updateMaterial: function (e) {
              var a;
              getMaterialData(e, this.materialData);
              for (a in this.materialData)
                this.material[a] = this.materialData[a];
            },
          });
        },
        { "../core/shader": 111, "../lib/three": 150, "../utils/": 173 },
      ],
      152: [
        function (_dereq_, module, exports) {
          _dereq_("./flat"),
            _dereq_("./standard"),
            _dereq_("./sdf"),
            _dereq_("./msdf"),
            _dereq_("./ios10hls");
        },
        {
          "./flat": 151,
          "./ios10hls": 153,
          "./msdf": 154,
          "./sdf": 155,
          "./standard": 156,
        },
      ],
      153: [
        function (_dereq_, module, exports) {
          var registerShader = _dereq_("../core/shader").registerShader;
          module.exports.Shader = registerShader("ios10hls", {
            schema: {
              src: { type: "map", is: "uniform" },
              opacity: { type: "number", is: "uniform", default: 1 },
            },
            vertexShader: [
              "varying vec2 vUV;",
              "void main(void) {",
              "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
              "  vUV = uv;",
              "}",
            ].join("\n"),
            fragmentShader: [
              "uniform sampler2D src;",
              "uniform float opacity;",
              "varying vec2 vUV;",
              "void main() {",
              "  vec2 offset = vec2(0, 0);",
              "  vec2 repeat = vec2(1, 1);",
              "  vec4 color = texture2D(src, vec2(vUV.x / repeat.x + offset.x, (1.0 - vUV.y) / repeat.y + offset.y)).bgra;",
              "  gl_FragColor = vec4(color.rgb, opacity);",
              "}",
            ].join("\n"),
          });
        },
        { "../core/shader": 111 },
      ],
      154: [
        function (_dereq_, module, exports) {
          var registerShader = _dereq_("../core/shader").registerShader;
          module.exports.Shader = registerShader("msdf", {
            schema: {
              alphaTest: { type: "number", is: "uniform", default: 0.5 },
              color: { type: "color", is: "uniform", default: "white" },
              map: { type: "map", is: "uniform" },
              negate: { type: "boolean", is: "uniform", default: !0 },
              opacity: { type: "number", is: "uniform", default: 1 },
            },
            raw: !0,
            vertexShader: [
              "attribute vec2 uv;",
              "attribute vec3 position;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 modelViewMatrix;",
              "varying vec2 vUV;",
              "void main(void) {",
              "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
              "  vUV = uv;",
              "}",
            ].join("\n"),
            fragmentShader: [
              "#ifdef GL_OES_standard_derivatives",
              "#extension GL_OES_standard_derivatives: enable",
              "#endif",
              "precision highp float;",
              "uniform bool negate;",
              "uniform float alphaTest;",
              "uniform float opacity;",
              "uniform sampler2D map;",
              "uniform vec3 color;",
              "varying vec2 vUV;",
              "float median(float r, float g, float b) {",
              "  return max(min(r, g), min(max(r, g), b));",
              "}",
              "#define BIG_ENOUGH 0.001",
              "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
              "void main() {",
              "  vec3 sample = texture2D(map, vUV).rgb;",
              "  if (negate) { sample = 1.0 - sample; }",
              "  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;",
              "  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);",
              "  float dscale = 0.353505;",
              "  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));",
              "  float isBigEnough = max(abs(duv.x), abs(duv.y));",
              "  // Do modified alpha test.",
              "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
              "  gl_FragColor = vec4(color.xyz, alpha * opacity);",
              "}",
            ].join("\n"),
          });
        },
        { "../core/shader": 111 },
      ],
      155: [
        function (_dereq_, module, exports) {
          var registerShader = _dereq_("../core/shader").registerShader;
          module.exports.Shader = registerShader("sdf", {
            schema: {
              alphaTest: { type: "number", is: "uniform", default: 0.5 },
              color: { type: "color", is: "uniform", default: "white" },
              map: { type: "map", is: "uniform" },
              opacity: { type: "number", is: "uniform", default: 1 },
            },
            raw: !0,
            vertexShader: [
              "attribute vec2 uv;",
              "attribute vec3 position;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 modelViewMatrix;",
              "varying vec2 vUV;",
              "void main(void) {",
              "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
              "  vUV = uv;",
              "}",
            ].join("\n"),
            fragmentShader: [
              "#ifdef GL_OES_standard_derivatives",
              "#extension GL_OES_standard_derivatives: enable",
              "#endif",
              "precision highp float;",
              "uniform float alphaTest;",
              "uniform float opacity;",
              "uniform sampler2D map;",
              "uniform vec3 color;",
              "varying vec2 vUV;",
              "#ifdef GL_OES_standard_derivatives",
              "  float contour(float width, float value) {",
              "    return smoothstep(0.5 - value, 0.5 + value, width);",
              "  }",
              "#else",
              "  float aastep(float value, float afwidth) {",
              "    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);",
              "  }",
              "#endif",
              "#define BIG_ENOUGH 0.001",
              "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
              "#define ALL_SMOOTH 0.4",
              "#define ALL_ROUGH 0.02",
              "#define DISCARD_ALPHA (alphaTest / (2.2 - 1.2 * ratio))",
              "void main() {",
              "  #ifdef GL_OES_standard_derivatives",
              "    vec2 uv = vUV;",
              "    vec4 texColor = texture2D(map, uv);",
              "    float dist = texColor.a;",
              "    float width = fwidth(dist);",
              "    float alpha = contour(dist, width);",
              "    float dscale = 0.353505;",
              "    vec2 duv = dscale * (dFdx(uv) + dFdy(uv));",
              "    float isBigEnough = max(abs(duv.x), abs(duv.y));",
              "    if (isBigEnough <= BIG_ENOUGH) {",
              "      vec4 box = vec4 (uv - duv, uv + duv);",
              "      alpha = (alpha + 0.5 * (",
              "        contour(texture2D(map, box.xy).a, width)",
              "        + contour(texture2D(map, box.zw).a, width)",
              "        + contour(texture2D(map, box.xw).a, width)",
              "        + contour(texture2D(map, box.zy).a, width)",
              "      )) / 3.0;",
              "    }",
              "    if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
              "  #else",
              "    vec4 texColor = texture2D(map, vUV);",
              "    float value = texColor.a;",
              "    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));",
              "    float alpha = aastep(value, afwidth);",
              "    float ratio = (gl_FragCoord.w >= ALL_SMOOTH) ? 1.0 : (gl_FragCoord.w < ALL_ROUGH) ? 0.0 : (gl_FragCoord.w - ALL_ROUGH) / (ALL_SMOOTH - ALL_ROUGH);",
              "    if (alpha < alphaTest) { if (ratio >= 1.0) { discard; return; } alpha = 0.0; }",
              "    alpha = alpha * ratio + (1.0 - ratio) * value;",
              "    if (ratio < 1.0 && alpha <= DISCARD_ALPHA) { discard; return; }",
              "  #endif",
              "  gl_FragColor = vec4(color, opacity * alpha);",
              "}",
            ].join("\n"),
          });
        },
        { "../core/shader": 111 },
      ],
      156: [
        function (_dereq_, module, exports) {
          function getMaterialData(e, t) {
            return (
              t.color.set(e.color),
              t.emissive.set(e.emissive),
              (t.emissiveIntensity = e.emissiveIntensity),
              (t.fog = e.fog),
              (t.metalness = e.metalness),
              (t.roughness = e.roughness),
              (t.wireframe = e.wireframe),
              (t.wireframeLinewidth = e.wireframeLinewidth),
              e.normalMap && (t.normalScale = e.normalScale),
              e.ambientOcclusionMap &&
                (t.aoMapIntensity = e.ambientOcclusionMapIntensity),
              e.displacementMap &&
                ((t.displacementScale = e.displacementScale),
                (t.displacementBias = e.displacementBias)),
              t
            );
          }
          var registerShader = _dereq_("../core/shader").registerShader,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            CubeLoader = new THREE.CubeTextureLoader(),
            texturePromises = {};
          module.exports.Shader = registerShader("standard", {
            schema: {
              ambientOcclusionMap: { type: "map" },
              ambientOcclusionMapIntensity: { default: 1 },
              ambientOcclusionTextureOffset: { type: "vec2" },
              ambientOcclusionTextureRepeat: {
                type: "vec2",
                default: { x: 1, y: 1 },
              },
              color: { type: "color" },
              displacementMap: { type: "map" },
              displacementScale: { default: 1 },
              displacementBias: { default: 0.5 },
              displacementTextureOffset: { type: "vec2" },
              displacementTextureRepeat: {
                type: "vec2",
                default: { x: 1, y: 1 },
              },
              emissive: { type: "color", default: "#000" },
              emissiveIntensity: { default: 1 },
              envMap: { default: "" },
              fog: { default: !0 },
              height: { default: 256 },
              metalness: { default: 0, min: 0, max: 1 },
              metalnessMap: { type: "map" },
              metalnessTextureOffset: { type: "vec2" },
              metalnessTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
              normalMap: { type: "map" },
              normalScale: { type: "vec2", default: { x: 1, y: 1 } },
              normalTextureOffset: { type: "vec2" },
              normalTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
              offset: { type: "vec2", default: { x: 0, y: 0 } },
              repeat: { type: "vec2", default: { x: 1, y: 1 } },
              roughness: { default: 0.5, min: 0, max: 1 },
              roughnessMap: { type: "map" },
              roughnessTextureOffset: { type: "vec2" },
              roughnessTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
              sphericalEnvMap: { type: "map" },
              src: { type: "map" },
              width: { default: 512 },
              wireframe: { default: !1 },
              wireframeLinewidth: { default: 2 },
            },
            init: function (e) {
              (this.materialData = {
                color: new THREE.Color(),
                emissive: new THREE.Color(),
              }),
                getMaterialData(e, this.materialData),
                (this.material = new THREE.MeshStandardMaterial(
                  this.materialData
                )),
                utils.material.updateMap(this, e),
                e.normalMap &&
                  utils.material.updateDistortionMap("normal", this, e),
                e.displacementMap &&
                  utils.material.updateDistortionMap("displacement", this, e),
                e.ambientOcclusionMap &&
                  utils.material.updateDistortionMap(
                    "ambientOcclusion",
                    this,
                    e
                  ),
                e.metalnessMap &&
                  utils.material.updateDistortionMap("metalness", this, e),
                e.roughnessMap &&
                  utils.material.updateDistortionMap("roughness", this, e),
                this.updateEnvMap(e);
            },
            update: function (e) {
              this.updateMaterial(e),
                utils.material.updateMap(this, e),
                e.normalMap &&
                  utils.material.updateDistortionMap("normal", this, e),
                e.displacementMap &&
                  utils.material.updateDistortionMap("displacement", this, e),
                e.ambientOcclusionMap &&
                  utils.material.updateDistortionMap(
                    "ambientOcclusion",
                    this,
                    e
                  ),
                e.metalnessMap &&
                  utils.material.updateDistortionMap("metalness", this, e),
                e.roughnessMap &&
                  utils.material.updateDistortionMap("roughness", this, e),
                this.updateEnvMap(e);
            },
            updateMaterial: function (e) {
              var t,
                a = this.material;
              getMaterialData(e, this.materialData);
              for (t in this.materialData) a[t] = this.materialData[t];
            },
            updateEnvMap: function (e) {
              var t = this,
                a = this.material,
                i = e.envMap,
                s = e.sphericalEnvMap;
              return (!i && !s) || this.isLoadingEnvMap
                ? ((a.envMap = null), void (a.needsUpdate = !0))
                : ((this.isLoadingEnvMap = !0),
                  s
                    ? void this.el.sceneEl.systems.material.loadTexture(
                        s,
                        { src: s },
                        function (e) {
                          (t.isLoadingEnvMap = !1),
                            (e.mapping = THREE.SphericalReflectionMapping),
                            (a.envMap = e),
                            utils.material.handleTextureEvents(t.el, e),
                            (a.needsUpdate = !0);
                        }
                      )
                    : texturePromises[i]
                    ? void texturePromises[i].then(function (e) {
                        (t.isLoadingEnvMap = !1),
                          (a.envMap = e),
                          utils.material.handleTextureEvents(t.el, e),
                          (a.needsUpdate = !0);
                      })
                    : void (texturePromises[i] = new Promise(function (e) {
                        utils.srcLoader.validateCubemapSrc(i, function (i) {
                          CubeLoader.load(i, function (i) {
                            (t.isLoadingEnvMap = !1),
                              (a.envMap = i),
                              utils.material.handleTextureEvents(t.el, i),
                              e(i);
                          });
                        });
                      })));
            },
          });
        },
        { "../core/shader": 111, "../lib/three": 150, "../utils/": 173 },
      ],
      157: [
        function (_dereq_, module, exports) {
          var css =
            "html.a-fullscreen{bottom:0;left:0;position:fixed;right:0;top:0}html.a-fullscreen body{height:100%;margin:0;overflow:hidden;padding:0;width:100%}html.a-fullscreen .a-canvas{width:100%!important;height:100%!important;top:0!important;left:0!important;right:0!important;bottom:0!important;position:fixed!important}html:not(.a-fullscreen) .a-enter-vr{right:5px;bottom:5px}:-webkit-full-screen{background-color:transparent}.a-hidden{display:none!important}.a-canvas{height:100%;left:0;position:absolute;top:0;width:100%}.a-canvas.a-grab-cursor:hover{cursor:grab;cursor:-moz-grab;cursor:-webkit-grab}.a-inspector-loader{background-color:#ed3160;position:fixed;left:3px;top:3px;padding:6px 10px;color:#fff;text-decoration:none;font-size:12px;font-family:Roboto,sans-serif;text-align:center;z-index:99999;width:204px}@keyframes dots-1{from{opacity:0}25%{opacity:1}}@keyframes dots-2{from{opacity:0}50%{opacity:1}}@keyframes dots-3{from{opacity:0}75%{opacity:1}}@-webkit-keyframes dots-1{from{opacity:0}25%{opacity:1}}@-webkit-keyframes dots-2{from{opacity:0}50%{opacity:1}}@-webkit-keyframes dots-3{from{opacity:0}75%{opacity:1}}.a-inspector-loader .dots span{animation:dots-1 2s infinite steps(1);-webkit-animation:dots-1 2s infinite steps(1)}.a-inspector-loader .dots span:first-child+span{animation-name:dots-2;-webkit-animation-name:dots-2}.a-inspector-loader .dots span:first-child+span+span{animation-name:dots-3;-webkit-animation-name:dots-3}a-scene{display:block;position:relative;height:100%;width:100%}a-assets,a-scene audio,a-scene img,a-scene video{display:none}.a-enter-vr-modal,.a-orientation-modal{font-family:Consolas,Andale Mono,Courier New,monospace}.a-enter-vr-modal a{border-bottom:1px solid #fff;padding:2px 0;text-decoration:none;transition:.1s color ease-in}.a-enter-vr-modal a:hover{background-color:#fff;color:#111;padding:2px 4px;position:relative;left:-4px}.a-enter-vr{font-family:sans-serif,monospace;font-size:13px;width:100%;font-weight:200;line-height:16px;position:absolute;right:20px;bottom:20px}.a-enter-vr-button,.a-enter-vr-modal,.a-enter-vr-modal a{color:#fff}.a-enter-vr-button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E) 50% 50%/70% 70% no-repeat rgba(0,0,0,.35);border:0;bottom:0;cursor:pointer;min-width:50px;min-height:30px;padding-right:5%;padding-top:4%;position:absolute;right:0;transition:background-color .05s ease;-webkit-transition:background-color .05s ease;z-index:9999}.a-enter-vr-button:active,.a-enter-vr-button:hover{background-color:#666}[data-a-enter-vr-no-webvr] .a-enter-vr-button{border-color:#666;opacity:.65}[data-a-enter-vr-no-webvr] .a-enter-vr-button:active,[data-a-enter-vr-no-webvr] .a-enter-vr-button:hover{background-color:rgba(0,0,0,.35);cursor:not-allowed}.a-enter-vr-modal{background-color:#666;border-radius:0;display:none;min-height:32px;margin-right:70px;padding:9px;width:280px;right:2%;position:absolute}.a-enter-vr-modal:after{border-bottom:10px solid transparent;border-left:10px solid #666;border-top:10px solid transparent;display:inline-block;content:'';position:absolute;right:-5px;top:5px;width:0;height:0}.a-enter-vr-modal a,.a-enter-vr-modal p{display:inline}.a-enter-vr-modal p{margin:0}.a-enter-vr-modal p:after{content:' '}[data-a-enter-vr-no-headset].a-enter-vr:hover .a-enter-vr-modal,[data-a-enter-vr-no-webvr].a-enter-vr:hover .a-enter-vr-modal{display:block}.a-orientation-modal{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center/50% 50% no-repeat rgba(244,244,244,1);bottom:0;font-size:14px;font-weight:600;left:0;line-height:20px;right:0;position:fixed;top:0;z-index:9999999}.a-orientation-modal:after{color:#666;content:\"Insert phone into Cardboard holder.\";display:block;position:absolute;text-align:center;top:70%;transform:translateY(-70%);width:100%}.a-orientation-modal button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;border:none;height:50px;text-indent:-9999px;width:50px}.a-loader-title{background-color:rgba(0,0,0,.6);font-family:sans-serif,monospace;text-align:center;font-size:20px;height:50px;font-weight:300;line-height:50px;position:absolute;right:0;left:0;top:0;color:#fff}";
          _dereq_("browserify-css").createStyle(css, {
            href: "src/style/aframe.css",
          });
          module.exports = css;
        },
        { "browserify-css": 5 },
      ],
      158: [
        function (_dereq_, module, exports) {
          var css =
            ".rs-base{background-color:#333;color:#fafafa;border-radius:0;font:10px monospace;left:5px;line-height:1em;opacity:.85;overflow:hidden;padding:10px;position:fixed;top:5px;width:300px;z-index:10000}.rs-base div.hidden{display:none}.rs-base h1{color:#fff;cursor:pointer;font-size:1.4em;font-weight:300;margin:0 0 5px;padding:0}.rs-group{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-direction:column-reverse;flex-direction:column-reverse;margin-bottom:5px}.rs-group:last-child{margin-bottom:0}.rs-counter-base{align-items:center;display:-webkit-box;display:-webkit-flex;display:flex;height:10px;-webkit-justify-content:space-between;justify-content:space-between;margin:2px 0}.rs-counter-base.alarm{color:#b70000;text-shadow:0 0 0 #b70000,0 0 1px #fff,0 0 1px #fff,0 0 2px #fff,0 0 2px #fff,0 0 3px #fff,0 0 3px #fff,0 0 4px #fff,0 0 4px #fff}.rs-counter-id{font-weight:300;-webkit-box-ordinal-group:0;-webkit-order:0;order:0;width:54px}.rs-counter-value{font-weight:300;-webkit-box-ordinal-group:1;-webkit-order:1;order:1;text-align:right;width:35px}.rs-canvas{-webkit-box-ordinal-group:2;-webkit-order:2;order:2}@media (min-width:480px){.rs-base{left:20px;top:20px}}";
          _dereq_("browserify-css").createStyle(css, {
            href: "src/style/rStats.css",
          });
          module.exports = css;
        },
        { "browserify-css": 5 },
      ],
      159: [
        function (_dereq_, module, exports) {
          function removeDefaultCamera(e) {
            var t;
            e.camera &&
              (t = e.querySelector("[" + DEFAULT_CAMERA_ATTR + "]")) &&
              e.removeChild(t);
          }
          var constants = _dereq_("../constants/"),
            registerSystem = _dereq_("../core/system").registerSystem,
            DEFAULT_CAMERA_ATTR = "data-aframe-default-camera";
          module.exports.System = registerSystem("camera", {
            init: function () {
              (this.activeCameraEl = null),
                (this.render = this.render.bind(this)),
                (this.unwrapRender = this.unwrapRender.bind(this)),
                (this.wrapRender = this.wrapRender.bind(this)),
                (this.initialCameraFound = !1),
                (this.numUserCameras = 0),
                (this.numUserCamerasChecked = 0),
                this.setupInitialCamera();
            },
            setupInitialCamera: function () {
              var e,
                t,
                a = this.sceneEl,
                r = this;
              if (a.camera && !a.camera.el.getAttribute("camera").spectator)
                return void a.emit("cameraready", { cameraEl: a.camera.el });
              if (((e = a.querySelectorAll("a-camera, [camera]")), !e.length))
                return void this.createDefaultCamera();
              for (this.numUserCameras = e.length, t = 0; t < e.length; t++)
                e[t].addEventListener("object3dset", function (e) {
                  "camera" === e.detail.type && r.checkUserCamera(this);
                }),
                  e[t].isNode
                    ? e[t].load()
                    : e[t].addEventListener("nodeready", function () {
                        this.load();
                      });
            },
            checkUserCamera: function (e) {
              var t,
                a = this.el.sceneEl;
              if ((this.numUserCamerasChecked++, !this.initialCameraFound)) {
                if (((t = e.getAttribute("camera")), !t.active || t.spectator))
                  return void (
                    this.numUserCamerasChecked === this.numUserCameras &&
                    this.createDefaultCamera()
                  );
                (this.initialCameraFound = !0),
                  (a.camera = e.getObject3D("camera")),
                  a.emit("cameraready", { cameraEl: e });
              }
            },
            createDefaultCamera: function () {
              var e,
                t = this.sceneEl;
              (e = document.createElement("a-entity")),
                e.setAttribute("camera", { active: !0 }),
                e.setAttribute("position", {
                  x: 0,
                  y: constants.DEFAULT_CAMERA_HEIGHT,
                  z: 0,
                }),
                e.setAttribute("wasd-controls", ""),
                e.setAttribute("look-controls", ""),
                e.setAttribute(constants.AFRAME_INJECTED, ""),
                e.addEventListener("object3dset", function (a) {
                  "camera" === a.detail.type &&
                    ((t.camera = a.detail.object),
                    t.emit("cameraready", { cameraEl: e }));
                }),
                t.appendChild(e),
                e.load();
            },
            disableActiveCamera: function () {
              var e, t;
              (e = this.sceneEl.querySelectorAll("[camera]")),
                (t = e[e.length - 1]),
                t.setAttribute("camera", "active", !0);
            },
            setActiveCamera: function (e) {
              var t,
                a,
                r,
                i,
                s = this.activeCameraEl,
                n = this.sceneEl;
              if ((i = e.getObject3D("camera")) && e !== this.activeCameraEl) {
                var c = n.querySelector("[" + DEFAULT_CAMERA_ATTR + "]"),
                  m = c && c.querySelector("[camera]");
                for (
                  e !== m && removeDefaultCamera(n),
                    this.activeCameraEl = e,
                    this.activeCameraEl.play(),
                    n.camera = i,
                    s && s.setAttribute("camera", "active", !1),
                    a = n.querySelectorAll("[camera]"),
                    r = 0;
                  r < a.length;
                  r++
                )
                  (t = a[r]),
                    t.isEntity &&
                      e !== t &&
                      (t.setAttribute("camera", "active", !1), t.pause());
                n.emit("camera-set-active", { cameraEl: e });
              }
            },
            setSpectatorCamera: function (e) {
              var t,
                a,
                r = this.spectatorCameraEl,
                i = this.sceneEl;
              (t = e.getObject3D("camera")) &&
                e !== this.spectatorCameraEl &&
                (r && r.setAttribute("camera", "spectator", !1),
                (a = this.spectatorCameraEl = e),
                i.addEventListener("enter-vr", this.wrapRender),
                i.addEventListener("exit-vr", this.unwrapRender),
                a.setAttribute("camera", "active", !1),
                a.play(),
                i.emit("camera-set-spectator", { cameraEl: e }));
            },
            disableSpectatorCamera: function () {
              this.spectatorCameraEl = void 0;
            },
            wrapRender: function () {
              this.spectatorCameraEl &&
                ((this.originalRender = this.sceneEl.renderer.render),
                (this.sceneEl.renderer.render = this.render));
            },
            unwrapRender: function () {
              this.originalRender &&
                ((this.sceneEl.renderer.render = this.originalRender),
                (this.originalRender = void 0));
            },
            render: function (e, t, a) {
              var r,
                i,
                s = this.sceneEl;
              (r = s.renderer.vr.enabled),
                this.originalRender.call(s.renderer, e, t, a),
                this.spectatorCameraEl &&
                  !s.isMobile &&
                  r &&
                  ((i = this.spectatorCameraEl.components.camera.camera),
                  (s.renderer.vr.enabled = !1),
                  this.originalRender.call(s.renderer, e, i),
                  (s.renderer.vr.enabled = r));
            },
          });
        },
        { "../constants/": 93, "../core/system": 112 },
      ],
      160: [
        function (_dereq_, module, exports) {
          function createGeometry(e) {
            var t = e.primitive,
              r = geometries[t] && geometries[t].Geometry,
              o = new r();
            if (!r) throw new Error("Unknown geometry `" + t + "`");
            return o.init(e), toBufferGeometry(o.geometry, e.buffer);
          }
          function decrementCacheCount(e, t) {
            e[t]--;
          }
          function incrementCacheCount(e, t) {
            e[t] = void 0 === e[t] ? 1 : e[t] + 1;
          }
          function toBufferGeometry(e, t) {
            var r;
            return t
              ? ((r = new THREE.BufferGeometry().fromGeometry(e)),
                (r.metadata = { type: e.type, parameters: e.parameters || {} }),
                e.dispose(),
                r)
              : e;
          }
          var geometries = _dereq_("../core/geometry").geometries,
            registerSystem = _dereq_("../core/system").registerSystem,
            THREE = _dereq_("../lib/three");
          module.exports.System = registerSystem("geometry", {
            init: function () {
              (this.cache = {}), (this.cacheCount = {});
            },
            clearCache: function () {
              (this.cache = {}), (this.cacheCount = {});
            },
            getOrCreateGeometry: function (e) {
              var t,
                r,
                o = this.cache;
              return e.skipCache
                ? createGeometry(e)
                : ((r = this.hash(e)),
                  (t = o[r]),
                  incrementCacheCount(this.cacheCount, r),
                  t || ((t = createGeometry(e)), (o[r] = t), t));
            },
            unuseGeometry: function (e) {
              var t,
                r,
                o = this.cache,
                i = this.cacheCount;
              e.skipCache ||
                ((r = this.hash(e)),
                o[r] &&
                  (decrementCacheCount(i, r),
                  i[r] > 0 ||
                    ((t = o[r]), t.dispose(), delete o[r], delete i[r])));
            },
            hash: function (e) {
              return JSON.stringify(e);
            },
          });
        },
        { "../core/geometry": 102, "../core/system": 112, "../lib/three": 150 },
      ],
      161: [
        function (_dereq_, module, exports) {
          var registerSystem = _dereq_("../core/system").registerSystem,
            THREE = _dereq_("../lib/three");
          module.exports.System = registerSystem("gltf-model", {
            schema: { dracoDecoderPath: { default: "" } },
            init: function () {
              var e = this.data.dracoDecoderPath;
              THREE.DRACOLoader.setDecoderPath(e),
                (this.dracoLoader = e ? new THREE.DRACOLoader() : null);
            },
            getDRACOLoader: function () {
              return this.dracoLoader;
            },
          });
        },
        { "../core/system": 112, "../lib/three": 150 },
      ],
      162: [
        function (_dereq_, module, exports) {
          _dereq_("./camera"),
            _dereq_("./geometry"),
            _dereq_("./gltf-model"),
            _dereq_("./light"),
            _dereq_("./material"),
            _dereq_("./shadow"),
            _dereq_("./tracked-controls");
        },
        {
          "./camera": 159,
          "./geometry": 160,
          "./gltf-model": 161,
          "./light": 163,
          "./material": 164,
          "./shadow": 165,
          "./tracked-controls": 166,
        },
      ],
      163: [
        function (_dereq_, module, exports) {
          var registerSystem = _dereq_("../core/system").registerSystem,
            bind = _dereq_("../utils/bind"),
            constants = _dereq_("../constants/"),
            DEFAULT_LIGHT_ATTR = "data-aframe-default-light";
          module.exports.System = registerSystem("light", {
            schema: { defaultLightsEnabled: { default: !0 } },
            init: function () {
              (this.defaultLights = !1),
                (this.userDefinedLights = !1),
                this.sceneEl.addEventListener(
                  "loaded",
                  bind(this.setupDefaultLights, this)
                );
            },
            registerLight: function (t) {
              t.hasAttribute(DEFAULT_LIGHT_ATTR) ||
                (this.removeDefaultLights(), (this.userDefinedLights = !0));
            },
            removeDefaultLights: function () {
              var t,
                e = this.sceneEl;
              if (this.defaultLights) {
                t = document.querySelectorAll("[" + DEFAULT_LIGHT_ATTR + "]");
                for (var i = 0; i < t.length; i++) e.removeChild(t[i]);
                this.defaultLights = !1;
              }
            },
            setupDefaultLights: function () {
              var t,
                e,
                i = this.sceneEl;
              this.userDefinedLights ||
                this.defaultLights ||
                !this.data.defaultLightsEnabled ||
                ((t = document.createElement("a-entity")),
                t.setAttribute("light", { color: "#BBB", type: "ambient" }),
                t.setAttribute(DEFAULT_LIGHT_ATTR, ""),
                t.setAttribute(constants.AFRAME_INJECTED, ""),
                i.appendChild(t),
                (e = document.createElement("a-entity")),
                e.setAttribute("light", {
                  color: "#FFF",
                  intensity: 0.6,
                  castShadow: !0,
                }),
                e.setAttribute("position", { x: -0.5, y: 1, z: 1 }),
                e.setAttribute(DEFAULT_LIGHT_ATTR, ""),
                e.setAttribute(constants.AFRAME_INJECTED, ""),
                i.appendChild(e),
                (this.defaultLights = !0));
            },
          });
        },
        { "../constants/": 93, "../core/system": 112, "../utils/bind": 167 },
      ],
      164: [
        function (_dereq_, module, exports) {
          function calculateVideoCacheHash(e, t) {
            var r,
              i,
              n,
              a = t.getAttribute("id");
            if (a) return a;
            for (i = "", n = e || {}, r = 0; r < t.attributes.length; r++)
              n[t.attributes[r].name] = t.attributes[r].value;
            return (
              Object.keys(n)
                .sort()
                .forEach(function (e) {
                  i += e + ":" + n[e] + ";";
                }),
              i
            );
          }
          function loadImageTexture(e, t) {
            function r(r, i) {
              function n(e) {
                setTextureProperties(e, t), (e.needsUpdate = !0), r(e);
              }
              if ("string" != typeof e) return void n(new THREE.Texture(e));
              TextureLoader.load(
                e,
                n,
                function () {},
                function (e) {
                  error(
                    "`$s` could not be fetched (Error code: %s; Response: %s)",
                    e.status,
                    e.statusText
                  );
                }
              );
            }
            return new Promise(r);
          }
          function setTextureProperties(e, t) {
            var r = t.offset || { x: 0, y: 0 },
              i = t.repeat || { x: 1, y: 1 };
            (t.npot || !1) &&
              ((e.wrapS = THREE.ClampToEdgeWrapping),
              (e.wrapT = THREE.ClampToEdgeWrapping),
              (e.magFilter = THREE.LinearFilter),
              (e.minFilter = THREE.LinearFilter)),
              (1 === i.x && 1 === i.y) ||
                ((e.wrapS = THREE.RepeatWrapping),
                (e.wrapT = THREE.RepeatWrapping),
                e.repeat.set(i.x, i.y)),
              (0 === r.x && 0 === r.y) || e.offset.set(r.x, r.y);
          }
          function createVideoEl(e, t, r) {
            var i = document.createElement("video");
            return (
              (i.width = t),
              (i.height = r),
              i.setAttribute("playsinline", ""),
              i.setAttribute("webkit-playsinline", ""),
              (i.autoplay = !0),
              (i.loop = !0),
              (i.crossOrigin = "anonymous"),
              i.addEventListener(
                "error",
                function () {
                  warn("`$s` is not a valid video", e);
                },
                !0
              ),
              (i.src = e),
              i
            );
          }
          function fixVideoAttributes(e) {
            return (
              (e.autoplay =
                e.hasAttribute("autoplay") &&
                "false" !== e.getAttribute("autoplay")),
              (e.controls =
                e.hasAttribute("controls") &&
                "false" !== e.getAttribute("controls")),
              "false" === e.getAttribute("loop") && e.removeAttribute("loop"),
              "false" === e.getAttribute("preload") && (e.preload = "none"),
              (e.crossOrigin = e.crossOrigin || "anonymous"),
              e.setAttribute("playsinline", ""),
              e.setAttribute("webkit-playsinline", ""),
              e
            );
          }
          var registerSystem = _dereq_("../core/system").registerSystem,
            THREE = _dereq_("../lib/three"),
            utils = _dereq_("../utils/"),
            isHLS = _dereq_("../utils/material").isHLS,
            bind = utils.bind,
            debug = utils.debug,
            error = debug("components:texture:error"),
            TextureLoader = new THREE.TextureLoader(),
            warn = debug("components:texture:warn");
          TextureLoader.setCrossOrigin("anonymous"),
            (module.exports.System = registerSystem("material", {
              init: function () {
                (this.materials = {}),
                  (this.textureCounts = {}),
                  (this.textureCache = {}),
                  this.sceneEl.addEventListener(
                    "materialtextureloaded",
                    bind(this.onMaterialTextureLoaded, this)
                  );
              },
              clearTextureCache: function () {
                this.textureCache = {};
              },
              loadTexture: function (e, t, r) {
                function i(e) {
                  a.loadImage(e, t, r);
                }
                function n(e) {
                  a.loadVideo(e, t, r);
                }
                var a = this;
                return "CANVAS" === e.tagName
                  ? void this.loadCanvas(e, t, r)
                  : "VIDEO" === e.tagName
                  ? (e.src ||
                      e.srcObject ||
                      e.childElementCount ||
                      warn(
                        "Video element was defined with neither `source` elements nor `src` / `srcObject` attributes."
                      ),
                    void this.loadVideo(e, t, r))
                  : void utils.srcLoader.validateSrc(e, i, n);
              },
              loadImage: function (e, t, r) {
                var i = this.hash(t),
                  n = this.textureCache;
                if (n[i]) return void n[i].then(r);
                (n[i] = loadImageTexture(e, t)), n[i].then(r);
              },
              loadCanvas: function (e, t, r) {
                var i;
                (i = new THREE.CanvasTexture(e)),
                  setTextureProperties(i, t),
                  r(i);
              },
              loadVideo: function (e, t, r) {
                function i(e) {
                  (e.texture.needsUpdate = !0), r(e.texture, e.videoEl);
                }
                var n,
                  a,
                  s,
                  o,
                  u = this.textureCache;
                if ("string" != typeof e) {
                  if (((s = e), (n = this.hashVideo(t, s)), u[n]))
                    return void u[n].then(i);
                  fixVideoAttributes(s);
                }
                if (
                  ((s = s || createVideoEl(e, t.width, t.height)),
                  (n = this.hashVideo(t, s)),
                  u[n])
                )
                  return void u[n].then(i);
                (a = new THREE.VideoTexture(s)),
                  (a.minFilter = THREE.LinearFilter),
                  setTextureProperties(a, t),
                  this.sceneEl.isIOS &&
                    isHLS(
                      s.src || s.getAttribute("src"),
                      s.type || s.getAttribute("type")
                    ) &&
                    ((a.format = THREE.RGBAFormat),
                    (a.needsCorrectionBGRA = !0),
                    (a.flipY = !1),
                    (a.needsCorrectionFlipY = !0)),
                  (o = { texture: a, videoEl: s }),
                  (u[n] = Promise.resolve(o)),
                  i(o);
              },
              hash: function (e) {
                return (
                  e.src.tagName &&
                    ((e = utils.extendDeep({}, e)), (e.src = e.src.src)),
                  JSON.stringify(e)
                );
              },
              hashVideo: function (e, t) {
                return calculateVideoCacheHash(e, t);
              },
              registerMaterial: function (e) {
                this.materials[e.uuid] = e;
              },
              unregisterMaterial: function (e) {
                delete this.materials[e.uuid];
                var t = this.textureCounts;
                Object.keys(e)
                  .filter(function (t) {
                    return e[t] && e[t].isTexture;
                  })
                  .forEach(function (r) {
                    --t[e[r].uuid] <= 0 && e[r].dispose();
                  });
              },
              updateMaterials: function (e) {
                var t = this.materials;
                Object.keys(t).forEach(function (e) {
                  t[e].needsUpdate = !0;
                });
              },
              onMaterialTextureLoaded: function (e) {
                this.textureCounts[e.detail.texture.uuid] ||
                  (this.textureCounts[e.detail.texture.uuid] = 0),
                  this.textureCounts[e.detail.texture.uuid]++;
              },
            }));
        },
        {
          "../core/system": 112,
          "../lib/three": 150,
          "../utils/": 173,
          "../utils/material": 175,
        },
      ],
      165: [
        function (_dereq_, module, exports) {
          var registerSystem = _dereq_("../core/system").registerSystem,
            THREE = _dereq_("../lib/three"),
            SHADOW_MAP_TYPE_MAP = {
              basic: THREE.BasicShadowMap,
              pcf: THREE.PCFShadowMap,
              pcfsoft: THREE.PCFSoftShadowMap,
            };
          module.exports.System = registerSystem("shadow", {
            schema: {
              autoUpdate: { default: !0 },
              type: { default: "pcf", oneOf: ["basic", "pcf", "pcfsoft"] },
            },
            init: function () {
              var e = this.sceneEl,
                a = this.data;
              (this.shadowMapEnabled = !1),
                e.renderer &&
                  ((e.renderer.shadowMap.type = SHADOW_MAP_TYPE_MAP[a.type]),
                  (e.renderer.shadowMap.autoUpdate = a.autoUpdate),
                  this.setShadowMapEnabled(this.shadowMapEnabled));
            },
            setShadowMapEnabled: function (e) {
              var a = this.sceneEl.renderer;
              (this.shadowMapEnabled = e), a && (a.shadowMap.enabled = e);
            },
          });
        },
        { "../core/system": 112, "../lib/three": 150 },
      ],
      166: [
        function (_dereq_, module, exports) {
          var registerSystem = _dereq_("../core/system").registerSystem,
            utils = _dereq_("../utils");
          module.exports.System = registerSystem("tracked-controls", {
            init: function () {
              var t = this;
              (this.controllers = []),
                this.updateControllerList(),
                (this.throttledUpdateControllerList = utils.throttle(
                  this.updateControllerList,
                  500,
                  this
                )),
                window.vrDisabled ||
                  (navigator.getVRDisplays &&
                    this.sceneEl.addEventListener("enter-vr", function () {
                      navigator.getVRDisplays().then(function (e) {
                        e.length && (t.vrDisplay = e[0]);
                      });
                    }));
            },
            tick: function () {
              window.vrDisabled ||
                (-1 !== navigator.userAgent.indexOf("Chrome") &&
                  navigator.getGamepads &&
                  navigator.getGamepads(),
                this.throttledUpdateControllerList());
            },
            updateControllerList: function () {
              var t,
                e,
                r,
                i,
                s = this.controllers;
              if (
                !window.vrDisabled &&
                (e = navigator.getGamepads && navigator.getGamepads())
              ) {
                for (i = s.length, s.length = 0, r = 0; r < e.length; ++r)
                  (t = e[r]) && t.pose && s.push(t);
                s.length !== i &&
                  this.el.emit("controllersupdated", void 0, !1);
              }
            },
          });
        },
        { "../core/system": 112, "../utils": 173 },
      ],
      167: [
        function (_dereq_, module, exports) {
          module.exports = function (r, t) {
            return (function (n) {
              return function () {
                var o = n.concat(Array.prototype.slice.call(arguments, 0));
                return r.apply(t, o);
              };
            })(Array.prototype.slice.call(arguments, 2));
          };
        },
        {},
      ],
      168: [
        function (_dereq_, module, exports) {
          function parse(e, r) {
            var t, o;
            if (e && e instanceof Object) {
              var i = void 0 === e.x ? r && r.x : e.x,
                n = void 0 === e.y ? r && r.y : e.y,
                s = void 0 === e.z ? r && r.z : e.z,
                d = void 0 === e.w ? r && r.w : e.w;
              return (
                void 0 !== i && (e.x = parseIfString(i)),
                void 0 !== n && (e.y = parseIfString(n)),
                void 0 !== s && (e.z = parseIfString(s)),
                void 0 !== d && (e.w = parseIfString(d)),
                e
              );
            }
            return null === e || void 0 === e
              ? "object" == typeof r
                ? extend({}, r)
                : r
              : ((t = e.trim().split(/\s+/g)),
                (o = {}),
                COORDINATE_KEYS.forEach(function (e, i) {
                  if (t[i]) o[e] = parseFloat(t[i], 10);
                  else {
                    var n = r && r[e];
                    if (void 0 === n) return;
                    o[e] = parseIfString(n);
                  }
                }),
                o);
          }
          function stringify(e) {
            return "object" != typeof e
              ? e
              : [e.x, e.y, e.z, e.w].join(" ").trim();
          }
          function isCoordinates(e) {
            return regex.test(e);
          }
          function parseIfString(e) {
            return e.constructor === String ? parseFloat(e, 10) : e;
          }
          var debug = _dereq_("./debug"),
            extend = _dereq_("object-assign"),
            warn = debug("utils:coordinates:warn"),
            COORDINATE_KEYS = ["x", "y", "z", "w"],
            regex =
              /^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/;
          (module.exports.regex = regex),
            (module.exports.parse = parse),
            (module.exports.stringify = stringify),
            (module.exports.isCoordinates = isCoordinates),
            (module.exports.isCoordinate = function (e) {
              return (
                warn(
                  "`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"
                ),
                isCoordinates(e)
              );
            }),
            (module.exports.toVector3 = function (e) {
              return new THREE.Vector3(e.x, e.y, e.z);
            });
        },
        { "./debug": 169, "object-assign": 25 },
      ],
      169: [
        function (_dereq_, module, exports) {
          (function (process) {
            function getDebugNamespaceType(e) {
              var r = e.split(":");
              return r[r.length - 1];
            }
            function getDebugNamespaceColor(e) {
              var r = getDebugNamespaceType(e);
              return (settings.colors && settings.colors[r]) || null;
            }
            function storage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
            var debugLib = _dereq_("debug"),
              extend = _dereq_("object-assign"),
              settings = {
                colors: {
                  debug: "gray",
                  error: "red",
                  info: "gray",
                  warn: "orange",
                },
              },
              debug = function (e) {
                var r = debugLib(e);
                return (r.color = getDebugNamespaceColor(e)), r;
              };
            extend(debug, debugLib);
            var ls = storage();
            ls && (parseInt(ls.logs, 10) || "true" === ls.logs)
              ? debug.enable("*")
              : debug.enable("*:error,*:info,*:warn"),
              process.browser && (window.logs = debug),
              (module.exports = debug);
          }.call(this, _dereq_("_process")));
        },
        { _process: 6, debug: 10, "object-assign": 25 },
      ],
      170: [
        function (_dereq_, module, exports) {
          (function (process) {
            function getVRDisplay() {
              return vrDisplay;
            }
            function checkHeadsetConnected() {
              return !!getVRDisplay();
            }
            function checkHasPositionalTracking() {
              var i = getVRDisplay();
              return (
                !isMobile() && !isGearVR() && i && i.capabilities.hasPosition
              );
            }
            function isTablet(i) {
              return /ipad|Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(
                i || window.navigator.userAgent
              );
            }
            function isIOS() {
              return /iPad|iPhone|iPod/.test(window.navigator.platform);
            }
            function isGearVR() {
              return /SamsungBrowser.+Mobile VR/i.test(
                window.navigator.userAgent
              );
            }
            function isOculusGo() {
              return /Pacific Build.+OculusBrowser.+SamsungBrowser.+Mobile VR/i.test(
                window.navigator.userAgent
              );
            }
            function isR7() {
              return /R7 Build/.test(window.navigator.userAgent);
            }
            var vrDisplay;
            window.vrDisabled ||
              (navigator.getVRDisplays &&
                navigator.getVRDisplays().then(function (i) {
                  vrDisplay = i.length && i[0];
                })),
              (module.exports.getVRDisplay = getVRDisplay),
              (module.exports.checkHeadsetConnected = checkHeadsetConnected),
              (module.exports.checkHasPositionalTracking =
                checkHasPositionalTracking);
            var isMobile = (function () {
              var i = !1;
              return (
                (function (e) {
                  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                    e
                  ) ||
                    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                      e.substr(0, 4)
                    )) &&
                    (i = !0),
                    (isIOS() || isTablet() || isR7()) && (i = !0);
                })(
                  window.navigator.userAgent ||
                    window.navigator.vendor ||
                    window.opera
                ),
                function () {
                  return i;
                }
              );
            })();
            (module.exports.isMobile = isMobile),
              (module.exports.isTablet = isTablet),
              (module.exports.isIOS = isIOS),
              (module.exports.isGearVR = isGearVR),
              (module.exports.isOculusGo = isOculusGo),
              (module.exports.isR7 = isR7),
              (module.exports.isLandscape = function () {
                var i = window.orientation;
                return isR7() && (i += 90), 90 === i || -90 === i;
              }),
              (module.exports.isBrowserEnvironment = !(
                process && !process.browser
              )),
              (module.exports.isNodeEnvironment =
                !module.exports.isBrowserEnvironment),
              (module.exports.PolyfillControls = function (i) {
                this.update = function () {};
              });
          }.call(this, _dereq_("_process")));
        },
        { _process: 6 },
      ],
      171: [
        function (_dereq_, module, exports) {
          function getComponentPropertyPath(t, e) {
            return (
              (e = e || "."),
              propertyPathCache[e] || (propertyPathCache[e] = {}),
              -1 !== t.indexOf(e)
                ? (propertyPathCache[e][t] = t.split(e))
                : (propertyPathCache[e][t] = t),
              propertyPathCache[e][t]
            );
          }
          var propertyPathCache = {};
          (module.exports.getComponentPropertyPath = getComponentPropertyPath),
            (module.exports.propertyPathCache = propertyPathCache),
            (module.exports.getComponentProperty = function (t, e, r) {
              var o;
              return (
                (r = r || "."),
                -1 !== e.indexOf(r)
                  ? ((o = getComponentPropertyPath(e, r)),
                    o.constructor === String
                      ? t.getAttribute(o)
                      : t.getAttribute(o[0])[o[1]])
                  : t.getAttribute(e)
              );
            }),
            (module.exports.setComponentProperty = function (t, e, r, o) {
              var p;
              if (((o = o || "."), -1 !== e.indexOf(o)))
                return (
                  (p = getComponentPropertyPath(e, o)),
                  void (p.constructor === String
                    ? t.setAttribute(p, r)
                    : t.setAttribute(p[0], p[1], r))
                );
              t.setAttribute(e, r);
            });
        },
        {},
      ],
      172: [
        function (_dereq_, module, exports) {
          module.exports = function (t) {
            var e = t.style.width,
              s = t.style.height;
            (t.style.width = parseInt(e, 10) + 1 + "px"),
              (t.style.height = parseInt(s, 10) + 1 + "px"),
              setTimeout(function () {
                (t.style.width = e), (t.style.height = s);
              }, 200);
          };
        },
        {},
      ],
      173: [
        function (_dereq_, module, exports) {
          var debug = _dereq_("./debug"),
            deepAssign = _dereq_("deep-assign"),
            device = _dereq_("./device"),
            objectAssign = _dereq_("object-assign"),
            objectPool = _dereq_("./object-pool"),
            warn = debug("utils:warn");
          (module.exports.bind = _dereq_("./bind")),
            (module.exports.coordinates = _dereq_("./coordinates")),
            (module.exports.debug = debug),
            (module.exports.device = device),
            (module.exports.entity = _dereq_("./entity")),
            (module.exports.forceCanvasResizeSafariMobile = _dereq_(
              "./forceCanvasResizeSafariMobile"
            )),
            (module.exports.material = _dereq_("./material")),
            (module.exports.objectPool = objectPool),
            (module.exports.split = _dereq_("./split").split),
            (module.exports.styleParser = _dereq_("./styleParser")),
            (module.exports.trackedControls = _dereq_("./tracked-controls")),
            (module.exports.checkHeadsetConnected = function () {
              return (
                warn(
                  "`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"
                ),
                device.checkHeadsetConnected(arguments)
              );
            }),
            (module.exports.isGearVR = function () {
              return (
                warn("`utils.isGearVR` has moved to `utils.device.isGearVR`"),
                device.isGearVR(arguments)
              );
            }),
            (module.exports.isIOS = function () {
              return (
                warn("`utils.isIOS` has moved to `utils.device.isIOS`"),
                device.isIOS(arguments)
              );
            }),
            (module.exports.isMobile = function () {
              return (
                warn("`utils.isMobile has moved to `utils.device.isMobile`"),
                device.isMobile(arguments)
              );
            }),
            (module.exports.throttle = function (e, r, t) {
              var o;
              return (
                t && (e = module.exports.bind(e, t)),
                function () {
                  var t = Date.now(),
                    n = void 0 === o ? r : t - o;
                  (void 0 === o || n >= r) &&
                    ((o = t), e.apply(null, arguments));
                }
              );
            }),
            (module.exports.throttleTick = function (e, r, t) {
              var o;
              return (
                t && (e = module.exports.bind(e, t)),
                function (t, n) {
                  var i = void 0 === o ? n : t - o;
                  (void 0 === o || i >= r) && ((o = t), e(t, i));
                }
              );
            }),
            (module.exports.debounce = function (e, r, t) {
              var o;
              return function () {
                var n = this,
                  i = arguments,
                  u = function () {
                    (o = null), t || e.apply(n, i);
                  },
                  s = t && !o;
                clearTimeout(o), (o = setTimeout(u, r)), s && e.apply(n, i);
              };
            }),
            (module.exports.extend = objectAssign),
            (module.exports.extendDeep = deepAssign),
            (module.exports.clone = function (e) {
              return JSON.parse(JSON.stringify(e));
            });
          var deepEqual = (function () {
            var e = objectPool.createPool(function () {
              return [];
            });
            return function (r, t) {
              var o, n, i, u, s, c;
              if (
                void 0 === r ||
                void 0 === t ||
                null === r ||
                null === t ||
                !(
                  (r &&
                    t &&
                    r.constructor === Object &&
                    t.constructor === Object) ||
                  (r.constructor === Array && t.constructor === Array)
                )
              )
                return r === t;
              (n = e.use()), (i = e.use()), (n.length = 0), (i.length = 0);
              for (o in r) n.push(o);
              for (o in t) i.push(o);
              if (n.length !== i.length) return e.recycle(n), e.recycle(i), !1;
              for (u = 0; u < n.length; ++u)
                if (
                  ((s = r[n[u]]),
                  (c = t[n[u]]),
                  "object" == typeof s ||
                    "object" == typeof c ||
                    (Array.isArray(s) && Array.isArray(c)))
                ) {
                  if (s === c) continue;
                  if (!deepEqual(s, c)) return e.recycle(n), e.recycle(i), !1;
                } else if (s !== c) return e.recycle(n), e.recycle(i), !1;
              return e.recycle(n), e.recycle(i), !0;
            };
          })();
          (module.exports.deepEqual = deepEqual),
            (module.exports.diff = (function () {
              var e = [];
              return function (r, t, o) {
                var n, i, u, s, c, l, d;
                (s = o || {}), (e.length = 0);
                for (c in r) e.push(c);
                if (!t) return s;
                for (u in t) -1 === e.indexOf(u) && e.push(u);
                for (l = 0; l < e.length; l++)
                  (c = e[l]),
                    (n = r[c]),
                    (i = t[c]),
                    (((d =
                      n &&
                      i &&
                      n.constructor === Object &&
                      i.constructor === Object) &&
                      !deepEqual(n, i)) ||
                      (!d && n !== i)) &&
                      (s[c] = i);
                return s;
              };
            })()),
            (module.exports.shouldCaptureKeyEvent = function (e) {
              return !e.metaKey && document.activeElement === document.body;
            }),
            (module.exports.splitString = function (e, r) {
              void 0 === r && (r = " ");
              var t = new RegExp(r, "g");
              return (e = (e || "").replace(t, r)), e.split(r);
            }),
            (module.exports.getElData = function (e, r) {
              function t(r) {
                e.hasAttribute(r) && (o[r] = e.getAttribute(r));
              }
              r = r || {};
              var o = {};
              return Object.keys(r).forEach(t), o;
            }),
            (module.exports.getUrlParameter = function (e) {
              e = e.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
              var r = new RegExp("[\\?&]" + e + "=([^&#]*)"),
                t = r.exec(location.search);
              return null === t
                ? ""
                : decodeURIComponent(t[1].replace(/\+/g, " "));
            }),
            (module.exports.isIframed = function () {
              return window.top !== window.self;
            }),
            (module.exports.findAllScenes = function (e) {
              for (
                var r = [],
                  t = e.getElementsByTagName("*"),
                  o = 0,
                  n = t.length;
                o < n;
                o++
              )
                t[o].isScene && r.push(t[o]);
              return r;
            }),
            (module.exports.srcLoader = _dereq_("./src-loader"));
        },
        {
          "./bind": 167,
          "./coordinates": 168,
          "./debug": 169,
          "./device": 170,
          "./entity": 171,
          "./forceCanvasResizeSafariMobile": 172,
          "./material": 175,
          "./object-pool": 176,
          "./split": 177,
          "./src-loader": 178,
          "./styleParser": 179,
          "./tracked-controls": 180,
          "deep-assign": 12,
          "object-assign": 25,
        },
      ],
      174: [
        function (_dereq_, module, exports) {
          module.exports = function (o) {
            return /(iphone|ipod|ipad).*os.(7_|8_|9_)/i.test(o);
          };
        },
        {},
      ],
      175: [
        function (_dereq_, module, exports) {
          function handleTextureEvents(e, t) {
            t &&
              (e.emit("materialtextureloaded", { src: t.image, texture: t }),
              t.image &&
                "VIDEO" === t.image.tagName &&
                (t.image.addEventListener("loadeddata", function () {
                  e.components &&
                    e.components.material &&
                    (t.needsCorrectionBGRA &&
                      t.needsCorrectionFlipY &&
                      -1 !==
                        ["standard", "flat"].indexOf(
                          e.components.material.data.shader
                        ) &&
                      e.setAttribute("material", "shader", "ios10hls"),
                    e.emit("materialvideoloadeddata", {
                      src: t.image,
                      texture: t,
                    }));
                }),
                t.image.addEventListener("ended", function () {
                  e.emit("materialvideoended", { src: t.image, texture: t });
                })));
          }
          var THREE = _dereq_("../lib/three"),
            HLS_MIMETYPES = [
              "application/x-mpegurl",
              "application/vnd.apple.mpegurl",
            ];
          (module.exports.updateMapMaterialFromData = function (e, t, a, r) {
            function n(t) {
              a.materialSrcs[e] === l && i(t);
            }
            function i(t) {
              (s[e] = t), (s.needsUpdate = !0), handleTextureEvents(o, t);
            }
            var o = a.el,
              s = a.material,
              l = r[t];
            if ((a.materialSrcs || (a.materialSrcs = {}), !l))
              return delete a.materialSrcs[e], void i(null);
            l !== a.materialSrcs[e] &&
              ((a.materialSrcs[e] = l),
              l instanceof THREE.Texture
                ? i(l)
                : o.sceneEl.systems.material.loadTexture(
                    l,
                    {
                      src: l,
                      repeat: r.repeat,
                      offset: r.offset,
                      npot: r.npot,
                    },
                    n
                  ));
          }),
            (module.exports.updateMap = function (e, t) {
              return module.exports.updateMapMaterialFromData(
                "map",
                "src",
                e,
                t
              );
            }),
            (module.exports.updateDistortionMap = function (e, t, a) {
              function r(e) {
                (o[n + "Map"] = e),
                  (o.needsUpdate = !0),
                  handleTextureEvents(i, e);
              }
              var n = e;
              "ambientOcclusion" === e && (n = "ao");
              var i = t.el,
                o = t.material,
                s = a[e + "Map"],
                l = {};
              if (
                ((l.src = s),
                (l.offset = a[e + "TextureOffset"]),
                (l.repeat = a[e + "TextureRepeat"]),
                (l.wrap = a[e + "TextureWrap"]),
                s)
              ) {
                if (s === t[e + "TextureSrc"]) return;
                return (
                  (t[e + "TextureSrc"] = s),
                  void i.sceneEl.systems.material.loadTexture(s, l, r)
                );
              }
              o.map && r(null);
            }),
            (module.exports.handleTextureEvents = handleTextureEvents),
            (module.exports.isHLS = function (e, t) {
              return (
                !(!t || !HLS_MIMETYPES.includes(t.toLowerCase())) ||
                !!(e && e.toLowerCase().indexOf(".m3u8") > 0)
              );
            });
        },
        { "../lib/three": 150 },
      ],
      176: [
        function (_dereq_, module, exports) {
          function defaultObjectFactory() {
            return {};
          }
          function clearObject(e) {
            var t;
            if (e && e.constructor === Object) for (t in e) e[t] = void 0;
          }
          var EMPTY_SLOT = Object.freeze(Object.create(null));
          (module.exports.createPool = function (e) {
            function t() {
              var e;
              return (
                (null !== o && o !== l.length) || r(l.length || 5),
                (e = l[o]),
                (l[o++] = EMPTY_SLOT),
                clearObject(e),
                e
              );
            }
            function n(e) {
              if (e instanceof Object)
                return null === o || -1 === o
                  ? void (l[l.length] = e)
                  : void (l[--o] = e);
            }
            function r(t) {
              var n, r;
              if (
                ((t = void 0 === t ? l.length : t),
                t > 0 && null == o && (o = 0),
                t > 0)
              )
                for (
                  n = l.length, l.length += Number(t), r = n;
                  r < l.length;
                  r++
                )
                  l[r] = e();
              return l.length;
            }
            function c() {
              return l.length;
            }
            var l = [],
              o = null;
            return (
              (e = e || defaultObjectFactory),
              { grow: r, pool: l, recycle: n, size: c, use: t }
            );
          }),
            (module.exports.clearObject = clearObject);
        },
        {},
      ],
      177: [
        function (_dereq_, module, exports) {
          module.exports.split = (function () {
            var n = {};
            return function (t, i) {
              return (
                i in n || (n[i] = {}),
                t in n[i] ? n[i][t] : ((n[i][t] = t.split(i)), n[i][t])
              );
            };
          })();
        },
        {},
      ],
      178: [
        function (_dereq_, module, exports) {
          function validateSrc(e, a, t) {
            checkIsImage(e, function (r) {
              if (r) return void a(e);
              t(e);
            });
          }
          function validateCubemapSrc(e, a) {
            function t(e) {
              o.push(e), 6 === o.length && a(o);
            }
            var r,
              n,
              c,
              s = "",
              o = [];
            for (n = 0; n < 5; n++) s += "(url\\((?:[^\\)]+)\\),\\s*)";
            if (
              ((s += "(url\\((?:[^\\)]+)\\)\\s*)"),
              (c = e.match(new RegExp(s))))
            )
              for (n = 1; n < 7; n++) validateSrc(parseUrl(c[n]), t);
            else if ((r = validateAndGetQuerySelector(e)))
              return "A-CUBEMAP" === r.tagName && r.srcs
                ? a(r.srcs)
                : void warn('Selector "%s" does not point to <a-cubemap>', e);
          }
          function parseUrl(e) {
            var a = e.match(/\url\((.+)\)/);
            if (a) return a[1];
          }
          function checkIsImage(e, a) {
            var t;
            if (e.tagName) return void a("IMG" === e.tagName);
            (t = new XMLHttpRequest()),
              t.open("HEAD", e),
              t.addEventListener("load", function (r) {
                var n;
                t.status >= 200 && t.status < 300
                  ? ((n = t.getResponseHeader("Content-Type")),
                    null == n
                      ? checkIsImageFallback(e, a)
                      : a(n.startsWith("image") ? !0 : !1))
                  : checkIsImageFallback(e, a),
                  t.abort();
              }),
              t.send();
          }
          function checkIsImageFallback(e, a) {
            function t() {
              a(!0);
            }
            function r() {
              a(!1);
            }
            var n = new Image();
            n.addEventListener("load", t),
              n.addEventListener("error", r),
              (n.src = e);
          }
          function validateAndGetQuerySelector(e) {
            try {
              var a = document.querySelector(e);
              return (
                a ||
                  warn('No element was found matching the selector: "%s"', e),
                a
              );
            } catch (a) {
              return void warn('"%s" is not a valid selector', e);
            }
          }
          var debug = _dereq_("./debug"),
            warn = debug("utils:src-loader:warn");
          module.exports = {
            parseUrl: parseUrl,
            validateSrc: validateSrc,
            validateCubemapSrc: validateCubemapSrc,
          };
        },
        { "./debug": 169 },
      ],
      179: [
        function (_dereq_, module, exports) {
          function toCamelCase(e) {
            return e.replace(DASH_REGEX, upperCase);
          }
          function transformKeysToCamelCase(e) {
            var r, t;
            for (t in e)
              (r = toCamelCase(t)), t !== r && ((e[r] = e[t]), delete e[t]);
            return e;
          }
          function styleParse(e, r) {
            var t, n, s, a, o, u;
            for (
              r = r || {}, t = getKeyValueChunks(e), n = 0;
              n < t.length;
              n++
            )
              (s = t[n]) &&
                ((a = s.indexOf(":")),
                (o = s.substr(0, a).trim()),
                (u = s.substr(a + 1).trim()),
                (r[o] = u));
            return r;
          }
          function styleStringify(e) {
            var r,
              t = 0,
              n = 0,
              s = "";
            for (r in e) t++;
            for (r in e) (s += r + ": " + e[r]), n < t - 1 && (s += "; "), n++;
            return s;
          }
          function upperCase(e) {
            return e[1].toUpperCase();
          }
          var DASH_REGEX = /-([a-z])/g;
          (module.exports.parse = function (e, r) {
            var t;
            return "string" != typeof e
              ? e
              : ((t = styleParse(e, r)),
                t[""] ? e : transformKeysToCamelCase(t));
          }),
            (module.exports.stringify = function (e) {
              return "string" == typeof e ? e : styleStringify(e);
            }),
            (module.exports.toCamelCase = toCamelCase),
            (module.exports.transformKeysToCamelCase =
              transformKeysToCamelCase);
          var getKeyValueChunks = (function () {
            var e = [],
              r = /url\([^)]+$/;
            return function (t) {
              var n,
                s = "",
                a = 0;
              for (e.length = 0; a < t.length; )
                (n = t.indexOf(";", a)),
                  -1 === n && (n = t.length),
                  (s += t.substring(a, n)),
                  r.test(s)
                    ? ((s += ";"), (a = n + 1))
                    : (e.push(s.trim()), (s = ""), (a = n + 1));
              return e;
            };
          })();
        },
        {},
      ],
      180: [
        function (_dereq_, module, exports) {
          function isControllerPresent(e, n, t) {
            var r,
              o,
              l = e.el.sceneEl,
              i = t.index || 0;
            return (
              !!n &&
              !!(o = l && l.systems["tracked-controls"]) &&
              ((r = o.controllers),
              !!r.length && !!findMatchingController(r, null, n, t.hand, i))
            );
          }
          function findMatchingController(e, n, t, r, o) {
            var l,
              i,
              s = 0,
              d = o || 0;
            for (i = 0; i < e.length; i++)
              if (
                ((l = e[i]),
                (!t || l.id.startsWith(t)) &&
                  (t || l.id === n) &&
                  (!r || !l.hand || r === l.hand))
              ) {
                if (
                  (r &&
                    !l.hand &&
                    (d = NUM_HANDS * o + (r === DEFAULT_HANDEDNESS ? 0 : 1)),
                  s === d)
                )
                  return l;
                ++s;
              }
          }
          var DEFAULT_HANDEDNESS = _dereq_("../constants").DEFAULT_HANDEDNESS,
            AXIS_LABELS = ["x", "y", "z", "w"],
            NUM_HANDS = 2;
          (module.exports.checkControllerPresentAndSetup = function (e, n, t) {
            var r = e.el,
              o = isControllerPresent(e, n, t);
            if (
              (e.controllerPresent &&
                !e.controllerEventsActive &&
                e.addEventListeners(),
              o === e.controllerPresent)
            )
              return o;
            (e.controllerPresent = o),
              o
                ? (e.injectTrackedControls(),
                  e.addEventListeners(),
                  r.emit("controllerconnected", { name: e.name, component: e }))
                : (e.removeEventListeners(),
                  r.emit("controllerdisconnected", {
                    name: e.name,
                    component: e,
                  }));
          }),
            (module.exports.isControllerPresent = isControllerPresent),
            (module.exports.findMatchingController = findMatchingController),
            (module.exports.emitIfAxesChanged = function (e, n, t) {
              var r, o, l, i, s;
              for (o in n) {
                for (r = n[o], l = !1, s = 0; s < r.length; s++)
                  t.detail.changed[r[s]] && (l = !0);
                if (l) {
                  for (i = {}, s = 0; s < r.length; s++)
                    i[AXIS_LABELS[s]] = t.detail.axis[r[s]];
                  e.el.emit(o + "moved", i);
                }
              }
            }),
            (module.exports.onButtonEvent = function (e, n, t, r) {
              var o = r ? t.mapping[r] : t.mapping,
                l = o.buttons[e];
              t.el.emit(l + n), t.updateModel && t.updateModel(l, n);
            });
        },
        { "../constants": 93 },
      ],
      181: [
        function (_dereq_, module, exports) {
          (window.glStats = function () {
            function e(e, r) {
              return function () {
                r.apply(this, arguments), e.apply(this, arguments);
              };
            }
            function r() {
              a("allcalls").set(s + i),
                a("drawElements").set(i),
                a("drawArrays").set(s),
                a("bindTexture").set(c),
                a("useProgram").set(l),
                a("glfaces").set(d),
                a("glvertices").set(m),
                a("glpoints").set(p);
            }
            function t() {
              (s = 0), (i = 0), (l = 0), (d = 0), (m = 0), (p = 0), (c = 0);
            }
            function n() {}
            function o(e) {
              a = e;
            }
            var a = null,
              s = 0,
              i = 0,
              l = 0,
              d = 0,
              m = 0,
              p = 0,
              c = 0;
            return (
              (WebGLRenderingContext.prototype.drawArrays = e(
                WebGLRenderingContext.prototype.drawArrays,
                function () {
                  s++,
                    arguments[0] == this.POINTS
                      ? (p += arguments[2])
                      : (m += arguments[2]);
                }
              )),
              (WebGLRenderingContext.prototype.drawElements = e(
                WebGLRenderingContext.prototype.drawElements,
                function () {
                  i++, (d += arguments[1] / 3), (m += arguments[1]);
                }
              )),
              (WebGLRenderingContext.prototype.useProgram = e(
                WebGLRenderingContext.prototype.useProgram,
                function () {
                  l++;
                }
              )),
              (WebGLRenderingContext.prototype.bindTexture = e(
                WebGLRenderingContext.prototype.bindTexture,
                function () {
                  c++;
                }
              )),
              {
                update: r,
                start: t,
                end: n,
                attach: o,
                values: {
                  allcalls: { over: 3e3, caption: "Calls (hook)" },
                  drawelements: { caption: "drawElements (hook)" },
                  drawarrays: { caption: "drawArrays (hook)" },
                },
                groups: [
                  {
                    caption: "WebGL",
                    values: [
                      "allcalls",
                      "drawelements",
                      "drawarrays",
                      "useprogram",
                      "bindtexture",
                      "glfaces",
                      "glvertices",
                      "glpoints",
                    ],
                  },
                ],
                fractions: [
                  { base: "allcalls", steps: ["drawelements", "drawarrays"] },
                ],
              }
            );
          }),
            (window.threeStats = function (e) {
              function r() {
                a("renderer.info.memory.geometries").set(
                  e.info.memory.geometries
                ),
                  a("renderer.info.programs").set(e.info.programs.length),
                  a("renderer.info.memory.textures").set(
                    e.info.memory.textures
                  ),
                  a("renderer.info.render.calls").set(e.info.render.calls),
                  a("renderer.info.render.triangles").set(
                    e.info.render.triangles
                  ),
                  a("renderer.info.render.points").set(e.info.render.points);
              }
              function t() {}
              function n() {}
              function o(e) {
                a = e;
              }
              var a = null;
              return {
                update: r,
                start: t,
                end: n,
                attach: o,
                values: {
                  "renderer.info.memory.geometries": { caption: "Geometries" },
                  "renderer.info.memory.textures": { caption: "Textures" },
                  "renderer.info.programs": { caption: "Programs" },
                  "renderer.info.render.calls": { caption: "Calls" },
                  "renderer.info.render.triangles": {
                    caption: "Triangles",
                    over: 1e3,
                  },
                  "renderer.info.render.points": { caption: "Points" },
                },
                groups: [
                  {
                    caption: "Three.js - Memory",
                    values: [
                      "renderer.info.memory.geometries",
                      "renderer.info.programs",
                      "renderer.info.memory.textures",
                    ],
                  },
                  {
                    caption: "Three.js - Render",
                    values: [
                      "renderer.info.render.calls",
                      "renderer.info.render.triangles",
                      "renderer.info.render.points",
                    ],
                  },
                ],
                fractions: [],
              };
            }),
            (window.BrowserStats = function () {
              function e(e) {
                var r = Math.floor(Math.log(e) / p);
                return Math.round((100 * e) / Math.pow(1024, r)) / 100;
              }
              function r() {
                (s = e(performance.memory.usedJSHeapSize)),
                  (i = e(performance.memory.totalJSHeapSize)),
                  a("memory").set(s),
                  a("total").set(i);
              }
              function t() {
                s = 0;
              }
              function n() {}
              function o(e) {
                a = e;
              }
              var a = null,
                s = 0,
                i = 0;
              window.performance &&
                !performance.memory &&
                (performance.memory = {
                  usedJSHeapSize: 0,
                  totalJSHeapSize: 0,
                }),
                0 === performance.memory.totalJSHeapSize &&
                  console.warn(
                    "totalJSHeapSize === 0... performance.memory is only available in Chrome ."
                  );
              var l = {
                  memory: {
                    caption: "Used Memory",
                    average: !0,
                    avgMs: 1e3,
                    over: 22,
                  },
                  total: { caption: "Total Memory" },
                },
                d = [{ caption: "Browser", values: ["memory", "total"] }],
                m = [{ base: "total", steps: ["memory"] }],
                p = Math.log(1024);
              return {
                update: r,
                start: t,
                end: n,
                attach: o,
                values: l,
                groups: d,
                fractions: m,
              };
            }),
            "object" == typeof module &&
              (module.exports = {
                glStats: window.glStats,
                threeStats: window.threeStats,
                BrowserStats: window.BrowserStats,
              });
        },
        {},
      ],
      182: [
        function (_dereq_, module, exports) {
          "use strict";
          !(function () {
            "performance" in window == 0 && (window.performance = {});
            var e = window.performance;
            if ("now" in e == 0) {
              var t = Date.now();
              e.timing &&
                e.timing.navigationStart &&
                (t = e.timing.navigationStart),
                (e.now = function () {
                  return Date.now() - t;
                });
            }
            e.mark || (e.mark = function () {}),
              e.measure || (e.measure = function () {});
          })(),
            (window.rStats = function (e) {
              function t(e, t) {
                for (var n = Object.keys(e), a = 0, r = n.length; a < r; a++)
                  t(n[a]);
              }
              function n(e) {
                var t = document.createElement("link");
                (t.href = e),
                  (t.rel = "stylesheet"),
                  (t.type = "text/css"),
                  document.getElementsByTagName("head")[0].appendChild(t);
              }
              function a(e, t, n) {
                function a(e, t) {
                  (l += 0.1 * (e - l)),
                    (c *= 0.99),
                    l > c && (c = l),
                    o.drawImage(
                      i,
                      1,
                      0,
                      i.width - 1,
                      i.height,
                      0,
                      0,
                      i.width - 1,
                      i.height
                    ),
                    t
                      ? o.drawImage(
                          f,
                          i.width - 1,
                          i.height - (l * i.height) / c - p
                        )
                      : o.drawImage(
                          u,
                          i.width - 1,
                          i.height - (l * i.height) / c - p
                        );
                }
                var r = n || {},
                  i = document.createElement("canvas"),
                  o = i.getContext("2d"),
                  c = 0,
                  l = 0,
                  s = r.color ? r.color : "#666666",
                  u = document.createElement("canvas"),
                  d = u.getContext("2d");
                (u.width = 1),
                  (u.height = 2 * p),
                  (d.fillStyle = "#444444"),
                  d.fillRect(0, 0, 1, 2 * p),
                  (d.fillStyle = s),
                  d.fillRect(0, p, 1, p),
                  (d.fillStyle = "#ffffff"),
                  (d.globalAlpha = 0.5),
                  d.fillRect(0, p, 1, 1),
                  (d.globalAlpha = 1);
                var f = document.createElement("canvas"),
                  m = f.getContext("2d");
                return (
                  (f.width = 1),
                  (f.height = 2 * p),
                  (m.fillStyle = "#444444"),
                  m.fillRect(0, 0, 1, 2 * p),
                  (m.fillStyle = "#b70000"),
                  m.fillRect(0, p, 1, p),
                  (m.globalAlpha = 0.5),
                  (m.fillStyle = "#ffffff"),
                  m.fillRect(0, p, 1, 1),
                  (m.globalAlpha = 1),
                  (function () {
                    (i.width = h),
                      (i.height = p),
                      (i.style.width = i.width + "px"),
                      (i.style.height = i.height + "px"),
                      (i.className = "rs-canvas"),
                      e.appendChild(i),
                      (o.fillStyle = "#444444"),
                      o.fillRect(0, 0, i.width, i.height);
                  })(),
                  { draw: a }
                );
              }
              function r(e, n) {
                function a(e) {
                  i.drawImage(
                    r,
                    1,
                    0,
                    r.width - 1,
                    r.height,
                    0,
                    0,
                    r.width - 1,
                    r.height
                  );
                  var n = 0;
                  t(e, function (t) {
                    var a = e[t] * r.height;
                    (i.fillStyle = s[t]),
                      i.fillRect(r.width - 1, n, 1, a),
                      (n += a);
                  });
                }
                var r = document.createElement("canvas"),
                  i = r.getContext("2d");
                return (
                  (function () {
                    (r.width = h),
                      (r.height = p * n),
                      (r.style.width = r.width + "px"),
                      (r.style.height = r.height + "px"),
                      (r.className = "rs-canvas"),
                      e.appendChild(r),
                      (i.fillStyle = "#444444"),
                      i.fillRect(0, 0, r.width, r.height);
                  })(),
                  { draw: a }
                );
              }
              function i(e, t) {
                function n(e) {
                  if (x && x.average) {
                    (v += e), C++;
                    var t = performance.now();
                    t - w >= (x.avgMs || 1e3) &&
                      ((g = v / C), (v = 0), (w = t), (C = 0));
                  }
                }
                function r() {
                  (d = performance.now()),
                    l.userTimingAPI && performance.mark(p + "-start"),
                    (I = !0);
                }
                function i() {
                  (h = performance.now() - d),
                    l.userTimingAPI &&
                      (performance.mark(p + "-end"),
                      I && performance.measure(p, p + "-start", p + "-end")),
                    n(h);
                }
                function o() {
                  i(), r();
                }
                function c() {
                  var e = x && x.average ? g : h;
                  b.nodeValue = Math.round(100 * e) / 100;
                  var t =
                    x && ((x.below && h < x.below) || (x.over && h > x.over));
                  N.draw(h, t),
                    (y.className = t
                      ? "rs-counter-base alarm"
                      : "rs-counter-base");
                }
                function s() {
                  var e = performance.now(),
                    t = e - d;
                  m++,
                    t > 1e3 &&
                      ((h = x && !1 === x.interpolate ? m : (1e3 * m) / t),
                      (m = 0),
                      (d = e),
                      n(h));
                }
                function u(e) {
                  (h = e), n(h);
                }
                var d,
                  p = e,
                  h = 0,
                  m = 0,
                  g = 0,
                  v = 0,
                  w = performance.now(),
                  C = 0,
                  y = document.createElement("div"),
                  E = document.createElement("span"),
                  S = document.createElement("div"),
                  b = document.createTextNode(""),
                  x = l ? l.values[p.toLowerCase()] : null,
                  N = new a(y, p, x),
                  I = !1;
                return (
                  (E.className = "rs-counter-id"),
                  (E.textContent = x && x.caption ? x.caption : p),
                  (S.className = "rs-counter-value"),
                  S.appendChild(b),
                  y.appendChild(E),
                  y.appendChild(S),
                  t ? t.div.appendChild(y) : f.appendChild(y),
                  (d = performance.now()),
                  {
                    set: u,
                    start: r,
                    tick: o,
                    end: i,
                    frame: s,
                    value: function () {
                      return h;
                    },
                    draw: c,
                  }
                );
              }
              function o(e) {
                var n = e.toLowerCase();
                if ((void 0 === n && (n = "default"), m[n])) return m[n];
                var a = null;
                l &&
                  l.groups &&
                  t(l.groups, function (e) {
                    var t = l.groups[parseInt(e, 10)];
                    a || -1 === t.values.indexOf(n.toLowerCase()) || (a = t);
                  });
                var r = new i(n, a);
                return (m[n] = r), r;
              }
              function c() {
                t(l.plugins, function (e) {
                  l.plugins[e].update();
                }),
                  t(m, function (e) {
                    m[e].draw();
                  }),
                  l &&
                    l.fractions &&
                    t(l.fractions, function (e) {
                      var n = l.fractions[parseInt(e, 10)],
                        a = [],
                        r = m[n.base.toLowerCase()];
                      r &&
                        ((r = r.value()),
                        t(l.fractions[e].steps, function (t) {
                          var n =
                              l.fractions[e].steps[
                                parseInt(t, 10)
                              ].toLowerCase(),
                            i = m[n];
                          i && a.push(i.value() / r);
                        })),
                        n.graph.draw(a);
                    });
              }
              var l = e || {},
                s = l.colours || [
                  "#850700",
                  "#c74900",
                  "#fcb300",
                  "#284280",
                  "#4c7c0c",
                ],
                u = (l.CSSPath ? l.CSSPath : "") + "rStats.css";
              (
                l.css || [
                  "https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",
                  u,
                ]
              ).forEach(function (e) {
                n(e);
              }),
                l.values || (l.values = {});
              var d,
                f,
                p = 10,
                h = 200,
                m = {};
              return (
                (function () {
                  if (l.plugins) {
                    l.values || (l.values = {}),
                      l.groups || (l.groups = []),
                      l.fractions || (l.fractions = []);
                    for (var e = 0; e < l.plugins.length; e++)
                      l.plugins[e].attach(o),
                        t(l.plugins[e].values, function (t) {
                          l.values[t] = l.plugins[e].values[t];
                        }),
                        (l.groups = l.groups.concat(l.plugins[e].groups)),
                        (l.fractions = l.fractions.concat(
                          l.plugins[e].fractions
                        ));
                  } else l.plugins = {};
                  (d = document.createElement("div")),
                    (d.className = "rs-base"),
                    (f = document.createElement("div")),
                    (f.className = "rs-container"),
                    (f.style.height = "auto"),
                    d.appendChild(f),
                    document.body.appendChild(d),
                    l &&
                      (l.groups &&
                        t(l.groups, function (e) {
                          var t = l.groups[parseInt(e, 10)],
                            n = document.createElement("div");
                          (n.className = "rs-group"), (t.div = n);
                          var a = document.createElement("h1");
                          (a.textContent = t.caption),
                            a.addEventListener(
                              "click",
                              function (e) {
                                this.classList.toggle("hidden"),
                                  e.preventDefault();
                              }.bind(n)
                            ),
                            f.appendChild(a),
                            f.appendChild(n);
                        }),
                      l.fractions &&
                        t(l.fractions, function (e) {
                          var n = l.fractions[parseInt(e, 10)],
                            a = document.createElement("div");
                          a.className = "rs-fraction";
                          var i = document.createElement("div");
                          i.className = "rs-legend";
                          var o = 0;
                          t(l.fractions[e].steps, function (t) {
                            var n = document.createElement("p");
                            (n.textContent = l.fractions[e].steps[t]),
                              (n.style.color = s[o]),
                              i.appendChild(n),
                              o++;
                          }),
                            a.appendChild(i),
                            (a.style.height = o * p + "px"),
                            (n.div = a);
                          var c = new r(a, o);
                          (n.graph = c), f.appendChild(a);
                        }));
                })(),
                function (e) {
                  return e ? o(e) : { element: d, update: c };
                }
              );
            }),
            "object" == typeof module && (module.exports = window.rStats);
        },
        {},
      ],
      183: [
        function (_dereq_, module, exports) {
          var Util = {};
          (Util.base64 = function (e, i) {
            return "data:" + e + ";base64," + i;
          }),
            (Util.isMobile = function () {
              var e = !1;
              return (
                (function (i) {
                  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                    i
                  ) ||
                    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                      i.substr(0, 4)
                    )) &&
                    (e = !0);
                })(navigator.userAgent || navigator.vendor || window.opera),
                e
              );
            }),
            (Util.isIOS = function () {
              return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
            }),
            (Util.isIFrame = function () {
              try {
                return window.self !== window.top;
              } catch (e) {
                return !0;
              }
            }),
            (Util.appendQueryParameter = function (e, i, t) {
              return (e += (e.indexOf("?") < 0 ? "?" : "&") + i + "=" + t);
            }),
            (Util.getQueryParameter = function (e) {
              e = e.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
              var i = new RegExp("[\\?&]" + e + "=([^&#]*)"),
                t = i.exec(location.search);
              return null === t
                ? ""
                : decodeURIComponent(t[1].replace(/\+/g, " "));
            }),
            (Util.isLandscapeMode = function () {
              return 90 == window.orientation || -90 == window.orientation;
            }),
            (module.exports = Util);
        },
        {},
      ],
      184: [
        function (_dereq_, module, exports) {
          function AndroidWakeLock() {
            var A = document.createElement("video");
            A.addEventListener("ended", function () {
              A.play();
            }),
              (this.request = function () {
                A.paused &&
                  ((A.src = Util.base64(
                    "video/webm",
                    "GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="
                  )),
                  A.play());
              }),
              (this.release = function () {
                A.pause(), (A.src = "");
              });
          }
          function iOSWakeLock() {
            var A = null;
            (this.request = function () {
              A ||
                (A = setInterval(function () {
                  (window.location.href = "/"), setTimeout(window.stop, 0);
                }, 15e3));
            }),
              (this.release = function () {
                A && (clearInterval(A), (A = null));
              });
          }
          function getWakeLock() {
            var A = navigator.userAgent || navigator.vendor || window.opera;
            return A.match(/iPhone/i) || A.match(/iPod/i)
              ? iOSWakeLock
              : AndroidWakeLock;
          }
          var Util = _dereq_("./util.js");
          module.exports = getWakeLock();
        },
        { "./util.js": 183 },
      ],
    },
    {},
    [148]
  )(148);
});

//# sourceMappingURL=aframe-master.min.js.map
